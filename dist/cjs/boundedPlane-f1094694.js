'use strict';

const request = require('./messageBundle-8be88d04.js');
const mathUtils = require('./mathUtils-af6066f0.js');
const vectorStacks = require('./vectorStacks-f48a010a.js');
const mat4 = require('./mat4-f68486bc.js');
const mat4f64 = require('./mat4f64-fc3339e5.js');
const common = require('./common-41a349f2.js');
const lineSegment = require('./lineSegment-a86bf7bd.js');
const plane = require('./plane-0816c6c9.js');
const sphere = require('./sphere-ef7f801f.js');

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
const L=request.s$1.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class z{constructor(){this.plane=plane.p(),this.origin=common.n(),this.basis1=common.n(),this.basis2=common.n();}}function G(s=Ns){return {plane:plane.p(s.plane),origin:common.t$1(s.origin),basis1:common.t$1(s.basis1),basis2:common.t$1(s.basis2)}}function W(s,i,n){const t=Ss.get();return t.origin=s,t.basis1=i,t.basis2=n,t.plane=plane.M(0,0,0,0),K(t),t}function D(s,i=G()){return J(s.origin,s.basis1,s.basis2,i)}function H(s,i){mathUtils.r(i.origin,s.origin),mathUtils.r(i.basis1,s.basis1),mathUtils.r(i.basis2,s.basis2),plane.b(s.plane,i.plane);}function J(s,i,n,t=G()){return mathUtils.r(t.origin,s),mathUtils.r(t.basis1,i),mathUtils.r(t.basis2,n),K(t),ys(t,"fromValues()"),t}function K(s){plane.B(s.basis2,s.basis1,s.origin,s.plane);}function Q(s,i,n){s!==n&&D(s,n);const t=mathUtils.d(vectorStacks.c.get(),ms(s),i);return mathUtils.u(n.origin,n.origin,t),n.plane[3]-=i,n}function X(s,i,n){return Z(i,n),Q(n,gs(s,s.origin),n),n}function Z(s,i=G()){const n=(s[2]-s[0])/2,t=(s[3]-s[1])/2;return mathUtils.o(i.origin,s[0]+n,s[1]+t,0),mathUtils.o(i.basis1,n,0,0),mathUtils.o(i.basis2,0,t,0),plane.j(0,0,1,0,i.plane),i}function $(s,i,n){return !!plane.D(s.plane,i,n)&&hs(s,n)}function ss(s,i,n){if($(s,i,n))return n;const t=is(s,i,vectorStacks.c.get());return mathUtils.u(n,i.origin,mathUtils.d(vectorStacks.c.get(),i.direction,mathUtils.q(i.origin,t)/mathUtils.s(i.direction))),n}function is(s,n,t){const a=vs.get();Ps(s,n,a,vs.get());let o=Number.POSITIVE_INFINITY;for(const r of Ts){const e=Is(s,r,ws.get()),u=vectorStacks.c.get();if(plane.E(a,e,u)){const s=mathUtils.H(vectorStacks.c.get(),n.origin,u),a=Math.abs(mathUtils.l(mathUtils.z(n.direction,s)));a<o&&(o=a,mathUtils.r(t,u));}}return o===Number.POSITIVE_INFINITY?ns(s,n,t):t}function ns(s,i,n){if($(s,i,n))return n;const t=vs.get(),a=vs.get();Ps(s,i,t,a);let o=Number.POSITIVE_INFINITY;for(const r of Ts){const e=Is(s,r,ws.get()),u=vectorStacks.c.get();if(plane.F(t,e,u)){const s=sphere.h(i,u);if(!plane.I(a,u))continue;s<o&&(o=s,mathUtils.r(n,u));}}return os(s,i.origin)<o&&ts(s,i.origin,n),n}function ts(s,i,n){const t=plane.O(s.plane,i,vectorStacks.c.get()),a=lineSegment.A(js(s,s.basis1),t,-1,1,vectorStacks.c.get()),o=lineSegment.A(js(s,s.basis2),t,-1,1,vectorStacks.c.get());return mathUtils.c(n,mathUtils.u(vectorStacks.c.get(),a,o),s.origin),n}function as(s,i,n){const{origin:t,basis1:a,basis2:o}=s,r=mathUtils.c(vectorStacks.c.get(),i,t),e=sphere.e(a,r),c=sphere.e(o,r),u=sphere.e(ms(s),r);return mathUtils.o(n,e,c,u)}function os(s,i){const n=as(s,i,vectorStacks.c.get()),{basis1:t,basis2:a}=s,o=mathUtils.s(t),r=mathUtils.s(a),e=Math.max(Math.abs(n[0])-o,0),c=Math.max(Math.abs(n[1])-r,0),u=n[2];return e*e+c*c+u*u}function rs(s,i){return Math.sqrt(os(s,i))}function es(s,i){let n=Number.NEGATIVE_INFINITY;for(const t of Ts){const a=Is(s,t,ws.get()),o=lineSegment.b(a,i);o>n&&(n=o);}return Math.sqrt(n)}function cs(s,i){return plane.I(s.plane,i)&&hs(s,i)}function us(s,i,n,t){return ds(s,n,t)}function gs(s,i){const n=-s.plane[3];return sphere.e(ms(s),i)-n}function bs(s,i,n,t){const a=gs(s,i),o=mathUtils.d(Ms,ms(s),n-a);return mathUtils.u(t,i,o),t}function fs(s,i){return mathUtils.F(s.basis1,i.basis1)&&mathUtils.F(s.basis2,i.basis2)&&mathUtils.F(s.origin,i.origin)}function ls(s,i,n){return s!==n&&D(s,n),mat4.h(As,i),mat4.o(As,As),mathUtils.I(n.basis1,s.basis1,As),mathUtils.I(n.basis2,s.basis2,As),mathUtils.I(plane.W(n.plane),plane.W(s.plane),As),mathUtils.I(n.origin,s.origin,i),plane.z(n.plane,n.origin,n.plane),n}function ps(s,i,n,t){return s!==t&&D(s,t),mat4.f(Vs,mat4.r(Vs),i,n),mathUtils.I(t.basis1,s.basis1,Vs),mathUtils.I(t.basis2,s.basis2,Vs),K(t),t}function ms(s){return plane.W(s.plane)}function ds(s,i,n){switch(i){case 0:mathUtils.r(n,s.basis1),mathUtils.j$1(n,n);break;case 1:mathUtils.r(n,s.basis2),mathUtils.j$1(n,n);break;case 2:mathUtils.r(n,ms(s));}return n}function hs(s,i){const n=mathUtils.c(vectorStacks.c.get(),i,s.origin),t=mathUtils.p$1(s.basis1),a=mathUtils.p$1(s.basis2),o=mathUtils.z(s.basis1,n),r=mathUtils.z(s.basis2,n);return -o-t<0&&o-t<0&&-r-a<0&&r-a<0}function js(s,i){const n=ws.get();return mathUtils.r(n.origin,s.origin),mathUtils.r(n.vector,i),n}function Is(s,i,n){const{basis1:t,basis2:a,origin:o}=s,r=mathUtils.d(vectorStacks.c.get(),t,i.origin[0]),e=mathUtils.d(vectorStacks.c.get(),a,i.origin[1]);mathUtils.u(n.origin,r,e),mathUtils.u(n.origin,n.origin,o);const c=mathUtils.d(vectorStacks.c.get(),t,i.direction[0]),b=mathUtils.d(vectorStacks.c.get(),a,i.direction[1]);return mathUtils.d(n.vector,mathUtils.u(c,c,b),2),n}function ys(s,i){Math.abs(mathUtils.z(s.basis1,s.basis2)/(mathUtils.s(s.basis1)*mathUtils.s(s.basis2)))>1e-6&&L.warn(i,"Provided basis vectors are not perpendicular"),Math.abs(mathUtils.z(s.basis1,ms(s)))>1e-6&&L.warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-mathUtils.z(ms(s),s.origin)-s.plane[3])>1e-6&&L.warn(i,"Plane offset is not consistent with plane origin");}function Ps(s,i,n,t){const a=ms(s);plane.B(a,i.direction,i.origin,n),plane.B(plane.W(n),a,i.origin,t);}const Ns={plane:plane.p(),origin:common.r(0,0,0),basis1:common.r(1,0,0),basis2:common.r(0,1,0)},vs=new vectorStacks.s(plane.p),ws=new vectorStacks.s(lineSegment.v),Ms=common.n(),Ss=new vectorStacks.s((()=>({origin:null,basis1:null,basis2:null,plane:null}))),Ts=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],As=mat4f64.e(),Vs=mat4f64.e(),_s=Object.freeze({__proto__:null,BoundedPlaneClass:z,create:G,wrap:W,copy:D,copyWithoutVerify:H,fromValues:J,updateUnboundedPlane:K,elevate:Q,setExtent:X,fromAABoundingRect:Z,intersectRay:$,intersectRayClosestSilhouette:ss,closestPointOnSilhouette:is,closestPoint:ns,projectPoint:ts,projectPointLocal:as,distance2:os,distance:rs,distanceToSilhouette:es,extrusionContainsPoint:cs,axisAt:us,altitudeAt:gs,setAltitudeAt:bs,equals:fs,transform:ls,rotate:ps,normal:ms,UP:Ns});

exports.D = D;
exports.G = G;
exports.H = H;
exports.J = J;
exports.K = K;
exports.Z = Z;
exports._s = _s;
exports.cs = cs;
exports.ls = ls;
exports.ms = ms;
exports.ps = ps;
exports.rs = rs;
exports.z = z;
