import { L as s, cO as H, aX as t, s as s$1, cP as D, R as r, r as r$1, q as h, cQ as x$1, Z as n$1, aD as a$1, t as t$1, B as f, a5 as n$2 } from './index.js';
import { G } from './brushes.js';
import { n as n$3 } from './Container.js';
import { m as m$2 } from './number.js';
import { I } from './Utils.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
const m$1=s.getLogger("esri.views.2d.engine.webgl.Mesh2D"),u=t=>{switch(t.BYTES_PER_ELEMENT){case 1:return 5121;case 2:return 5123;case 4:return 5125;default:throw new s$1("Cannot get DataType of array")}},y=(e,t,r,s)=>{let n=0;for(let o=1;o<r;o++){const r=e[2*(t+o-1)],s=e[2*(t+o-1)+1];n+=(e[2*(t+o)]-r)*(e[2*(t+o)+1]+s);}return s?n>0:n<0},x=({coords:e,lengths:t},r)=>{const n=[];for(let o=0,c=0;o<t.length;c+=t[o],o+=1){const i=c,a=[];for(;o<t.length-1&&y(e,c+t[o],t[o+1],r);o+=1,c+=t[o])a.push(c+t[o]-i);const f=e.slice(2*i,2*(c+t[o])),h=x$1(f,a,2);for(const e of h)n.push(e+i);}return n};class g{constructor(e,t,r,s=!1){this._cache={},this.vertices=e,this.indices=t,this.primitiveType=r,this.isMapSpace=s;}static fromRect({x:e,y:t,width:r,height:s}){const n=e,o=t,c=n+r,i=o+s;return g.fromScreenExtent({xmin:n,ymin:o,xmax:c,ymax:i})}static fromPath(e){const t$1=H(new t,e.path,!1,!1),r=t$1.coords,s=new Uint32Array(x(t$1,!0)),n=new Uint32Array(r.length/2);for(let o=0;o<n.length;o++)n[o]=m$2(Math.floor(r[2*o]),Math.floor(r[2*o+1]));return new g({geometry:n},s,4)}static fromGeometry(t,r){const s=r.geometry.type;switch(s){case"polygon":return g.fromPolygon(t,r.geometry);case"extent":return g.fromMapExtent(t,r.geometry);default:return m$1.error(new s$1("mapview-bad-type",`Unable to create a mesh from type ${s}`,r)),g.fromRect({x:0,y:0,width:1,height:1})}}static fromPolygon(e,t$1){const r$1=D(new t,t$1,!1,!1),s=r$1.coords,c=new Uint32Array(x(r$1,!1)),h=new Uint32Array(s.length/2),m=n$1(),u=n$1();for(let o=0;o<h.length;o++)r(m,s[2*o],s[2*o+1]),e.toScreen(u,m),h[o]=m$2(Math.floor(u[0]),Math.floor(u[1]));return new g({geometry:h},c,4,!0)}static fromScreenExtent({xmin:e,xmax:t,ymin:r,ymax:s}){const n={geometry:new Uint32Array([m$2(e,r),m$2(t,r),m$2(e,s),m$2(e,s),m$2(t,r),m$2(t,s)])},o=new Uint32Array([0,1,2,3,4,5]);return new g(n,o,4)}static fromMapExtent(e,t){const[r,s]=e.toScreen([0,0],[t.xmin,t.ymin]),[n,o]=e.toScreen([0,0],[t.xmax,t.ymax]),c={geometry:new Uint32Array([m$2(r,s),m$2(n,s),m$2(r,o),m$2(r,o),m$2(n,s),m$2(n,o)])},i=new Uint32Array([0,1,2,3,4,5]);return new g(c,i,4)}destroy(){r$1(this._cache.indexBuffer)&&this._cache.indexBuffer.dispose();for(const e in this._cache.vertexBuffers)r$1(this._cache.vertexBuffers[e])&&this._cache.vertexBuffers[e].dispose();}get elementType(){return u(this.indices)}getIndexBuffer(e,t=35044){return this._cache.indexBuffer||(this._cache.indexBuffer=h.createIndex(e,t,this.indices)),this._cache.indexBuffer}getVertexBuffers(e,t=35044){return this._cache.vertexBuffers||(this._cache.vertexBuffers=Object.keys(this.vertices).reduce(((r,s)=>({...r,[s]:h.createVertex(e,t,this.vertices[s])})),{})),this._cache.vertexBuffers}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
const c=s.getLogger("esri.views.2d.engine.webgl.ClippingInfo"),n=t=>parseFloat(t)/100;class m extends a$1{constructor(t,e){super(),this._clip=e,this._cache={},this.stage=t,this._handle=e.watch("version",(()=>this._invalidate())),this.ready();}static fromClipArea(t,e){return new m(t,e)}_destroyGL(){r$1(this._cache.mesh)&&(this._cache.mesh.destroy(),this._cache.mesh=null),r$1(this._cache.vao)&&(this._cache.vao.dispose(),this._cache.vao=null);}destroy(){this._destroyGL(),this._handle.remove();}getVAO(t,e,r,i){const[o,h]=e.size;if("geometry"!==this._clip.type&&this._lastWidth===o&&this._lastHeight===h||(this._lastWidth=o,this._lastHeight=h,this._destroyGL()),t$1(this._cache.vao)){const s=this._createMesh(e,this._clip),o=s.getIndexBuffer(t),h=s.getVertexBuffers(t);this._cache.mesh=s,this._cache.vao=new f(t,r,i,h,o);}return this._cache.vao}_createTransforms(){return {dvs:n$2()}}_invalidate(){this._destroyGL(),this.requestRender();}_createScreenRect(t,e){const[r,s]=t.size,i="string"==typeof e.left?n(e.left)*r:e.left,o="string"==typeof e.right?n(e.right)*r:e.right,h="string"==typeof e.top?n(e.top)*s:e.top,a="string"==typeof e.bottom?n(e.bottom)*s:e.bottom,c=i,m=h;return {x:c,y:m,width:Math.max(r-o-c,0),height:Math.max(s-a-m,0)}}_createMesh(e,r){switch(r.type){case"rect":return g.fromRect(this._createScreenRect(e,r));case"path":return g.fromPath(r);case"geometry":return g.fromGeometry(e,r);default:return c.error(new s$1("mapview-bad-type","Unable to create ClippingInfo mesh from clip of type: ${clip.type}")),g.fromRect({x:0,y:0,width:1,height:1})}}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
class a extends n$3{constructor(){super(...arguments),this.name=this.constructor.name;}set clips(e){this._clips=e,this.children.forEach((r=>r.clips=e)),this._updateClippingInfo();}_createTransforms(){return {dvs:n$2()}}doRender(e){const r=this.createRenderParams(e),{painter:s,globalOpacity:t,profiler:i,drawPhase:n}=r,a=n===I.LABEL?1:t*this.computedOpacity;i.recordContainerStart(this.name),s.beforeRenderLayer(r,this._clippingInfos?255:0,a),this.updateTransforms(e.state),this.renderChildren(r),s.compositeLayer(r,a),i.recordContainerEnd();}renderChildren(r){t$1(this._renderPasses)&&(this._renderPasses=this.prepareRenderPasses(r.painter));for(const e of this.children)e.beforeRender(r);for(const e of this._renderPasses)try{e.render(r);}catch(s){}for(const e of this.children)e.afterRender(r);}createRenderParams(e){return e.requireFBO=this.requiresDedicatedFBO,e}prepareRenderPasses(e){return [e.registerRenderPass({name:"clip",brushes:[G.clip],target:()=>this._clippingInfos,drawPhase:I.MAP|I.LABEL|I.LABEL_ALPHA|I.DEBUG|I.HIGHLIGHT})]}updateTransforms(e){for(const r of this.children)r.setTransform(e);}onAttach(){super.onAttach(),this._updateClippingInfo();}onDetach(){super.onDetach(),this._updateClippingInfo();}_updateClippingInfo(){if(r$1(this._clippingInfos)&&(this._clippingInfos.forEach((e=>e.destroy())),this._clippingInfos=null),!this.stage)return;const e=this._clips;r$1(e)&&e.length&&(this._clippingInfos=e.items.map((e=>m.fromClipArea(this.stage,e)))),this.requestRender();}}

export { a };
