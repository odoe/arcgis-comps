import { ag as a, ah as p, jQ as E, r, oX as p$1, t, aF as F, bX as v, eI as tn, fs as O$1, e2 as s, bK as et, jf as i, e, d, i as i$1, bG as rn, hf as v$1 } from './index.js';
import { u } from './normalizeUtilsSync.js';
import { m } from './FeatureStore.js';
import { V } from './QueryEngine.js';
import { o } from './queryEngineUtils.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
let k=class extends(a(p)){constructor(e){super(e),this.availability=1,this.sources={multipoint:null,point:null,polygon:null,polyline:null},this.loadedWkids=new Set,this.loadedWkts=new Set,this.pendingAdds=[];}get updating(){return this.updatingHandles.updating}get layer(){return this.layerSource.layer}destroy(){const e=this.pendingAdds;this.pendingAdds.length=0;for(const t of e)t.task.abort();this.mapSources((e=>this.destroySource(e)));}initialize(){this.handles.add([this.layer.on("graphic-update",(e=>this.onGraphicUpdate(e))),this.updatingHandles.addOnCollectionChange(this.layer.graphics,(e=>this.onGraphicsChanged(e)))]),this.addMany(this.layer.graphics.toArray());}async fetchCandidates(e,t){const r$1=await E(this.mapSources((r$1=>r$1.queryEngine.executeQueryForSnapping({point:e.coordinateHelper.vectorToPoint(e.point).toJSON(),distance:e.distance,types:e.types,query:r(e.filter)?e.filter.createQuery().toJSON():{where:"1=1"}},t).then((({candidates:e})=>e))))),s=r$1.flat().map((t=>o(t,e.coordinateHelper)));return p$1(e.point,s),s}refresh(){}onGraphicUpdate(e){switch(e.property){case"geometry":case"visible":this.remove(e.graphic),this.addMany([e.graphic]);}}onGraphicsChanged(e){for(const t of e.removed)this.remove(t);this.addMany(e.added);}addMany(e){const t$1=[],r=new Map;for(const s of e)t(s.geometry)||(this.needsInitializeProjection(s.geometry.spatialReference)?(t$1.push(s.geometry.spatialReference),r.set(s.uid,s)):this.add(s));this.createPendingAdd(t$1,r);}createPendingAdd(e,t){if(!e.length)return;const s=F((async r=>{await rn(e.map((e=>({source:e,dest:this.spatialReference}))),{signal:r}),this.markLoadedSpatialReferences(e);for(const[,e]of t)this.add(e);}));this.updatingHandles.addPromise(s.promise);const o={task:s,graphics:t},i=()=>v$1(this.pendingAdds,o);s.promise.then(i,i),this.pendingAdds.push(o);}markLoadedSpatialReferences(e){for(const t of e)null!=t.wkid&&this.loadedWkids.add(t.wkid),null!=t.wkt&&this.loadedWkts.add(t.wkt);}add(e){if(t(e.geometry)||!e.visible)return;let t$1=e.geometry;if("mesh"===t$1.type)return;"extent"===t$1.type&&(t$1=v.fromExtent(t$1));const r$1=this.ensureSource(t$1.type);if(t(r$1))return;const s=this.createOptimizedFeature(e.uid,t$1);r(s)&&r$1.featureStore.add(s);}needsInitializeProjection(e){return (null==e.wkid||!this.loadedWkids.has(e.wkid))&&((null==e.wkt||!this.loadedWkts.has(e.wkt))&&!tn(e,this.spatialReference))}createOptimizedFeature(e,t){const r=O$1(u(t),this.spatialReference);return r?new s(et(r,!1,!1),{[O]:e},null,e):null}ensureSource(e){const t=this.sources[e];if(r(t))return t;const r$1=this.createSource(e);return this.sources[e]=r$1,r$1}createSource(e){const t=i.toJSON(e),r$1=new m({geometryType:t,hasZ:!1,hasM:!1});return {featureStore:r$1,queryEngine:new V({featureStore:r$1,fields:[{name:O,type:"esriFieldTypeOID",alias:O}],geometryType:t,hasM:!1,hasZ:!1,objectIdField:O,spatialReference:this.spatialReference,scheduler:r(this.view)&&"3d"===this.view.type?this.view.resourceController.scheduler:null}),type:e}}remove(e){this.mapSources((t=>this.removeFromSource(t,e)));for(const t of this.pendingAdds)t.graphics.delete(e.uid),0===t.graphics.size&&t.task.abort();}removeFromSource(e,t){const r=t.uid;e.featureStore.has(r)&&e.featureStore.removeById(t.uid);}destroySource(e){e.queryEngine.destroy(),this.sources[e.type]=null;}mapSources(e){const{point:t,polygon:r$1,polyline:s,multipoint:i}=this.sources,a=[];return r(t)&&a.push(e(t)),r(r$1)&&a.push(e(r$1)),r(s)&&a.push(e(s)),r(i)&&a.push(e(i)),a}};e([d({constructOnly:!0})],k.prototype,"spatialReference",void 0),e([d({constructOnly:!0})],k.prototype,"layerSource",void 0),e([d({constructOnly:!0})],k.prototype,"view",void 0),e([d({readOnly:!0})],k.prototype,"updating",null),e([d({readOnly:!0})],k.prototype,"availability",void 0),k=e([i$1("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")],k);const O="OBJECTID";

export { k as GraphicsSnappingSource };
