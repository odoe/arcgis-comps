import{A as t,aW as e,c as i,e as s,d as r,i as o,p as n,D as a,af as l,cM as c,cN as h,cO as u,ct as p,ce as d,cg as f,r as v,u as m,ai as g,V as w,bK as x,bx as y,aN as S,a as b,cs as C,cP as D,cG as P}from"./p-e58503d5.js";import{a as z,e as M}from"./p-2c84c65f.js";import{s as A,u as O,d as T,f as _,o as E,I as j,c as R,_ as F,a as L,z as N,r as V,B as I,q as W,F as U,E as H,J as G,X as $,Q as B,k,H as Z,Z as q,L as Q,e as J,h as Y,t as X,y as K,v as tt,l as et}from"./p-2f398ed1.js";import{n as it,r as st,b as rt,e as ot,l as nt}from"./p-d3105731.js";import{d as at,l as lt,a as ct,p as ht,j as ut,e as pt,P as dt,_ as ft,B as vt,L as mt}from"./p-95909347.js";import{f as gt,j as wt,T as xt,r as yt}from"./p-728dcbb0.js";import{_ as St,$ as bt,t as Ct,a0 as Dt,a1 as Pt,a as zt,j as Mt,n as At,w as Ot,h as Tt,a2 as _t,I as Et,S as jt,y as Rt,e as Ft,b as Lt,c as Nt,d as Vt,o as It,k as Wt,a3 as Ut,a4 as Ht,a5 as Gt,X as $t,a6 as Bt,N as kt,a7 as Zt,a8 as qt,a9 as Qt,f as Jt,aa as Yt,l as Xt,ab as Kt,ac as te,ad as ee,ae as ie,af as se,ag as re,ah as oe,ai as ne,aj as ae,g as le,x as ce,J as he,ak as ue,P as pe,al as de,R as fe,am as ve,an as me,ao as ge,ap as we,aq as xe,ar as ye,as as Se,r as be,G as Ce,K as De,at as Pe,au as ze,av as Me,Z as Ae,i as Oe,F as Te,aw as _e}from"./p-eb48bb01.js";import{c as Ee,r as je,l as Re,f as Fe,u as Le}from"./p-0d1e969a.js";import{t as Ne,n as Ve,r as Ie}from"./p-c2152437.js";import{p as We,b as Ue,y as He,K as Ge,R as $e,L as Be,N as ke,v as Ze,D as qe,W as Qe}from"./p-dcdb33cf.js";import{l as Je,h as Ye,g as Xe,u as Ke}from"./p-37f005a2.js";import{i as ti,B as ei,$ as ii,C as si,z as ri,j as oi,A as ni,E as ai}from"./p-7f47b970.js";import{i as li,x as ci}from"./p-fb38a9d0.js";import{a as hi}from"./p-b9aa4901.js";import{e as ui}from"./p-8f986f60.js";import{e as pi,h as di,n as fi,A as vi,o as mi,F as gi,m as wi,b as xi,l as yi,E as Si,r as bi,c as Ci}from"./p-ccdb8e80.js";import{a as Di,k as Pi}from"./p-e6fe5d89.js";import{t as zi,n as Mi}from"./p-746a9d8f.js";import{u as Ai,d as Oi,a as Ti}from"./p-ea916a39.js";import{A as _i}from"./p-a72732f2.js";import{r as Ei,n as ji,_ as Ri,t as Fi,l as Li}from"./p-4d38e149.js";import{g as Ni,c as Vi,r as Ii,t as Wi,l as Ui,u as Hi,b as Gi,f as $i,d as Bi,h as ki,j as Zi,e as qi,s as Qi}from"./p-bdf9e611.js";import{r as Ji,n as Yi}from"./p-a6c8fb32.js";import{a as Xi}from"./p-765e6c28.js";import{o as Ki,x as ts,v as es,w as is}from"./p-c93d2280.js";import{S as ss,z as rs,E as os}from"./p-f94762ac.js";import{d as ns,l as as,s as ls}from"./p-b79fcce3.js";import{v as cs}from"./p-3bcc4805.js";import{o as hs}from"./p-025c0c8e.js";import{d as us}from"./p-6ded4c02.js";import{l as ps}from"./p-e72a43d7.js";import{h as ds}from"./p-54330161.js";import{d as fs}from"./p-c048b814.js";import{n as vs}from"./p-56ed1c7a.js";import{l as ms,f as gs,h as ws,r as xs}from"./p-19bc1e3d.js";import{o as ys}from"./p-0bb84768.js";import{s as Ss,f as bs,r as Cs}from"./p-3c70d22f.js";import{b as Ds,l as Ps,k as zs,v as Ms}from"./p-1c99992b.js";import{t as As}from"./p-04a0cfca.js";import{s as Os}from"./p-b0565d49.js";import{D as Ts,f as _s,C as Es}from"./p-ca295674.js";import{i as js,u as Rs}from"./p-f06611ed.js";function Fs(t){return t?{ray:at(t.ray),c0:t.c0,c1:t.c1}:{ray:at(),c0:0,c1:Number.MAX_VALUE}}function Ls(t,e=Fs()){return lt(t,e.ray),e.c0=0,e.c1=Number.MAX_VALUE,e}function Ns(t,e){return Is(t,t.c0,e)}function Vs(t,e){return Is(t,t.c1,e)}function Is(t,e,i){return O(i,t.ray.origin,T(i,t.ray.direction,e))}function Ws(t){return t?[We(t[0]),We(t[1]),We(t[2]),We(t[3]),We(t[4]),We(t[5])]:[We(),We(),We(),We(),We(),We()]}function Us(){return[it(),it(),it(),it(),it(),it(),it(),it()]}function Hs(t,e=Ws()){for(let i=0;i<6;i++)Ue(t[i],e[i])}function Gs(t,e,i,s=er){const r=pi(bs.get(),e,t);di(r,r);for(let t=0;t<8;++t){const e=_(Cs.get(),Ks[t],r);E(s[t],e[0]/e[3],e[1]/e[3],e[2]/e[3])}$s(i,s)}function $s(t,e){He(e[4],e[0],e[3],t[0]),He(e[1],e[5],e[6],t[1]),He(e[4],e[5],e[1],t[2]),He(e[3],e[2],e[6],t[3]),He(e[0],e[1],e[2],t[4]),He(e[5],e[4],e[7],t[5])}function Bs(t,e){for(let i=0;i<6;i++){const s=t[i];if(s[0]*e[0]+s[1]*e[1]+s[2]*e[2]+s[3]>=e[3])return!1}return!0}function ks(t,e){return Ys(t,Ls(e,tr.get()))}function Zs(t,e){for(let i=0;i<6;i++)if(!ke(t[i],e))return!1;return!0}function qs(t,e,i){return Ys(t,function(t,e,i=Fs()){const s=A(t.vector);return ct(t.origin,e,i.ray),i.c0=0,i.c1=s,i}(e,i,tr.get()))}function Qs(t,e){for(let i=0;i<6;i++)if($e(t[i],e)>0)return!1;return!0}function Js(t,e){for(let i=0;i<6;i++)if(Ge(t[i],e))return!1;return!0}function Ys(t,e){for(let i=0;i<6;i++)if(!Be(t[i],e))return!1;return!0}new Ss((()=>({c0:0,c1:0,ray:null})));const Xs={bottom:[5,1,0,4],near:[0,1,2,3],far:[5,4,7,6],right:[1,5,6,2],left:[4,0,3,7],top:[7,3,2,6]},Ks=[Ei(-1,-1,-1,1),Ei(1,-1,-1,1),Ei(1,1,-1,1),Ei(-1,1,-1,1),Ei(-1,-1,1,1),Ei(1,-1,1,1),Ei(1,1,1,1),Ei(-1,1,1,1)],tr=new Ss(Fs),er=Us();class ir{constructor(){this.verticalOffset=0,this.selectionMode=!1,this.hud=!0,this.selectOpaqueTerrainOnly=!0,this.invisibleTerrain=!1,this.backfacesTerrain=!0,this.isFiltered=!1,this.store=2}}class sr{constructor(t){this.options=new ir,this.results=new gt,this.transform=new St,this.tolerance=1e-5,this.verticalOffset=null,this._ray={origin:it(),direction:it()},this._rayEndPoint=it(),this._rayStartPointTransformed=it(),this._rayEndPointTransformed=it(),this.viewingMode=null==t?1:t}get ray(){return this._ray}get rayBeginPoint(){return this._ray.origin}get rayEndPoint(){return this._rayEndPoint}reset(t,e){this.resetWithRay(ht(t,e,this._ray))}resetWithRay(t){t!==this._ray&&lt(t,this._ray),0!==this.options.verticalOffset?2===this.viewingMode?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,O(this._rayEndPoint,this._ray.origin,this._ray.direction),this.results.init(this._ray)}intersect(e=null,i,s,r,o,n){this.point=i,this.camera=s,this.filterPredicate=o,this.tolerance=null==r?1e-5:r;const a=bt(this.verticalOffset);if(t(e)&&e.length>0){const i=n?t=>{n(t)&&this.intersectObject(t)}:t=>{this.intersectObject(t)};for(const s of e){const e=s.getSpatialQueryAccelerator&&s.getSpatialQueryAccelerator();t(e)?(t(a)?e.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,i,a):e.forEachAlongRay(this._ray.origin,this._ray.direction,i),this.options.selectionMode&&this.options.hud&&e.forEachDegenerateObject(i)):s.objects.forAll((t=>i(t)))}}this.sortResults()}intersectObject(e){const i=e.geometryRecords;if(!i)return;const s=e.id,r=e.transformation;let o;const n=bt(this.verticalOffset);for(const a of i){const{geometry:i,material:l,instanceParameters:c}=a;if(Ee(c))continue;o=i.id,this.transform.setAndInvalidateLazyTransforms(r,a.getShaderTransformation()),j(this._rayStartPointTransformed,this._ray.origin,this.transform.inverse),j(this._rayEndPointTransformed,this._rayEndPoint,this.transform.inverse);const h=this.transform.transform;t(n)&&(n.objectTransform=this.transform),l.intersect(i,c,this.transform.transform,this,this._rayStartPointTransformed,this._rayEndPointTransformed,((i,r,n,a,l,c)=>{if(i>=0){if(t(this.filterPredicate)&&!this.filterPredicate(this._ray.origin,this._rayEndPoint,i))return;const u=`Object3D ${s}`;if(l)return void((null==this.results.hud.dist||i<this.results.hud.dist)&&this.results.hud.set(e,u,i,r,z,a,c,o,n));const p=t=>t.set(e,u,i,r,h,a,null,o,n);if((null==this.results.min.drapedLayerOrder||a>=this.results.min.drapedLayerOrder)&&(null==this.results.min.dist||i<this.results.min.dist)&&p(this.results.min),0!==this.options.store&&(null==this.results.max.drapedLayerOrder||a<this.results.max.drapedLayerOrder)&&(null==this.results.max.dist||i>this.results.max.dist)&&p(this.results.max),2===this.options.store){const t=new wt(this._ray);p(t),this.results.all.push(t)}}}),a.shaderTransformation)}}sortResults(){this.results.all.sort(((t,e)=>t.dist!==e.dist?t.dist-e.dist:t.drapedLayerOrder!==e.drapedLayerOrder?(void 0!==t.drapedLayerOrder?t.drapedLayerOrder:Number.MAX_VALUE)-(void 0!==e.drapedLayerOrder?e.drapedLayerOrder:Number.MAX_VALUE):(void 0!==e.drapedLayerGraphicOrder?e.drapedLayerGraphicOrder:Number.MIN_VALUE)-(void 0!==t.drapedLayerGraphicOrder?t.drapedLayerGraphicOrder:Number.MIN_VALUE)))}}function rr(t){return"point"===t.type}sr.DEFAULT_TOLERANCE=1e-5;class or{constructor(t,e=null,i=0){this.array=t,this.spatialReference=e,this.offset=i}}function nr(t){return"array"in t}function ar(t,i,s="ground"){if(rr(i))return t.getElevation(i.x,i.y,i.z||0,i.spatialReference,s);if(nr(i)){let r=i.offset;return t.getElevation(i.array[r++],i.array[r++],i.array[r]||0,e(i.spatialReference,t.spatialReference),s)}return t.getElevation(i[0],i[1],i[2]||0,t.spatialReference,s)}function lr(t){t.fragment.code.add(Ct`const float GAMMA = 2.2;
const float INV_GAMMA = 0.4545454545;
vec4 delinearizeGamma(vec4 color) {
return vec4(pow(color.rgb, vec3(INV_GAMMA)), color.w);
}
vec3 linearizeGamma(vec3 color) {
return pow(color, vec3(GAMMA));
}`)}var cr;!function(t){t.length=function(t,e){const i=t[e],s=t[e+1],r=t[e+2];return Math.sqrt(i*i+s*s+r*r)},t.normalize=function(t,e){const i=t[e],s=t[e+1],r=t[e+2],o=1/Math.sqrt(i*i+s*s+r*r);t[e]*=o,t[e+1]*=o,t[e+2]*=o},t.scale=function(t,e,i){t[e]*=i,t[e+1]*=i,t[e+2]*=i},t.add=function(t,e,i,s,r,o=e){(r=r||t)[o]=t[e]+i[s],r[o+1]=t[e+1]+i[s+1],r[o+2]=t[e+2]+i[s+2]},t.subtract=function(t,e,i,s,r,o=e){(r=r||t)[o]=t[e]-i[s],r[o+1]=t[e+1]-i[s+1],r[o+2]=t[e+2]-i[s+2]}}(cr||(cr={}));const hr=cr;var ur,pr,dr,fr;!function(t){const e=.5,i=[[-e,-e,e],[e,-e,e],[e,e,e],[-e,e,e],[-e,-e,-e],[e,-e,-e],[e,e,-e],[-e,e,-e]],s=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],r=[0,0,1,0,1,1,0,1],o=new Uint16Array([0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5]),n=new Uint16Array(36);for(let t=0;t<6;t++)for(let e=0;e<6;e++)n[6*t+e]=t;const a=new Uint16Array(36);for(let t=0;t<6;t++)a[6*t+0]=0,a[6*t+1]=1,a[6*t+2]=2,a[6*t+3]=2,a[6*t+4]=3,a[6*t+5]=0;t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(24);for(let s=0;s<8;s++)e[3*s]=i[s][0]*t[0],e[3*s+1]=i[s][1]*t[1],e[3*s+2]=i[s][2]*t[2];return new Dt([["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:s}],["uv0",{size:2,data:r}]],[["position",o],["normal",n],["uv0",a]])}}(ur||(ur={})),function(t){const e=.5,i=[[-e,0,-e],[e,0,-e],[e,0,e],[-e,0,e],[0,-e,0],[0,e,0]],s=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],r=new Uint16Array([5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0]),o=new Uint16Array([0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7]);t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(18);for(let s=0;s<6;s++)e[3*s]=i[s][0]*t[0],e[3*s+1]=i[s][1]*t[1],e[3*s+2]=i[s][2]*t[2];return new Dt([["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:s}]],[["position",r],["normal",o]])}}(pr||(pr={})),function(t){const e=.5,i=Ne(-e,0,-e),s=Ne(e,0,-e),r=Ne(0,0,e),o=Ne(0,.5,0),n=Ve(),a=Ve(),l=Ve(),c=Ve(),h=Ve();R(n,i,o),R(a,i,s),F(l,n,a),L(l,l),R(n,s,o),R(a,s,r),F(c,n,a),L(c,c),R(n,r,o),R(a,r,i),F(h,n,a),L(h,h);const u=[i,s,r,o],p=[0,-1,0,l[0],l[1],l[2],c[0],c[1],c[2],h[0],h[1],h[2]],d=[0,1,2,3,1,0,3,2,1,3,0,2],f=[0,0,0,1,1,1,2,2,2,3,3,3];t.createGeometry=function(t){Array.isArray(t)||(t=[t,t,t]);const e=new Array(12);for(let i=0;i<4;i++)e[3*i]=u[i][0]*t[0],e[3*i+1]=u[i][1]*t[1],e[3*i+2]=u[i][2]*t[2];return new Dt([["position",{size:3,data:e,exclusive:!0}],["normal",{size:3,data:p}]],[["position",new Uint16Array(d)],["normal",new Uint16Array(f)]])}}(dr||(dr={})),function(t){t.createBoxGeometry=ur.createGeometry,t.createDiamondGeometry=pr.createGeometry,t.createTetrahedronGeometry=dr.createGeometry,t.createSphereGeometry=function(t,e,i,s={uv:!0}){const r=-Math.PI,o=2*Math.PI,n=-Math.PI/2,a=Math.PI,l=Math.max(3,Math.floor(e)),c=Math.max(2,Math.floor(i)),h=(l+1)*(c+1),u=new Float32Array(3*h),p=new Float32Array(3*h),d=new Float32Array(2*h),f=[];let v=0;for(let e=0;e<=c;e++){const i=[],s=e/c,h=n+s*a,m=Math.cos(h);for(let e=0;e<=l;e++){const n=e/l,a=r+n*o,c=Math.cos(a)*m,f=Math.sin(h),g=-Math.sin(a)*m;u[3*v]=c*t,u[3*v+1]=f*t,u[3*v+2]=g*t,p[3*v]=c,p[3*v+1]=f,p[3*v+2]=g,d[2*v]=n,d[2*v+1]=s,i.push(v),++v}f.push(i)}const m=new Uint32Array(2*l*(c-1)*3);v=0;for(let t=0;t<c;t++)for(let e=0;e<l;e++){const i=f[t][e],s=f[t][e+1],r=f[t+1][e+1],o=f[t+1][e];0===t?(m[v++]=i,m[v++]=r,m[v++]=o):t===c-1?(m[v++]=i,m[v++]=s,m[v++]=r):(m[v++]=i,m[v++]=s,m[v++]=r,m[v++]=r,m[v++]=o,m[v++]=i)}const g=[["position",m],["normal",m]],w=[["position",{size:3,data:u,exclusive:!0}],["normal",{size:3,data:p,exclusive:!0}]];return s.uv&&(w.push(["uv0",{size:2,data:d,exclusive:!0}]),g.push(["uv0",m])),s.offset&&(g[0][0]="offset",w[0][0]="offset",g.push(["position",new Uint32Array(m.length)]),w.push(["position",{size:3,data:Float64Array.from(s.offset),exclusive:!0}])),new Dt(w,g)},t.createPolySphereGeometry=function(t,e,i){const s=t;let r,o;if(i)r=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],o=new Uint32Array([0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1]);else{const t=s*(1+Math.sqrt(5))/2;r=[-s,t,0,s,t,0,-s,-t,0,s,-t,0,0,-s,t,0,s,t,0,-s,-t,0,s,-t,t,0,-s,t,0,s,-t,0,-s,-t,0,s],o=new Uint32Array([0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1])}for(let e=0;e<r.length;e+=3)hr.scale(r,e,t/hr.length(r,e));let n={};function a(e,i){e>i&&([e,i]=[i,e]);const s=e.toString()+"."+i.toString();if(n[s])return n[s];let o=r.length;return r.length+=3,hr.add(r,3*e,r,3*i,r,o),hr.scale(r,o,t/hr.length(r,o)),o/=3,n[s]=o,o}for(let t=0;t<e;t++){const t=o.length,e=new Uint32Array(4*t);for(let i=0;i<t;i+=3){const t=o[i],s=o[i+1],r=o[i+2],n=a(t,s),l=a(s,r),c=a(r,t),h=4*i;e[h]=t,e[h+1]=n,e[h+2]=c,e[h+3]=s,e[h+4]=l,e[h+5]=n,e[h+6]=r,e[h+7]=c,e[h+8]=l,e[h+9]=n,e[h+10]=l,e[h+11]=c}o=e,n={}}const l=new Float32Array(r);for(let t=0;t<l.length;t+=3)hr.normalize(l,t);const c=[["position",o],["normal",o]],h=[["position",{size:3,data:new Float32Array(r),exclusive:!0}],["normal",{size:3,data:l,exclusive:!0}]];return new Dt(h,c)},t.createPointGeometry=function(t,e,i,s,r,o,n){const a=[["position",{size:3,data:e?[e[0],e[1],e[2]]:[0,0,0],exclusive:!0}],["normal",{size:3,data:t?[t[0],t[1],t[2]]:[0,0,1],exclusive:!0}],["uv0",{size:(o=o||[0,0]).length,data:o}],["color",{size:4,data:i?[255*i[0],255*i[1],255*i[2],i.length>3?255*i[3]:255]:[255,255,255,255],exclusive:!0}],["size",{size:2,data:null!=s&&2===s.length?s:[1,1]}]];if(null!=r){const t=new Float32Array([r[0],r[1],r[2],r[3]]);a.push(["auxpos1",{size:4,data:t}])}if(null!=n){const t=new Float32Array([n[0],n[1],n[2],n[3]]);a.push(["auxpos2",{size:4,data:t}])}return new Dt(a,null,1)},t.updatePointGeometry=function(t,e,i,s,r,o,n,a){if(null!=t){const{data:e}=a.getMutableAttribute("normal");e[0]=t[0],e[1]=t[1],e[2]=t[2]}if(null!=e){const{data:t}=a.getMutableAttribute("position");t[0]=e[0],t[1]=e[1],t[2]=e[2]}if(null!=i){const{data:t}=a.getMutableAttribute("color");t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[3]}if(null!=s){const{data:t}=a.getMutableAttribute("size");t[0]=s[0],t[1]=s[1]}if(null!=r){const{data:t}=a.getMutableAttribute("auxpos1");t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3]}if(null!=o){const{data:t}=a.getMutableAttribute("uv0");t[0]=o[0],t[1]=o[1]}if(null!=n){const{data:t}=a.getMutableAttribute("auxpos2");t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3]}},t.createPointArrayGeometry=function(t,e){const i=new Float32Array(3*t.length),s=new Float32Array(e?3*t.length:3),r=new Uint32Array(t.length),o=new Uint32Array(t.length);for(let n=0;n<t.length;n++)i[3*n]=t[n][0],i[3*n+1]=t[n][1],i[3*n+2]=t[n][2],e&&(s[3*n]=e[n][0],s[3*n+1]=e[n][1],s[3*n+2]=e[n][2]),r[n]=n,o[n]=0;return e||(s[0]=0,s[1]=1,s[2]=0),new Dt([["position",{size:3,data:i,exclusive:!0}],["normal",{size:3,data:s,exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",r],["normal",e?r:o],["uv0",o]],1)},t.createTriangleGeometry=function(){const t=new Uint16Array([0,1,2]),e=new Uint16Array([0,0,0]),i=new Uint16Array([0,0,0]);return new Dt([["position",{size:3,data:[0,0,0,0,0,100,100,0,0],exclusive:!0}],["normal",{size:3,data:[0,1,0],exclusive:!0}],["uv0",{size:2,data:[0,0],exclusive:!0}]],[["position",t],["normal",e],["uv0",i]])};const e=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function i(t,e,i,s,r){return!(Math.abs(N(e,t))>r||(F(i,t,e),L(i,i),F(s,i,t),L(s,s),0))}function s(t,e,s,r,o,n,a){return i(t,e,o,n,a)||i(t,s,o,n,a)||i(t,r,o,n,a)}t.createSquareGeometry=function(t=e){const i=new Array(12);for(let e=0;e<4;e++)for(let s=0;s<3;s++)i[3*e+s]=t[e][s];const s=new Uint32Array([0,1,2,2,3,0]),r=new Uint32Array([0,0,0,0,0,0]);return new Dt([["position",{size:3,data:i,exclusive:!0}],["normal",{size:3,data:[0,0,1],exclusive:!0}],["uv0",{size:2,data:[0,0,1,0,1,1,0,1],exclusive:!0}],["color",{size:4,data:[255,255,255,255],exclusive:!0}]],[["position",s],["normal",r],["uv0",s],["color",r]])},t.createConeGeometry=function(t,e,i,s,r=!0,o=!0){let n=0;const a=e,l=t;let c=Ne(0,n,0),h=Ne(0,n+l,0),u=Ne(0,-1,0),p=Ne(0,1,0);s&&(n=l,h=Ne(0,0,0),c=Ne(0,n,0),u=Ne(0,1,0),p=Ne(0,-1,0));const d=[h,c],f=[u,p],v=i+2,m=Math.sqrt(l*l+a*a);if(s)for(let t=i-1;t>=0;t--){const e=t*(2*Math.PI/i),s=Ne(Math.cos(e)*a,n,Math.sin(e)*a);d.push(s);const r=Ne(l*Math.cos(e)/m,-a/m,l*Math.sin(e)/m);f.push(r)}else for(let t=0;t<i;t++){const e=t*(2*Math.PI/i),s=Ne(Math.cos(e)*a,n,Math.sin(e)*a);d.push(s);const r=Ne(l*Math.cos(e)/m,a/m,l*Math.sin(e)/m);f.push(r)}const g=new Uint32Array(2*(i+2)*3),w=new Uint32Array(2*(i+2)*3);let x=0,y=0;if(r){for(let t=3;t<d.length;t++)g[x++]=1,g[x++]=t-1,g[x++]=t,w[y++]=0,w[y++]=0,w[y++]=0;g[x++]=d.length-1,g[x++]=2,g[x++]=1,w[y++]=0,w[y++]=0,w[y++]=0}if(o){for(let t=3;t<d.length;t++)g[x++]=t,g[x++]=t-1,g[x++]=0,w[y++]=t,w[y++]=t-1,w[y++]=1;g[x++]=0,g[x++]=2,g[x++]=d.length-1,w[y++]=1,w[y++]=2,w[y++]=f.length-1}const S=new Float32Array(3*v);for(let t=0;t<v;t++)S[3*t]=d[t][0],S[3*t+1]=d[t][1],S[3*t+2]=d[t][2];const b=new Float32Array(3*v);for(let t=0;t<v;t++)b[3*t]=f[t][0],b[3*t+1]=f[t][1],b[3*t+2]=f[t][2];return new Dt([["position",{size:3,data:S,exclusive:!0}],["normal",{size:3,data:b,exclusive:!0}]],[["position",g],["normal",w]])},t.createCylinderGeometry=function(t,e,i,s,r,o){const n=s?Ie(s):Ne(1,0,0),a=r?Ie(r):Ne(0,0,0);o=null==o||o;const l=Ve();L(l,n);const c=Ve();T(c,l,Math.abs(t));const h=Ve();T(h,c,-.5),O(h,h,a);const u=Ne(0,1,0);Math.abs(1-N(l,u))<.2&&E(u,0,0,1);const p=Ve();F(p,l,u),L(p,p),F(u,p,l);const d=2*i+(o?2:0),f=i+(o?2:0),v=new Float32Array(3*d),m=new Float32Array(3*f),g=new Float32Array(2*d),w=new Uint32Array(3*i*(o?4:2)),x=new Uint32Array(3*i*(o?4:2));o&&(v[3*(d-2)+0]=h[0],v[3*(d-2)+1]=h[1],v[3*(d-2)+2]=h[2],g[2*(d-2)]=0,g[2*(d-2)+1]=0,v[3*(d-1)+0]=v[3*(d-2)+0]+c[0],v[3*(d-1)+1]=v[3*(d-2)+1]+c[1],v[3*(d-1)+2]=v[3*(d-2)+2]+c[2],g[2*(d-1)]=1,g[2*(d-1)+1]=1,m[3*(f-2)+0]=-l[0],m[3*(f-2)+1]=-l[1],m[3*(f-2)+2]=-l[2],m[3*(f-1)+0]=l[0],m[3*(f-1)+1]=l[1],m[3*(f-1)+2]=l[2]);const y=function(t,e,i){w[t]=e,x[t]=i};let S=0;const b=Ve(),C=Ve();for(let t=0;t<i;t++){const s=t*(2*Math.PI/i);T(b,u,Math.sin(s)),T(C,p,Math.cos(s)),O(b,b,C),m[3*t+0]=b[0],m[3*t+1]=b[1],m[3*t+2]=b[2],T(b,b,e),O(b,b,h),v[3*t+0]=b[0],v[3*t+1]=b[1],v[3*t+2]=b[2],g[2*t+0]=t/i,g[2*t+1]=0,v[3*(t+i)+0]=v[3*t+0]+c[0],v[3*(t+i)+1]=v[3*t+1]+c[1],v[3*(t+i)+2]=v[3*t+2]+c[2],g[2*(t+i)+0]=t/i,g[2*t+1]=1;const r=(t+1)%i;y(S++,t,t),y(S++,t+i,t),y(S++,r,r),y(S++,r,r),y(S++,t+i,t),y(S++,r+i,r)}if(o){for(let t=0;t<i;t++){const e=(t+1)%i;y(S++,d-2,f-2),y(S++,t,f-2),y(S++,e,f-2)}for(let t=0;t<i;t++){const e=(t+1)%i;y(S++,t+i,f-1),y(S++,d-1,f-1),y(S++,e+i,f-1)}}return new Dt([["position",{size:3,data:v,exclusive:!0}],["normal",{size:3,data:m,exclusive:!0}],["uv0",{size:2,data:g,exclusive:!0}]],[["position",w],["normal",x],["uv0",w]])},t.createTubeGeometry=function(e,i,s,r,o){s=s||10,r=null==r||r,ti(e.length>1);const n=[],a=[];for(let t=0;t<s;t++){n.push([0,-t-1,-(t+1)%s-1]);const e=t/s*2*Math.PI;a.push([Math.cos(e)*i,Math.sin(e)*i])}return t.createPathExtrusionGeometry(a,e,[[0,0,0]],n,r,o)},t.createPathExtrusionGeometry=function(t,e,i,r,o,n=Ne(0,0,0)){const a=t.length,l=new Float32Array(e.length*a*3+(6*i.length||0)),c=new Float32Array(e.length*a*3+(i?6:0)),h=(e.length-1)*a*6+3*r.length*2,u=new Uint32Array(h),p=new Uint32Array(h);let d=0,f=0,v=0,m=0;const g=Ve(),w=Ve(),x=Ve(),y=Ve(),S=Ve(),b=Ve(),C=Ve(),D=it(),P=Ve(),z=Ve(),M=Ve(),A=Ve(),_=Ve(),j=We();E(P,0,1,0),R(w,e[1],e[0]),L(w,w),o?(O(D,e[0],n),L(x,D)):E(x,0,0,1),s(w,x,P,P,S,x,vr),V(y,x),V(A,S);for(let t=0;t<i.length;t++)T(b,S,i[t][0]),T(D,x,i[t][2]),O(b,b,D),O(b,b,e[0]),l[d++]=b[0],l[d++]=b[1],l[d++]=b[2];c[f++]=-w[0],c[f++]=-w[1],c[f++]=-w[2];for(let t=0;t<r.length;t++)u[v++]=r[t][0]>0?r[t][0]:-r[t][0]-1+i.length,u[v++]=r[t][1]>0?r[t][1]:-r[t][1]-1+i.length,u[v++]=r[t][2]>0?r[t][2]:-r[t][2]-1+i.length,p[m++]=0,p[m++]=0,p[m++]=0;let N=i.length;const I=i.length-1;for(let i=0;i<e.length;i++){let r=!1;i>0&&(V(g,w),i<e.length-1?(R(w,e[i+1],e[i]),L(w,w)):r=!0,O(z,g,w),L(z,z),O(M,e[i-1],y),Ze(e[i],z,j),qe(j,ut(M,g),D)?(R(D,D,e[i]),L(x,D),F(S,z,x),L(S,S)):s(z,y,A,P,S,x,vr),V(y,x),V(A,S)),o&&(O(D,e[i],n),L(_,D));for(let s=0;s<a;s++)if(T(b,S,t[s][0]),T(D,x,t[s][1]),O(b,b,D),L(C,b),c[f++]=C[0],c[f++]=C[1],c[f++]=C[2],O(b,b,e[i]),l[d++]=b[0],l[d++]=b[1],l[d++]=b[2],!r){const t=(s+1)%a;u[v++]=N+s,u[v++]=N+a+s,u[v++]=N+t,u[v++]=N+t,u[v++]=N+a+s,u[v++]=N+a+t;for(let t=0;t<6;t++)p[m++]=u[v-6+t]-I}N+=a}const W=e[e.length-1];for(let t=0;t<i.length;t++)T(b,S,i[t][0]),T(D,x,i[t][1]),O(b,b,D),O(b,b,W),l[d++]=b[0],l[d++]=b[1],l[d++]=b[2];const U=f/3;c[f++]=w[0],c[f++]=w[1],c[f++]=w[2];const H=N-a;for(let t=0;t<r.length;t++)u[v++]=r[t][0]>=0?N+r[t][0]:-r[t][0]-1+H,u[v++]=r[t][2]>=0?N+r[t][2]:-r[t][2]-1+H,u[v++]=r[t][1]>=0?N+r[t][1]:-r[t][1]-1+H,p[m++]=U,p[m++]=U,p[m++]=U;return new Dt([["position",{size:3,data:l,exclusive:!0}],["normal",{size:3,data:c,exclusive:!0}]],[["position",u],["normal",p]])},t.createPolylineGeometry=function(t,e,i){ti(t.length>1,"createPolylineGeometry(): polyline needs at least 2 points"),ti(3===t[0].length,"createPolylineGeometry(): malformed vertex"),ti(null==e||e.length===t.length,"createPolylineGeometry: need same number of points and normals"),ti(null==e||3===e[0].length,"createPolylineGeometry(): malformed normal");const s=new Float64Array(3*t.length),r=new Uint32Array(2*(t.length-1));let o=0,n=0;for(let e=0;e<t.length;e++){for(let i=0;i<3;i++)s[o++]=t[e][i];e>0&&(r[n++]=e-1,r[n++]=e)}const a=[],l=[];if(a.push(["position",r]),l.push(["position",{size:3,data:s,exclusive:!0}]),e){const i=new Float32Array(3*e.length);let s=0;for(let r=0;r<t.length;r++)for(let t=0;t<3;t++)i[s++]=e[r][t];a.push(["normal",r]),l.push(["normal",{size:3,data:i,exclusive:!0}])}return i&&(l.push(["color",{size:4,data:i}]),a.push(["color",Je(i.length/4)])),new Dt(l,a,2)},t.createExtrudedTriangle=function(t,e,i,s,r=0){const o=new Array(18),n=[[-e,r,s/2],[i,r,s/2],[0,t+r,s/2],[-e,r,-s/2],[i,r,-s/2],[0,t+r,-s/2]],a=new Uint16Array([0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5]);for(let t=0;t<6;t++)o[3*t]=n[t][0],o[3*t+1]=n[t][1],o[3*t+2]=n[t][2];return new Dt([["position",{size:3,data:o,exclusive:!0}]],[["position",a]])},t.transformInPlace=function(t,e){const i=t.getMutableAttribute("position").data;for(let t=0;t<i.length;t+=3)E(mr,i[t],i[t+1],i[t+2]),j(mr,mr,e),i[t]=mr[0],i[t+1]=mr[1],i[t+2]=mr[2]},t.cgToGIS=function(t,e=t){const i=t.vertexAttributes,s=i.get("position").data,r=i.get("normal").data;if(r){const t=e.getMutableAttribute("normal").data;for(let e=0;e<r.length;e+=3){const i=r[e+1];t[e+1]=-r[e+2],t[e+2]=i}}if(s){const t=e.getMutableAttribute("position").data;for(let e=0;e<s.length;e+=3){const i=s[e+1];t[e+1]=-s[e+2],t[e+2]=i}}return e},t.makeOrthoBasisDirUp=i,t.makeOrthoBasisDirUpFallback=s}(fr||(fr={}));const vr=.99619469809,mr=Ve(),gr=fr;function wr(t){const e=Ct`vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`,i=Ct`vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {
vec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;
vec2 pixelSz = vec2(1.0) / widthHeight;
vec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;
vec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;
return vec4(result, clipCoord.zw);
}`;t.vertex.code.add(e),t.vertex.code.add(i),t.fragment.code.add(e),t.fragment.code.add(i)}class xr{constructor(t=it()){this.intensity=t}}class yr{constructor(t=it(),e=st(.57735,.57735,.57735)){this.intensity=t,this.direction=e}}class Sr{constructor(t=it(),e=st(.57735,.57735,.57735),i=!0){this.intensity=t,this.direction=e,this.castShadows=i}}class br{constructor(){this.r=[0],this.g=[0],this.b=[0]}}const Cr=i.getLogger("esri.views.3d.webgl-engine.lib.Camera");class Dr{constructor(e=null,i=null,s=null){this._viewUp=it(),this._viewForward=it(),this._viewRight=it(),this._ray=at(),this._viewport=Ei(0,0,1,1),this._padding=Ei(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=zi(1,1e3),this._viewDirty=!0,this._viewMatrix=M(),this._projectionDirty=!0,this._projectionMatrix=M(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=M(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=M(),this._frustumDirty=!0,this._frustum=Ws(),this._fullViewport=ji(),this.pixelRatio=1,this.relativeElevation=0,this.distanceFromSurface=0,t(e)&&V(this._ray.origin,e),this._center=t(i)?rt(i):it(),this._up=t(s)?rt(s):st(0,0,1)}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center)}get ray(){return R(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up)}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){fi(this._viewMatrix,t),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),this._viewForward}get viewUp(){return this._ensureViewClean(),this._viewUp}get viewRight(){return this._ensureViewClean(),this._viewRight}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get x(){return this._viewport[0]}set x(t){this._viewport[0]!==(t+=this._padding[3])&&(this._viewport[0]=t,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get y(){return this._viewport[1]}set y(t){this._viewport[1]!==(t+=this._padding[2])&&(this._viewport[1]=t,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get fullWidth(){return this._viewport[2]+this._padding[1]+this._padding[3]}set fullWidth(t){this.width=t-(this._padding[1]+this._padding[3])}get fullHeight(){return this._viewport[3]+this._padding[0]+this._padding[2]}set fullHeight(t){this.height=t-(this._padding[0]+this._padding[2])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[3],this._fullViewport[1]=this._viewport[1]-this._padding[2],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){this._padding[0]===t[0]&&this._padding[1]===t[1]&&this._padding[2]===t[2]&&this._padding[3]===t[3]||(this._viewport[0]+=t[3]-this._padding[3],this._viewport[1]+=t[2]-this._padding[2],this._viewport[2]-=t[1]+t[3]-(this._padding[1]+this._padding[3]),this._viewport[3]-=t[0]+t[2]-(this._padding[0]+this._padding[2]),I(this._padding,t),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0)}get viewProjectionMatrix(){return this._viewProjectionDirty&&(pi(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){if(this._projectionDirty){const t=this.width,e=this.height,i=this.near*Math.tan(this.fovY/2),s=i*this.aspect;vi(this._projectionMatrix,-s*(1+2*this._padding[3]/t),s*(1+2*this._padding[1]/t),-i*(1+2*this._padding[2]/e),i*(1+2*this._padding[0]/e),this.near,this.far),this._projectionDirty=!1}return this._projectionMatrix}set projectionMatrix(t){fi(this._projectionMatrix,t),this._projectionDirty=!1,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fov(){return this._fov}set fov(t){this._fov=t,this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return ei(this._fov,this.width,this.height)}set fovX(t){this._fov=ii(t,this.width,this.height),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return si(this._fov,this.width,this.height)}set fovY(t){this._fov=ri(t,this.width,this.height),this._projectionDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return W(this._center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&(di(this._viewInverseTransposeMatrix,this.viewMatrix),mi(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){return 2*this.near*this.far/(this.far+this.near-(2*t-1)*(this.far-this.near))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return this.relativeElevation&&this.relativeElevation>=0}copyFrom(t){V(this._ray.origin,t.eye),V(this._center,t.center),V(this._up,t.up),I(this._viewport,t.viewport),I(this._padding,t.padding),Di(this._nearFar,t.nearFar),this._fov=t.fov,this.relativeElevation=t.relativeElevation,this.distanceFromSurface=t.distanceFromSurface;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||(fi(this._viewMatrix,t.viewMatrix),V(this._viewRight,t.viewRight),V(this._viewUp,t.viewUp),V(this._viewForward,t.viewForward)),e._projectionDirty?this._projectionDirty=!0:(fi(this._projectionMatrix,t.projectionMatrix),this._projectionDirty=!1),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||(Hs(t.frustum,this._frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:(fi(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),I(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up}clone(){return(new Dr).copyFrom(this)}equals(t){return U(this.eye,t.eye)&&U(this._center,t.center)&&U(this._up,t.up)&&H(this._viewport,t.viewport)&&H(this._padding,t.padding)&&Pi(this._nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation}almostEquals(t){if(this.pixelRatio!==t.pixelRatio||Math.abs(t.fov-this._fov)>=.001)return!1;const e=5e-4;G(Mr,t.eye,t.center),G(Ar,this.eye,this._center);const i=N(Mr,Ar),s=q(Mr),r=q(Ar);return i*i>=(1-1e-10)*s*r&&$(t.eye,this.eye)<Math.max(s,r)*e*e&&B(t.padding,this._padding)<.5&&B(t.viewport,this._viewport)<.5}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this.viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this.viewDirectionDistance(t))}viewDirectionDistance(t){return Math.abs(pt(this.viewForward,R(Mr,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=li()){return t[0]=(this.padding[3]+this.width/2)/this.pixelRatio,t[1]=(this.padding[0]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,i=.5){return t[0]=this.padding[3]+this.width*e,t[1]=this.padding[2]+this.height*i,t[2]=.5,t}setGLViewport(t){const e=this.viewport,i=this.padding;t.setViewport(e[0]-i[3],e[1]-i[2],e[2]+i[1]+i[3],e[3]+i[0]+i[2])}applyProjection(t,e,i=!1){t!==Pr&&V(Pr,t),Pr[3]=1,i&&(e[2]=-Pr[2]),_(Pr,Pr,this.projectionMatrix),T(Pr,Pr,1/Math.abs(Pr[3]));const s=this.fullViewport;return e[0]=k(0,s[0]+s[2],.5+.5*Pr[0]),e[1]=k(0,s[1]+s[3],.5+.5*Pr[1]),i||(e[2]=.5*(Pr[2]+1)),e}projectToScreen(t,e){this.projectToRenderScreen(t,Or),this.renderToScreen(Or,e)}projectToRenderScreen(t,e){if(Pr[0]=t[0],Pr[1]=t[1],Pr[2]=t[2],Pr[3]=1,_(Pr,Pr,this.viewProjectionMatrix),0===Pr[3])return null;T(Pr,Pr,1/Math.abs(Pr[3]));const i=this.fullViewport;return"x"in e?(e.x=k(0,i[0]+i[2],.5+.5*Pr[0]),e.y=k(0,i[1]+i[3],.5+.5*Pr[1])):(e[0]=k(0,i[0]+i[2],.5+.5*Pr[0]),e[1]=k(0,i[1]+i[3],.5+.5*Pr[1]),e.length>2&&(e[2]=.5*(Pr[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,Or),e)}unprojectFromRenderScreen(t,e){if(pi(zr,this.projectionMatrix,this.viewMatrix),!di(zr,zr))return null;const i=this.fullViewport;return Pr[0]=2*(t[0]-i[0])/i[2]-1,Pr[1]=2*(t[1]-i[1])/i[3]-1,Pr[2]=2*t[2]-1,Pr[3]=1,_(Pr,Pr,zr),0===Pr[3]?null:(e[0]=Pr[0]/Pr[3],e[1]=Pr[1]/Pr[3],e[2]=Pr[2]/Pr[3],e)}constrainWindowSize(t,e,i,s=i){const r=t*this.pixelRatio,o=e*this.pixelRatio,n=Math.max(r-i/2,0),a=Math.max(this.fullHeight-o-s/2,0),l=-Math.min(r-i/2,0),c=-Math.min(this.fullHeight-o-s/2,0);return[n,a,i-l- -Math.min(this.fullWidth-r-i/2,0),s-c- -Math.min(o-s/2,0)]}computeUp(t){1===t?this.computeUpGlobal():this.computeUpLocal()}screenToRender(t,e){const i=this.fullHeight-t[1]*this.pixelRatio;return e[0]=t[0]*this.pixelRatio,e[1]=i,e}renderToScreen(t,e){const i=(this.fullHeight-t[1])/this.pixelRatio;e[0]=t[0]/this.pixelRatio,e[1]=i}computeUpGlobal(){R(Mr,this.center,this.eye);const t=A(this.center);t<1?(E(this._up,0,0,1),this._markViewDirty()):Math.abs(N(Mr,this.center))>.9999*A(Mr)*t||(F(this._up,Mr,this.center),F(this._up,this._up,Mr),L(this._up,this._up),this._markViewDirty())}computeUpLocal(){Z(Mr,this.eye,this.center),Math.abs(Mr[2])<=.9999&&(T(Mr,Mr,Mr[2]),E(this._up,-Mr[0],-Mr[1],1-Mr[2]),L(this._up,this._up),this._markViewDirty())}_compareAndSetView(t,e){"number"==typeof t[0]&&isFinite(t[0])&&"number"==typeof t[1]&&isFinite(t[1])&&"number"==typeof t[2]&&isFinite(t[2])?U(t,e)||(V(e,t),this._markViewDirty()):Cr.warn("Camera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&(Gs(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&(gi(this._viewMatrix,this.eye,this._center,this._up),E(this._viewForward,-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10]),E(this._viewUp,this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9]),E(this._viewRight,this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8]),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}}const Pr=ji(),zr=M(),Mr=it(),Ar=it(),Or=ci();let Tr=class extends n{constructor(){super(...arguments),this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR=!1,this.SCENEVIEW_LOCKING_LOG=!1,this.HIGHLIGHTS_GRID_OPTIMIZATION_ENABLED=!0,this.HIGHLIGHTS_PROFILE_TO_CONSOLE=!1,this.DECONFLICTOR_SHOW_VISIBLE=!1,this.DECONFLICTOR_SHOW_INVISIBLE=!1,this.DECONFLICTOR_SHOW_GRID=!1,this.LABELS_SHOW_BORDER=!1,this.OVERLAY_DRAW_DEBUG_TEXTURE=!1,this.OVERLAY_SHOW_CENTER=!1,this.SHOW_POI=!1,this.TESTS_DISABLE_OPTIMIZATIONS=!1,this.TESTS_DISABLE_FAST_UPDATES=!1,this.DRAW_MESH_GEOMETRY_NORMALS=!1,this.FEATURE_TILE_FETCH_SHOW_TILES=!1,this.FEATURE_TILE_TREE_SHOW_TILES=!1,this.TERRAIN_TILE_TREE_SHOW_TILES=!1,this.I3S_TREE_SHOW_TILES=!1,this.I3S_SHOW_MODIFICATIONS=!1,this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES=!1,this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL=!1,this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES=!1,this.ENABLE_CONTINUOUS_LINE_PATTERNS=!1,this.ENABLE_PER_SEGMENT_DISTANCE_LINE_PATTERNS=!1}};s([r()],Tr.prototype,"SCENEVIEW_HITTEST_RETURN_INTERSECTOR",void 0),s([r()],Tr.prototype,"SCENEVIEW_LOCKING_LOG",void 0),s([r()],Tr.prototype,"HIGHLIGHTS_GRID_OPTIMIZATION_ENABLED",void 0),s([r()],Tr.prototype,"HIGHLIGHTS_PROFILE_TO_CONSOLE",void 0),s([r()],Tr.prototype,"DECONFLICTOR_SHOW_VISIBLE",void 0),s([r()],Tr.prototype,"DECONFLICTOR_SHOW_INVISIBLE",void 0),s([r()],Tr.prototype,"DECONFLICTOR_SHOW_GRID",void 0),s([r()],Tr.prototype,"LABELS_SHOW_BORDER",void 0),s([r()],Tr.prototype,"OVERLAY_DRAW_DEBUG_TEXTURE",void 0),s([r()],Tr.prototype,"OVERLAY_SHOW_CENTER",void 0),s([r()],Tr.prototype,"SHOW_POI",void 0),s([r()],Tr.prototype,"TESTS_DISABLE_OPTIMIZATIONS",void 0),s([r()],Tr.prototype,"TESTS_DISABLE_FAST_UPDATES",void 0),s([r()],Tr.prototype,"DRAW_MESH_GEOMETRY_NORMALS",void 0),s([r()],Tr.prototype,"FEATURE_TILE_FETCH_SHOW_TILES",void 0),s([r()],Tr.prototype,"FEATURE_TILE_TREE_SHOW_TILES",void 0),s([r()],Tr.prototype,"TERRAIN_TILE_TREE_SHOW_TILES",void 0),s([r()],Tr.prototype,"I3S_TREE_SHOW_TILES",void 0),s([r()],Tr.prototype,"I3S_SHOW_MODIFICATIONS",void 0),s([r()],Tr.prototype,"LOD_INSTANCE_RENDERER_DISABLE_UPDATES",void 0),s([r()],Tr.prototype,"LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL",void 0),s([r()],Tr.prototype,"EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES",void 0),s([r()],Tr.prototype,"ENABLE_CONTINUOUS_LINE_PATTERNS",void 0),s([r()],Tr.prototype,"ENABLE_PER_SEGMENT_DISTANCE_LINE_PATTERNS",void 0),Tr=s([o("esri.views.3d.support.DebugFlags")],Tr);const _r=new Tr;class Er{constructor(t,e){this._material=t,this._repository=e,this._map=new Map}destroy(){this._map.forEach(((e,i)=>{t(e)&&this._repository.release(this._material,jr(i))}))}load(e,i){this._map.has(i)||this._map.set(i,this._repository.acquire(this._material,jr(i)));const s=this._map.get(i);if(t(s)){if(2===s.ensureResources(e))return s;this._repository.requestRender()}return null}}function jr(t){switch(t){default:return 0;case 1:return 7;case 4:case 7:case 6:return 3;case 3:return 2;case 2:return 1;case 5:return 4}}function Rr(t,e){const i=t;i.include(Pt),i.attributes.add("position","vec3"),i.attributes.add("normal","vec3"),i.attributes.add("auxpos1","vec4"),i.vertex.uniforms.add("proj","mat4"),i.vertex.uniforms.add("view","mat4"),i.vertex.uniforms.add("viewNormal","mat4"),i.vertex.uniforms.add("viewport","vec4"),i.vertex.uniforms.add("camPos","vec3"),i.vertex.uniforms.add("polygonOffset","float"),i.vertex.uniforms.add("cameraGroundRelative","float"),i.vertex.uniforms.add("pixelRatio","float"),i.vertex.uniforms.add("perDistancePixelRatio","float"),i.vertex.uniforms.add("uRenderTransparentlyOccludedHUD","float"),e.verticalOffsetEnabled&&i.vertex.uniforms.add("verticalOffset","vec4"),e.screenSizePerspectiveEnabled&&i.vertex.uniforms.add("screenSizePerspectiveAlignment","vec4"),i.vertex.uniforms.add("hudVisibilityTexture","sampler2D"),i.vertex.constants.add("smallOffsetAngle","float",.984807753012208),i.vertex.code.add(Ct`struct ProjectHUDAux {
vec3 posModel;
vec3 posView;
vec3 vnormal;
float distanceToCamera;
float absCosAngle;
};`),i.vertex.code.add(Ct`float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {
float pointGroundSign = sign(pointGroundDistance);
if (pointGroundSign == 0.0) {
pointGroundSign = cameraGroundRelative;
}
float groundRelative = cameraGroundRelative * pointGroundSign;
if (polygonOffset > .0) {
float cosAlpha = clamp(absCosAngle, 0.01, 1.0);
float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;
float factor = (1.0 - tanAlpha / viewport[2]);
if (groundRelative > 0.0) {
posView *= factor;
}
else {
posView /= factor;
}
}
return groundRelative;
}`),e.isDraped||i.vertex.code.add(Ct`void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {
float distanceToCamera = length(posView);
float pixelOffset = distanceToCamera * perDistancePixelRatio * 0.5;
vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;
vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
posModel += modelOffset;
posView += viewOffset;
}`),i.vertex.code.add(Ct`
    vec4 projectPositionHUD(out ProjectHUDAux aux) {
      // centerOffset is in view space and is used to implement world size offsetting
      // of labels with respect to objects. It also pulls the label towards the viewer
      // so that the label is visible in front of the object.
      vec3 centerOffset = auxpos1.xyz;

      // The pointGroundDistance is the distance of the geometry to the ground and is
      // negative if the point is below the ground, or positive if the point is above
      // ground.
      float pointGroundDistance = auxpos1.w;

      aux.posModel = position;
      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;
      aux.vnormal = normal;
      ${e.isDraped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);"}

      // Screen sized offset in world space, used for example for line callouts
      // Note: keep this implementation in sync with the CPU implementation, see
      //   - MaterialUtil.verticalOffsetAtDistance
      //   - HUDMaterial.applyVerticalOffsetTransformation

      aux.distanceToCamera = length(aux.posView);

      vec3 viewDirObjSpace = normalize(camPos - aux.posModel);
      float cosAngle = dot(aux.vnormal, viewDirObjSpace);

      aux.absCosAngle = abs(cosAngle);

      ${e.screenSizePerspectiveEnabled&&(e.verticalOffsetEnabled||1===e.screenCenterOffsetUnitsEnabled)?"vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":""}

      ${e.verticalOffsetEnabled?e.screenSizePerspectiveEnabled?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":""}

      ${e.verticalOffsetEnabled?Ct`
            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);
            vec3 modelOffset = aux.vnormal * worldOffset;
            aux.posModel += modelOffset;
            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;
            aux.posView += viewOffset;
            // Since we elevate the object, we need to take that into account
            // in the distance to ground
            pointGroundDistance += worldOffset;`:""}

      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);

      ${1!==e.screenCenterOffsetUnitsEnabled?Ct`
            // Apply x/y in view space, but z in screen space (i.e. along posView direction)
            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);

            // Same material all have same z != 0.0 condition so should not lead to
            // branch fragmentation and will save a normalization if it's not needed
            if (centerOffset.z != 0.0) {
              aux.posView -= normalize(aux.posView) * centerOffset.z;
            }
          `:""}

      vec4 posProj = proj * vec4(aux.posView, 1.0);

      ${1===e.screenCenterOffsetUnitsEnabled?e.screenSizePerspectiveEnabled?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":""}

      ${1===e.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""}

      // constant part of polygon offset emulation
      posProj.z -= groundRelative * polygonOffset * posProj.w;
      return posProj;
    }
  `),i.vertex.code.add(Ct`bool testVisibilityHUD(vec4 posProj) {
vec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);
vec4 occlusionPixel = texture2D(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);
if (uRenderTransparentlyOccludedHUD > 0.5) {
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * uRenderTransparentlyOccludedHUD < 1.0;
}
return occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;
}`)}function Fr(t,e){t.setUniform1f("uRenderTransparentlyOccludedHUD",0===e.renderTransparentlyOccludedHUD?1:1===e.renderTransparentlyOccludedHUD?0:.75)}function Lr(t){t.include(zt),t.uniforms.add("geometryDepthTexture","sampler2D"),t.uniforms.add("cameraNearFar","vec2"),t.code.add(Ct`bool geometryDepthTest(vec2 pos, float elementDepth) {
float geometryDepth = linearDepthFromTexture(geometryDepthTexture, pos, cameraNearFar);
return (elementDepth < (geometryDepth - 1.0));
}`)}function Nr(t,e){e.multipassGeometryEnabled&&e.geometryLinearDepthTexture&&t.bindTexture(e.geometryLinearDepthTexture,"geometryDepthTexture")}function Vr(t,e){e.multipassGeometryEnabled&&t.vertex.include(Lr),e.multipassTerrainEnabled&&t.varyings.add("depth","float"),t.vertex.code.add(Ct`
  void main(void) {
    vec4 posProjCenter;
    if (dot(position, position) > 0.0) {
      // Render single point to center of the pixel to avoid subpixel
      // filtering to affect the marker color
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      posProjCenter = alignToPixelCenter(posProj, viewport.zw);

      ${e.multipassGeometryEnabled?Ct`
        // Don't draw vertices behind geometry
        if(geometryDepthTest(.5 + .5 * posProjCenter.xy / posProjCenter.w, projectAux.posView.z)){
          posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
        }`:""}

      ${e.multipassTerrainEnabled?"depth = projectAux.posView.z;":""}
      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        // Project out of clip space
        posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
      }

    } else {
      // Project out of clip space
      posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
    }

    gl_Position = posProjCenter;
    gl_PointSize = 1.0;
  }
  `),e.multipassTerrainEnabled&&t.fragment.include(zt),t.fragment.uniforms.add("terrainDepthTexture","sampler2D"),t.fragment.uniforms.add("cameraNearFar","vec2"),t.fragment.uniforms.add("inverseViewport","vec2"),t.fragment.include(Mt),t.fragment.code.add(Ct`
  void main() {
    gl_FragColor = vec4(1, 1, 1, 1);
    ${e.multipassTerrainEnabled?Ct`

          vec2 uv = gl_FragCoord.xy * inverseViewport;

          //Read the rgba data from the texture linear depth
          vec4 terrainDepthData = texture2D(terrainDepthTexture, uv);

          float terrainDepth = linearDepthFromFloat(rgba2float(terrainDepthData), cameraNearFar);

          //If HUD vertex is behind terrain and the terrain depth is not the initialize value (e.g. we are not looking at the sky)
          //Mark the HUD vertex as occluded by transparent terrain
          if(depth < terrainDepth && terrainDepthData != vec4(0,0,0,1)){
            gl_FragColor.g = 0.5;
          }`:""}
  }
  `)}function Ir(t){const e=new At,i=t.signedDistanceFieldEnabled;if(e.include(wr),e.include(Rr,t),e.include(Ot,t),6===t.output)return e.include(Vr,t),e;e.include(Pt),e.fragment.include(Mt),e.fragment.include(Tt),e.include(_t,t),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2"),t.binaryHighlightOcclusionEnabled&&e.varyings.add("voccluded","float"),e.vertex.uniforms.add("screenOffset","vec2").add("anchorPos","vec2").add("textureCoordinateScaleFactor","vec2").add("materialColor","vec4"),i&&e.vertex.uniforms.add("outlineColor","vec4"),t.screenSizePerspectiveEnabled&&e.vertex.uniforms.add("screenSizePerspective","vec4"),(t.debugDrawBorder||t.binaryHighlightOcclusionEnabled)&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add("uv0","vec2"),e.attributes.add("color","vec4"),e.attributes.add("size","vec2"),e.attributes.add("auxpos2","vec4"),e.vertex.code.add(Ct`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }
      vec2 inputSize;
      ${t.screenSizePerspectiveEnabled?Ct`
      inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
      vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
         `:Ct`
      inputSize = size;
      vec2 screenOffsetScaled = screenOffset;`}

      ${t.vvSize?"inputSize *= vvScale(auxpos2).xx;":""}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${t.occlusionTestEnabled||t.binaryHighlightOcclusionEnabled?"bool visible = testVisibilityHUD(posProj);":""}

      ${t.binaryHighlightOcclusionEnabled?"voccluded = visible ? 0.0 : 1.0;":""}
    `);const s=Ct`vec2 uv01 = floor(uv0);
vec2 uv = uv0 - uv01;
quadOffset.xy = ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffsetScaled) / viewport.zw * posProj.w;`,r=t.pixelSnappingEnabled?i?Ct`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:Ct`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:Ct`posProj += quadOffset;`;e.vertex.code.add(Ct`
      ${t.occlusionTestEnabled?"if (visible) {":""}
      ${s}
      ${t.vvColor?"vcolor = vvGetColor(auxpos2, vvColorValues, vvColorColors) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

      bool alphaDiscard = vcolor.a < ${Ct.float(Et)};
      ${i?`alphaDiscard = alphaDiscard && outlineColor.a < ${Ct.float(Et)};`:""}
      if (alphaDiscard) {
        // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      } else {
        ${r}
        gl_Position = posProj;
      }

      vtc = uv * textureCoordinateScaleFactor;

      ${t.debugDrawBorder?"debugBorderCoords = vec4(uv01, 1.5 / combinedSize);":""}
      vsize = inputSize;
      ${t.occlusionTestEnabled?Ct`} else { vtc = vec2(0.0);
        ${t.debugDrawBorder?"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);}":"}"}`:""}
    }
    `),e.fragment.uniforms.add("tex","sampler2D"),i&&(e.fragment.uniforms.add("outlineColor","vec4"),e.fragment.uniforms.add("outlineSize","float"));const o=t.debugDrawBorder?Ct`(isBorder > 0.0 ? 0.0 : ${Ct.float(jt)})`:Ct.float(jt),n=Ct`
    ${t.debugDrawBorder?Ct`
      float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`:""}

    ${i?Ct`
      vec4 fillPixelColor = vcolor;

      // Attempt to sample texel centers to avoid that thin cross outlines
      // disappear with large symbol sizes.
      // see: https://devtopia.esri.com/WebGIS/arcgis-js-api/issues/7058#issuecomment-603041
      const float txSize = 128.0;
      const float texelSize = 1.0 / txSize;
      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgba2float(texture2D(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${o} ||
          fillPixelColor.a + outlinePixelColor.a < ${Ct.float(Et)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        gl_FragColor = vec4(compositeColor, compositeAlpha);
      } else {
        if (fillAlphaFactor < ${o}) {
          discard;
        }

        gl_FragColor = premultiplyAlpha(fillPixelColor);
      }

      // visualize SDF:
      // gl_FragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:Ct`
          vec4 texColor = texture2D(tex, vtc, -0.5);
          if (texColor.a < ${o}) {
            discard;
          }
          gl_FragColor = texColor * premultiplyAlpha(vcolor);
          `}

    ${t.debugDrawBorder?Ct`gl_FragColor = mix(gl_FragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder);`:""}
  `;return 7===t.output&&e.fragment.code.add(Ct`
      void main() {
        ${n}
        gl_FragColor = vec4(gl_FragColor.a);
      }
      `),0===t.output&&e.fragment.code.add(Ct`
    void main() {
      ${n}
      ${t.FrontFacePass?"gl_FragColor.rgb /= gl_FragColor.a;":""}
    }
    `),4===t.output&&(e.include(Rt),e.fragment.code.add(Ct`
    void main() {
      ${n}
      ${t.binaryHighlightOcclusionEnabled?Ct`
          if (voccluded == 1.0) {
            gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
          } else {
            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
          }`:"outputHighlight();"}
    }
    `)),e}function Wr(t,e,i){t.setUniform4fv("materialColor",e.color),e.textureIsSignedDistanceField&&(e.outlineColor[3]<=0||e.outlineSize<=0?(t.setUniform4fv("outlineColor",Ri),t.setUniform1f("outlineSize",0)):(t.setUniform4fv("outlineColor",e.outlineColor),t.setUniform1f("outlineSize",e.outlineSize))),t.setUniform2f("screenOffset",2*e.screenOffset[0]*i,2*e.screenOffset[1]*i),t.setUniform2fv("anchorPos",Ur(e))}function Ur(t,e=Hr){return t.textureIsSignedDistanceField?function(t,e,i){i[0]=t[0]*(e[2]-e[0])+e[0],i[1]=t[1]*(e[3]-e[1])+e[1]}(t.anchorPos,t.distanceFieldBoundingBox,e):Di(e,t.anchorPos),e}const Hr=Mi(),Gr=Object.freeze({__proto__:null,build:Ir,bindHUDMaterialUniforms:Wr,calculateAnchorPosForRendering:Ur});class $r extends Nt{initializeProgram(t){const e=$r.shader.get(),i=this.configuration,s=e.build({output:i.output,FrontFacePass:2===i.transparencyPassType,viewingMode:t.viewingMode,occlusionTestEnabled:i.occlusionTestEnabled,signedDistanceFieldEnabled:i.sdf,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!0,debugDrawBorder:i.debugDrawBorder,binaryHighlightOcclusionEnabled:i.binaryHighlightOcclusion,screenCenterOffsetUnitsEnabled:i.screenCenterOffsetUnitsEnabled,screenSizePerspectiveEnabled:i.screenSizePerspective,verticalOffsetEnabled:i.verticalOffset,pixelSnappingEnabled:i.pixelSnappingEnabled,vvSize:i.vvSize,vvColor:i.vvColor,vvInstancingEnabled:!1,isDraped:i.isDraped,multipassGeometryEnabled:i.multipassGeometryEnabled,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new Vt(t.rctx,s,It)}bindPass(t,e){Wt(this.program,e.camera.projectionMatrix),this.program.setUniform1f("cameraGroundRelative",e.camera.aboveGround?1:-1),this.program.setUniform1f("perDistancePixelRatio",Math.tan(e.camera.fovY/2)/(e.camera.fullViewport[2]/2)),this.program.setUniformMatrix4fv("viewNormal",e.camera.viewInverseTransposeMatrix),this.program.setUniform1f("polygonOffset",t.shaderPolygonOffset),Ut(this.program,t,e),Ht(this.program,t),this.program.setUniform1f("pixelRatio",e.camera.pixelRatio||1),Gt(this.program,e),6===this.configuration.output?(this.program.setUniform2fv("cameraNearFar",e.camera.nearFar),this.program.setUniform2fv("inverseViewport",e.inverseViewport),Nr(this.program,e),$t(this.program,e)):(Fr(this.program,e),Wr(this.program,t,e.camera.pixelRatio||1),Bt(this.program,t),this.configuration.occlusionTestEnabled&&this.program.bindTexture(e.hudVisibilityTexture,"hudVisibilityTexture")),4===this.configuration.output&&kt(this.program,e)}bindDraw(t){Zt(this.program,t),qt(this.program,t.origin,t.camera.viewInverseTransposeMatrix),Qt(this.program,this.configuration,t),this.program.rebindTextures()}setPipelineState(t){const e=this.configuration,i=3===t,s=this.configuration.polygonOffsetEnabled&&Br,r=!i&&2!==t||4===e.output?null:(e.depthEnabled||6===e.output)&&Ui;return Ni({blending:0===e.output||7===e.output||4===e.output?i?kr:Vi(t):null,depthTest:{func:515},depthWrite:r,colorWrite:Ii,polygonOffset:s})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}get primitiveType(){return 6===this.configuration.output?0:4}}$r.shader=new Jt(Gr,(()=>import("./p-43e93b8b.js")));const Br={factor:0,units:-4},kr=Wi(1,771);class Zr extends Lt{constructor(){super(...arguments),this.output=0,this.occlusionTestEnabled=!0,this.sdf=!1,this.vvSize=!1,this.vvColor=!1,this.verticalOffset=!1,this.screenSizePerspective=!1,this.screenCenterOffsetUnitsEnabled=0,this.debugDrawBorder=!0,this.binaryHighlightOcclusion=!0,this.slicePlaneEnabled=!1,this.polygonOffsetEnabled=!1,this.depthEnabled=!0,this.transparencyPassType=3,this.pixelSnappingEnabled=!0,this.isDraped=!1,this.multipassGeometryEnabled=!1,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}s([Ft({count:8})],Zr.prototype,"output",void 0),s([Ft()],Zr.prototype,"occlusionTestEnabled",void 0),s([Ft()],Zr.prototype,"sdf",void 0),s([Ft()],Zr.prototype,"vvSize",void 0),s([Ft()],Zr.prototype,"vvColor",void 0),s([Ft()],Zr.prototype,"verticalOffset",void 0),s([Ft()],Zr.prototype,"screenSizePerspective",void 0),s([Ft({count:2})],Zr.prototype,"screenCenterOffsetUnitsEnabled",void 0),s([Ft()],Zr.prototype,"debugDrawBorder",void 0),s([Ft()],Zr.prototype,"binaryHighlightOcclusion",void 0),s([Ft()],Zr.prototype,"slicePlaneEnabled",void 0),s([Ft()],Zr.prototype,"polygonOffsetEnabled",void 0),s([Ft()],Zr.prototype,"depthEnabled",void 0),s([Ft({count:4})],Zr.prototype,"transparencyPassType",void 0),s([Ft()],Zr.prototype,"pixelSnappingEnabled",void 0),s([Ft()],Zr.prototype,"isDraped",void 0),s([Ft()],Zr.prototype,"multipassGeometryEnabled",void 0),s([Ft()],Zr.prototype,"multipassTerrainEnabled",void 0),s([Ft()],Zr.prototype,"cullAboveGround",void 0);class qr extends Yt{constructor(t){super(t,mo),this.techniqueConfig=new Zr}getTechniqueConfig(t,e){return this.techniqueConfig.output=t,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.verticalOffset=!!this.parameters.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.parameters.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?1:0,this.techniqueConfig.polygonOffsetEnabled=this.parameters.polygonOffset,this.techniqueConfig.isDraped=this.parameters.isDraped,this.techniqueConfig.occlusionTestEnabled=this.parameters.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this.techniqueConfig.sdf=this.parameters.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.parameters.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.parameters.vvColorEnabled,0===t&&(this.techniqueConfig.debugDrawBorder=!!this.parameters.debugDrawBorder),4===t&&(this.techniqueConfig.binaryHighlightOcclusion=this.parameters.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.parameters.depthEnabled,this.techniqueConfig.transparencyPassType=e.transparencyPassType,this.techniqueConfig.multipassGeometryEnabled=e.multipassGeometryEnabled,this.techniqueConfig.multipassTerrainEnabled=e.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=e.cullAboveGround,this.techniqueConfig}intersect(t,e,i,s,r,o,n,a,l){l?this.intersectDrapedHudGeometry(t,o,n,a):this.intersectHudGeometry(t,e,i,s,n,a)}intersectDrapedHudGeometry(e,i,s,r){const o=e.vertexAttributes.get("position"),n=e.vertexAttributes.get("size"),a=this.parameters,l=Ur(a);let c=1,h=1;if(t(r)){const t=r(ho);c=t[0],h=t[5]}c*=e.screenToWorldRatio,h*=e.screenToWorldRatio;const u=po*e.screenToWorldRatio;for(let t=0;t<o.data.length/o.size;t++){const r=t*o.size,p=o.data[r],d=o.data[r+1],f=t*n.size;let v;fo[0]=n.data[f]*c,fo[1]=n.data[f+1]*h,a.textureIsSignedDistanceField&&(v=a.outlineSize*e.screenToWorldRatio/2),Yr(i,p,d,fo,u,v,a,l)&&s()}}intersectHudGeometry(e,i,s,r,o,n){if(!r.options.selectionMode||!r.options.hud)return;if(Ee(i))return;const a=this.parameters;let l=1,c=1;if(hi(oo,s),t(n)){const t=n(ho);l=t[0],c=t[5],function(t){const e=t[0],i=t[1],s=t[2],r=t[3],o=t[4],n=t[5],a=t[6],l=t[7],c=t[8],h=1/Math.sqrt(e*e+i*i+s*s),u=1/Math.sqrt(r*r+o*o+n*n),p=1/Math.sqrt(a*a+l*l+c*c);t[0]=e*h,t[1]=i*h,t[2]=s*h,t[3]=r*u,t[4]=o*u,t[5]=n*u,t[6]=a*p,t[7]=l*p,t[8]=c*p}(oo)}const h=e.vertexAttributes.get("position"),u=e.vertexAttributes.get("size"),p=e.vertexAttributes.get("normal"),d=e.vertexAttributes.get("auxpos1");ti(h.size>=3);const f=r.point,v=r.camera,m=Ur(a);l*=v.pixelRatio,c*=v.pixelRatio;const g="screen"===this.parameters.centerOffsetUnits;for(let t=0;t<h.data.length/h.size;t++){const e=t*h.size;E(to,h.data[e],h.data[e+1],h.data[e+2]),j(to,to,s);const i=t*u.size;fo[0]=u.data[i]*l,fo[1]=u.data[i+1]*c,j(to,to,v.viewMatrix);const n=t*d.size;if(E(lo,d.data[n+0],d.data[n+1],d.data[n+2]),!g&&(to[0]+=lo[0],to[1]+=lo[1],0!==lo[2])){const t=lo[2];L(lo,to),R(to,to,T(lo,lo,t))}const w=t*p.size;if(E(eo,p.data[w],p.data[w+1],p.data[w+2]),this.normalAndViewAngle(eo,oo,v,co),this.applyVerticalOffsetTransformationView(to,co,v,Xr),v.applyProjection(to,io),io[0]>-1){let t,e=Math.floor(io[0])+this.parameters.screenOffset[0],i=Math.floor(io[1])+this.parameters.screenOffset[1];if(g&&(e+=lo[0],0!==lo[1]&&(i+=ae(lo[1],Xr.factorAlignment))),Xt(fo,Xr.factor,fo),a.textureIsSignedDistanceField&&(t=a.outlineSize*v.pixelRatio/2),Yr(f,e,i,fo,uo*v.pixelRatio,t,a,m)){const t=r.ray;if(j(ro,to,di(ao,v.viewMatrix)),io[0]=f[0],io[1]=f[1],v.unprojectFromRenderScreen(io,to)){const e=it();V(e,t.direction);const i=1/A(e);T(e,e,i),o(W(t.origin,to)*i,e,-1,1,!0,ro)}}}}}computeAttachmentOrigin(t,e){const i=t.vertexAttributes;if(!i)return!1;const s=i.get("position"),r=t.indices.get("position");return Ye(s,r,e)}createBufferWriter(){return new wo(this)}normalAndViewAngle(t,e,i,s){return function(t){return function(t){return t instanceof Float32Array&&t.length>=16}(t)||function(t){return Array.isArray(t)&&t.length>=16}(t)}(e)&&(e=hi(no,e)),Q(s.normal,t,e),j(s.normal,s.normal,i.viewInverseTransposeMatrix),s.cosAngle=N(so,vo),s}updateScaleInfo(t,e,i){const s=this.parameters;s.screenSizePerspective?Kt(i,e,s.screenSizePerspective,t.factor):(t.factor.scale=1,t.factor.factor=0,t.factor.minPixelSize=0,t.factor.paddingPixels=0),s.screenSizePerspectiveAlignment?Kt(i,e,s.screenSizePerspectiveAlignment,t.factorAlignment):(t.factorAlignment.factor=t.factor.factor,t.factorAlignment.scale=t.factor.scale,t.factorAlignment.minPixelSize=t.factor.minPixelSize,t.factorAlignment.paddingPixels=t.factor.paddingPixels)}applyShaderOffsetsView(t,e,i,s,r,o,n){const a=this.normalAndViewAngle(e,i,r,co);return this.applyVerticalGroundOffsetView(t,a,r,n),this.applyVerticalOffsetTransformationView(n,a,r,o),this.applyPolygonOffsetView(n,a,s[3],r,n),this.applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,i,s,r,o){return this.applyCenterOffsetNDC(e,i,s,r),t(o)&&V(o,r),this.applyPolygonOffsetNDC(r,i,s,r),r}applyPolygonOffsetView(t,e,i,s,r){const o=s.aboveGround?1:-1;let n=Math.sign(i);0===n&&(n=o);const a=o*n;if(this.parameters.shaderPolygonOffset<=0)return V(r,t);const l=J(Math.abs(e.cosAngle),.01,1),c=1-Math.sqrt(1-l*l)/l/s.viewport[2];return T(r,t,a>0?c:1/c),r}applyVerticalGroundOffsetView(t,e,i,s){const r=A(t),o=i.aboveGround?1:-1,n=.5*i.computeRenderPixelSizeAtDist(r),a=T(to,e.normal,o*n);return O(s,t,a),s}applyVerticalOffsetTransformationView(t,e,i,s){const r=this.parameters;if(!r.verticalOffset||!r.verticalOffset.screenLength){if(r.screenSizePerspective||r.screenSizePerspectiveAlignment){const i=A(t);this.updateScaleInfo(s,i,e.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return t}const o=A(t),n=ne(i,o,r.verticalOffset,e.cosAngle,r.screenSizePerspectiveAlignment||r.screenSizePerspective);return this.updateScaleInfo(s,o,e.cosAngle),T(e.normal,e.normal,n),O(t,t,e.normal)}applyCenterOffsetView(t,e,i){const s="screen"!==this.parameters.centerOffsetUnits;return i!==t&&V(i,t),s&&(i[0]+=e[0],i[1]+=e[1],e[2]&&(L(eo,i),O(i,i,T(eo,eo,e[2])))),i}applyCenterOffsetNDC(t,e,i,s){const r="screen"!==this.parameters.centerOffsetUnits;return s!==t&&V(s,t),r||(s[0]+=e[0]/i.fullWidth*2,s[1]+=e[1]/i.fullHeight*2),s}applyPolygonOffsetNDC(t,e,i,s){const r=this.parameters.shaderPolygonOffset;if(t!==s&&V(s,t),r){const t=i.aboveGround?1:-1,o=t*Math.sign(e[3]);s[2]-=(o||t)*r}return s}requiresSlot(t,e){const i=jr(e);if(0===i||7===i){if(20===t)return!0;const e=this.parameters.drawInSecondSlot?17:16;return this.parameters.occlusionTest&&11===t||t===e}return t===(this.parameters.drawInSecondSlot?17:16)||20===t}createGLMaterial(t){return 0===t.output||7===t.output?new Jr(t):4===t.output?new Qr(t):null}calculateRelativeScreenBounds(t,e,i=Ai()){return function(t,e,i,s=Kr){Di(s,t.anchorPos),s[0]*=-e[0],s[1]*=-e[1],s[0]+=t.screenOffset[0]*i,s[1]+=t.screenOffset[1]*i}(this.parameters,t,e,i),i[2]=i[0]+t[0],i[3]=i[1]+t[1],i}}class Qr extends te{constructor(t){super({...t,...t.material.parameters})}updateParameters(t){return this.updateTexture(this._material.parameters.textureId),this.selectProgram(t)}selectProgram(t){return this.ensureTechnique($r,t)}beginSlot(t){return this.updateParameters(t)}bind(t,e){this.bindTextures(e.program),this.bindTextureScale(e.program),e.bindPass(this._material.parameters,t)}}class Jr extends Qr{isOcclusionSlot(t){return 11===t.slot&&this._material.parameters.occlusionTest&&(0===this._output||7===this._output)}selectProgram(t){return this.ensureTechnique($r,t,this.isOcclusionSlot(t)?6:this._output)}bind(t,e){this.isOcclusionSlot(t)||(this.bindTextures(e.program),this.bindTextureScale(e.program)),e.bindPass(this._material.parameters,t)}}function Yr(t,e,i,s,r,o,n,a){let l=e-r-(a[0]>0?s[0]*a[0]:0),c=l+s[0]+2*r,h=i-r-(a[1]>0?s[1]*a[1]:0),u=h+s[1]+2*r;if(n.textureIsSignedDistanceField){const t=n.distanceFieldBoundingBox;l+=s[0]*t[0],h+=s[1]*t[1],c-=s[0]*(1-t[2]),u-=s[1]*(1-t[3]),l-=o,c+=o,h-=o,u+=o}return t[0]>l&&t[0]<c&&t[1]>h&&t[1]<u}const Xr={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},Kr=Mi(),to=it(),eo=it(),io=ci(),so=it(),ro=it(),oo=ui(),no=ui(),ao=M(),lo=it(),co={normal:so,cosAngle:0},ho=M(),uo=1,po=2,fo=[0,0],vo=st(0,0,1),mo={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,slicePlaneEnabled:!1,anchorPos:zi(.5,.5),shaderPolygonOffset:1e-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",depthEnabled:!0,pixelSnappingEnabled:!0,debugDrawBorder:!1,isDraped:!1,...ee},go=_i().vec3f("position").vec3f("normal").vec2f("uv0").vec4u8("color").vec2f("size").vec4f("auxpos1").vec4f("auxpos2");class wo{constructor(t){this.material=t,this.vertexBufferLayout=go}allocate(t){return this.vertexBufferLayout.createBuffer(t)}elementCount(t){return 6*t.indices.get("position").length}write(t,e,i,s){ie(e.indices.get("position"),e.vertexAttributes.get("position").data,t.transformation,i.position,s,6),se(e.indices.get("normal"),e.vertexAttributes.get("normal").data,t.invTranspTransformation,i.normal,s,6);{const t=e.vertexAttributes.get("uv0").data;let r,o,n,a;if(null==t||t.length<4){const t=this.material.parameters;r=0,o=0,n=t.texCoordScale[0],a=t.texCoordScale[1]}else r=t[0],o=t[1],n=t[2],a=t[3];n=Math.min(1.99999,n+1),a=Math.min(1.99999,a+1);const l=e.indices.get("position").length,c=i.uv0;let h=s;for(let t=0;t<l;++t)c.set(h,0,r),c.set(h,1,o),h+=1,c.set(h,0,n),c.set(h,1,o),h+=1,c.set(h,0,n),c.set(h,1,a),h+=1,c.set(h,0,n),c.set(h,1,a),h+=1,c.set(h,0,r),c.set(h,1,a),h+=1,c.set(h,0,r),c.set(h,1,o),h+=1}re(e.indices.get("color"),e.vertexAttributes.get("color").data,4,i.color,s,6);{const t=e.indices.get("size"),r=e.vertexAttributes.get("size").data,o=t.length,n=i.size;let a=s;for(let e=0;e<o;++e){const i=r[2*t[e]],s=r[2*t[e]+1];for(let t=0;t<6;++t)n.set(a,0,i),n.set(a,1,s),a+=1}}e.indices.get("auxpos1")&&e.vertexAttributes.get("auxpos1")&&oe(e.indices.get("auxpos1"),e.vertexAttributes.get("auxpos1").data,i.auxpos1,s,6),e.indices.get("auxpos2")&&e.vertexAttributes.get("auxpos2")&&oe(e.indices.get("auxpos2"),e.vertexAttributes.get("auxpos2").data,i.auxpos2,s,6)}}function xo(t){return"declaredClass"in t}function yo(t){return"declaredClass"in t}function So(t,e){if(!t)return null;if(function(t){return"declaredClass"in t}(t))return t;const i=new ds({layer:e,sourceLayer:e});return i.visible=t.visible,i.symbol=a(t.symbol),i.attributes=a(t.attributes),i.geometry=bo(t.geometry),i}function bo(t){return l(t)?null:xo(t)?t:fs(function(t){const e=t.spatialReference.toJSON();switch(t.type){case"point":{const{x:i,y:s,z:r,m:o}=t;return{x:i,y:s,z:r,m:o,spatialReference:e}}case"polygon":{const{rings:i,hasZ:s,hasM:r}=t;return{rings:Co(i),hasZ:s,hasM:r,spatialReference:e}}case"polyline":{const{paths:i,hasZ:s,hasM:r}=t;return{paths:Co(i),hasZ:s,hasM:r,spatialReference:e}}case"extent":{const{xmin:i,xmax:s,ymin:r,ymax:o,zmin:n,zmax:a,mmin:l,mmax:c,hasZ:h,hasM:u}=t;return{xmin:i,xmax:s,ymin:r,ymax:o,zmin:n,zmax:a,mmin:l,mmax:c,hasZ:h,hasM:u,spatialReference:e}}case"multipoint":{const{points:i,hasZ:s,hasM:r}=t;return{points:Po(i)?Do(i):i,hasZ:s,hasM:r,spatialReference:e}}default:return}}(t))}function Co(t){return function(t){for(const e of t)if(0!==e.length)return Po(e);return!1}(t)?t.map((t=>Do(t))):t}function Do(t){return t.map((t=>u(t)))}function Po(t){return t.length&&(c(t[0])||h(t[0]))}function zo(t,e){if(!t)return null;let i;if(yo(t)){if(null==e)return t.clone();if(yo(e))return e.copy(t)}return null!=e?(i=e,i.x=t.x,i.y=t.y,i.spatialReference=t.spatialReference,t.hasZ?(i.z=t.z,i.hasZ=t.hasZ):(i.z=null,i.hasZ=!1),t.hasM?(i.m=t.m,i.hasM=!0):(i.m=null,i.hasM=!1)):(i=cs(t.x,t.y,t.z,t.spatialReference),t.hasM&&(i.m=t.m,i.hasM=!0)),i}function Mo(t,e){if("point"===t.type)return Oo(t,e,!1);if(xo(t))switch(t.type){case"extent":return Oo(t.center,e,!1);case"polygon":return Oo(t.centroid,e,!1);case"polyline":return Oo(Ao(t),e,!0);case"mesh":return Oo(t.origin,e,!1)}else switch(t.type){case"extent":return Oo(function(t){const e=isFinite(t.zmin);return cs(.5*(t.xmax+t.xmin),.5*(t.ymax+t.ymin),e?.5*(t.zmax+t.zmin):void 0,t.spatialReference)}(t),e,!0);case"polygon":return Oo(function(t){const e=t.rings[0];if(!e||0===e.length)return null;const i=ns(t.rings,t.hasZ);return cs(i[0],i[1],i[2],t.spatialReference)}(t),e,!0);case"polyline":return Oo(Ao(t),e,!0)}}function Ao(t){const e=t.paths[0];if(!e||0===e.length)return null;const i=as(e,ls(e)/2);return cs(i[0],i[1],i[2],t.spatialReference)}function Oo(t,e,i){const s=i?t:zo(t);return e&&t?Ki(t,s,e)?s:null:s}function To(t,e,i,s=0){if(t){e||(e=Ai());const r=t;let o=.5*r.width*(i-1),n=.5*r.height*(i-1);return r.width<1e-7*r.height?o+=n/20:r.height<1e-7*r.width&&(n+=o/20),Y(e,r.xmin-o-s,r.ymin-n-s,r.xmax+o+s,r.ymax+n+s),e}return null}function _o(t,e){for(let i=0;i<t.geometries.length;++i){const s=t.geometries[i].getMutableAttribute("auxpos1");s&&s.data[3]!==e&&(s.data[3]=e,t.geometryVertexAttrsUpdated(t.geometryRecords[i]))}}function Eo(e,i){const s=Fi(Li);return t(e)&&(s[0]=e[0],s[1]=e[1],s[2]=e[2]),t(i)?s[3]=i:t(e)&&e.length>3&&(s[3]=e[3]),s}function jo(e,i,s,r,o,n=[0,0,0,0]){for(let i=0;i<3;++i)n[i]=t(e)&&null!=e[i]?e[i]:t(s)&&null!=s[i]?s[i]:o[i];return n[3]=t(i)?i:t(r)?r:o[3],n}function Ro(t=nt,e,i,s=1){const r=new Array(3);if(l(e)||l(i))r[0]=1,r[1]=1,r[2]=1;else{let s,o=0;for(let n=2;n>=0;n--){const a=t[n];let l;const c=null!=a,h=0===n&&!s&&!c,u=i[n];"symbol-value"===a||h?l=0!==u?e[n]/u:1:c&&"proportional"!==a&&isFinite(a)&&(l=0!==u?a/u:1),null!=l&&(r[n]=l,s=l,o=Math.max(o,Math.abs(l)))}for(let t=2;t>=0;t--)null==r[t]?r[t]=s:0===r[t]&&(r[t]=.001*o)}for(let t=2;t>=0;t--)r[t]/=s;return ot(r)}function Fo(t){return function(t){return null!=t.isPrimitive}(t)&&(t=[t.width,t.depth,t.height]),Lo(t)?null:"Symbol sizes may not be negative values"}function Lo(t){if(Array.isArray(t)){for(const e of t)if(!Lo(e))return!1;return!0}return null==t||t>=0}function No(t,e,i,s=M()){const r=t||0,o=e||0,n=i||0;return 0!==r&&wi(s,s,-r/180*Math.PI),0!==o&&xi(s,s,o/180*Math.PI),0!==n&&yi(s,s,n/180*Math.PI),s}function Vo(t,e){return null!=e.minDemResolution?e.minDemResolution:ss(t)?e.minDemResolutionForPoints:.01*rs(t)}const Io={"bottom-left":zi(0,0),bottom:zi(.5,0),"bottom-right":zi(1,0),left:zi(0,.5),center:zi(.5,.5),right:zi(1,.5),"top-left":zi(0,1),top:zi(.5,1),"top-right":zi(1,1)};function Wo(t,e,i,s,r,o,n,a,l,c,h){const u=Qo[h.mode];let p,d,f=0;if(ts(t,e,i,s,l.spatialReference,r,a))return u.requiresAlignment(h)?(f=u.applyElevationAlignmentBuffer(s,r,o,n,a,l,c,h),p=o,d=n):(p=s,d=r),ts(p,l.spatialReference,d,o,c.spatialReference,n,a)?f:void 0}function Uo(t,i,s,r,o){const n=(rr(t)?t.z:nr(t)?t.array[t.offset+2]:t[2])||0;switch(s.mode){case"on-the-ground":{const s=e(ar(i,t,"ground"),0);return o.verticalDistanceToGround=0,o.sampledElevation=s,void(o.z=s)}case"relative-to-ground":{const a=e(ar(i,t,"ground"),0),l=s.geometryZWithOffset(n,r);return o.verticalDistanceToGround=l,o.sampledElevation=a,void(o.z=l+a)}case"relative-to-scene":{const a=e(ar(i,t,"scene"),0),l=s.geometryZWithOffset(n,r);return o.verticalDistanceToGround=l,o.sampledElevation=a,void(o.z=l+a)}case"absolute-height":{const a=s.geometryZWithOffset(n,r),l=e(ar(i,t,"ground"),0);return o.verticalDistanceToGround=a-l,o.sampledElevation=l,void(o.z=a)}default:return void(o.z=0)}}function Ho(t,e,i,s){return Uo(t,e,i,s,Yo),Yo.z}function Go(t,e,i){return null==e||null==i?t.definedChanged:"on-the-ground"===e&&"on-the-ground"===i?t.staysOnTheGround:e===i||"on-the-ground"!==e&&"on-the-ground"!==i?qo.UPDATE:t.onTheGroundChanged}function $o(t){return"relative-to-ground"===t||"relative-to-scene"===t}function Bo(t){return"absolute-height"!==t}function ko(t,e,i,s,r){Uo(e,i,r,s,Yo),_o(t,Yo.verticalDistanceToGround);const o=Yo.sampledElevation,n=fi(Jo,t.transformation);return Xo[0]=e.x,Xo[1]=e.y,Xo[2]=Yo.z,es(e.spatialReference,Xo,n,s.spatialReference)?t.transformation=n:console.warn("Could not locate symbol object properly, it might be misplaced"),o}class Zo{constructor(){this.verticalDistanceToGround=0,this.sampledElevation=0,this.z=0}}var qo;!function(t){t[t.NONE=0]="NONE",t[t.UPDATE=1]="UPDATE",t[t.RECREATE=2]="RECREATE"}(qo||(qo={}));const Qo={"absolute-height":{applyElevationAlignmentBuffer:function(t,e,i,s,r,o,n,a){const l=a.calculateOffsetRenderUnits(n),c=a.featureExpressionInfoContext;e*=3,s*=3;for(let o=0;o<r;++o){const r=t[e+1],o=t[e+2];i[s+0]=t[e+0],i[s+1]=r,i[s+2]=null==c?o+l:l,e+=3,s+=3}return 0},requiresAlignment:function(t){return 0!==t.meterUnitOffset||null!=t.featureExpressionInfoContext}},"on-the-ground":{applyElevationAlignmentBuffer:function(t,i,s,r,o,n){let a=0;const l=n.spatialReference;i*=3,r*=3;for(let c=0;c<o;++c){const o=t[i+0],c=t[i+1],h=e(n.getElevation(o,c,t[i+2],l,"ground"),0);a+=h,s[r+0]=o,s[r+1]=c,s[r+2]=h,i+=3,r+=3}return a/o},requiresAlignment:()=>!0},"relative-to-ground":{applyElevationAlignmentBuffer:function(t,i,s,r,o,n,a,l){let c=0;const h=l.calculateOffsetRenderUnits(a),u=l.featureExpressionInfoContext,p=n.spatialReference;i*=3,r*=3;for(let a=0;a<o;++a){const o=t[i+0],a=t[i+1],l=t[i+2],d=e(n.getElevation(o,a,l,p,"ground"),0);c+=d,s[r+0]=o,s[r+1]=a,s[r+2]=null==u?l+d+h:d+h,i+=3,r+=3}return c/o},requiresAlignment:()=>!0},"relative-to-scene":{applyElevationAlignmentBuffer:function(t,i,s,r,o,n,a,l){let c=0;const h=l.calculateOffsetRenderUnits(a),u=l.featureExpressionInfoContext,p=n.spatialReference;i*=3,r*=3;for(let a=0;a<o;++a){const o=t[i+0],a=t[i+1],l=t[i+2],d=e(n.getElevation(o,a,l,p,"scene"),0);c+=d,s[r+0]=o,s[r+1]=a,s[r+2]=null==u?l+d+h:d+h,i+=3,r+=3}return c/o},requiresAlignment:()=>!0}},Jo=M(),Yo=new Zo,Xo=it(),Ko=i.getLogger("esri.views.3d.layers.graphics.featureExpressionInfoUtils");function tn(t){const e=t&&t.expression;if("string"==typeof e){const t=ln(e);if(null!=t)return{cachedResult:t}}return null}async function en(t,e,i){const s=t&&t.expression;if("string"!=typeof s)return null;const r=ln(s);if(null!=r)return{cachedResult:r};const o=await Xi(),n=o.arcadeUtils,a=n.createSyntaxTree(s);return n.dependsOnView(a)?(null!=i&&i.error("Expressions containing '$view' are not supported on ElevationInfo"),{cachedResult:0}):{arcade:{func:n.createFunction(a),context:n.createExecContext(null,{sr:e}),modules:o}}}function sn(t,e,i){return t.arcadeUtils.createFeature(e.attributes,e.geometry,i)}function rn(t,e){if(null!=t&&!an(t)){if(!e||!t.arcade)return void Ko.errorOncePerTick("Arcade support required but not provided");const i=e;i._geometry&&(i._geometry=bo(i._geometry)),t.arcade.modules.arcadeUtils.updateExecContext(t.arcade.context,e)}}function on(t,e=!1){let i=t&&t.featureExpressionInfo;return e||"0"===(i&&i.expression)||(i=null),i}const nn={cachedResult:0};function an(t){return null!=t.cachedResult}function ln(t){return"0"===t?0:null}class cn{constructor(){this._meterUnitOffset=0,this._renderUnitOffset=0,this._unit="meters",this._metersPerElevationInfoUnit=1,this._featureExpressionInfoContext=null,this.centerPointInElevationSR=null,this.mode=null}get featureExpressionInfoContext(){return this._featureExpressionInfoContext}get meterUnitOffset(){return this._meterUnitOffset}get unit(){return this._unit}set unit(t){this._unit=t,this._metersPerElevationInfoUnit=Ji(t)}reset(){this.mode=null,this._meterUnitOffset=0,this._renderUnitOffset=0,this._featureExpressionInfoContext=null,this.unit="meters"}set offsetMeters(t){this._meterUnitOffset=t,this._renderUnitOffset=0}set offsetElevationInfoUnits(t){this._meterUnitOffset=t*this._metersPerElevationInfoUnit,this._renderUnitOffset=0}addOffsetRenderUnits(t){this._renderUnitOffset+=t}geometryZWithOffset(t,e){const i=this.calculateOffsetRenderUnits(e);return null!=this.featureExpressionInfoContext?i:t+i}calculateOffsetRenderUnits(t){let e=this._meterUnitOffset;const i=this.featureExpressionInfoContext;return null!=i&&(e+=function(t){if(null!=t){if(an(t))return t.cachedResult;const e=t.arcade;let i=t.arcade.modules.arcadeUtils.executeFunction(e.func,e.context);return"number"!=typeof i&&(t.cachedResult=0,i=0),i}return 0}(i)*this._metersPerElevationInfoUnit),e/t.unitInMeters+this._renderUnitOffset}setFromElevationInfo(t){this.mode=t.mode,this.unit=Yi(t.unit)?t.unit:"meters",this.offsetElevationInfoUnits=e(t.offset,0)}updateFeatureExpressionInfoContext(e,i,s){if(l(e))return void(this._featureExpressionInfoContext=null);const r=e&&e.arcade;r&&t(i)&&t(s)?(this._featureExpressionInfoContext=function(t){return{cachedResult:t.cachedResult,arcade:t.arcade?{func:t.arcade.func,context:t.arcade.modules.arcadeUtils.createExecContext(null,{sr:t.arcade.context.spatialReference}),modules:t.arcade.modules}:null}}(e),rn(this._featureExpressionInfoContext,sn(r.modules,i,s))):this._featureExpressionInfoContext=e}static fromElevationInfo(e){const i=new cn;return t(e)&&i.setFromElevationInfo(e),i}}const hn=it();function un(e,i,s,r,o,n,a,l){const c=s?s.length:0,h=e.clippingExtent;if(is(i,hn,e.elevationProvider.spatialReference),t(h)&&!os(h,hn))return null;is(i,hn,e.renderCoordsHelper.spatialReference);const u=e.localOriginFactory.getOrigin(hn),p=new xt({castShadow:!1,metadata:{layerUid:n,graphicUid:a,usesVerticalDistanceToGround:!0}});for(let t=0;t<c;t++)p.addGeometry(s[t],r[t],z,u,l);return{object:p,sampledElevation:ko(p,i,e.elevationProvider,e.renderCoordsHelper,o)}}function pn(t,e,i){const s=t.elevationContext,r=i.spatialReference;is(e,hn,r),s.centerPointInElevationSR=cs(hn[0],hn[1],e.hasZ?hn[2]:0,r)}function dn(t){switch(t.type){case"point":return t;case"polygon":case"extent":return Mo(t);case"polyline":{const e=t.paths[0];if(!e||0===e.length)return null;const i=as(e,ls(e)/2);return cs(i[0],i[1],i[2],t.spatialReference)}case"mesh":return t.origin}return null}function fn(t,e,i,s,r){const o=new Float64Array(3*t.length),n=new Float64Array(o.length);t.forEach(((t,e)=>{o[3*e+0]=t[0],o[3*e+1]=t[1],o[3*e+2]=t.length>2?t[2]:0}));const a=Wo(o,e,0,n,0,o,0,o.length/3,i,s,r);return{numVertices:t.length,position:o,mapPosition:n,projectionSuccess:null!=a,sampledElevation:a}}class vn{constructor(t,e){this.vec3=t,this.id=e}}function mn(t,e,i,s){return new vn(st(t,e,i),s)}class gn{constructor(t,e){this.index=t,this.renderTargets=e,this.extent=Ai(),this.resolution=0,this.renderLocalOrigin=mn(0,0,0,"O"),this.pixelRatio=1,this.mapUnitsPerPixel=1,this.canvasGeometries={extents:[Ai(),Ai(),Ai()],numViews:0},this.validTargets=null,this.hasDrapedFeatureSource=!1,this.hasDrapedRasterSource=!1,this.hasTargetWithoutRasterImage=!1,this.index=t,this.validTargets=new Array(e.renderTargets.length).fill(!1)}getValidTarget(t){return this.validTargets[t]?this.renderTargets.getTarget(t):null}get needsColorWithoutRasterImage(){return this.hasDrapedRasterSource&&this.hasDrapedFeatureSource&&this.hasTargetWithoutRasterImage}getColorTexture(t){const e=this.renderTargets.getTarget(1===t?0:2===t?2:4);return e?e.getTexture():null}getNormalTexture(t){const e=1===t?this.renderTargets.getTarget(3):null;return e?e.getTexture():null}draw(t,e){const i=this.computeRenderTargetValidityBitfield(),s=this.needsColorWithoutRasterImage;for(const i of this.renderTargets.renderTargets)this.validTargets[i.type]=(1!==i.type||!1!==s)&&t.drawTarget(this,i,e);return i^this.computeRenderTargetValidityBitfield()?0:1}computeRenderTargetValidityBitfield(){const t=this.validTargets;return+t[0]|+t[1]<<1|+t[2]<<2|+t[3]<<3|+t[4]<<4}setupGeometryViewsCyclical(t){this.setupGeometryViewsDirect();const e=.001*t.range;if(this.extent[0]-e<=t.min){const e=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Oi(this.extent,t.range,0,e)}if(this.extent[2]+e>=t.max){const e=this.canvasGeometries.extents[this.canvasGeometries.numViews++];Oi(this.extent,-t.range,0,e)}}setupGeometryViewsDirect(){this.canvasGeometries.numViews=1,Ti(this.canvasGeometries.extents[0],this.extent)}hasSomeSizedView(){for(let t=0;t<this.canvasGeometries.numViews;t++){const e=this.canvasGeometries.extents[t];if(e[0]!==e[2]&&e[1]!==e[3])return!0}return!1}applyViewport(t){t.setViewport(0===this.index?0:this.resolution,0,this.resolution,this.resolution)}}function wn(t,e,i){return Math.min(X(Math.max(t,e)+256),i)}class xn{constructor(t,e){this.size=vs(),this._fbo=null,this._fbo=new ms(t,{colorTarget:0,depthStencilTarget:0},{target:3553,pixelFormat:6408,dataType:5121,wrapMode:33071,samplingMode:9987,hasMipmap:e,maxAnisotropy:8,width:0,height:0})}dispose(){this._fbo=p(this._fbo)}getTexture(){return this._fbo?this._fbo.colorTexture:null}isValid(){return null!==this._fbo}resize(t,e){this.size[0]=t,this.size[1]=e,this._fbo.resize(this.size[0],this.size[1])}bind(t){t.bindFramebuffer(this._fbo)}generateMipMap(){this._fbo.colorTexture.descriptor.hasMipmap&&this._fbo.colorTexture.generateMipmap()}disposeRenderTargetMemory(){var t;null==(t=this._fbo)||t.resize(0,0)}get gpuMemoryUsage(){var t,e;return null!=(t=null==(e=this._fbo)?void 0:e.gpuMemoryUsage)?t:0}}class yn{constructor(t){const e=(e,i,s=!0)=>({type:i,fbo:new xn(t,s),renderPass:e,valid:!1,lastUsed:1/0});this.renderTargets=[e(0,0),e(0,1),e(5,2,!1),e(3,3),e(0,4)]}getTarget(t){return this.renderTargets[t].fbo}dispose(){for(const t of this.renderTargets)t.fbo.dispose()}disposeRenderTargetMemory(){for(const t of this.renderTargets)t.fbo.disposeRenderTargetMemory()}validateUsageForTarget(t,e,i){if(t)e.lastUsed=i;else if(i-e.lastUsed>Sn)e.fbo.disposeRenderTargetMemory(),e.lastUsed=1/0;else if(e.lastUsed<1/0)return!0;return!1}get gpuMemoryUsage(){return this.renderTargets.reduce(((t,e)=>t+e.fbo.gpuMemoryUsage),0)}}const Sn=1e3;class bn{constructor(){this._outer=new Map}clear(){this._outer.clear()}get empty(){return 0===this._outer.size}get(t,e){var i;return null==(i=this._outer.get(t))?void 0:i.get(e)}set(t,e,i){const s=this._outer.get(t);s?s.set(e,i):this._outer.set(t,new Map([[e,i]]))}delete(t,e){const i=this._outer.get(t);i&&(i.delete(e),0===i.size&&this._outer.delete(t))}forEach(t){this._outer.forEach(((e,i)=>t(e,i)))}}class Cn{constructor(t){this.technique=t,this.refCount=0,this.refZeroFrame=0}}class Dn{constructor(t){this._context=t,this._perConstructorInstances=new bn,this._frameCounter=0,this._keepAliveFrameCount=Pn}get viewingMode(){return this._context.viewingMode}get constructionContext(){return this._context}dispose(){this._perConstructorInstances.forEach((t=>t.forEach((t=>t.technique.dispose())))),this._perConstructorInstances.clear()}acquire(t,e){const i=e.key;let s=this._perConstructorInstances.get(t,i);if(l(s)){const r=new t(this._context,e,(()=>this.release(r)));s=new Cn(r),this._perConstructorInstances.set(t,i,s)}return++s.refCount,s.technique}releaseAndAcquire(e,i,s){if(t(s)){if(i.key===s.key)return s;s.release()}return this.acquire(e,i)}release(t){if(l(t)||this._perConstructorInstances.empty)return;const e=this._perConstructorInstances.get(t.constructor,t.key);l(e)||(--e.refCount,0===e.refCount&&(e.refZeroFrame=this._frameCounter))}frameUpdate(){this._frameCounter++,this._keepAliveFrameCount!==Pn&&this._perConstructorInstances.forEach(((t,e)=>{t.forEach(((t,i)=>{0===t.refCount&&t.refZeroFrame+this._keepAliveFrameCount<this._frameCounter&&(t.technique.dispose(),this._perConstructorInstances.delete(e,i))}))}))}async reloadAll(){const t=new Array;this._perConstructorInstances.forEach(((e,i)=>{t.push((async(t,e)=>{const i=e.shader;i&&(await i.reload(),t.forEach((t=>{t.technique.reload(this._context)})))})(e,i))})),await Promise.all(t)}}const Pn=-1,zn=t=>class extends t{constructor(){super(...arguments),this._isDisposed=!1}dispose(){for(const e of null!=(t=this._managedDisposables)?t:[]){var t;const i=this[e];this[e]=null,i&&"function"==typeof i.dispose&&i.dispose()}this._isDisposed=!0}get isDisposed(){return this._isDisposed}};class Mn extends(zn(class{})){}function An(){return(t,e)=>{var i,s;t.hasOwnProperty("_managedDisposables")||(t._managedDisposables=null!=(i=null==(s=t._managedDisposables)?void 0:s.slice())?i:[]),t._managedDisposables.unshift(e)}}const On=i.getLogger("esri.views.3d.webgl-engine.lib.GLMaterialRepository");class Tn{constructor(t){this._glMaterial=t,this.refCnt=0,this._glMaterial=t}incRefCnt(){++this.refCnt}decRefCnt(){--this.refCnt,ti(this.refCnt>=0)}getRefCnt(){return this.refCnt}get glMaterial(){return this._glMaterial}}class _n{constructor(t,e,i,s){this._textureRepository=t,this._techniqueRepository=e,this.materialChanged=i,this.requestRender=s,this._id2glMaterialRef=new bn}dispose(){this._textureRepository.dispose()}acquire(t,e){this._ownMaterial(t);let i=this._id2glMaterialRef.get(e,t.id);if(l(i)){const s=t.createGLMaterial({material:t,techniqueRep:this._techniqueRepository,textureRep:this._textureRepository,output:e});i=new Tn(s),this._id2glMaterialRef.set(e,t.id,i)}return i.incRefCnt(),i.glMaterial}release(e,i){const s=this._id2glMaterialRef.get(i,e.id);t(s)&&(s.decRefCnt(),0===s.getRefCnt()&&(p(s.glMaterial),this._id2glMaterialRef.delete(i,e.id)))}_ownMaterial(e){t(e.repository)&&e.repository!==this&&On.error("Material is already owned by a different material repository"),e.repository=this}}const En=["layerObjectAdded","layerObjectRemoved","layerObjectsAdded","layerObjectsRemoved","shaderTransformationChanged","objectTransformation","visibilityChanged","occlusionChanged","highlightChanged","objectGeometryAdded","objectGeometryRemoved","vertexAttrsUpdated"];class jn{constructor(t,e){this._objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new Rn,this._objectCount=0,e&&(void 0!==e.maximumObjectsPerNode&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),void 0!==e.maximumDepth&&(this._maximumDepth=e.maximumDepth))}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),Rn.clearPool(),Bn[0]=null,Jn.prune(),ia.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const i=Rn.acquire();for(let s=0;s<e;s++){const e=t[s];this._isDegenerate(e)?this._degenerateObjects.add(e):(i.init(this._root),this._add(e,i))}Rn.release(i)}remove(e,i=null){this._objectCount-=e.length;const s=Rn.acquire();for(const r of e){const e=t(i)?i:ft(this._objectToBoundingSphere(r),Yn);Un(e[3])?(s.init(this._root),this._remove(r,e,s)):this._degenerateObjects.delete(r)}Rn.release(s),this._shrink()}update(t,e){if(!Un(e[3])&&this._isDegenerate(t))return;const i=function(t){return Bn[0]=t,Bn}(t);this.remove(i,e),this.add(i)}forEachAlongRay(t,e,i){const s=ut(t,e);this._forEachNode(this._root,(t=>{if(!this._intersectsNode(s,t))return!1;const e=t.node;return e.terminals.forAll((t=>{this._intersectsObject(s,t)&&i(t)})),null!==e.residents&&e.residents.forAll((t=>{this._intersectsObject(s,t)&&i(t)})),!0}))}forEachAlongRayWithVerticalOffset(t,e,i,s){const r=ut(t,e);this._forEachNode(this._root,(t=>{if(!this._intersectsNodeWithOffset(r,t,s))return!1;const e=t.node;return e.terminals.forAll((t=>{this._intersectsObjectWithOffset(r,t,s)&&i(t)})),null!==e.residents&&e.residents.forAll((t=>{this._intersectsObjectWithOffset(r,t,s)&&i(t)})),!0}))}forEach(t){this._forEachNode(this._root,(e=>{const i=e.node;return i.terminals.forAll(t),null!==i.residents&&i.residents.forAll(t),!0})),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,i,s=(()=>!0),r=1/0){let o=1/0,n=1/0,a=null;const l=In(t,e),c=l=>{if(--r,!s(l))return;const c=this._objectToBoundingSphere(l);if(!Bs(i,c))return;const h=Wn(t,e,mt(c)),u=h-c[3];u<o&&(o=u,n=h+c[3],a=l)};return this._forEachNodeDepthOrdered(this._root,(s=>{if(r<=0||!Bs(i,s.bounds))return!1;if(T(Zn,l,s.halfSize),O(Zn,Zn,s.bounds),Wn(t,e,Zn)>n)return!1;const o=s.node;return o.terminals.forAll((t=>c(t))),null!==o.residents&&o.residents.forAll((t=>c(t))),!0}),t,e),a}forEachInDepthRange(t,e,i,s,r,o,n){let a=-1/0,l=1/0;const c={setRange:t=>{1===i?(a=Math.max(a,t.near),l=Math.min(l,t.far)):(a=Math.max(a,-t.far),l=Math.min(l,-t.near))}};c.setRange(s);const h=Wn(e,i,t),u=In(e,i),p=In(e,-i),d=t=>{if(!n(t))return;const s=this._objectToBoundingSphere(t),u=mt(s),p=Wn(e,i,u)-h;p-s[3]>l||p+s[3]<a||!Bs(o,s)||r(t,c)};this._forEachNodeDepthOrdered(this._root,(t=>{if(!Bs(o,t.bounds))return!1;if(T(Zn,u,t.halfSize),O(Zn,Zn,t.bounds),Wn(e,i,Zn)-h>l)return!1;if(T(Zn,p,t.halfSize),O(Zn,Zn,t.bounds),Wn(e,i,Zn)-h<a)return!1;const s=t.node;return s.terminals.forAll((t=>d(t))),null!==s.residents&&s.residents.forAll((t=>d(t))),!0}),e,i)}forEachNode(t){this._forEachNode(this._root,(e=>t(e.node,e.bounds,e.halfSize)))}_intersectsNode(t,e){return Nn(e.bounds,2*-e.halfSize,qn),Nn(e.bounds,2*e.halfSize,Qn),oi(t.origin,t.direction,qn,Qn)}_intersectsNodeWithOffset(t,e,i){return Nn(e.bounds,2*-e.halfSize,qn),Nn(e.bounds,2*e.halfSize,Qn),i.applyToMinMax(qn,Qn),oi(t.origin,t.direction,qn,Qn)}_intersectsObject(t,e){const i=this._objectToBoundingSphere(e);return!(i[3]>0)||vt(i,t)}_intersectsObjectWithOffset(t,e,i){const s=this._objectToBoundingSphere(e);return!(s[3]>0)||vt(i.applyToBoundingSphere(s),t)}_forEachNode(t,e){let i=Rn.acquire().init(t);const s=[i];for(;0!==s.length;){if(i=s.pop(),e(i)&&!i.isLeaf())for(let t=0;t<i.node.children.length;t++)i.node.children[t]&&s.push(Rn.acquire().init(i).advance(t));Rn.release(i)}}_forEachNodeDepthOrdered(t,e,i,s=1){let r=Rn.acquire().init(t);const o=[r];for(function(t,e,i){if(!ia.length)for(let t=0;t<8;++t)ia.push({index:0,distance:0});for(let i=0;i<8;++i){const s=Hn[i];ia.data[i].index=i,ia.data[i].distance=Wn(t,e,s)}ia.sort(((t,e)=>t.distance-e.distance));for(let t=0;t<8;++t)i[t]=ia.data[t].index}(i,s,sa);0!==o.length;){if(r=o.pop(),e(r)&&!r.isLeaf())for(let t=7;t>=0;--t){const e=sa[t];r.node.children[e]&&o.push(Rn.acquire().init(r).advance(e))}Rn.release(r)}}_remove(t,e,i){Jn.clear();const s=i.advanceTo(e,((t,e)=>{Jn.push(t.node),Jn.push(e)}))?i.node.terminals:i.node.residents;if(s.removeUnordered(t),0===s.length)for(let t=Jn.length-2;t>=0&&this._purge(Jn.data[t],Jn.data[t+1]);t-=2);}_nodeIsEmpty(t){if(0!==t.terminals.length)return!1;if(null!==t.residents)return 0===t.residents.length;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(null===t.residents&&(t.residents=new f({shrink:!0})),!0)}_add(t,e){e.advanceTo(this._objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let i=0;i<e.length;i++){const s=Rn.acquire().init(t);this._add(e.getItemAt(i),s),Rn.release(s)}}_grow(t,e){if(0!==e&&(Vn(t,e,(t=>this._objectToBoundingSphere(t)),Xn),Un(Xn[3])&&!this._fitsInsideTree(Xn)))if(this._nodeIsEmpty(this._root.node))ft(Xn,this._root.bounds),this._root.halfSize=1.25*Xn[3];else{const t=this._rootBoundsForRootAsSubNode(Xn);this._placingRootViolatesMaxDepth(t)?this._rebuildTree(Xn,t):this._growRootAsSubNode(t),Rn.release(t)}}_rebuildTree(t,e){V(Kn,e.bounds),Kn[3]=e.halfSize,Vn([t,Kn],2,(t=>t),ta);const i=Rn.acquire().init(this._root);this._root.initFrom(null,ta,1.25*ta[3]),this._forEachNode(i,(t=>(this.add(t.node.terminals.data,t.node.terminals.length),null!==t.node.residents&&this.add(t.node.residents.data,t.node.residents.length),!0))),Rn.release(i)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let i=0;return this._forEachNode(this._root,(t=>(i=Math.max(i,t.depth),i+e<=this._maximumDepth))),i+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],i=t;let s=-1/0;const r=this._root.bounds,o=this._root.halfSize;for(let t=0;t<3;t++){const n=i[t]+e-(r[t]+o),a=Math.max(0,Math.ceil((r[t]-o-(i[t]-e))/(2*o))),l=Math.max(0,Math.ceil(n/(2*o)))+1,c=2**Math.ceil(Math.log(a+l)*Math.LOG2E);s=Math.max(s,c),ea[t].min=a,ea[t].max=l}for(let t=0;t<3;t++){let e=ea[t].min,i=ea[t].max;const n=(s-(e+i))/2;e+=Math.ceil(n),i+=Math.floor(n),kn[t]=r[t]-o-e*o*2+(i+e)*o}return kn[3]=s*o*$n,Rn.acquire().initFrom(null,kn,s*o,0)}_growRootAsSubNode(t){const e=this._root.node;V(Xn,this._root.bounds),Xn[3]=this._root.halfSize,this._root.init(t),t.advanceTo(Xn,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(-1===t)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(0!==this._root.node.terminals.length||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let i=0,s=0;for(;s<e.length&&null==t;)i=s++,t=e[i];for(;s<e.length;)if(e[s++])return-1;return i}_isDegenerate(t){return!Un(this._objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,i=this._root.halfSize;return t[3]<=i&&t[0]>=e[0]-i&&t[0]<=e[0]+i&&t[1]>=e[1]-i&&t[1]<=e[1]+i&&t[2]>=e[2]-i&&t[2]<=e[2]+i}}class Rn{constructor(){this.bounds=dt(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(e,i,s,r=this.depth){return this.node=t(e)?e:Rn.createEmptyNode(),t(i)&&ft(i,this.bounds),this.halfSize=s,this.depth=r,this}advance(t){let e=this.node.children[t];e||(e=Rn.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const i=Hn[t];return this.bounds[0]+=i[0]*this.halfSize,this.bounds[1]+=i[1]*this.halfSize,this.bounds[2]+=i[2]*this.halfSize,this.bounds[3]=this.halfSize*$n,this}advanceTo(t,e,i=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!i)return e&&e(this,-1),!1;this.node.residents=null}const s=this._childIndex(t);e&&e(this,s),this.advance(s)}}isLeaf(){return null!=this.node.residents}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new f({shrink:!0}),residents:new f({shrink:!0})}}static acquire(){return Rn._pool.acquire()}static release(t){Rn._pool.release(t)}static clearPool(){Rn._pool.prune()}}function Fn(t,e){t[0]=Math.min(t[0],e[0]-e[3]),t[1]=Math.min(t[1],e[1]-e[3]),t[2]=Math.min(t[2],e[2]-e[3])}function Ln(t,e){t[0]=Math.max(t[0],e[0]+e[3]),t[1]=Math.max(t[1],e[1]+e[3]),t[2]=Math.max(t[2],e[2]+e[3])}function Nn(t,e,i){i[0]=t[0]+e,i[1]=t[1]+e,i[2]=t[2]+e}function Vn(t,e,i,s){if(1===e){const e=i(t[0]);ft(e,s)}else{qn[0]=1/0,qn[1]=1/0,qn[2]=1/0,Qn[0]=-1/0,Qn[1]=-1/0,Qn[2]=-1/0;for(let s=0;s<e;s++){const e=i(t[s]);Un(e[3])&&(Fn(qn,e),Ln(Qn,e))}K(s,qn,Qn,.5),s[3]=Math.max(Qn[0]-qn[0],Qn[1]-qn[1],Qn[2]-qn[2])/2}}function In(t,e){let i=1/0,s=null;for(let r=0;r<8;++r){const o=Wn(t,e,Gn[r]);o<i&&(i=o,s=Gn[r])}return s}function Wn(t,e,i){return e*(t[0]*i[0]+t[1]*i[1]+t[2]*i[2])}function Un(t){return!isNaN(t)&&t!==-1/0&&t!==1/0&&t>0}Rn._pool=new d(Rn);const Hn=[st(-1,-1,-1),st(1,-1,-1),st(-1,1,-1),st(1,1,-1),st(-1,-1,1),st(1,-1,1),st(-1,1,1),st(1,1,1)],Gn=[st(-1,-1,-1),st(-1,-1,1),st(-1,1,-1),st(-1,1,1),st(1,-1,-1),st(1,-1,1),st(1,1,-1),st(1,1,1)],$n=Math.sqrt(3),Bn=[null],kn=dt(),Zn=it(),qn=it(),Qn=it(),Jn=new f,Yn=dt(),Xn=dt(),Kn=dt(),ta=dt(),ea=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],ia=new f,sa=[0,0,0,0,0,0,0,0];class ra extends je{constructor(t,e=""){var i,s,r;super(),this.apiLayerUid=e,this.type=0,this.events=new v,this.isSliceable=!1,this._objects=new f,this._stageHandles=new m,this.apiLayerUid=e,this.isVisible=null==(i=null==t?void 0:t.isVisible)||i,this.isPickable=null==(s=null==t?void 0:t.isPickable)||s,this.updatePolicy=null!=(r=null==t?void 0:t.updatePolicy)?r:0}get objects(){return this._objects}destroy(){this.detachStage(),this._stage=null}attachStage(t){this.detachStage(),this._stage=t;for(const e of En)this._stageHandles.add(this.events.on(e,(i=>t.handleEvent(e,i))))}detachStage(){this._stageHandles.removeAll(),this.invalidateSpatialQueryAccelerator()}add(e){this._objects.push(e),e.parentLayer=this,this.events.emit("layerObjectAdded",{layer:this,object:e}),t(this._octree)&&this._octree.add([e])}remove(e){this._objects.removeUnordered(e)&&(e.parentLayer=null,this.events.emit("layerObjectRemoved",{layer:this,object:e}),t(this._octree)&&this._octree.remove([e]))}addMany(e){this._objects.pushArray(e);for(const t of e)t.parentLayer=this;this.events.emit("layerObjectsAdded",{layer:this,objects:e}),t(this._octree)&&this._octree.add(e)}removeMany(e){const i=new Array;if(this._objects.removeUnorderedMany(e,e.length,i),0!==i.length){for(const t of i)t.parentLayer=null;this.events.emit("layerObjectsRemoved",{layer:this,objects:i}),t(this._octree)&&this._octree.remove(i)}}sync(){t(this._stage)&&1!==this.updatePolicy&&this._stage.syncLayer(this.id)}notifyObjectBBChanged(e,i){t(this._octree)&&this._octree.update(e,i)}getSpatialQueryAccelerator(){return l(this._octree)&&this._objects.length>50&&this._createOctree(),this._octree}shaderTransformationChanged(){this.invalidateSpatialQueryAccelerator(),this.events.emit("shaderTransformationChanged",this)}invalidateSpatialQueryAccelerator(){this._octree=g(this._octree)}_createOctree(){this._octree=new jn((t=>t.boundingVolumeWorldSpace.bounds)),this._octree.add(this._objects.data,this._objects.length)}}function oa(e){return t(e)&&0===e.type}var na;(na||(na={})).Default={vvSizeEnabled:!1,vvSizeMinSize:Ne(1,1,1),vvSizeMaxSize:Ne(100,100,100),vvSizeOffset:Ne(0,0,0),vvSizeFactor:Ne(1,1,1),vvSizeValue:Ne(1,1,1),vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],vvOpacityEnabled:!1,vvOpacityValues:[0,0,0,0,0,0,0,0],vvOpacityOpacities:[1,1,1,1,1,1,1,1],vvSymbolAnchor:[0,0,0],vvSymbolRotationMatrix:ui()};const aa=na;function la(t,e){t.vertex.uniforms.add("intrinsicWidth","float"),e.vvSize?(t.attributes.add("sizeFeatureAttribute","float"),t.vertex.uniforms.add("vvSizeMinSize","vec3"),t.vertex.uniforms.add("vvSizeMaxSize","vec3"),t.vertex.uniforms.add("vvSizeOffset","vec3"),t.vertex.uniforms.add("vvSizeFactor","vec3"),t.vertex.code.add(Ct`float getSize() {
return intrinsicWidth * clamp(vvSizeOffset + sizeFeatureAttribute * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).x;
}`)):(t.attributes.add("size","float"),t.vertex.code.add(Ct`float getSize(){
return intrinsicWidth * size;
}`)),e.vvOpacity?(t.attributes.add("opacityFeatureAttribute","float"),t.vertex.constants.add("vvOpacityNumber","int",8),t.vertex.code.add(Ct`uniform float vvOpacityValues[vvOpacityNumber];
uniform float vvOpacityOpacities[vvOpacityNumber];
float interpolateOpacity( float value ){
if (value <= vvOpacityValues[0]) {
return vvOpacityOpacities[0];
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f);
}
}
return vvOpacityOpacities[vvOpacityNumber - 1];
}
vec4 applyOpacity( vec4 color ){
return vec4(color.xyz, interpolateOpacity(opacityFeatureAttribute));
}`)):t.vertex.code.add(Ct`vec4 applyOpacity( vec4 color ){
return color;
}`),e.vvColor?(t.attributes.add("colorFeatureAttribute","float"),t.vertex.constants.add("vvColorNumber","int",8),t.vertex.code.add(Ct`uniform float vvColorValues[vvColorNumber];
uniform vec4 vvColorColors[vvColorNumber];
vec4 interpolateColor( float value ) {
if (value <= vvColorValues[0]) {
return vvColorColors[0];
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return mix(vvColorColors[i-1], vvColorColors[i], f);
}
}
return vvColorColors[vvColorNumber - 1];
}
vec4 getColor(){
return applyOpacity(interpolateColor(colorFeatureAttribute));
}`)):(t.attributes.add("color","vec4"),t.vertex.code.add(Ct`vec4 getColor(){
return applyOpacity(color);
}`))}function ca(t,e){t.constants.add("stippleAlphaColorDiscard","float",.001),t.constants.add("stippleAlphaHighlightDiscard","float",.5),e.stippleEnabled?function(t,e){t.fragment.include(Mt);const i=_r.ENABLE_CONTINUOUS_LINE_PATTERNS;i?(t.vertex.uniforms.add("stipplePatternPixelSize","float"),e.draped?t.vertex.uniforms.add("worldToScreenRatio","float"):(t.vertex.uniforms.add("worldToScreenPerDistanceRatio","float"),t.vertex.uniforms.add("cameraDistanceToSurface","float"),t.vertex.uniforms.add("camPos","vec3"))):t.vertex.uniforms.add("stipplePatternPixelSizeInv","float"),e.stippleDistanceMaxEnabled&&t.varyings.add("stippleDistanceMax","float"),t.varyings.add("stippleDistance","float"),i&&(t.varyings.add("vStippleDistanceLimits","vec2"),e.draped||t.vertex.code.add(Ct`
      float computeWorldToScreenRatio(vec3 segmentCenter) {
        float segmentDistanceToCamera = length(segmentCenter - camPos);

        ${_r.ENABLE_PER_SEGMENT_DISTANCE_LINE_PATTERNS?Ct`float distanceToCamera = segmentDistanceToCamera;`:Ct`float distanceToCamera = cameraDistanceToSurface < 0.0 ? segmentDistanceToCamera : cameraDistanceToSurface;`}

        return worldToScreenPerDistanceRatio / distanceToCamera;
      }
    `),t.vertex.code.add(Ct`float discretizeWorldToScreenRatio(float worldToScreenRatio) {
float step = 0.2;
float discreteWorldToScreenRatio = log(worldToScreenRatio);
discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);
return discreteWorldToScreenRatio;
}`),t.vertex.code.add(Ct`vec2 computeStippleDistanceLimits(float startPseudoScreen, float segmentLengthPseudoScreen, float segmentLengthScreen, float patternLength) {
if (segmentLengthPseudoScreen < patternLength) {
return vec2(startPseudoScreen, startPseudoScreen + segmentLengthPseudoScreen);
}
float segmentLengthScreenRounded = max(1.0, floor(segmentLengthScreen / patternLength + 0.5)) * patternLength;
return vec2(0.0, segmentLengthScreenRounded);
}`)),t.fragment.uniforms.add("stipplePatternTexture","sampler2D"),t.fragment.uniforms.add("stipplePatternSDFNormalizer","float"),t.fragment.uniforms.add("stipplePatternTextureSize","float"),i&&t.fragment.uniforms.add("stipplePatternPixelSizeInv","float"),e.stippleOffColorEnabled&&t.fragment.uniforms.add("stippleOffColor","vec4"),t.fragment.code.add(Ct`float padTexture(float u) {
return (u * stipplePatternTextureSize + 1.0)/(stipplePatternTextureSize + 2.0);
}`),t.fragment.code.add(i?Ct`
      float getStippleValue() {
        float stippleDistanceClamped = clamp(stippleDistance, vStippleDistanceLimits.x, vStippleDistanceLimits.y) * gl_FragCoord.w;
        ${e.scaleStippleWithLineWidth?Ct`float u = fract(stippleDistanceClamped * stipplePatternPixelSizeInv * vLineSizeInv);`:Ct`float u = fract(stippleDistanceClamped * stipplePatternPixelSizeInv);`}
        return rgba2float(texture2D(stipplePatternTexture, vec2(padTexture(u), 0.5)));
      }
    `:Ct`
      float getStippleValue() {
        float stippleDistanceClamped = stippleDistance * gl_FragCoord.w;
        ${e.stippleDistanceMaxEnabled?"stippleDistanceClamped = clamp(stippleDistanceClamped, 0.0, stippleDistanceMax);":""}
        ${e.scaleStippleWithLineWidth?Ct`float u = fract(stippleDistanceClamped * vLineSizeInv);`:Ct`float u = fract(stippleDistanceClamped);`}
        return rgba2float(texture2D(stipplePatternTexture, vec2(padTexture(u), 0.5)));
      }
    `),t.fragment.code.add(Ct`
    float getStippleSDF() {
      return (getStippleValue() * 2.0 - 1.0) * stipplePatternSDFNormalizer;
    }

    float getStippleAlpha() {
      ${e.scaleStippleWithLineWidth?Ct`return clamp(getStippleSDF() * vLineWidth + 0.5, 0.0, 1.0);`:Ct`return clamp(getStippleSDF() + 0.5, 0.0, 1.0);`}
    }
  `),t.fragment.code.add(e.stippleOffColorEnabled?Ct`#define discardByStippleAlpha(stippleAlpha, threshold) {}
#define blendStipple(color, stippleAlpha) mix(color, stippleOffColor, stippleAlpha)`:Ct`#define discardByStippleAlpha(stippleAlpha, threshold) if (stippleAlpha < threshold) { discard; }
#define blendStipple(color, stippleAlpha) vec4(color.rgb, color.a * stippleAlpha)`)}(t,e):function(t){t.fragment.code.add(Ct`float getStippleAlpha() { return 1.0; }
#define discardByStippleAlpha(_stippleAlpha_, _threshold_) {}
#define blendStipple(color, _stippleAlpha_) color`)}(t)}function ha(t){const e=new At;e.extensions.add("GL_OES_standard_derivatives"),e.include(le),e.include(la,t),e.include(ca,t),1===t.output&&e.include(ce,t),e.vertex.uniforms.add("proj","mat4").add("view","mat4").add("cameraNearFar","vec2").add("pixelRatio","float").add("miterLimit","float").add("screenSize","vec2"),e.attributes.add("position","vec3"),e.attributes.add("subdivisionFactor","float"),e.attributes.add("uv0","vec2"),e.attributes.add("auxpos1","vec3"),e.attributes.add("auxpos2","vec3"),e.varyings.add("vColor","vec4"),e.varyings.add("vpos","vec3"),e.varyings.add("linearDepth","float"),t.multipassTerrainEnabled&&e.varyings.add("depth","float");const i=2===t.capType,s=_r.ENABLE_CONTINUOUS_LINE_PATTERNS,r=s&&t.stippleEnabled&&i,o=t.falloffEnabled||r,n=t.innerColorEnabled,a=t.stippleEnabled&&t.scaleStippleWithLineWidth||i,l=t.stippleEnabled&&t.scaleStippleWithLineWidth,c=1===t.capType||2===t.capType;return a&&e.varyings.add("vLineWidth","float"),l&&e.varyings.add("vLineSizeInv","float"),n&&e.varyings.add("vLineDistance","float"),o&&e.varyings.add("vLineDistanceNorm","float"),t.falloffEnabled&&e.fragment.uniforms.add("falloff","float"),t.innerColorEnabled&&(e.fragment.uniforms.add("innerColor","vec4"),e.fragment.uniforms.add("innerWidth","float")),i&&e.varyings.add("vCapPosition","vec2"),e.vertex.code.add(Ct`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}
vec2 rotate(vec2 v, float a) {
float s = sin(a);
float c = cos(a);
mat2 m = mat2(c, -s, s, c);
return m * v;
}`),e.vertex.code.add(Ct`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= screenSize / posNdc.w;
return posNdc;
}`),e.vertex.code.add(Ct`
    void clipAndTransform(inout vec4 pos, inout vec4 prev, inout vec4 next, in bool isStartVertex) {
      float vnp = cameraNearFar[0] * 0.99;

      //current pos behind ncp --> we need to clip
      if(pos.z > -cameraNearFar[0]) {
        if (!isStartVertex) {
          //previous in front of ncp
          if(prev.z < -cameraNearFar[0]) {
            pos = mix(prev, pos, interp(vnp, prev, pos));
            next = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
        //next in front of ncp
        if(isStartVertex) {
          if(next.z < -cameraNearFar[0]) {
            pos = mix(pos, next, interp(vnp, pos, next));
            prev = pos;
          } else {
            pos = vec4(0.0, 0.0, 0.0, 1.0);
          }
        }
      } else {
        //current position visible
        //previous behind ncp
        if (prev.z > -cameraNearFar[0]) {
          prev = mix(pos, prev, interp(vnp, pos, prev));
        }
        //next behind ncp
        if (next.z > -cameraNearFar[0]) {
          next = mix(next, pos, interp(vnp, next, pos));
        }
      }

      ${t.multipassTerrainEnabled?"depth = pos.z;":""}
      linearDepth = (-pos.z - cameraNearFar[0]) / (cameraNearFar[1] - cameraNearFar[0]);

      pos = projectAndScale(pos);
      next = projectAndScale(next);
      prev = projectAndScale(prev);
    }
`),e.vertex.code.add(Ct`
  void main(void) {
    // unpack values from uv0.y
    bool isStartVertex = abs(abs(uv0.y)-3.0) == 1.0;

    float coverage = 1.0;
    vpos = position;

    // Check for special value of uv0.y which is used by the Renderer when graphics
    // are removed before the VBO is recompacted. If this is the case, then we just
    // project outside of clip space.
    if (uv0.y == 0.0) {
      // Project out of clip space
      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
    }
    else {
      bool isJoin = abs(uv0.y) < 3.0;

      float lineSize = getSize();
      float lineWidth = lineSize * pixelRatio;
      ${a?Ct`vLineWidth = lineWidth;`:""}
      ${l?Ct`vLineSizeInv = 1.0 / lineSize;`:""}

      // convert sub-pixel coverage to alpha
      if (lineWidth < 1.0) {
        coverage = lineWidth;
        lineWidth = 1.0;
      }else{
        // Ribbon lines cannot properly render non-integer sizes. Round width to integer size if
        // larger than one for better quality. Note that we do render < 1 pixels more or less correctly
        // so we only really care to round anything larger than 1.
        lineWidth = floor(lineWidth + 0.5);
      }

      vec4 pos  = view * vec4(position.xyz, 1.0);
      vec4 prev = view * vec4(auxpos1.xyz, 1.0);
      vec4 next = view * vec4(auxpos2.xyz, 1.0);

      clipAndTransform(pos, prev, next, isStartVertex);

      vec2 left = (pos.xy - prev.xy);
      vec2 right = (next.xy - pos.xy);

      float leftLen = length(left);
      float rightLen = length(right);
  `),t.stippleEnabled&&e.vertex.code.add(Ct`float isEndVertex = float(!isStartVertex);
vec4 segmentInfo = mix(vec4(pos.xy, right), vec4(prev.xy, left), isEndVertex);
vec2 segmentOrigin = segmentInfo.xy;
vec2 segment = segmentInfo.zw;`),e.vertex.code.add(Ct`left = (leftLen > 0.001) ? left/leftLen : vec2(0.0, 0.0);
right = (rightLen > 0.001) ? right/rightLen : vec2(0.0, 0.0);
vec2 capDisplacementDir = vec2(0, 0);
vec2 joinDisplacementDir = vec2(0, 0);
float displacementLen = lineWidth;
if (isJoin) {
bool isOutside = (left.x * right.y - left.y * right.x) * uv0.y > 0.0;
joinDisplacementDir = normalize(left + right);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
if (leftLen > 0.001 && rightLen > 0.001) {
float nDotSeg = dot(joinDisplacementDir, left);
displacementLen /= length(nDotSeg * left - joinDisplacementDir);
if (!isOutside) {
displacementLen = min(displacementLen, min(leftLen, rightLen)/abs(nDotSeg));
}
}
if (isOutside && (displacementLen > miterLimit * lineWidth)) {`),e.vertex.code.add(t.roundJoins?Ct`vec2 startDir;
vec2 endDir;
if (leftLen < 0.001) {
startDir = right;
}
else{
startDir = left;
}
startDir = normalize(startDir);
startDir = PERPENDICULAR(startDir);
if (rightLen < 0.001) {
endDir = left;
}
else{
endDir = right;
}
endDir = normalize(endDir);
endDir = PERPENDICULAR(endDir);
float rotationAngle = acos(clamp(dot(startDir, endDir), -1.0, 1.0));
joinDisplacementDir = rotate(startDir, -sign(uv0.y) * subdivisionFactor * rotationAngle);`:Ct`if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = isStartVertex ? right : left;
}
joinDisplacementDir = normalize(joinDisplacementDir);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);`),e.vertex.code.add(Ct`displacementLen = lineWidth;
}
} else {
if (leftLen < 0.001) {
joinDisplacementDir = right;
}
else if (rightLen < 0.001) {
joinDisplacementDir = left;
}
else {
joinDisplacementDir = isStartVertex ? right : left;
}
joinDisplacementDir = normalize(joinDisplacementDir);
joinDisplacementDir = PERPENDICULAR(joinDisplacementDir);
displacementLen = lineWidth;
capDisplacementDir = isStartVertex ? -right : left;
capDisplacementDir *= subdivisionFactor;
}`),e.vertex.code.add(Ct`
  // Displacement (in pixels) caused by join/or cap
  vec2 dpos = joinDisplacementDir * sign(uv0.y) * displacementLen + capDisplacementDir * displacementLen;

  ${o||n?Ct`float lineDistNorm = sign(uv0.y) * pos.w;`:""}

  ${n?Ct`vLineDistance = lineWidth * lineDistNorm;`:""}
  ${o?Ct`vLineDistanceNorm = lineDistNorm;`:""}

  ${i?Ct`vCapPosition = isJoin ? vec2(0.0) : dpos;`:""}

  pos.xy += dpos;
  `),t.stippleEnabled&&(s?(t.draped||e.vertex.code.add(Ct`vec3 segmentCenter = mix((auxpos2 + position) * 0.5, (position + auxpos1) * 0.5, isEndVertex);
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),e.vertex.code.add(Ct`
        float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);

        float segmentLengthScreen = length(segment);
        float segmentLengthRender = length(mix(auxpos2 - position, position - auxpos1, isEndVertex));
        float startPseudoScreen = mix(uv0.x, uv0.x - segmentLengthRender, isEndVertex) * discreteWorldToScreenRatio;
        float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;

        float patternLength = ${t.scaleStippleWithLineWidth?"lineSize * ":""} stipplePatternPixelSize;

        // Compute the coordinates at both start and end of the line segment, because we need both to clamp to in the fragment shader
        // The 0.5 factor on the screen length is to correct for pixel ratio (it is calculated at double resolution)
        vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, segmentLengthScreen * 0.5, patternLength);

        ${c?Ct`vStippleDistanceLimits += vec2(lineSize * 0.5);`:""}

        stippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, isEndVertex);

        // Adjust the coordinate to the displaced position (the pattern is shortened/overextended on the in/outside of joins)
        if (segmentLengthScreen >= 0.001) {
          // Project the actual vertex position onto the line segment. Note that the resulting factor is within [0..1] at the
          // original vertex positions, and slightly outside of that range at the displaced positions
          vec2 stippleDisplacement = pos.xy - segmentOrigin;
          float stippleDisplacementFactor = dot(segment, stippleDisplacement) / (segmentLengthScreen * segmentLengthScreen);

          // Apply this offset to the actual vertex coordinate (can be screen or pseudo-screen space)
          stippleDistance += (stippleDisplacementFactor - isEndVertex) * (vStippleDistanceLimits.y - vStippleDistanceLimits.x);
        }

        // Cancel out perspective correct interpolation because we want this length the really represent the screen distance
        vStippleDistanceLimits *= pos.w;
        stippleDistance *= pos.w;
      `)):(e.vertex.code.add(Ct`vec2 posVec = pos.xy - segmentOrigin;
float segmentDirectionLength = length(segment);`),t.stippleIntegerRepeatsEnabled&&e.vertex.code.add(Ct`float numberOfPatternRepeats = segmentDirectionLength * 0.5 * stipplePatternPixelSizeInv;
float roundedNumberOfPatternRepeats = floor(numberOfPatternRepeats);
stippleDistanceMax = roundedNumberOfPatternRepeats;`),e.vertex.code.add(Ct`
        if (segmentDirectionLength >= 0.001) {
          // Project the vertex position onto the line segment.
          float projectedLength = dot(segment, posVec) / segmentDirectionLength * 0.5;
          ${t.stippleIntegerRepeatsEnabled?"float wholeNumberOfRepeatsScale = roundedNumberOfPatternRepeats / numberOfPatternRepeats;":"float wholeNumberOfRepeatsScale = 1.0;"}
          stippleDistance = projectedLength * wholeNumberOfRepeatsScale * stipplePatternPixelSizeInv * pos.w;
        } else {
          stippleDistance = 1.0;
        }
      `))),e.vertex.code.add(Ct`pos.xy = pos.xy / screenSize * pos.w;
vColor = getColor();
vColor.a *= coverage;
gl_Position = pos;
}
}`),t.multipassTerrainEnabled&&(e.fragment.include(zt),e.include(he,t)),e.include(Ot,t),e.fragment.uniforms.add("intrinsicColor","vec4"),e.fragment.include(Tt),e.fragment.code.add(Ct`
  void main() {
    discardBySlice(vpos);
    ${t.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
  `),i&&e.fragment.code.add(Ct`
    float fragmentRadius = length(vCapPosition);
    float fragmentSDF = (fragmentRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
    float capCoverage = clamp(0.5 - fragmentSDF, 0.0, 1.0);
    if (capCoverage < ${Ct.float(Et)}) {
      discard;
    }
  `),e.fragment.code.add(r?Ct`
      vec2 stipplePosition = vec2(
        max(1.0 - getStippleSDF() * 2.0, 0.0),
        vLineDistanceNorm * gl_FragCoord.w
      );
      float stippleRadius = length(stipplePosition * vLineWidth);
      float stippleCapSDF = (stippleRadius - vLineWidth) * 0.5; // Divide by 2 to transform from double pixel scale
      float stippleCoverage = clamp(0.5 - stippleCapSDF, 0.0, 1.0);
      float stippleAlpha = step(${Ct.float(Et)}, stippleCoverage);
    `:Ct`float stippleAlpha = getStippleAlpha();`),e.fragment.code.add(Ct`discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);
vec4 color = intrinsicColor * vColor;`),t.innerColorEnabled&&(e.fragment.uniforms.add("pixelRatio","float"),e.fragment.code.add(Ct`float distToInner = abs(vLineDistance * gl_FragCoord.w) - innerWidth;
float innerAA = clamp(0.5 - distToInner, 0.0, 1.0);
float innerAlpha = innerColor.a + color.a * (1.0 - innerColor.a);
color = mix(color, vec4(innerColor.rgb, innerAlpha), innerAA);`)),e.fragment.code.add(Ct`vec4 finalColor = blendStipple(color, stippleAlpha);`),t.falloffEnabled&&e.fragment.code.add(Ct`finalColor.a *= pow(max(0.0, 1.0 - abs(vLineDistanceNorm * gl_FragCoord.w)), falloff);`),e.fragment.code.add(Ct`
    if (finalColor.a < ${Ct.float(Et)}) {
      discard;
    }

    ${7===t.output?Ct`gl_FragColor = vec4(finalColor.a);`:""}
    ${0===t.output?Ct`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${0===t.output&&t.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    ${4===t.output?Ct`gl_FragColor = vec4(1.0);`:""}
    ${1===t.output?Ct`outputDepth(linearDepth);`:""}
  }
  `),e}const ua=Object.freeze({__proto__:null,build:ha}),pa=new Map([["position",0],["subdivisionFactor",1],["uv0",2],["auxpos1",3],["auxpos2",4],["size",6],["sizeFeatureAttribute",6],["color",5],["colorFeatureAttribute",5],["opacityFeatureAttribute",7]]);class da extends Nt{constructor(t,e,i){super(t,e,i),this.stippleTextureRepository=t.stippleTextureRepository}initializeProgram(t){const e=da.shader.get(),i=this.configuration,s=e.build({OITEnabled:0===i.transparencyPassType,output:i.output,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,draped:i.draped,stippleEnabled:i.stippleEnabled,stippleOffColorEnabled:i.stippleOffColorEnabled,stippleDistanceMaxEnabled:i.stippleIntegerRepeatsEnabled,stippleIntegerRepeatsEnabled:i.stippleIntegerRepeatsEnabled,scaleStippleWithLineWidth:i.scaleStippleWithLineWidth,capType:i.capType,roundJoins:i.roundJoins,vvColor:i.vvColor,vvSize:i.vvSize,vvInstancingEnabled:!0,vvOpacity:i.vvOpacity,falloffEnabled:i.falloffEnabled,innerColorEnabled:i.innerColorEnabled,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new Vt(t.rctx,s,pa)}dispose(){super.dispose(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(i,s){if(Wt(this.program,s.camera.projectionMatrix),4===this.configuration.output&&kt(this.program,s),s.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",s.inverseViewport),$t(this.program,s)),this.program.setUniform1f("intrinsicWidth",i.width),this.program.setUniform4fv("intrinsicColor",i.color),this.program.setUniform1f("miterLimit","miter"!==i.join?0:i.miterLimit),this.program.setUniform2fv("cameraNearFar",s.camera.nearFar),this.program.setUniform1f("pixelRatio",s.camera.pixelRatio),this.program.setUniform2f("screenSize",s.camera.fullViewport[2],s.camera.fullViewport[3]),ue(this.program,i),this.stipplePattern!==i.stipplePattern){const t=i.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,t),this.stipplePattern=t}if(this.configuration.stippleEnabled){const{pixelSize:e,sdfNormalizer:r,pixels:o}=t(this.stippleTextureBind)?this.stippleTextureBind(this.program):{pixelSize:1,sdfNormalizer:1,pixels:1};if(this.program.setUniform1f("stipplePatternSDFNormalizer",r),this.program.setUniform1f("stipplePatternTextureSize",o),_r.ENABLE_CONTINUOUS_LINE_PATTERNS?(this.program.setUniform1f("stipplePatternPixelSize",e),this.program.setUniform1f("stipplePatternPixelSizeInv",1/e),this.configuration.draped?this.program.setUniform1f("worldToScreenRatio",1/s.screenToWorldRatio):(this.program.setUniform1f("worldToScreenPerDistanceRatio",1/s.camera.perScreenPixelRatio),this.program.setUniform1f("cameraDistanceToSurface",s.camera.distanceFromSurface))):this.program.setUniform1f("stipplePatternPixelSizeInv",1/(e*s.camera.pixelRatio)),this.configuration.stippleOffColorEnabled){const t=w(i.stippleOffColor);this.program.setUniform4f("stippleOffColor",t[0],t[1],t[2],t.length>3?t[3]:1)}}this.configuration.falloffEnabled&&this.program.setUniform1f("falloff",i.falloff),this.configuration.innerColorEnabled&&(this.program.setUniform4fv("innerColor",e(i.innerColor,i.color)),this.program.setUniform1f("innerWidth",i.innerWidth*s.camera.pixelRatio))}bindDraw(t){Zt(this.program,t),this.configuration.stippleEnabled&&_r.ENABLE_CONTINUOUS_LINE_PATTERNS&&!this.configuration.draped&&qt(this.program,t.origin,t.camera.viewInverseTransposeMatrix),Qt(this.program,this.configuration,t),this.program.rebindTextures()}makePipelineState(t,e){const i=this.configuration,s=3===t,r=2===t;return Ni({blending:0===i.output||7===i.output?s?Hi:Vi(t):null,depthTest:{func:Gi(t)},depthWrite:s?!i.transparent&&i.writeDepth&&Ui:$i(t),colorWrite:Ii,stencilWrite:i.sceneHasOcludees?pe:null,stencilTest:i.sceneHasOcludees?e?de:fe:null,polygonOffset:s||r?i.polygonOffset&&fa:Bi})}initializePipeline(){const t=this.configuration,e=t.polygonOffset&&fa;return t.occluder&&(this._occluderPipelineTransparent=Ni({blending:Hi,polygonOffset:e,depthTest:ve,depthWrite:null,colorWrite:Ii,stencilWrite:null,stencilTest:me}),this._occluderPipelineOpaque=Ni({blending:Hi,polygonOffset:e,depthTest:ve,depthWrite:null,colorWrite:Ii,stencilWrite:ge,stencilTest:we}),this._occluderPipelineMaskWrite=Ni({blending:null,polygonOffset:e,depthTest:xe,depthWrite:null,colorWrite:null,stencilWrite:pe,stencilTest:de})),this._occludeePipelineState=this.makePipelineState(this.configuration.transparencyPassType,!0),this.makePipelineState(this.configuration.transparencyPassType,!1)}get primitiveType(){return 5}getPipelineState(t,e){return e?this._occludeePipelineState:this.configuration.occluder?10===t?this._occluderPipelineTransparent:9===t?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipelineState(t,e)}}da.shader=new Jt(ua,(()=>import("./p-7bc3b507.js")));const fa={factor:0,units:-4};class va extends Lt{constructor(){super(...arguments),this.output=0,this.occluder=!1,this.slicePlaneEnabled=!1,this.transparent=!1,this.polygonOffset=!1,this.writeDepth=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleIntegerRepeatsEnabled=!1,this.scaleStippleWithLineWidth=!1,this.capType=0,this.roundJoins=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.falloffEnabled=!1,this.innerColorEnabled=!1,this.sceneHasOcludees=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}s([Ft({count:8})],va.prototype,"output",void 0),s([Ft()],va.prototype,"occluder",void 0),s([Ft()],va.prototype,"slicePlaneEnabled",void 0),s([Ft()],va.prototype,"transparent",void 0),s([Ft()],va.prototype,"polygonOffset",void 0),s([Ft()],va.prototype,"writeDepth",void 0),s([Ft()],va.prototype,"draped",void 0),s([Ft()],va.prototype,"stippleEnabled",void 0),s([Ft()],va.prototype,"stippleOffColorEnabled",void 0),s([Ft()],va.prototype,"stippleIntegerRepeatsEnabled",void 0),s([Ft()],va.prototype,"scaleStippleWithLineWidth",void 0),s([Ft({count:3})],va.prototype,"capType",void 0),s([Ft()],va.prototype,"roundJoins",void 0),s([Ft()],va.prototype,"vvSize",void 0),s([Ft()],va.prototype,"vvColor",void 0),s([Ft()],va.prototype,"vvOpacity",void 0),s([Ft()],va.prototype,"falloffEnabled",void 0),s([Ft()],va.prototype,"innerColorEnabled",void 0),s([Ft()],va.prototype,"sceneHasOcludees",void 0),s([Ft({count:4})],va.prototype,"transparencyPassType",void 0),s([Ft()],va.prototype,"multipassTerrainEnabled",void 0),s([Ft()],va.prototype,"cullAboveGround",void 0);const ma=i.getLogger("esri.views.3d.webgl-engine.materials.RibbonLineMaterial");class ga extends Yt{constructor(t){super(t,xa),this._vertexAttributeLocations=pa,this.techniqueConfig=new va,this.layout=this.createLayout()}isClosed(t,e){return Ca(this.parameters,t,e)}dispose(){}getPassParameters(){return this.parameters}getTechniqueConfig(e,i){this.techniqueConfig.output=e,this.techniqueConfig.draped=20===i.slot;const s=t(this.parameters.stipplePattern);return this.techniqueConfig.stippleEnabled=s,this.techniqueConfig.stippleIntegerRepeatsEnabled=s&&this.parameters.stippleIntegerRepeats,this.techniqueConfig.stippleOffColorEnabled=s&&t(this.parameters.stippleOffColor),this.techniqueConfig.scaleStippleWithLineWidth=s&&this.parameters.scaleStippleWithLineWidth,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,this.techniqueConfig.roundJoins="round"===this.parameters.join,this.techniqueConfig.capType=this.parameters.cap,this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.polygonOffset=this.parameters.polygonOffset,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.vvColor=this.parameters.vvColorEnabled,this.techniqueConfig.vvOpacity=this.parameters.vvOpacityEnabled,this.techniqueConfig.vvSize=this.parameters.vvSizeEnabled,this.techniqueConfig.innerColorEnabled=this.parameters.innerWidth>0&&t(this.parameters.innerColor),this.techniqueConfig.falloffEnabled=this.parameters.falloff>0,this.techniqueConfig.occluder=8===this.parameters.renderOccluded,this.techniqueConfig.transparencyPassType=i.transparencyPassType,this.techniqueConfig.multipassTerrainEnabled=i.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=i.cullAboveGround,this.techniqueConfig}intersect(t,e,i,s,r,o,n,a,l){l?this.intersectDrapedLineGeometry(t,s,o,n):this.intersectLineGeometry(t,e,i,s,n)}intersectDrapedLineGeometry(t,e,i,s){if(!e.options.selectionMode)return;const r=t.vertexAttributes.get("position").data,o=t.vertexAttributes.get("size");let n=this.parameters.width;if(this.parameters.vvSizeEnabled){const e=t.vertexAttributes.get("sizeFeatureAttribute").data[0];n*=J(this.parameters.vvSizeOffset[0]+e*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else o&&(n*=o.data[0]);const a=i[0],l=i[1],c=(n/2+4)*t.screenToWorldRatio;let h=Number.MAX_VALUE;for(let t=0;t<r.length-5;t+=3){const e=r[t],i=r[t+1],s=a-e,o=l-i,n=r[t+3]-e,c=r[t+4]-i,u=J((n*s+c*o)/(n*n+c*c),0,1),p=n*u-s,d=c*u-o,f=p*p+d*d;f<h&&(h=f)}h<c*c&&s()}intersectLineGeometry(t,e,i,s,r){if(!s.options.selectionMode||Ee(e))return;if(!ni(i))return void ma.error("intersection assumes a translation-only matrix");const o=t.vertexAttributes,n=o.get("position").data;let a=this.parameters.width;if(this.parameters.vvSizeEnabled){const t=o.get("sizeFeatureAttribute").data[0];a*=J(this.parameters.vvSizeOffset[0]+t*this.parameters.vvSizeFactor[0],this.parameters.vvSizeMinSize[0],this.parameters.vvSizeMaxSize[0])}else o.has("size")&&(a*=o.get("size").data[0]);const l=s.camera,c=Oa;Di(c,s.point);const h=a*l.pixelRatio/2+4*l.pixelRatio;E(Ia[0],c[0]-h,c[1]+h,0),E(Ia[1],c[0]+h,c[1]+h,0),E(Ia[2],c[0]+h,c[1]-h,0),E(Ia[3],c[0]-h,c[1]-h,0);for(let t=0;t<4;t++)if(!l.unprojectFromRenderScreen(Ia[t],Wa[t]))return;He(l.eye,Wa[0],Wa[1],Ua),He(l.eye,Wa[1],Wa[2],Ha),He(l.eye,Wa[2],Wa[3],Ga),He(l.eye,Wa[3],Wa[0],$a);let u=Number.MAX_VALUE;const p=ba(this.parameters,o,t.indices)?n.length-2:n.length-5;for(let t=0;t<p;t+=3){Pa[0]=n[t]+i[12],Pa[1]=n[t+1]+i[13],Pa[2]=n[t+2]+i[14];const e=(t+3)%n.length;if(za[0]=n[e]+i[12],za[1]=n[e+1]+i[13],za[2]=n[e+2]+i[14],$e(Ua,Pa)<0&&$e(Ua,za)<0||$e(Ha,Pa)<0&&$e(Ha,za)<0||$e(Ga,Pa)<0&&$e(Ga,za)<0||$e($a,Pa)<0&&$e($a,za)<0)continue;if(l.projectToRenderScreen(Pa,Ta),l.projectToRenderScreen(za,_a),Ta[2]<0&&_a[2]>0){R(Ma,Pa,za);const t=l.frustum,e=-$e(t[4],Pa)/N(Ma,Qe(t[4]));T(Ma,Ma,e),O(Pa,Pa,Ma),l.projectToRenderScreen(Pa,Ta)}else if(Ta[2]>0&&_a[2]<0){R(Ma,za,Pa);const t=l.frustum,e=-$e(t[4],za)/N(Ma,Qe(t[4]));T(Ma,Ma,e),O(za,za,Ma),l.projectToRenderScreen(za,_a)}else if(Ta[2]<0&&_a[2]<0)continue;Ta[2]=0,_a[2]=0;const s=Ds(Ps(Ta,_a,Ra),c);s<u&&(u=s,V(Ea,Pa),V(ja,za))}const d=s.rayBeginPoint,f=s.rayEndPoint;if(u<h*h){let t=Number.MAX_VALUE;if(zs(Ps(Ea,ja,Ra),Ps(d,f,Fa),Aa)){R(Aa,Aa,d);const e=A(Aa);T(Aa,Aa,1/e),t=e/W(d,f)}r(t,Aa)}}computeAttachmentOrigin(t,e){const i=t.vertexAttributes;if(!i)return null;const s=t.indices,r=i.get("position");return Xe(r,s?s.get("position"):null,s&&ba(this.parameters,i,s),e)}createLayout(){const t=_i().vec3f("position").f32("subdivisionFactor").vec2f("uv0").vec3f("auxpos1").vec3f("auxpos2");return t.f32(this.parameters.vvSizeEnabled?"sizeFeatureAttribute":"size"),this.parameters.vvColorEnabled?t.f32("colorFeatureAttribute"):t.vec4f("color"),this.parameters.vvOpacityEnabled&&t.f32("opacityFeatureAttribute"),t}createBufferWriter(){return new ya(this.layout,this.parameters)}requiresSlot(t,e){if(20===t)return!0;if(8===this.parameters.renderOccluded)return 2===t||9===t||10===t;const i=jr(e);return 0===i||7===i?t===(this.parameters.writeDepth?4:7):2===t}createGLMaterial(t){return 0===t.output||7===t.output||4===t.output||1===t.output?new wa(t):null}validateParameters(t){"miter"!==t.join&&(t.miterLimit=0),this.requiresTransparent(t)&&(t.transparent=!0)}requiresTransparent(t){return!!((t.color&&t.color[3])<1||t.innerWidth>0&&this.colorRequiresTransparent(t.innerColor)||t.stipplePattern&&this.colorRequiresTransparent(t.stippleOffColor)||t.falloff>0)}colorRequiresTransparent(e){return t(e)&&e[3]<1&&e[3]>0}}class wa extends ye{updateParameters(t){return this.ensureTechnique(da,t)}_updateOccludeeState(t){t.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:t.hasOccludees})}beginSlot(t){return 0!==this._output&&7!==this._output||this._updateOccludeeState(t),this.updateParameters(t)}bind(t,e){e.bindPass(this._material.getPassParameters(),t)}}const xa={width:0,color:[1,1,1,1],join:"miter",cap:0,miterLimit:5,writeDepth:!0,polygonOffset:!1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,scaleStippleWithLineWidth:!1,slicePlaneEnabled:!1,vvFastUpdate:!1,transparent:!1,isClosed:!1,falloff:0,innerWidth:0,innerColor:null,sceneHasOcludees:!1,...ee,...aa.Default};class ya{constructor(t,e){switch(this.parameters=e,this.numJoinSubdivisions=0,this.vertexBufferLayout=t,this.parameters.join){case"miter":case"bevel":this.numJoinSubdivisions=e.stipplePattern?1:0;break;case"round":this.numJoinSubdivisions=Da}}isClosed(t){return ba(this.parameters,t.vertexAttributes,t.indices)}numCapSubdivisions(t){if(this.isClosed(t))return 0;switch(this.parameters.cap){case 1:case 2:return 1;default:return 0}}allocate(t){return this.vertexBufferLayout.createBuffer(t)}elementCount(t){const e=2*this.numCapSubdivisions(t)+2,i=t.indices.get("position").length/2+1,s=this.isClosed(t);let r=s?2:2*e;const o=s?0:1,n=s?i:i-1;if(t.vertexAttributes.has("subdivisions")){const e=t.vertexAttributes.get("subdivisions").data;for(let t=o;t<n;++t)r+=4+2*e[t]}else r+=(n-o)*(2*this.numJoinSubdivisions+4);return r+=2,r}write(t,e,i,s){const r=La,o=Na,n=Va,a=e.vertexAttributes.get("position").data,l=e.indices&&e.indices.get("position"),c=this.numCapSubdivisions(e);l&&l.length!==2*(a.length/3-1)&&console.warn("RibbonLineMaterial does not support indices");let h=null;e.vertexAttributes.has("subdivisions")&&(h=e.vertexAttributes.get("subdivisions").data);let u=1,p=0;this.parameters.vvSizeEnabled?p=e.vertexAttributes.get("sizeFeatureAttribute").data[0]:e.vertexAttributes.has("size")&&(u=e.vertexAttributes.get("size").data[0]);let d=[1,1,1,1],f=0;this.parameters.vvColorEnabled?f=e.vertexAttributes.get("colorFeatureAttribute").data[0]:e.vertexAttributes.has("color")&&(d=e.vertexAttributes.get("color").data);let v=0;this.parameters.vvOpacityEnabled&&(v=e.vertexAttributes.get("opacityFeatureAttribute").data[0]);const m=a.length/3,g=t.transformation,w=new Float32Array(i.buffer),x=this.vertexBufferLayout.stride/4;let y=s*x;const S=y;let b=0;const C=(t,e,i,s,r,o,n)=>{if(w[y++]=e[0],w[y++]=e[1],w[y++]=e[2],w[y++]=s,w[y++]=n,w[y++]=r,w[y++]=t[0],w[y++]=t[1],w[y++]=t[2],w[y++]=i[0],w[y++]=i[1],w[y++]=i[2],w[y++]=this.parameters.vvSizeEnabled?p:u,this.parameters.vvColorEnabled)w[y++]=f;else{const t=Math.min(4*o,d.length-4);w[y++]=d[t+0],w[y++]=d[t+1],w[y++]=d[t+2],w[y++]=d[t+3]}this.parameters.vvOpacityEnabled&&(w[y++]=v)};y+=x,E(o,a[0],a[1],a[2]),g&&j(o,o,g);const D=this.isClosed(e);if(D){const t=a.length-3;E(r,a[t],a[t+1],a[t+2]),g&&j(r,r,g)}else{V(r,o),E(n,a[3],a[4],a[5]),g&&j(n,n,g);for(let t=0;t<c;++t){const e=1-t/c;C(r,o,n,e,-4,0,b),C(r,o,n,e,4,0,b)}C(r,o,n,0,-4,0,b),C(r,o,n,0,4,0,b),V(r,o),V(o,n)}const P=D?0:1,z=D?m:m-1;for(let t=P;t<z;t++){const e=(t+1)%m*3;E(n,a[e+0],a[e+1],a[e+2]),g&&j(n,n,g),b+=W(r,o),C(r,o,n,0,-1,t,b),C(r,o,n,0,1,t,b);const i=h?h[t]:this.numJoinSubdivisions;for(let e=0;e<i;++e){const s=(e+1)/(i+1);C(r,o,n,s,-2,t,b),C(r,o,n,s,2,t,b)}C(r,o,n,1,-2,t,b),C(r,o,n,1,2,t,b),V(r,o),V(o,n)}if(D)E(n,a[3],a[4],a[5]),g&&j(n,n,g),b+=W(r,o),C(r,o,n,0,-1,P,b),C(r,o,n,0,1,P,b);else{b+=W(r,o),C(r,o,n,0,-5,z,b),C(r,o,n,0,5,z,b);for(let t=0;t<c;++t){const e=(t+1)/c;C(r,o,n,e,-5,z,b),C(r,o,n,e,5,z,b)}}Sa(w,S+x,w,S,x),y=Sa(w,y-x,w,y,x)}}function Sa(t,e,i,s,r){for(let o=0;o<r;o++)i[s++]=t[e++];return s}function ba(t,e,i){return Ca(t,e.get("position").data,i?i.get("position"):null)}function Ca(t,e,i){return!!t.isClosed&&(i?i.length>2:e.length>6)}const Da=1,Pa=it(),za=it(),Ma=it(),Aa=it(),Oa=it(),Ta=ci(),_a=ci(),Ea=it(),ja=it(),Ra=Ms(),Fa=Ms(),La=it(),Na=it(),Va=it(),Ia=[ci(),ci(),ci(),ci()],Wa=[it(),it(),it(),it()],Ua=We(),Ha=We(),Ga=We(),$a=We();class Ba{constructor(t,e=125e4){this._originSR=t,this._gridSize=e,this._origins=new Map,this._objects=new Map,this._rootOriginId="root/"+x()}getOrigin(e){const i=this._origins.get(this._rootOriginId);if(null==i){if(t(ka))return this._origins.set(this._rootOriginId,mn(ka[0],ka[1],ka[2],this._rootOriginId)),this.getOrigin(e);const i=mn(e[0]+Math.random()-.5,e[1]+Math.random()-.5,e[2]+Math.random()-.5,this._rootOriginId);return this._origins.set(this._rootOriginId,i),i}const s=this._gridSize,r=Math.round(e[0]/s),o=Math.round(e[1]/s),n=Math.round(e[2]/s),a=`${r}/${o}/${n}`;let l=this._origins.get(a);const c=.5*s;if(R(Za,e,i.vec3),Za[0]=Math.abs(Za[0]),Za[1]=Math.abs(Za[1]),Za[2]=Math.abs(Za[2]),Za[0]<c&&Za[1]<c&&Za[2]<c){if(l){const t=Math.max(...Za);if(R(Za,e,l.vec3),Za[0]=Math.abs(Za[0]),Za[1]=Math.abs(Za[1]),Za[2]=Math.abs(Za[2]),Math.max(...Za)<t)return l}return i}return l||(l=mn(r*s,o*s,n*s,a),this._origins.set(a,l)),l}_drawOriginBox(t,e=[1,1,0,1]){const i=window.view,s=i._stage,r=e.toString();if(!this._objects.has(r)){this._material=new ga({width:2,color:e}),s.add(this._material);const t=new ra({isPickable:!1}),i=new xt({castShadow:!1});s.add(i),t.add(i),s.add(t),this._objects.set(r,i)}const o=this._objects.get(r),n=[0,1,5,4,0,2,1,7,6,2,0,1,3,7,5,4,6,2,0],a=n.length,l=new Array(3*a),c=new Uint16Array(2*(a-1)),h=.5*this._gridSize;for(let e=0;e<a;e++)l[3*e+0]=t[0]+(1&n[e]?h:-h),l[3*e+1]=t[1]+(2&n[e]?h:-h),l[3*e+2]=t[2]+(4&n[e]?h:-h),e>0&&(c[2*e+0]=e-1,c[2*e+1]=e);ts(l,this._originSR,0,l,i.renderSpatialReference,0,a);const u=new Dt([["position",{size:3,data:l,exclusive:!0}]],[["position",c]],2);s.add(u),o.addGeometry(u,this._material,z)}}let ka=null;const Za=it();class qa{constructor(t){this.rctx=t,this.camera=null,this.lastFrameCamera=new Dr,this.pass=0,this.slot=2,this.highlightDepthTexture=null,this.renderOccludedMask=Ja,this.hasOccludees=!1}resetRenderOccludedMask(){this.renderOccludedMask=Ja}get isHighlightPass(){return 5===this.pass}}class Qa extends qa{constructor(t,e,i,s,r,o){super(t),this.offscreenRenderingHelper=e,this.scenelightingData=i,this.shadowMap=s,this.ssaoHelper=r,this.sliceHelper=o}}const Ja=13;class Ya{constructor(){this.adds=new f,this.removes=new f,this.updates=new f({allocator:t=>t||new Xa,deallocator:t=>(t.renderGeometry=null,t)})}clear(){this.adds.clear(),this.removes.clear(),this.updates.clear()}prune(){this.adds.prune(),this.removes.prune(),this.updates.prune()}}class Xa{}class Ka{constructor(){this.adds=new Array,this.removes=new Array,this.updates=new Array}}function tl(t){const e=new Map,i=t=>{let i=e.get(t);return i||(i=new Ka,e.set(t,i)),i};return t.adds.forAll((t=>{el(t)&&i(t.material).adds.push(t)})),t.removes.forAll((t=>{el(t)&&i(t.material).removes.push(t)})),t.updates.forAll((t=>{el(t.renderGeometry)&&i(t.renderGeometry.material).updates.push(t)})),e}function el(t){return t.data.indexCount>=1}class il{constructor(){this.enabled=!0,this._time=0}get time(){return y(this._time)}advance(e){return t(e.forcedTime)?this._time!==e.forcedTime&&(this._time=e.forcedTime,!0):!(!this.enabled||0===e.dt||(this._time+=e.dt,0))}}function sl(t){t.fragment.uniforms.add("lastFrameColorMap","sampler2D"),t.fragment.uniforms.add("reprojectionMat","mat4"),t.fragment.uniforms.add("rpProjectionMat","mat4"),t.fragment.code.add(Ct`vec2 reprojectionCoordinate(vec3 projectionCoordinate)
{
vec4 zw = rpProjectionMat * vec4(0.0, 0.0, -projectionCoordinate.z, 1.0);
vec4 reprojectedCoord = reprojectionMat * vec4(zw.w * (projectionCoordinate.xy * 2.0 - 1.0), zw.z, zw.w);
reprojectedCoord.xy /= reprojectedCoord.w;
return reprojectedCoord.xy * 0.5 + 0.5;
}`)}function rl(t,e){t.fragment.uniforms.add("nearFar","vec2"),t.fragment.uniforms.add("depthMapView","sampler2D"),t.fragment.uniforms.add("ssrViewMat","mat4"),t.fragment.uniforms.add("invResolutionHeight","float"),t.fragment.include(zt),t.include(sl),t.fragment.code.add(Ct`
  const int maxSteps = ${e.highStepCount?"150;":"75;"}

  vec4 applyProjectionMat(mat4 projectionMat, vec3 x)
  {
    vec4 projectedCoord =  projectionMat * vec4(x, 1.0);
    projectedCoord.xy /= projectedCoord.w;
    projectedCoord.xy = projectedCoord.xy*0.5 + 0.5;
    return projectedCoord;
  }

  vec3 screenSpaceIntersection(vec3 dir, vec3 startPosition, vec3 viewDir, vec3 normal)
  {
    vec3 viewPos = startPosition;
    vec3 viewPosEnd = startPosition;

    // Project the start position to the screen
    vec4 projectedCoordStart = applyProjectionMat(rpProjectionMat, viewPos);
    vec3  Q0 = viewPos / projectedCoordStart.w; // homogeneous camera space
    float k0 = 1.0/ projectedCoordStart.w;

    // advance the position in the direction of the reflection
    viewPos += dir;

    vec4 projectedCoordVanishingPoint = applyProjectionMat(rpProjectionMat, dir);

    // Project the advanced position to the screen
    vec4 projectedCoordEnd = applyProjectionMat(rpProjectionMat, viewPos);
    vec3  Q1 = viewPos / projectedCoordEnd.w; // homogeneous camera space
    float k1 = 1.0/ projectedCoordEnd.w;

    // calculate the reflection direction in the screen space
    vec2 projectedCoordDir = (projectedCoordEnd.xy - projectedCoordStart.xy);
    vec2 projectedCoordDistVanishingPoint = (projectedCoordVanishingPoint.xy - projectedCoordStart.xy);

    float yMod = min(abs(projectedCoordDistVanishingPoint.y), 1.0);

    float projectedCoordDirLength = length(projectedCoordDir);
    float maxSt = float(maxSteps);

    // normalize the projection direction depending on maximum steps
    // this determines how blocky the reflection looks
    vec2 dP = yMod * (projectedCoordDir)/(maxSt * projectedCoordDirLength);

    // Normalize the homogeneous camera space coordinates
    vec3  dQ = yMod * (Q1 - Q0)/(maxSt * projectedCoordDirLength);
    float dk = yMod * (k1 - k0)/(maxSt * projectedCoordDirLength);

    // initialize the variables for ray marching
    vec2 P = projectedCoordStart.xy;
    vec3 Q = Q0;
    float k = k0;
    float rayStartZ = -startPosition.z; // estimated ray start depth value
    float rayEndZ = -startPosition.z;   // estimated ray end depth value
    float prevEstimateZ = -startPosition.z;
    float rayDiffZ = 0.0;
    float dDepth;
    float depth;
    float rayDiffZOld = 0.0;

    // early outs
    if (dot(normal, dir) < 0.0 || dot(-viewDir, normal) < 0.0)
      return vec3(P, 0.0);

    for(int i = 0; i < maxSteps-1; i++)
    {
      depth = -linearDepthFromTexture(depthMapView, P, nearFar); // get linear depth from the depth buffer

      // estimate depth of the marching ray
      rayStartZ = prevEstimateZ;
      dDepth = -rayStartZ - depth;
      rayEndZ = (dQ.z * 0.5 + Q.z)/ ((dk * 0.5 + k));
      rayDiffZ = rayEndZ- rayStartZ;
      prevEstimateZ = rayEndZ;

      if(-rayEndZ > nearFar[1] || -rayEndZ < nearFar[0] || P.y < 0.0  || P.y > 1.0 )
      {
        return vec3(P, 0.);
      }

      // If we detect a hit - return the intersection point, two conditions:
      //  - dDepth > 0.0 - sampled point depth is in front of estimated depth
      //  - if difference between dDepth and rayDiffZOld is not too large
      //  - if difference between dDepth and 0.025/abs(k) is not too large
      //  - if the sampled depth is not behind far plane or in front of near plane

      if((dDepth) < 0.025/abs(k) + abs(rayDiffZ) && dDepth > 0.0 && depth > nearFar[0] && depth < nearFar[1] && abs(P.y - projectedCoordStart.y) > invResolutionHeight)
      {
          return vec3(P, depth);
      }

      // continue with ray marching
      P += dP;
      Q.z += dQ.z;
      k += dk;
      rayDiffZOld = rayDiffZ;
    }
    return vec3(P, 0.0);
  }
  `)}function ol(t,e){e.ssrEnabled&&(t.bindTexture(e.linearDepthTexture,"depthMapView"),t.setUniform2fv("nearFar",e.camera.nearFar),t.setUniformMatrix4fv("ssrViewMat",e.camera.viewMatrix),t.setUniform1f("invResolutionHeight",1/e.camera.height),function(t,e){t.bindTexture(e.lastFrameColorTexture,"lastFrameColorMap"),t.setUniformMatrix4fv("reprojectionMat",e.reprojectionMatrix),t.setUniformMatrix4fv("rpProjectionMat",e.camera.projectionMatrix)}(t,e))}function nl(t){t.fragment.code.add(Ct`float normals2FoamIntensity(vec3 n, float waveStrength){
float normalizationFactor =  max(0.015, waveStrength);
return max((n.x + n.y)*0.3303545/normalizationFactor + 0.3303545, 0.0);
}`)}function al(t){t.fragment.code.add(Ct`vec3 foamIntensity2FoamColor(float foamIntensityExternal, float foamPixelIntensity, vec3 skyZenitColor, float dayMod){
return foamIntensityExternal * (0.075 * skyZenitColor * pow(foamPixelIntensity, 4.) +  50.* pow(foamPixelIntensity, 23.0)) * dayMod;
}`)}function ll(t){t.fragment.uniforms.add("texWaveNormal","sampler2D"),t.fragment.uniforms.add("texWavePerturbation","sampler2D"),t.fragment.uniforms.add("waveParams","vec4"),t.fragment.uniforms.add("waveDirection","vec2"),t.include(nl),t.fragment.code.add(Ct`const vec2  FLOW_JUMP = vec2(6.0/25.0, 5.0/24.0);
vec2 textureDenormalized2D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rg - 1.0;
}
float sampleNoiseTexture(vec2 _uv) {
return texture2D(texWavePerturbation, _uv).b;
}
vec3 textureDenormalized3D(sampler2D _tex, vec2 _uv) {
return 2.0 * texture2D(_tex, _uv).rgb - 1.0;
}
float computeProgress(vec2 uv, float time) {
return fract(time);
}
float computeWeight(vec2 uv, float time) {
float progress = computeProgress(uv, time);
return 1.0 - abs(1.0 - 2.0 * progress);
}
vec3 computeUVPerturbedWeigth(sampler2D texFlow, vec2 uv, float time, float phaseOffset) {
float flowStrength = waveParams[2];
float flowOffset = waveParams[3];
vec2 flowVector = textureDenormalized2D(texFlow, uv) * flowStrength;
float progress = computeProgress(uv, time + phaseOffset);
float weight = computeWeight(uv, time + phaseOffset);
vec2 result = uv;
result -= flowVector * (progress + flowOffset);
result += phaseOffset;
result += (time - progress) * FLOW_JUMP;
return vec3(result, weight);
}
const float TIME_NOISE_TEXTURE_REPEAT = 0.3737;
const float TIME_NOISE_STRENGTH = 7.77;
vec3 getWaveLayer(sampler2D _texNormal, sampler2D _dudv, vec2 _uv, vec2 _waveDir, float time) {
float waveStrength = waveParams[0];
vec2 waveMovement = time * -_waveDir;
float timeNoise = sampleNoiseTexture(_uv * TIME_NOISE_TEXTURE_REPEAT) * TIME_NOISE_STRENGTH;
vec3 uv_A = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.0);
vec3 uv_B = computeUVPerturbedWeigth(_dudv, _uv + waveMovement, time + timeNoise, 0.5);
vec3 normal_A = textureDenormalized3D(_texNormal, uv_A.xy) * uv_A.z;
vec3 normal_B = textureDenormalized3D(_texNormal, uv_B.xy) * uv_B.z;
vec3 mixNormal = normalize(normal_A + normal_B);
mixNormal.xy *= waveStrength;
mixNormal.z = sqrt(1.0 - dot(mixNormal.xy, mixNormal.xy));
return mixNormal;
}
vec4 getSurfaceNormalAndFoam(vec2 _uv, float _time) {
float waveTextureRepeat = waveParams[1];
vec3 normal = getWaveLayer(texWaveNormal, texWavePerturbation, _uv * waveTextureRepeat, waveDirection, _time);
float foam  = normals2FoamIntensity(normal, waveParams[0]);
return vec4(normal, foam);
}`)}function cl(t,e){t.vertex.code.add(1===e.viewingMode?Ct`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return normalize(pos + origin);
}`:Ct`vec3 getLocalUp(in vec3 pos, in vec3 origin) {
return vec3(0.0, 0.0, 1.0);
}`),t.vertex.code.add(1===e.viewingMode?Ct`mat3 getTBNMatrix(in vec3 n) {
vec3 t = normalize(cross(vec3(0.0, 0.0, 1.0), n));
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`:Ct`mat3 getTBNMatrix(in vec3 n) {
vec3 t = vec3(1.0, 0.0, 0.0);
vec3 b = normalize(cross(n, t));
return mat3(t, b, n);
}`)}function hl(t,e){t.include(Se,e),t.include(lr),t.include(al),e.ssrEnabled&&t.include(rl,e),t.fragment.constants.add("fresnelSky","vec3",[.02,1,15]).add("fresnelMaterial","vec2",[.02,.1]).add("roughness","float",.015).add("foamIntensityExternal","float",1.7).add("ssrIntensity","float",.65).add("ssrHeightFadeStart","float",3e5).add("ssrHeightFadeEnd","float",5e5).add("waterDiffusion","float",.775).add("waterSeeColorMod","float",.8).add("correctionViewingPowerFactor","float",.4).add("skyZenitColor","vec3",[.52,.68,.9]).add("skyColor","vec3",[.67,.79,.9]),t.fragment.code.add(Ct`PBRShadingWater shadingInfo;
vec3 getSkyGradientColor(in float cosTheta, in vec3 horizon, in vec3 zenit) {
float exponent = pow((1.0 - cosTheta), fresnelSky[2]);
return mix(zenit, horizon, exponent);
}`),t.fragment.code.add(Ct`vec3 getSeaColor(in vec3 n, in vec3 v, in vec3 l, vec3 color, in vec3 lightIntensity, in vec3 localUp, in float shadow, float foamIntensity, vec3 positionView) {
float reflectionHit = 0.;
vec3 seaWaterColor = linearizeGamma(color);
vec3 h = normalize(l + v);
shadingInfo.NdotL = clamp(dot(n, l), 0.0, 1.0);
shadingInfo.NdotV = clamp(dot(n, v), 0.001, 1.0);
shadingInfo.VdotN = clamp(dot(v, n), 0.001, 1.0);
shadingInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
shadingInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
shadingInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
float upDotV = max(dot(localUp,v), 0.0);
vec3 skyHorizon = linearizeGamma(skyColor);
vec3 skyZenit = linearizeGamma(skyZenitColor);
vec3 skyColor = getSkyGradientColor(upDotV, skyHorizon, skyZenit );
float upDotL = max(dot(localUp,l),0.0);
float daytimeMod = 0.1 + upDotL * 0.9;
skyColor *= daytimeMod;
float shadowModifier = clamp(shadow, 0.8, 1.0);
vec3 fresnelModifier = fresnelReflection(shadingInfo.VdotN, vec3(fresnelSky[0]), fresnelSky[1]);
vec3 reflSky = fresnelModifier * skyColor * shadowModifier;
vec3 reflSea = seaWaterColor * mix(skyColor, upDotL * lightIntensity * LIGHT_NORMALIZATION, 2.0 / 3.0) * shadowModifier;
vec3 specular = vec3(0.0);
if(upDotV > 0.0 && upDotL > 0.0) {
vec3 specularSun = brdfSpecularWater(shadingInfo, roughness, vec3(fresnelMaterial[0]), fresnelMaterial[1]);
vec3 incidentLight = lightIntensity * LIGHT_NORMALIZATION * shadow;
specular = shadingInfo.NdotL * incidentLight * specularSun;
}
vec3 foam = vec3(0.0);
if(upDotV > 0.0) {
foam = foamIntensity2FoamColor(foamIntensityExternal, foamIntensity, skyZenitColor, daytimeMod);
}`),t.fragment.code.add(e.ssrEnabled?Ct`vec4 viewPosition = vec4(positionView.xyz, 1.0);
vec3 viewDir = normalize(viewPosition.xyz);
vec4 viewNormalVectorCoordinate = ssrViewMat *vec4(n, 0.0);
vec3 viewNormal = normalize(viewNormalVectorCoordinate.xyz);
vec4 viewUp = ssrViewMat *vec4(localUp, 0.0);
float correctionViewingFactor = pow(max(dot(-viewDir, viewUp.xyz), 0.0), correctionViewingPowerFactor);
vec3 viewNormalCorrected = mix(viewUp.xyz, viewNormal, correctionViewingFactor);
vec3 reflected = normalize(reflect(viewDir, viewNormalCorrected));
vec3 hitCoordinate = screenSpaceIntersection( normalize(reflected), viewPosition.xyz, viewDir, viewUp.xyz);
vec3 reflectedColor = vec3(0.0);
if (hitCoordinate.z > 0.0)
{
vec2 reprojectedCoordinate = reprojectionCoordinate(hitCoordinate);
vec2 dCoords = smoothstep(0.3, 0.6, abs(vec2(0.5, 0.5) - hitCoordinate.xy));
float heightMod = smoothstep(ssrHeightFadeEnd, ssrHeightFadeStart, -positionView.z);
reflectionHit = waterDiffusion * clamp(1.0 - (1.3*dCoords.y), 0.0, 1.0) * heightMod;
reflectedColor = linearizeGamma(texture2D(lastFrameColorMap, reprojectedCoordinate).xyz)* reflectionHit * fresnelModifier.y * ssrIntensity;
}
float seeColorMod =  mix(waterSeeColorMod, waterSeeColorMod*0.5, reflectionHit);
return tonemapACES((1. - reflectionHit) * reflSky + reflectedColor + reflSea * seeColorMod + specular + foam);
}`:Ct`return tonemapACES(reflSky + reflSea * waterSeeColorMod + specular + foam);
}`)}function ul(t){const e=new At;return e.include(be,{linearDepth:!1}),e.attributes.add("position","vec3"),e.attributes.add("uv0","vec2"),e.vertex.uniforms.add("proj","mat4").add("view","mat4").add("localOrigin","vec3"),e.vertex.uniforms.add("waterColor","vec4"),0!==t.output&&7!==t.output||(e.include(cl,t),e.include(Ce,t),e.varyings.add("vuv","vec2"),e.varyings.add("vpos","vec3"),e.varyings.add("vnormal","vec3"),e.varyings.add("vtbnMatrix","mat3"),t.multipassTerrainEnabled&&e.varyings.add("depth","float"),e.vertex.code.add(Ct`
      void main(void) {
        if (waterColor.a < ${Ct.float(Et)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vuv = uv0;
        vpos = position;

        vnormal = getLocalUp(vpos, localOrigin);
        vtbnMatrix = getTBNMatrix(vnormal);

        ${t.multipassTerrainEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}

        gl_Position = transformPosition(proj, view, vpos);
        ${0===t.output?"forwardLinearDepth();":""}
      }
    `)),t.multipassTerrainEnabled&&(e.fragment.include(zt),e.include(he,t)),7===t.output&&(e.include(Ot,t),e.fragment.uniforms.add("waterColor","vec4"),e.fragment.code.add(Ct`
        void main() {
          discardBySlice(vpos);
          ${t.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}

          gl_FragColor = vec4(waterColor.a);
        }
      `)),0===t.output&&(e.include(ll,t),e.include(Ot,t),t.receiveShadows&&e.include(De,t),e.include(hl,t),e.fragment.uniforms.add("waterColor","vec4").add("lightingMainDirection","vec3").add("lightingMainIntensity","vec3").add("camPos","vec3").add("timeElapsed","float").add("view","mat4"),e.fragment.include(Tt),e.fragment.code.add(Ct`
      void main() {
        discardBySlice(vpos);
        ${t.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
        vec3 localUp = vnormal;
        // the created normal is in tangent space
        vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);

        // we rotate the normal according to the tangent-bitangent-normal-Matrix
        vec3 n = normalize(vtbnMatrix * tangentNormalFoam.xyz);
        vec3 v = -normalize(vpos - camPos);
        float shadow = ${t.receiveShadows?Ct`1.0 - readShadowMap(vpos, linearDepth)`:"1.0"};
        vec4 vPosView = view*vec4(vpos, 1.0);
        vec4 final = vec4(getSeaColor(n, v, lightingMainDirection, waterColor.rgb, lightingMainIntensity, localUp, shadow, tangentNormalFoam.w, vPosView.xyz), waterColor.w);

        // gamma correction
        gl_FragColor = delinearizeGamma(final);
        gl_FragColor = highlightSlice(gl_FragColor, vpos);
        ${t.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
      }
    `)),2===t.output&&(e.include(cl,t),e.include(ll,t),e.include(Ot,t),e.varyings.add("vpos","vec3"),e.varyings.add("vuv","vec2"),e.vertex.code.add(Ct`
        void main(void) {
          if (waterColor.a < ${Ct.float(Et)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vuv = uv0;
          vpos = position;

          gl_Position = transformPosition(proj, view, vpos);
        }
    `),e.fragment.uniforms.add("timeElapsed","float"),e.fragment.code.add(Ct`void main() {
discardBySlice(vpos);
vec4 tangentNormalFoam = getSurfaceNormalAndFoam(vuv, timeElapsed);
tangentNormalFoam.xyz = normalize(tangentNormalFoam.xyz);
gl_FragColor = vec4((tangentNormalFoam.xyz + vec3(1.0)) * 0.5, tangentNormalFoam.w);
}`)),5===t.output&&(e.varyings.add("vpos","vec3"),e.vertex.code.add(Ct`
        void main(void) {
          if (waterColor.a < ${Ct.float(Et)}) {
            // Discard this vertex
            gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
            return;
          }

          vpos = position;
          gl_Position = transformPosition(proj, view, vpos);
        }
    `),e.fragment.uniforms.add("waterColor","vec4"),e.fragment.code.add(Ct`void main() {
gl_FragColor = waterColor;
}`)),4===t.output&&(e.include(Rt),e.varyings.add("vpos","vec3"),e.vertex.code.add(Ct`
      void main(void) {
        if (waterColor.a < ${Ct.float(Et)}) {
          // Discard this vertex
          gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
          return;
        }

        vpos = position;
        gl_Position = transformPosition(proj, view, vpos);
      }
    `),e.include(Ot,t),e.fragment.code.add(Ct`void main() {
discardBySlice(vpos);
outputHighlight();
}`)),e}const pl=Object.freeze({__proto__:null,build:ul});class dl extends Nt{constructor(t,e,i){super(t,e,i),this._textureRepository=t.waterTextureRepository}initializeProgram(t){const e=dl.shader.get(),i=this.configuration,s=e.build({OITEnabled:0===i.transparencyPassType,output:i.output,viewingMode:t.viewingMode,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,receiveShadows:i.receiveShadows,pbrMode:3,useCustomDTRExponentForWater:!0,ssrEnabled:i.useSSR,highStepCount:!0,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new Vt(t.rctx,s,It)}bindPass(t,e){Wt(this.program,e.camera.projectionMatrix),e.multipassTerrainEnabled&&(this.program.setUniform2fv("cameraNearFar",e.camera.nearFar),this.program.setUniform2fv("inverseViewport",e.inverseViewport),$t(this.program,e)),0===this.configuration.output&&(e.lighting.setUniforms(this.program,!1),ol(this.program,e)),0!==this.configuration.output&&2!==this.configuration.output||(function(t,e){t.setUniform4f("waveParams",e.waveStrength,e.waveTextureRepeat,e.flowStrength,e.flowOffset),t.setUniform2f("waveDirection",e.waveDirection[0]*e.waveVelocity,e.waveDirection[1]*e.waveVelocity)}(this.program,t),this._textureRepository.bind(this.program)),this.program.setUniform4fv("waterColor",t.color),4===this.configuration.output&&kt(this.program,e)}bindDraw(t){Zt(this.program,t),this.program.rebindTextures(),0!==this.configuration.output&&7!==this.configuration.output||qt(this.program,t.origin,t.camera.viewInverseTransposeMatrix),0===this.configuration.output&&Pe(this.program,t),0!==this.configuration.output&&7!==this.configuration.output&&4!==this.configuration.output||Qt(this.program,this.configuration,t)}setPipelineState(t){const e=this.configuration,i=3===t,s=2===t;return Ni({blending:2!==e.output&&4!==e.output&&e.transparent?i?Hi:Vi(t):null,depthTest:{func:Gi(t)},depthWrite:i?e.writeDepth&&Ui:$i(t),colorWrite:Ii,polygonOffset:i||s?null:ki(e.enableOffset)})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}dl.shader=new Jt(pl,(()=>import("./p-adfb1196.js")));class fl extends Lt{constructor(){super(...arguments),this.output=0,this.receiveShadows=!1,this.slicePlaneEnabled=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!1,this.useSSR=!1,this.isDraped=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}s([Ft({count:8})],fl.prototype,"output",void 0),s([Ft()],fl.prototype,"receiveShadows",void 0),s([Ft()],fl.prototype,"slicePlaneEnabled",void 0),s([Ft()],fl.prototype,"transparent",void 0),s([Ft()],fl.prototype,"enableOffset",void 0),s([Ft()],fl.prototype,"writeDepth",void 0),s([Ft()],fl.prototype,"useSSR",void 0),s([Ft()],fl.prototype,"isDraped",void 0),s([Ft({count:4})],fl.prototype,"transparencyPassType",void 0),s([Ft()],fl.prototype,"multipassTerrainEnabled",void 0),s([Ft()],fl.prototype,"cullAboveGround",void 0);class vl extends ye{updateParameters(t){return this.ensureTechnique(dl,t)}setElapsedTimeUniform(t){t.setUniform1f("timeElapsed",.001*this._material.animation.time*this._material.parameters.animationSpeed)}_updateShadowState(t){t.shadowMappingEnabled!==this._material.parameters.receiveShadows&&this._material.setParameters({receiveShadows:t.shadowMappingEnabled})}_updateSSRState(t){t.ssrEnabled!==this._material.parameters.ssrEnabled&&this._material.setParameters({ssrEnabled:t.ssrEnabled})}ensureResources(t){const e=this._techniqueRep.constructionContext.waterTextureRepository;return e.ready||e.updating||e.loadTextures(t),e.ready?2:1}beginSlot(t){return 0===this._output&&(this._updateShadowState(t),this._updateSSRState(t)),this.updateParameters(t)}bind(t,e){e.bindPass(this._material.parameters,t),2!==this._output&&0!==this._output||this.setElapsedTimeUniform(e.program)}}const ml=_i().vec3f("position"),gl=_i().vec3f("position").vec2f("uv0"),wl=_i().vec3f("position").vec4u8("color");class xl{constructor(t){this.vertexBufferLayout=t}allocate(t){return this.vertexBufferLayout.createBuffer(t)}elementCount(t){return t.indices.get("position").length}write(t,e,i,s){ze(e,this.vertexBufferLayout,t.transformation,t.invTranspTransformation,i,s)}}const yl={waveStrength:.06,waveTextureRepeat:32,waveDirection:zi(1,0),waveVelocity:.05,flowStrength:.015,flowOffset:-.5,animationSpeed:.35,color:[0,0,0,0],transparent:!0,writeDepth:!0,slicePlaneEnabled:!1,isDraped:!1,receiveShadows:!0,ssrEnabled:!1,...ee},Sl={"calm-small":{waveStrength:.005,perturbationStrength:.02,textureRepeat:12,waveVelocity:.01},"rippled-small":{waveStrength:.02,perturbationStrength:.09,textureRepeat:32,waveVelocity:.07},"slight-small":{waveStrength:.05,perturbationStrength:.07,textureRepeat:28,waveVelocity:.1},"moderate-small":{waveStrength:.075,perturbationStrength:.07,textureRepeat:24,waveVelocity:.1},"calm-medium":{waveStrength:.003125,perturbationStrength:.01,textureRepeat:8,waveVelocity:.02},"rippled-medium":{waveStrength:.035,perturbationStrength:.015,textureRepeat:12,waveVelocity:.07},"slight-medium":{waveStrength:.06,perturbationStrength:.015,textureRepeat:8,waveVelocity:.12},"moderate-medium":{waveStrength:.09,perturbationStrength:.03,textureRepeat:4,waveVelocity:.12},"calm-large":{waveStrength:.01,perturbationStrength:0,textureRepeat:4,waveVelocity:.05},"rippled-large":{waveStrength:.025,perturbationStrength:.01,textureRepeat:8,waveVelocity:.11},"slight-large":{waveStrength:.06,perturbationStrength:.02,textureRepeat:3,waveVelocity:.13},"moderate-large":{waveStrength:.14,perturbationStrength:.03,textureRepeat:2,waveVelocity:.15}};class bl extends Yt{constructor(t){super(t,yl),this._techniqueConfig=new fl,this.animation=new il}getTechniqueConfig(t,e){return this._techniqueConfig.output=t,this._techniqueConfig.writeDepth=this.parameters.writeDepth,this._techniqueConfig.receiveShadows=this.parameters.receiveShadows,this._techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this._techniqueConfig.transparent=this.parameters.transparent,this._techniqueConfig.useSSR=this.parameters.ssrEnabled,this._techniqueConfig.isDraped=this.parameters.isDraped,this._techniqueConfig.transparencyPassType=e.transparencyPassType,this._techniqueConfig.enableOffset=e.camera.relativeElevation<Zi,this._techniqueConfig.multipassTerrainEnabled=e.multipassTerrainEnabled,this._techniqueConfig.cullAboveGround=e.cullAboveGround,this._techniqueConfig}update(t){const e=Math.min(t.camera.relativeElevation,t.camera.distance);this.animation.enabled=Math.sqrt(this.parameters.waveTextureRepeat/this.parameters.waveStrength)*e<Cl;const i=this.animation.advance(t);return this.animation.enabled&&i}intersect(t,e,i,s,r,o,n){Me(t,e,s,r,o,void 0,n)}requiresSlot(t,e){switch(jr(e)){case 2:return 21===t;case 0:if(this.parameters.isDraped)return 20===t;break;case 4:return 2===t||20===t}let i=2;return this.parameters.transparent&&(i=this.parameters.writeDepth?4:7),t===i}createGLMaterial(t){if(0===t.output&&this.parameters.isDraped)return t.output=5,new vl(t);switch(t.output){case 0:case 2:case 4:case 7:return new vl(t)}return null}createBufferWriter(){return new xl(gl)}}const Cl=35e3;class Dl{constructor(t){this.first=t.from,this.count=t.to-t.from}}class Pl{constructor(t=0,e=0){this.from=t,this.to=e}}class zl extends Pl{constructor(t,e,i,s,r,o){super(e,i),this.id=t,this.isVisible=s,this.hasHighlights=r,this.hasOccludees=o}}function Ml(t){return Array.from(t.values()).sort(Al)}function Al(t,e){return t.from===e.from?t.to-e.to:t.from-e.from}function Ol(t,e){if(0===t.length)return void t.push(new Dl(e));const i=t[t.length-1];!function(t,e){return t.first+t.count>=e.from}(i,e)?t.push(new Dl(e)):i.count=e.from-i.first+e.to-e.from}class Tl{constructor(t,e){this._pool=t,this._size=0,this._buffer=t.newBuffer(_l(e))}dispose(){this._buffer=this._pool.deleteBuffer(this._buffer),this._size=0}release(){this.erase(0,this._size),this.dispose()}get vao(){return this._buffer.vao}get array(){return this._buffer.array}get size(){return this._size}grow(t){this._resize(this._size+t,!0).dispose()}alloc(t){return this._resize(t,!1)}_resize(t,e){let i;const s=function(t,e,i){return e<=i?t>=i?t:_l(Math.max(2*t,i)):t<=2*i?t:_l(i)}(this._buffer.length,this._size,t);if(this._buffer.length!==s){const t=this._pool.newBuffer(s);e&&(t.array.set(this._buffer.array.subarray(0,Math.min(this._size,s))),t.vao.vertexBuffers.geometry.setSubData(t.array,0,0,t.array.byteLength)),i=this._buffer,this._buffer=t}const r=this._size;return this._size=t,i?{dispose:()=>{i.array.fill(0,0,r),this._pool.deleteBuffer(i)},copy:(t,e,s)=>this._buffer.array.set(i.array.subarray(e,s),t),hasNewBuffer:!0}:{dispose:()=>{},copy:(t,e,i)=>{t!==e&&this._buffer.array.copyWithin(t,e,i)},hasNewBuffer:!1}}erase(t,e){this._buffer.array.fill(0,t,e)}}function _l(t){return 65536*Math.ceil(t/65536)}class El{constructor(t,e,i,s){this.vao=new gs(t,e,{geometry:i},{geometry:ws.createVertex(t,35044)}),this.array=new Float32Array(s),this.vao.vertexBuffers.geometry.setData(this.array)}dispose(){this.vao.dispose(!0)}get length(){return this.array.length}}const jl=Os+1;class Rl{constructor(t,e,i){this._rctx=t,this._locations=e,this._layout=i,this._cache=t.newCache(`MergedRenderer pool ${x()}`,Fl)}dispose(){this._cache.destroy()}newBuffer(e){const i=e.toString(),s=this._cache.pop(i);if(t(s)){const t=s.pop();return s.length>0&&this._cache.put(i,s,t.array.byteLength*s.length,jl),t}return new El(this._rctx,this._locations,this._layout,e)}deleteBuffer(e){const i=e.array.byteLength,s=e.array.length.toString(),r=this._cache.pop(s);return t(r)?(r.push(e),this._cache.put(s,r,i*r.length,-1)):this._cache.put(s,[e],i,-1),null}}function Fl(t,e){if(0===e)return void t.forEach((t=>t.dispose()));const i=t.pop(),s=t.length*i.array.byteLength;return i.dispose(),s}class Ll{constructor(t,e,i){this._rctx=t,this._materialRepository=e,this._material=i,this.type="MergedRenderer",this._dataByOrigin=new Map,this._renderCommandData=new f,this._hasHighlights=!1,this._hasOccludees=!1,this._glMaterials=new Er(this._material,this._materialRepository),this._bufferWriter=i.createBufferWriter(),this._bufferPool=new Rl(t,i.vertexAttributeLocations,As(this._bufferWriter.vertexBufferLayout))}dispose(){this._glMaterials.destroy(),this._dataByOrigin.forEach((t=>t.buffer.dispose())),this._dataByOrigin.clear(),this._bufferPool.dispose()}get isEmpty(){return 0===this._dataByOrigin.size}get hasHighlights(){return this._hasHighlights}get hasOccludees(){return this._hasOccludees}get hasWater(){return!this.isEmpty&&this._material instanceof bl}get rendersOccluded(){return!this.isEmpty&&1!==this._material.renderOccluded}modify(t){this.updateGeometries(t.updates),this.addAndRemoveGeometries(t.adds,t.removes),this.updateRenderCommands()}addAndRemoveGeometries(t,e){const i=this._bufferWriter,s=i.vertexBufferLayout.stride/4,r=this._dataByOrigin,o=function(t,e){const i=new Map;for(const e of t)Vl(i,e,!0);for(const t of e)Vl(i,t,!1);return i}(t,e);o.forEach(((t,e)=>{o.delete(e);const n=t.toAdd.reduce(((t,e)=>t+i.elementCount(e.data)),0);let a=r.get(e);if(null==a)ti(0===t.toRemove.length),a=new Hl(t.origin,new Tl(this._bufferPool,n*s)),r.set(e,a);else if(0===t.toAdd.length&&a.instances.size===t.toRemove.length)return a.buffer.dispose(),void r.delete(e);let l=0;a.instances.forEach((t=>l+=t.to-t.from));const c=t.toRemove.reduce(((t,e)=>t+i.elementCount(e.data)),0),h=(l+n-c)*s,u=$l;if(h<a.buffer.size/2?this.removeAndRebuild(a,t.toRemove,s,h,u):t.toRemove.length>0&&this.remove(a,t.toRemove,s,u),t.toAdd.length>0){const e=Bl;ai(e,-t.origin[0],-t.origin[1],-t.origin[2]),this.add(a,t.toAdd,s,e,u)}const p=a.buffer.vao.vertexBuffers.geometry;Ul(u),u.forAll((({from:t,to:e})=>{if(t<e){const i=4,s=t*i;p.setSubData(a.buffer.array,s,s,e*i)}})),u.clear(),a.drawCommandsDirty=!0}))}updateGeometries(t){const e=this._bufferWriter,i=e.vertexBufferLayout.stride/4;for(const s of t){const t=s.renderGeometry,r=this._dataByOrigin.get(t.origin.id),o=r&&r.instances.get(t.id);if(!o)return;const n=s.updateType;if(1&n&&(o.isVisible=t.instanceParameters.visible),9&n){const e=t.instanceParameters.visible;o.hasHighlights=!!t.instanceParameters.highlights&&e}if(16&n&&(o.hasOccludees=!!t.instanceParameters.occludees),6&n){const{array:s,vao:n}=r.buffer;Re(t,kl,Zl),e.write({transformation:kl,invTranspTransformation:Zl},t.data,e.vertexBufferLayout.createView(s.buffer),o.from),ti(o.from+e.elementCount(t.data)===o.to,"material VBO layout has changed"),n.vertexBuffers.geometry.setSubData(s,o.from*i*4,o.from*i*4,o.to*i*4)}r.drawCommandsDirty=!0}}updateRenderCommands(){this._hasHighlights=!1,this._hasOccludees=!1,this._dataByOrigin.forEach((t=>{t.hasHiddenInstances=!1,t.hasHighlights=!1,t.hasOccludees=!1,S(t.instances,(e=>(e.isVisible?(e.hasHighlights&&(this._hasHighlights=!0,t.hasHighlights=!0),e.hasOccludees&&(this._hasOccludees=!0,t.hasOccludees=!0)):t.hasHiddenInstances=!0,t.hasHiddenInstances&&t.hasHighlights&&t.hasOccludees)))}));const t=t=>{if(t.drawCommandsDefault=null,t.drawCommandsHighlight=null,t.drawCommandsOccludees=null,t.drawCommandsShadowHighlightRest=null,0===t.instances.size)return;if(!Il(t))return void(t.drawCommandsDefault=[{first:0,count:4*t.buffer.size/this._bufferWriter.vertexBufferLayout.stride}]);const e=Ml(t.instances);t.drawCommandsDefault=[],t.drawCommandsHighlight=[],t.drawCommandsOccludees=[],t.drawCommandsShadowHighlightRest=[];for(const i of e)i.isVisible&&(Ol(i.hasOccludees?t.drawCommandsOccludees:t.drawCommandsDefault,i),Ol(i.hasHighlights?t.drawCommandsHighlight:t.drawCommandsShadowHighlightRest,i))};this._dataByOrigin.forEach((e=>{e.drawCommandsDirty&&(t(e),e.drawCommandsDirty=!1)}))}updateLogic(t){return this._material.update(t)}render(e,i,s){if(null!=e&&!this._material.requiresSlot(e,i))return!1;const r=5===i||7===i;if(r&&!this._hasHighlights)return!1;const o=6===i,n=!(r||o);if(this._dataByOrigin.forEach((e=>{if(r&&!e.hasHighlights)return;const i=(r?e.drawCommandsHighlight:o&&Il(e)?e.drawCommandsShadowHighlightRest:e.drawCommandsDefault)||null,s=n&&e.drawCommandsOccludees||null;(t(i)||t(s))&&this._renderCommandData.push(new Gl(e.origin,e.buffer,i,s))})),0===this._renderCommandData.length)return!1;const a=this._rctx,c=this._glMaterials.load(a,i);if(l(c))return this._renderCommandData.clear(),!1;const h=c.beginSlot(s);return h.bindPipelineState(a,e,!1),a.useProgram(h.program),c.bind(s,h),this._renderCommandData.forAll((({origin:i,buffer:r,renderCommands:o,occludeeCommands:n})=>{s.origin=i,h.bindDraw(s),h.ensureAttributeLocations(r.vao),a.bindVAO(r.vao);const l=h.primitiveType;t(o)&&this.renderCommands(a,l,o),t(n)&&(h.bindPipelineState(a,e,!0),this.renderCommands(a,l,n),h.bindPipelineState(a,e,!1))})),this._renderCommandData.clear(),!0}renderCommands(t,e,i){for(let s=0;s<i.length;s++)t.drawArrays(e,i[s].first,i[s].count)}removeAndRebuild(t,e,i,s,r){for(const i of e)t.instances.delete(i.id);const o=Ml(t.instances);t.instances.clear();const n=t.buffer.size,a=t.buffer.alloc(s);let l=0;for(const e of o){const s=e.from*i,r=e.to*i;a.copy(l,s,r),e.from=l/i,l+=r-s,e.to=l/i,t.instances.set(e.id,e)}r.push(new Pl(0,a.hasNewBuffer?t.buffer.array.length:n)),a.dispose(),t.buffer.erase(l,r.back().to),t.holes.clear()}remove(t,e,i,s){for(const r of e){const e=r.id,o=t.instances.get(e),n=o.from*i,a=o.to*i;t.buffer.erase(n,a),t.holes.push(new Pl(o.from,o.to)),t.instances.delete(e),s.push(new Pl(n,a))}Ul(t.holes)}add(e,i,s,r,o){const n=this._bufferWriter;let a=n.vertexBufferLayout.createView(e.buffer.array.buffer);for(const c of i){const i=t(c.transformation)?pi(kl,r,c.transformation):r;di(Zl,i);const h=mi(Zl,Zl),u=n.elementCount(c.data),p=u*s;let d=Wl(e.holes,u);l(d)&&(d=e.buffer.size/s,e.buffer.grow(p),a=n.vertexBufferLayout.createView(e.buffer.array.buffer)),n.write({transformation:i,invTranspTransformation:h},c.data,a,d);const f=c.instanceParameters.visible,v=new zl(c.id,d,d+u,f,!!c.instanceParameters.highlights&&f,!!c.instanceParameters.occludees);ti(null==e.instances.get(c.id)),e.instances.set(c.id,v),o.push(new Pl(v.from*s,v.to*s))}}get test(){return{material:this._material,glMaterials:this._glMaterials}}}class Nl{constructor(t){this.origin=t,this.toAdd=new Array,this.toRemove=new Array}}function Vl(t,e,i){const s=e.origin;if(l(s))return;let r=t.get(s.id);null==r&&(r=new Nl(s.vec3),t.set(s.id,r)),i?r.toAdd.push(e):r.toRemove.push(e)}function Il(t){return t.hasOccludees||t.hasHighlights||t.hasHiddenInstances}function Wl(t,e){let i;if(!t.some((t=>!(t.to-t.from<e||(i=t,0)))))return null;const s=i.from;return i.from+=e,i.from>=i.to&&t.removeUnordered(i),s}function Ul(t){const e=new Map;t.forAll((t=>e.set(t.from,t)));let i=!0;for(;i;)i=!1,t.forEach((s=>{const r=e.get(s.to);r&&(s.to=r.to,e.delete(r.from),t.removeUnordered(r),i=!0)}))}class Hl{constructor(t,e){this.origin=t,this.buffer=e,this.instances=new Map,this.holes=new f({deallocator:null}),this.hasHiddenInstances=!1,this.hasHighlights=!1,this.hasOccludees=!1,this.drawCommandsDirty=!1}}class Gl{constructor(t,e,i,s){this.origin=t,this.buffer=e,this.renderCommands=i,this.occludeeCommands=s}}const $l=new f({deallocator:null}),Bl=M(),kl=M(),Zl=M();let ql=class extends n{constructor(){super(...arguments),this._pending=new Ql,this._changes=new Ya,this._materialRenderers=new Map,this._sortedMaterialRenderers=new f,this._hasHighlights=!1,this._hasWater=!1}dispose(){this._changes.prune(),this._materialRenderers.forEach((t=>t.dispose())),this._materialRenderers.clear(),this._sortedMaterialRenderers.clear()}get updating(){return!this._pending.empty||this._changes.updates.length>0}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return S(this._materialRenderers,(t=>t.rendersOccluded))}get isEmpty(){return!this.updating&&0===this._materialRenderers.size}commitChanges(){if(!this.updating)return!1;this._processAddsRemoves();const t=tl(this._changes);let e=!1,i=!1,s=!1;return t.forEach(((t,r)=>{let o=this._materialRenderers.get(r);if(!o&&t.adds.length>0&&(o=new Ll(this.rctx,this.materialRepository,r),this._materialRenderers.set(r,o),e=!0,i=!0,s=!0),!o)return;const n=i||o.hasHighlights,a=s||o.hasWater;o.modify(t),i=i||n!==o.hasHighlights,s=s||a!==o.hasWater,o.isEmpty&&(this._materialRenderers.delete(r),o.dispose(),e=!0)})),this._changes.clear(),e&&this.updateSortedMaterialRenderers(),i&&(this._hasHighlights=S(this._materialRenderers,(t=>t.hasHighlights))),s&&(this._hasWater=S(this._materialRenderers,(t=>t.hasWater))),this.notifyChange("updating"),!0}add(t){if(0===t.length)return;const e=this._pending.empty;for(const e of t)this._pending.adds.add(e);e&&this.notifyChange("updating")}remove(t){const e=this._pending.empty;for(const e of t)this._pending.adds.has(e)?(this._pending.removed.add(e),this._pending.adds.delete(e)):this._pending.removed.has(e)||this._pending.removes.add(e);e&&!this._pending.empty&&this.notifyChange("updating")}modify(t,e){const i=0===this._changes.updates.length;for(const i of t){const t=this._changes.updates.pushNew();t.renderGeometry=i,t.updateType=e}i&&this._changes.updates.length>0&&this.notifyChange("updating")}updateLogic(t){let e=!1;return this._sortedMaterialRenderers.forAll((({materialRenderer:i})=>e=i.updateLogic(t)||e)),e}render(t,e){for(let i=0;i<this._sortedMaterialRenderers.length;i++){const s=this._sortedMaterialRenderers.data[i];s.material.shouldRender(t)&&s.materialRenderer.render(e.slot,t.pass,e)}}updateSortedMaterialRenderers(){this._sortedMaterialRenderers.clear();let t=0;this._materialRenderers.forEach(((e,i)=>{i.insertOrder=t++,this._sortedMaterialRenderers.push({material:i,materialRenderer:e})})),this._sortedMaterialRenderers.sort(((t,e)=>{const i=e.material.renderPriority-t.material.renderPriority;return 0!==i?i:t.material.insertOrder-e.material.insertOrder}))}_processAddsRemoves(){this._changes.adds.clear(),this._changes.removes.clear(),this._changes.adds.pushArray(Array.from(this._pending.adds)),this._changes.removes.pushArray(Array.from(this._pending.removes));for(let t=0;t<this._changes.updates.length;)this._pending.has(this._changes.updates.data[t].renderGeometry)?this._changes.updates.removeUnorderedIndex(t):t++;this._pending.clear()}get test(){return{sortedMaterialRenderers:this._sortedMaterialRenderers}}};s([r()],ql.prototype,"rctx",void 0),s([r()],ql.prototype,"materialRepository",void 0),s([r()],ql.prototype,"updating",null),ql=s([o("esri.views.3d.webgl-engine.lib.SortedRenderGeometryRenderer")],ql);class Ql{constructor(){this.adds=new Set,this.removes=new Set,this.removed=new Set}get empty(){return 0===this.adds.size&&0===this.removes.size&&0===this.removed.size}has(t){return this.adds.has(t)||this.removes.has(t)||this.removed.has(t)}clear(){this.adds.clear(),this.removes.clear(),this.removed.clear()}}function Jl(t){t.attributes.add("position","vec2"),t.varyings.add("uv","vec2"),t.vertex.code.add(Ct`
    void main(void) {
      gl_Position = vec4(position, 0.0, 1.0);
      uv = position * 0.5 + vec2(0.5);
    }
  `)}function Yl(){const t=new At;return t.include(Jl),t.fragment.uniforms.add("tex","sampler2D"),t.fragment.uniforms.add("color","vec4"),t.fragment.code.add(Ct`void main() {
vec4 texColor = texture2D(tex, uv);
gl_FragColor = texColor * color;
}`),t}const Xl=Object.freeze({__proto__:null,build:Yl});class Kl extends Nt{initializeProgram(t){const e=Kl.shader.get().build();return new Vt(t.rctx,e,It)}initializePipeline(){return Ni(this.configuration.hasAlpha?{blending:qi(770,1,771,771),colorWrite:Ii}:{colorWrite:Ii})}}Kl.shader=new Jt(Xl,(()=>import("./p-e7a36aca.js")));class tc extends Lt{constructor(){super(...arguments),this.hasAlpha=!1}}function ec(t,e,i){(i=i||t).length=t.length;for(let s=0;s<t.length;s++)i[s]=t[s]*e[s];return i}function ic(t,e,i){(i=i||t).length=t.length;for(let s=0;s<t.length;s++)i[s]=t[s]*e;return i}function sc(t,e,i){(i=i||t).length=t.length;for(let s=0;s<t.length;s++)i[s]=t[s]+e[s];return i}function rc(t){return(t+1)*(t+1)}function oc(t,e,i){const s=t[0],r=t[1],o=t[2],n=i||[];return n.length=rc(e),e>=0&&(n[0]=.28209479177),e>=1&&(n[1]=.4886025119*s,n[2]=.4886025119*o,n[3]=.4886025119*r),e>=2&&(n[4]=1.09254843059*s*r,n[5]=1.09254843059*r*o,n[6]=.31539156525*(3*o*o-1),n[7]=1.09254843059*s*o,n[8]=.54627421529*(s*s-r*r)),n}function nc(t,e,i,s){(function(t,e){const i=rc(t),s=e||{r:[],g:[],b:[]};s.r.length=s.g.length=s.b.length=i;for(let t=0;t<i;t++)s.r[t]=s.g[t]=s.b[t]=0})(e,s),E(i.intensity,0,0,0);let r=!1;const o=ac,n=lc,a=cc;o.length=0,n.length=0,a.length=0;for(const e of t)e instanceof Sr&&!r?(V(i.direction,e.direction),i.intensity[0]=e.intensity[0],i.intensity[1]=e.intensity[1],i.intensity[2]=e.intensity[2],i.castShadows=e.castShadows,r=!0):e instanceof Sr||e instanceof yr?o.push(e):e instanceof xr?n.push(e):e instanceof br&&a.push(e);(function(t,e){const i=function(t){return J(Math.floor(Math.sqrt(t)-1),0,2)}(e.r.length);for(const s of t)tt(pc,s.direction),oc(pc,i,hc),ec(hc,dc),ic(hc,s.intensity[0],uc),sc(e.r,uc),ic(hc,s.intensity[1],uc),sc(e.g,uc),ic(hc,s.intensity[2],uc),sc(e.b,uc)})(o,s),function(t,e){oc(pc,0,hc);for(const i of t)e.r[0]+=hc[0]*dc[0]*i.intensity[0]*4*Math.PI,e.g[0]+=hc[0]*dc[0]*i.intensity[1]*4*Math.PI,e.b[0]+=hc[0]*dc[0]*i.intensity[2]*4*Math.PI}(n,s);for(const t of a)sc(s.r,t.r),sc(s.g,t.g),sc(s.b,t.b)}s([Ft()],tc.prototype,"hasAlpha",void 0);const ac=[],lc=[],cc=[],hc=[0],uc=[0],pc=it(),dc=[3.141593,2.094395,2.094395,2.094395,.785398,.785398,.785398,.785398,.785398];class fc{constructor(){this._shOrder=2,this._ambientBoost=.4,this._oldSunlight={direction:it(),ambient:{color:it(),intensity:1},diffuse:{color:it(),intensity:1}},this.globalFactor=.5,this.groundLightingFactor=.5,this._sphericalHarmonics=new br,this._mainLight={intensity:it(),direction:st(1,0,0),castShadows:!1}}get lightingMainDirection(){return this._mainLight.direction}setLightDirectionUniform(t){t.setUniform3fv("lightingMainDirection",this._mainLight.direction)}setUniforms(t,e=!1){t.setUniform1f("lightingFixedFactor",e?(1-this.groundLightingFactor)*(1-this.globalFactor):0),t.setUniform1f("lightingGlobalFactor",this.globalFactor),this.setLightDirectionUniform(t),t.setUniform3fv("lightingMainIntensity",this._mainLight.intensity),t.setUniform1f("ambientBoostFactor",this._ambientBoost);const i=this._sphericalHarmonics;0===this._shOrder?t.setUniform3f("lightingAmbientSH0",i.r[0],i.g[0],i.b[0]):1===this._shOrder?(t.setUniform4f("lightingAmbientSH_R",i.r[0],i.r[1],i.r[2],i.r[3]),t.setUniform4f("lightingAmbientSH_G",i.g[0],i.g[1],i.g[2],i.g[3]),t.setUniform4f("lightingAmbientSH_B",i.b[0],i.b[1],i.b[2],i.b[3])):2===this._shOrder&&(t.setUniform3f("lightingAmbientSH0",i.r[0],i.g[0],i.b[0]),t.setUniform4f("lightingAmbientSH_R1",i.r[1],i.r[2],i.r[3],i.r[4]),t.setUniform4f("lightingAmbientSH_G1",i.g[1],i.g[2],i.g[3],i.g[4]),t.setUniform4f("lightingAmbientSH_B1",i.b[1],i.b[2],i.b[3],i.b[4]),t.setUniform4f("lightingAmbientSH_R2",i.r[5],i.r[6],i.r[7],i.r[8]),t.setUniform4f("lightingAmbientSH_G2",i.g[5],i.g[6],i.g[7],i.g[8]),t.setUniform4f("lightingAmbientSH_B2",i.b[5],i.b[6],i.b[7],i.b[8]))}set(t){nc(t,this._shOrder,this._mainLight,this._sphericalHarmonics),V(this._oldSunlight.direction,this._mainLight.direction);const e=1/Math.PI;this._oldSunlight.ambient.color[0]=.282095*this._sphericalHarmonics.r[0]*e,this._oldSunlight.ambient.color[1]=.282095*this._sphericalHarmonics.g[0]*e,this._oldSunlight.ambient.color[2]=.282095*this._sphericalHarmonics.b[0]*e,T(this._oldSunlight.diffuse.color,this._mainLight.intensity,e),V(vc,this._oldSunlight.diffuse.color),T(vc,vc,this._ambientBoost*this.globalFactor),O(this._oldSunlight.ambient.color,this._oldSunlight.ambient.color,vc)}get old(){return this._oldSunlight}}const vc=it();class mc{constructor(t){this._rctx=t,this.cache=new Map}dispose(){this.cache.forEach((t=>t.texture=p(t.texture))),this.cache.clear()}acquire(t){if(l(t))return null;const e=this.patternId(t),i=this.cache.get(e);if(i)return i.refCount++,i.bind;const s=t.pixelRatio,{encodedData:r,sdfNormalizer:o,pixels:n,paddedPixels:a}=function(t,e){const i=t.map((t=>Math.round(t*e))),s=1/e,r=Math.floor(i.reduce(((t,e)=>t+e))),o=r+2,n=i.reduce(((t,e)=>Math.max(t,e))),a=(Math.floor(.5*(n-1))+.5)*s,l=new Uint8Array(4*o);let c=1,h=4;for(const t of i){for(let e=0;e<t;e++){const i=c*(Math.min(e,t-1-e)+.5)*s;hs(i/a*.5+.5,l,h),h+=4}c=-c}return l.copyWithin(0,h-4,h),l.copyWithin(h,4,8),{encodedData:l,sdfNormalizer:a,paddedPixels:o,pixels:r}}(t.pattern,s),c=n/s,h={refCount:1,texture:null,bind:t=>(l(h.texture)&&(h.texture=new ys(this._rctx,{width:a,height:1,internalFormat:6408,pixelFormat:6408,dataType:5121,wrapMode:33071},r)),t.bindTexture(h.texture,"stipplePatternTexture"),{pixelSize:c,sdfNormalizer:o,pixels:n})};return this.cache.set(e,h),h.bind}release(e){if(l(e))return;const i=this.patternId(e),s=this.cache.get(i);s&&(s.refCount--,0===s.refCount&&(t(s.texture)&&s.texture.dispose(),this.cache.delete(i)))}swap(t,e){const i=this.acquire(e);return this.release(t),i}patternId(t){return`${t.pattern.join(",")}-r${t.pixelRatio}`}}const gc=i.getLogger("esri.views.3d.webgl-engine.lib.OverlayRenderer");let wc=class extends(zn(n)){constructor(t){super(t),this._overlays=null,this._overlayRenderTarget=null,this._hasHighlights=!1,this._rendersOccluded=!1,this._hasWater=!1,this._lighting=new fc,this._handles=new m,this._frameTask=Ts,this._layerRenderers=new Map,this._sortedLayerRenderersDirty=!1,this._sortedLayerRenderers=new f,this._geometries=new Map,this.worldToPCSRatio=1,this.events=new v,this.longitudeCyclical=null}initialize(){const t=this.view._stage.renderView;this._rctx=t.renderingContext,this._renderContext=new qa(this._rctx);const e=t.waterTextureRepository;this._stippleTextureRepository=new mc(t.renderingContext),this._shaderTechniqueRepository=new Dn({rctx:this._rctx,viewingMode:2,stippleTextureRepository:this._stippleTextureRepository,waterTextureRepository:e}),this._handles.add([b(e,"loadingState",(()=>this.events.emit("content-changed"))),b(this,"spatialReference",(t=>this._localOrigins=new Ba(t)))]),this._materialRepository=new _n(t.textureRepository,this._shaderTechniqueRepository,(t=>{(t.renderOccluded&Pc)>0!==this._rendersOccluded&&this.updateRendersOccluded(),this.events.emit("content-changed"),this.notifyChange("updating")}),(()=>this.events.emit("content-changed"))),this._lighting.groundLightingFactor=1,this._lighting.globalFactor=0,this._lighting.set([new xr(st(1,1,1))]),this._bindParameters={slot:20,highlightDepthTexture:Ae(this._rctx),camera:Sc,inverseViewport:Mi(),origin:null,screenToWorldRatio:null,screenToPCSRatio:null,shadowMappingEnabled:!1,slicePlane:null,ssaoEnabled:!1,hasOccludees:!1,linearDepthTexture:null,lastFrameColorTexture:null,reprojectionMatrix:z,ssrEnabled:!1,lighting:this._lighting,transparencyPassType:3,terrainLinearDepthTexture:null,geometryLinearDepthTexture:null,multipassTerrainEnabled:!1,cullAboveGround:!1,multipassGeometryEnabled:!1,highlightColorTexture:null},this._frameTask=this.view.resourceController.scheduler.registerTask(_s.STAGE,this),this._handles.add(this._frameTask)}dispose(){this._handles.destroy(),this._layerRenderers.forEach((t=>t.dispose())),this._layerRenderers.clear(),this._debugTextureTechnique=C(this._debugTextureTechnique),this._debugPatternTexture=p(this._debugPatternTexture),this._bindParameters.highlightDepthTexture=p(this._bindParameters.highlightDepthTexture),this._shaderTechniqueRepository=p(this._shaderTechniqueRepository),this._temporaryFBO=p(this._temporaryFBO),this._quadVAO=p(this._quadVAO),this.disposeOverlays()}get updating(){return this._sortedLayerRenderersDirty||this._frameTask.updating||S(this._layerRenderers,(t=>t.updating))}get hasOverlays(){return t(this._overlays)&&t(this._overlayRenderTarget)}get gpuMemoryUsage(){return t(this._overlayRenderTarget)?this._overlayRenderTarget.gpuMemoryUsage:0}collectUnusedRenderTargetMemory(e){let i=!1;if(t(this._overlayRenderTarget))for(const t of this._overlayRenderTarget.renderTargets)i=this._overlayRenderTarget.validateUsageForTarget(this.overlays[0].validTargets[t.type]||!this.overlays[1].validTargets[t.type],t,e)||i;return i}get overlays(){return e(this._overlays,[])}ensureDrapeTargets(e){t(this._overlays)&&this._overlays.forEach((t=>{t.hasTargetWithoutRasterImage=D(e,(t=>1===t.drapeTargetType))}))}ensureDrapeSources(e){t(this._overlays)&&this._overlays.forEach((t=>{t.hasDrapedFeatureSource=S(e,((t,e)=>1===e.drapeSourceType)),t.hasDrapedRasterSource=S(e,((t,e)=>0===e.drapeSourceType))}))}ensureOverlays(t,e){l(this._overlays)&&(this._overlayRenderTarget=new yn(this._rctx),this._overlays=[new gn(0,this._overlayRenderTarget),new gn(1,this._overlayRenderTarget)]),this.ensureDrapeTargets(t),this.ensureDrapeSources(e)}disposeOverlays(){this._overlays=null,this._overlayRenderTarget=p(this._overlayRenderTarget),this.events.emit("textures-disposed")}get running(){return this.updating}runTask(t,e=(()=>!0)){this._frameTask.processQueue(t),t.done||this._processLayers(t,e)}_processLayers(e,i){let s=!1;for(const[t,r]of this._layerRenderers){if(e.done)break;i(t)&&(r.commitChanges()&&(s=!0,e.madeProgress()),r.isEmpty&&(s=!0,this._sortedLayerRenderersDirty=!0,this._layerRenderers.delete(t),this._handles.remove(t)))}this.updateSortedLayerRenderers(),s&&(t(this._overlays)&&0===this._layerRenderers.size&&this.disposeOverlays(),this.notifyChange("updating"),this.events.emit("content-changed"),this.updateHasHighlights(),this.updateRendersOccluded(),this.updateHasWater())}processSyncLayers(){this._processLayers(Es,(t=>1===t.updatePolicy))}addGeometries(t,e,i){for(const e of t)l(e.origin)&&(e.origin=this._localOrigins.getOrigin(e.boundingSphere)),this._geometries.set(e.id,e);this.ensureLayerRenderer(e).add(t),2===i&&this.notifyGraphicGeometryChanged(t,e)}removeGeometries(t,e,i){for(const e of t)this._geometries.delete(w(e.id));const s=this._layerRenderers.get(e);s&&(s.remove(t),2===i&&this.notifyGraphicGeometryChanged(t,e))}updateGeometries(t,e,i){const s=this._layerRenderers.get(e);if(s)switch(s.modify(t,i),i){case 4:case 2:return this.notifyGraphicGeometryChanged(t,e);case 1:return this.notifyGraphicVisibilityChanged(t,e)}else gc.warn("Attempted to update geometry for nonexistent layer")}notifyGraphicGeometryChanged(e,i){if(l(i.notifyGraphicGeometryChanged))return;let s;for(const r of e){const e=r.graphicUid;t(e)&&e!==s&&(i.notifyGraphicGeometryChanged(e),s=e)}}notifyGraphicVisibilityChanged(e,i){if(l(i.notifyGraphicVisibilityChanged))return;let s;for(const r of e){const e=r.graphicUid;t(e)&&e!==s&&(i.notifyGraphicVisibilityChanged(e),s=e)}}updateHighlights(t,e){const i=this._layerRenderers.get(e);i?i.modify(t,8):gc.warn("Attempted to update highlights for nonexistent layer")}isEmpty(){return 0===this._geometries.size&&!_r.OVERLAY_DRAW_DEBUG_TEXTURE}get hasHighlights(){return this._hasHighlights}get hasWater(){return this._hasWater}get rendersOccluded(){return this._rendersOccluded}updateLogic(t){let e=!1;return this._layerRenderers.forEach((i=>e=i.updateLogic(t)||e)),e}updateLayerOrder(){this._sortedLayerRenderersDirty=!0}drawTarget(e,i,s){const r=e.canvasGeometries;if(0===r.numViews)return!1;this._screenToWorldRatio=s*e.mapUnitsPerPixel;const o=i.renderPass;if(this.isEmpty()||5===o&&!this.hasHighlights||3===o&&!this.hasWater||!e.hasSomeSizedView())return!1;const n=i.fbo;if(!n.isValid())return!1;const a=2*e.resolution,l=e.resolution;n.resize(a,l);const c=this._rctx;Sc.pixelRatio=e.pixelRatio*s,this._renderContext.pass=o,this._bindParameters.screenToWorldRatio=this._screenToWorldRatio,this._bindParameters.screenToPCSRatio=this._screenToWorldRatio*this.worldToPCSRatio,this._bindParameters.slot=3===o?21:20,e.applyViewport(this._rctx),n.bind(c),0===e.index&&(c.setClearColor(0,0,0,0),c.clearSafe(16384));const h=1===i.type?2:4===i.type?1:0;if(1===h&&(this._renderContext.renderOccludedMask=Pc),_r.OVERLAY_DRAW_DEBUG_TEXTURE&&1!==h)for(let t=0;t<r.numViews;t++)this.setViewParameters(r.extents[t],e,Sc),this.drawDebugTexture(e.resolution,yc[e.index]);return this._layerRenderers.size>0&&this._sortedLayerRenderers.forAll((({layerView:i,renderer:s})=>{if(2===h&&t(i)&&0===i.drapeSourceType)return;const u=t(i)&&t(i.fullOpacity)&&i.fullOpacity<1&&0===o;u&&(this.bindTemporaryFramebuffer(this._rctx,a,l),c.clearSafe(16384));for(let t=0;t<r.numViews;t++)this.setViewParameters(r.extents[t],e,Sc),s.render(this._renderContext,this._bindParameters);u&&t(this._temporaryFBO)&&(n.bind(c),this.view._stage.renderView.compositingHelper.composite(this._temporaryFBO.getTexture(),2,w(w(i).fullOpacity),3,e.index))})),c.bindFramebuffer(null),n.generateMipMap(),this._renderContext.resetRenderOccludedMask(),!0}bindTemporaryFramebuffer(t,e,i){l(this._temporaryFBO)&&(this._temporaryFBO=new xn(t,!1)),this._temporaryFBO.resize(e,i),this._temporaryFBO.bind(t)}async reloadShaders(){await this._shaderTechniqueRepository.reloadAll()}intersect(t,e,i){let s=0;this._geometries.forEach((r=>{if(i&&!i(r))return;this.intersectRenderGeometry(r,e,0,t,s);const o=this.longitudeCyclical;o&&(r.boundingSphere[0]-r.boundingSphere[3]<o.min&&this.intersectRenderGeometry(r,e,o.range,t,s),r.boundingSphere[0]+r.boundingSphere[3]>o.max&&this.intersectRenderGeometry(r,e,-o.range,t,s)),s++}))}intersectRenderGeometry(e,i,s,r,o){if(!e.instanceParameters.visible)return;let n=0;t(e.transformation)&&(s+=e.transformation[12],n=e.transformation[13]),bc[0]=i[0]-s,bc[1]=i[1]-n,bc[2]=1,Cc[0]=i[0]-s,Cc[1]=i[1]-n,Cc[2]=0,e.screenToWorldRatio=this._screenToWorldRatio,e.material.intersect(e,null,e.getShaderTransformation(),r,bc,Cc,((t,i,s)=>{this.addIntersectionResult(s,e.material.renderPriority,o,r,e.layerUid,e.graphicUid)}),e.calculateShaderTransformation,!0)}addIntersectionResult(t,e,i,s,r,o){const n={type:"external",metadata:{layerUid:r,graphicUid:o}},a=r=>{r.set(n,null,s.results.ground.dist,s.results.ground.normal,s.results.ground.transformation,e,null,null,t,i),r.intersector="OverlayRenderer"};if((null==s.results.min.drapedLayerOrder||e>=s.results.min.drapedLayerOrder)&&(null==s.results.min.dist||s.results.ground.dist<=s.results.min.dist)&&a(s.results.min),0!==s.options.store&&(null==s.results.max.drapedLayerOrder||e<s.results.max.drapedLayerOrder)&&(null==s.results.max.dist||s.results.ground.dist>s.results.max.dist)&&a(s.results.max),2===s.options.store){const t=new wt(s.ray);a(t),s.results.all.push(t)}}ensureLayerRenderer(t){let e=this._layerRenderers.get(t);return e||(e=new ql({rctx:this._rctx,materialRepository:this._materialRepository}),this._layerRenderers.set(t,e),this._sortedLayerRenderersDirty=!0,"fullOpacity"in t&&this._handles.add(t.watch("fullOpacity",(()=>this.events.emit("content-changed"))),t),this._handles.add(b(e,"updating",(()=>this.notifyChange("updating"))),t)),e}updateSortedLayerRenderers(){if(!this._sortedLayerRenderersDirty)return;if(this._sortedLayerRenderersDirty=!1,this._sortedLayerRenderers.clear(),0===this._layerRenderers.size)return;const t=new Set(this._layerRenderers.values());this.view.allLayerViews.forEach((e=>{const i=e,s=this._layerRenderers.get(i);s&&(this._sortedLayerRenderers.push(new xc(i,s)),t.delete(s))})),t.forEach((t=>this._sortedLayerRenderers.push(new xc(null,t))))}setViewParameters(t,e,i){i.viewport[0]=i.viewport[1]=0,i.viewport[2]=i.viewport[3]=e.resolution,Si(i.projectionMatrix,0,t[2]-t[0],0,t[3]-t[1],i.near,i.far),bi(i.viewMatrix),Ci(i.viewMatrix,i.viewMatrix,[-t[0],-t[1],0]),this._renderContext.camera=i,this._bindParameters.camera=i,this._bindParameters.inverseViewport[0]=1/i.fullViewport[2],this._bindParameters.inverseViewport[1]=1/i.fullViewport[3]}updateHasWater(){const t=S(this._layerRenderers,(t=>t.hasWater));t!==this._hasWater&&(this._hasWater=t,this.events.emit("has-water",t))}updateHasHighlights(){const t=S(this._layerRenderers,(t=>t.hasHighlights));t!==this._hasHighlights&&(this._hasHighlights=t,this.events.emit("has-highlights",t))}updateRendersOccluded(){const t=S(this._layerRenderers,(t=>t.rendersOccluded));t!==this._rendersOccluded&&(this._rendersOccluded=t,this.events.emit("renders-occluded",t))}drawDebugTexture(t,e){const i=this._rctx;this.ensureDebugPatternResources(t,t);const s=this._debugTextureTechnique.program;i.useProgram(s),this._debugTextureTechnique.bindPipelineState(i),s.setUniform4f("color",e[0],e[1],e[2],1),s.bindTexture(this._debugPatternTexture,"tex"),i.bindVAO(this._quadVAO),i.drawArrays(5,0,xs(this._quadVAO,"geometry"))}ensureDebugPatternResources(t,e){if(this._debugPatternTexture)return;const i=new Uint8Array(t*e*4);let s=0;for(let r=0;r<e;r++)for(let o=0;o<t;o++){const n=Math.floor(o/10),a=Math.floor(r/10);n<2||a<2||10*n>t-20||10*a>e-20?(i[s++]=255,i[s++]=255,i[s++]=255,i[s++]=255):(i[s++]=255,i[s++]=255,i[s++]=255,i[s++]=1&n&&1&a?1&o^1&r?0:255:1&n^1&a?0:128)}this._debugPatternTexture=new ys(this._rctx,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,width:t,height:e},i);const r=new tc;r.hasAlpha=!0,this._debugTextureTechnique=this._shaderTechniqueRepository.acquire(Kl,r),this._quadVAO=Oe(this._rctx)}get test(){return{layerRenderers:this._layerRenderers}}};s([r()],wc.prototype,"_frameTask",void 0),s([r()],wc.prototype,"_sortedLayerRenderersDirty",void 0),s([(t,e)=>{var i,s;t.hasOwnProperty("_managedDisposables")||(t._managedDisposables=null!=(i=null==(s=t._managedDisposables)?void 0:s.slice())?i:[]),t._managedDisposables.unshift(e)}],wc.prototype,"_shaderTechniqueRepository",void 0),s([(t,e)=>{var i,s;t.hasOwnProperty("_managedDisposables")||(t._managedDisposables=null!=(i=null==(s=t._managedDisposables)?void 0:s.slice())?i:[]),t._managedDisposables.unshift(e)}],wc.prototype,"_stippleTextureRepository",void 0),s([r({constructOnly:!0})],wc.prototype,"view",void 0),s([r()],wc.prototype,"worldToPCSRatio",void 0),s([r()],wc.prototype,"spatialReference",void 0),s([r({type:Boolean,readOnly:!0})],wc.prototype,"updating",null),wc=s([o("esri.views.3d.terrain.OverlayRenderer")],wc);class xc{constructor(t,e){this.layerView=t,this.renderer=e}}const yc=[[1,.5,.5],[.5,.5,1]],Sc=new Dr;Sc.near=1,Sc.far=1e4,Sc.relativeElevation=null;const bc=it(),Cc=it(),Dc=-2,Pc=4,zc=1.2,Mc=Ri,Ac=Li;function Oc(t,e,i){switch(t){default:return Tc(e,i);case"square":return _c(e,i);case"cross":return jc(e,i);case"x":return Rc(e,i);case"kite":return Ec(e,i);case"triangle":return Fc(e,i)}}function Tc(t,e){const i=t,s=new Uint8Array(4*i*i),r=i/2-.5,o=e/2;for(let e=0;e<i;e++)for(let n=0;n<i;n++){const a=n+i*e,l=n-r,c=e-r;let h=Math.sqrt(l*l+c*c)-o;h=h/t+.5,hs(h,s,4*a)}return s}function _c(t,e){return Lc(t,e,!1)}function Ec(t,e){return Lc(t,e,!0)}function jc(t,e){return Nc(t,e,!1)}function Rc(t,e){return Nc(t,e,!0)}function Fc(t,e){const i=new Uint8Array(4*t*t),s=Math.sqrt(1.25),r=(t-e)/2;for(let o=0;o<t;o++)for(let n=0;n<t;n++){const a=o*t+n,l=(n-r)/e,c=(o-r+.75)/e,h=Math.max(-(1*l+-.5*c)/s,(1*(l-1)+-.5*-c)/s,-c);hs(h*e/t+.5,i,4*a)}return i}function Lc(t,e,i){i&&(e/=Math.SQRT2);const s=new Uint8Array(4*t*t);for(let r=0;r<t;r++)for(let o=0;o<t;o++){let n=o-.5*t+.25,a=.5*t-r-.75;const l=r*t+o;if(i){const t=(n+a)/Math.SQRT2;a=(a-n)/Math.SQRT2,n=t}let c=Math.max(Math.abs(n),Math.abs(a))-.5*e;c=c/t+.5,hs(c,s,4*l)}return s}function Nc(t,e,i){i&&(e*=Math.SQRT2);const s=.5*e,r=new Uint8Array(4*t*t);for(let e=0;e<t;e++)for(let o=0;o<t;o++){let n=o-.5*t,a=.5*t-e-1;const l=e*t+o;if(i){const t=(n+a)/Math.SQRT2;a=(a-n)/Math.SQRT2,n=t}let c;n=Math.abs(n),a=Math.abs(a),c=n>a?n>s?Math.sqrt((n-s)*(n-s)+a*a):a:a>s?Math.sqrt(n*n+(a-s)*(a-s)):n,c=c/t+.5,hs(c,r,4*l)}return r}class Vc{constructor(t,e,i=null,s=null,r=x(),o=null,n=null,a=!1){this.data=t,this.material=e,this.layerUid=i,this.graphicUid=s,this.id=r,this.boundingInfo=o,this.calculateShaderTransformation=n,this.castShadow=a,this.boundingSphere=ji(),this.instanceParameters={highlights:null,occludees:null,visible:!0},this._transformation=M(),this._shaderTransformationDirty=!0}get transformation(){return this._transformation}updateTransformation(t){t(this._transformation),this._shaderTransformationDirty=!0,this.computeBoundingSphere(this._transformation,this.boundingSphere)}shaderTransformationChanged(){this._shaderTransformationDirty=!0}computeBoundingSphere(t,e,i=us(t)){l(this.boundingInfo)||(j(e,this.boundingInfo.getCenter(),t),e[3]=this.boundingInfo.getBSRadius()*i)}get hasShaderTransformation(){return t(this.calculateShaderTransformation)}get primitiveType(){return this.data.primitiveType}getShaderTransformation(){return l(this.calculateShaderTransformation)?e(this.transformation,z):(this._shaderTransformationDirty&&(this._shaderTransformation||(this._shaderTransformation=M()),fi(this._shaderTransformation,this.calculateShaderTransformation(e(this.transformation,z))),this._shaderTransformationDirty=!1),this._shaderTransformation)}computeAttachmentOrigin(e){if(this.material.computeAttachmentOrigin)return!!this.material.computeAttachmentOrigin(this,e)&&(t(this._transformation)&&j(e,e,this._transformation),!0);const i=this.indices.get("position"),s=this.vertexAttributes.get("position");return!!Ke(s,i,e)&&(t(this._transformation)&&j(e,e,this._transformation),!0)}get indices(){return this.data.indices}get vertexAttributes(){return this.data.vertexAttributes}addHighlight(){const t=new yt(0),e=this.instanceParameters;return e.highlights=Fe(e.highlights,t),t}removeHighlight(t){const e=this.instanceParameters;e.highlights=Le(e.highlights,t)}}function Ic(i){const s=[],r=[];!function(t,e,i){const{attributeData:{position:s},removeDuplicateStartEnd:r}=t,o=function(t){const e=t.length;return t[0]===t[e-3]&&t[1]===t[e-2]&&t[2]===t[e-1]}(s)&&1===r,n=s.length/3-(o?1:0),a=new Uint32Array(2*(n-1)),l=o?P(s,0,s.length-3):s;let c=0;for(let t=0;t<n-1;t++)a[c++]=t,a[c++]=t+1;e.push(["position",{size:3,data:l,exclusive:o}]),i.push(["position",a])}(i,r,s);const o=r[0][1].data,n=new Uint16Array(s[0][1].length);return function(t,e,i){const s=t.attributeData.mapPosition;l(s)||(i.push(["mapPos",i[0][1]]),e.push(["mapPos",{size:3,data:s}]))}(i,r,s),function(i,s,r,o){t(i.attributeData.colorFeature)||(s.push(["color",{size:4,data:e(i.attributeData.color,Ac)}]),r.push(["color",o]))}(i,r,s,n),function(i,s,r,o){t(i.attributeData.sizeFeature)||(s.push(["size",{size:1,data:[e(i.attributeData.size,1)]}]),r.push(["size",o]))}(i,r,s,n),function(t,e,i,s){const r=t.attributeData.colorFeature;l(r)||(e.push(["colorFeatureAttribute",{size:1,data:new Float32Array([r])}]),i.push(["color",s]))}(i,r,s,n),function(t,e,i,s){const r=t.attributeData.sizeFeature;l(r)||(e.push(["sizeFeatureAttribute",{size:1,data:new Float32Array([r])}]),i.push(["sizeFeatureAttribute",s]))}(i,r,s,n),function(t,e,i,s){const r=t.attributeData.opacityFeature;l(r)||(e.push(["opacityFeatureAttribute",{size:1,data:new Float32Array([r])}]),i.push(["opacityFeatureAttribute",s]))}(i,r,s,n),function(t,i,s,r){if("round"!==t.join)return;const o=r.length/3,n=new Float32Array(o),a=$c,l=Bc;E(a,0,0,0);const c=e(t.uniformSize,1);for(let t=-1;t<o;++t){const e=t<0?o+t:t,i=(t+1)%o;if(E(l,r[3*i+0]-r[3*e+0],r[3*i+1]-r[3*e+1],r[3*i+2]-r[3*e+2]),L(l,l),t>=0){const e=(Math.PI-et(N(a,l)))*kc*1*Gc(c);n[t]=Math.max(Math.floor(e),0)}T(a,l,-1)}i.push(["subdivisions",{size:1,data:n}]),s.push(["subdivisions",s[0][1]])}(i,r,s,o),new Dt(r,s,2)}function Wc(t,e,i,s){const r="polygon"===t.type?1:0,o="polygon"===t.type?t.rings:t.paths,{position:n,outlines:a}=ps(o,t.hasZ,r),l=new Float64Array(n.length),c=Wo(n,t.spatialReference,0,l,0,n,0,n.length/3,e,i,s),h=null!=c;return{lines:h?Uc(a,n,l):[],projectionSuccess:h,sampledElevation:c}}function Uc(t,e,i){const s=new Array;for(const{index:r,count:o}of t){if(o<=1)continue;const t=3*r,n=t+3*o;s.push({position:e.subarray(t,n),mapPosition:i?i.subarray(t,n):void 0})}return s}function Hc(t,e){const i="polygon"===t.type?1:0,s="polygon"===t.type?t.rings:t.paths,{position:r,outlines:o}=ps(s,!1,i),n=ts(r,t.spatialReference,0,r,e,0,r.length/3);for(let t=2;t<r.length;t+=3)r[t]=-2;return{lines:n?Uc(o,r):[],projectionSuccess:n}}function Gc(t){return 1.863798+-2.0062872/(1+t/18.2313)**.8856294}const $c=it(),Bc=it(),kc=4/Math.PI;function Zc(t){switch(t){case"butt":return 0;case"square":return 1;case"round":return 2;default:return null}}const qc={dash:[4,3],dot:[1,3],"long-dash":[8,3],"short-dash":[4,1],"short-dot":[1,1]},Qc={dash:qc.dash,"dash-dot":[...qc.dash,...qc.dot],dot:qc.dot,"long-dash":qc["long-dash"],"long-dash-dot":[...qc["long-dash"],...qc.dot],"long-dash-dot-dot":[...qc["long-dash"],...qc.dot,...qc.dot],none:null,"short-dash":qc["short-dash"],"short-dash-dot":[...qc["short-dash"],...qc["short-dot"]],"short-dash-dot-dot":[...qc["short-dash"],...qc["short-dot"],...qc["short-dot"]],"short-dot":qc["short-dot"],solid:null};function Jc(t,e=2){return{pattern:[t,t],pixelRatio:e}}function Yc(e){return t(e)&&"style"===e.type?function(t,e=2){return l(t)?t:{pattern:t.slice(),pixelRatio:e}}(Qc[e.style],8):null}function Xc(t){const e=new At;e.include(be,{linearDepth:!1}),e.include(Te,t),e.include(ca,t),e.vertex.uniforms.add("proj","mat4").add("view","mat4"),e.attributes.add("position","vec3"),e.varyings.add("vpos","vec3");const i=_r.ENABLE_CONTINUOUS_LINE_PATTERNS;return e.vertex.code.add(Ct`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),t.stippleEnabled&&(e.attributes.add("auxpos1","vec3"),e.vertex.uniforms.add("ndcToPixel","vec2"),e.vertex.code.add(Ct`vec4 vpos2 = transformPosition(proj, view, auxpos1);
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`),i?(e.attributes.add("uv0","vec2"),t.draped||e.vertex.code.add(Ct`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),e.vertex.code.add(Ct`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);
float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;
vStippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
stippleDistance = mix(vStippleDistanceLimits.x, vStippleDistanceLimits.y, uv0.x);
vStippleDistanceLimits *= gl_Position.w;`)):e.vertex.code.add(Ct`
      stippleDistance = lineSegmentPixelSize * stipplePatternPixelSizeInv;
      ${t.stippleIntegerRepeatsEnabled?"stippleDistance = floor(stippleDistance + 0.5);":""}
      `),e.vertex.code.add(Ct`stippleDistance *= gl_Position.w;`)),e.vertex.code.add(Ct`}`),4===t.output&&e.include(Rt),e.include(Ot,t),e.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),e.fragment.code.add(Ct`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${t.attributeColor?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${Ct.float(Et)}) {
      discard;
    }

    ${0===t.output?Ct`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${4===t.output?Ct`outputHighlight();`:""}
  }
  `),e}const Kc=Object.freeze({__proto__:null,build:Xc});class th extends Nt{constructor(t,e,i){super(t,e,i),this.stipplePattern=null,this.stippleTextureBind=null,this.stippleTextureRepository=t.stippleTextureRepository}initializeProgram(t){const e=th.shader.get(),i=this.configuration,s=e.build({output:i.output,attributeColor:i.vertexColors,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,draped:i.draped,stippleEnabled:i.stippleEnabled,stippleOffColorEnabled:i.stippleOffColorEnabled,stippleDistanceMaxEnabled:!1,stippleIntegerRepeatsEnabled:i.stippleIntegerRepeatsEnabled,scaleStippleWithLineWidth:!1});return new Vt(t.rctx,s,It)}dispose(){super.dispose(),this.stippleTextureRepository.release(this.stipplePattern),this.stipplePattern=null,this.stippleTextureBind=null}bindPass(e,i){if(Wt(this.program,i.camera.projectionMatrix),this.stipplePattern!==e.stipplePattern){const t=e.stipplePattern;this.stippleTextureBind=this.stippleTextureRepository.swap(this.stipplePattern,t),this.stipplePattern=t}if(this.configuration.stippleEnabled){const{pixelSize:e,sdfNormalizer:s,pixels:r}=t(this.stippleTextureBind)?this.stippleTextureBind(this.program):{pixelSize:1,sdfNormalizer:1,pixels:1};this.program.setUniform1f("stipplePatternSDFNormalizer",s),this.program.setUniform1f("stipplePatternTextureSize",r),_r.ENABLE_CONTINUOUS_LINE_PATTERNS?(this.program.setUniform1f("stipplePatternPixelSize",e),this.program.setUniform1f("stipplePatternPixelSizeInv",1/e),this.configuration.draped?this.program.setUniform1f("worldToScreenRatio",1/i.screenToWorldRatio):(this.program.setUniform1f("worldToScreenPerDistanceRatio",1/i.camera.perScreenPixelRatio),this.program.setUniform1f("cameraDistanceToSurface",i.camera.distanceFromSurface))):this.program.setUniform1f("stipplePatternPixelSizeInv",1/(e*i.camera.pixelRatio)),this.program.setUniform2f("ndcToPixel",i.camera.fullViewport[2]/2,i.camera.fullViewport[3]/2)}if(this.program.setUniform4fv("constantColor",e.color),this.program.setUniform1f("alphaCoverage",Math.min(1,e.width*i.camera.pixelRatio)),this.configuration.stippleOffColorEnabled){const t=w(e.stippleOffColor);this.program.setUniform4f("stippleOffColor",t[0],t[1],t[2],t.length>3?t[3]:1)}4===this.configuration.output&&kt(this.program,i)}bindDraw(t){Zt(this.program,t),this.configuration.stippleEnabled&&_r.ENABLE_CONTINUOUS_LINE_PATTERNS&&!this.configuration.draped&&qt(this.program,t.origin,t.camera.viewInverseTransposeMatrix),Qt(this.program,this.configuration,t),this.program.rebindTextures()}initializePipeline(){const t=this.configuration,e=qi(770,1,771,771),i=(e,i=null,s=null)=>Ni({blending:i,depthTest:xe,depthWrite:s,colorWrite:Ii,stencilWrite:t.sceneHasOcludees?pe:null,stencilTest:t.sceneHasOcludees?e?de:fe:null});return 0===t.output?(this._occludeePipelineState=i(!0,t.transparent||t.stippleEnabled?e:null,Ui),i(!1,t.transparent||t.stippleEnabled?e:null,Ui)):i(!1)}get primitiveType(){return 1}getPipelineState(t,e){return e?this._occludeePipelineState:super.getPipelineState(t,e)}}th.shader=new Jt(Kc,(()=>import("./p-e0ba34c7.js")));class eh extends Lt{constructor(){super(...arguments),this.output=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.draped=!1,this.stippleEnabled=!1,this.stippleOffColorEnabled=!1,this.stippleIntegerRepeatsEnabled=!1,this.sceneHasOcludees=!1}}s([Ft({count:8})],eh.prototype,"output",void 0),s([Ft()],eh.prototype,"slicePlaneEnabled",void 0),s([Ft()],eh.prototype,"vertexColors",void 0),s([Ft()],eh.prototype,"transparent",void 0),s([Ft()],eh.prototype,"draped",void 0),s([Ft()],eh.prototype,"stippleEnabled",void 0),s([Ft()],eh.prototype,"stippleOffColorEnabled",void 0),s([Ft()],eh.prototype,"stippleIntegerRepeatsEnabled",void 0),s([Ft()],eh.prototype,"sceneHasOcludees",void 0);const ih=i.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");class sh extends Yt{constructor(t){super(t,nh),this._techniqueConfig=new eh}getTechniqueConfig(e,i){this._techniqueConfig.output=e,this._techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this._techniqueConfig.vertexColors=this.parameters.vertexColors,this._techniqueConfig.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._techniqueConfig.draped=20===i.slot;const s=t(this.parameters.stipplePattern);return this._techniqueConfig.stippleEnabled=s,this._techniqueConfig.stippleOffColorEnabled=s&&t(this.parameters.stippleOffColor),this._techniqueConfig.stippleIntegerRepeatsEnabled=s&&this.parameters.stippleIntegerRepeats,this._techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,this._techniqueConfig}getPassParameters(){return this.parameters}intersect(t,e,i,s,r,o,n,a,l){l?_e(t,s,o,1,n):this.intersectLineGeometry(t,e,i,s,n)}intersectLineGeometry(t,e,i,s,r){if(!s.options.selectionMode||Ee(e))return;if(!ni(i))return void ih.error("intersection assumes a translation-only matrix");const o=t.vertexAttributes.get("position").data,n=s.camera,a=gh;Di(a,s.point),E(wh[0],a[0]-2,a[1]+2,0),E(wh[1],a[0]+2,a[1]+2,0),E(wh[2],a[0]+2,a[1]-2,0),E(wh[3],a[0]-2,a[1]-2,0);for(let t=0;t<4;t++)if(!n.unprojectFromRenderScreen(wh[t],xh[t]))return;He(n.eye,xh[0],xh[1],yh),He(n.eye,xh[1],xh[2],Sh),He(n.eye,xh[2],xh[3],bh),He(n.eye,xh[3],xh[0],Ch);let l=Number.MAX_VALUE;for(let t=0;t<o.length-5;t+=3){if(ah[0]=o[t]+i[12],ah[1]=o[t+1]+i[13],ah[2]=o[t+2]+i[14],lh[0]=o[t+3]+i[12],lh[1]=o[t+4]+i[13],lh[2]=o[t+5]+i[14],$e(yh,ah)<0&&$e(yh,lh)<0||$e(Sh,ah)<0&&$e(Sh,lh)<0||$e(bh,ah)<0&&$e(bh,lh)<0||$e(Ch,ah)<0&&$e(Ch,lh)<0)continue;if(n.projectToRenderScreen(ah,uh),n.projectToRenderScreen(lh,ph),uh[2]<0&&ph[2]>0){R(ch,ah,lh);const t=n.frustum,e=-$e(t[4],ah)/N(ch,Qe(t[4]));T(ch,ch,e),O(ah,ah,ch),n.projectToRenderScreen(ah,uh)}else if(uh[2]>0&&ph[2]<0){R(ch,lh,ah);const t=n.frustum,e=-$e(t[4],lh)/N(ch,Qe(t[4]));T(ch,ch,e),O(lh,lh,ch),n.projectToRenderScreen(lh,ph)}else if(uh[2]<0&&ph[2]<0)continue;uh[2]=0,ph[2]=0;const e=Ds(Ps(uh,ph,vh),a);e<l&&(l=e,V(dh,ah),V(fh,lh))}const c=s.rayBeginPoint,h=s.rayEndPoint;if(l<4){let t=Number.MAX_VALUE;if(zs(Ps(dh,fh,vh),Ps(c,h,mh),hh)){R(hh,hh,c);const e=A(hh);T(hh,hh,1/e),t=e/W(c,h)}r(t,hh)}}computeAttachmentOrigin(t,e){const i=t.vertexAttributes;if(!i)return!1;const s=i.get("position");return Xe(s,null,!1,e)}requiresSlot(t){return 2===t||20===t}createGLMaterial(t){return 0===t.output||4===t.output?new rh(t):null}createBufferWriter(){const t=this.parameters.vertexColors?wl:ml;return l(this.parameters.stipplePattern)?new xl(t):new oh(t.clone().vec3f("auxpos1").vec2f("uv0"))}}class rh extends ye{updateParameters(t){return this.ensureTechnique(th,t)}_updateOccludeeState(t){t.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:t.hasOccludees})}beginSlot(t){return 0===this._output&&this._updateOccludeeState(t),this.updateParameters(t)}bind(t,e){e.bindPass(this._material.getPassParameters(),t)}}class oh{constructor(t){this.vertexBufferLayout=t}allocate(t){return this.vertexBufferLayout.createBuffer(t)}elementCount(t){return t.indices.get("position").length}write(t,e,i,s){ze(e,this.vertexBufferLayout,t.transformation,t.invTranspTransformation,i,s),this.writeAuxpos1(t,e,i,s),this.writeUV0(t,e,i,s)}writeAuxpos1(t,e,i,s){const r=i.getField("auxpos1",js),o=e.indices.get("position"),n=e.vertexAttributes.get("position").data,a=t.transformation,l=r.typedBufferStride,c=r.typedBuffer;s*=l;const h=_r.ENABLE_CONTINUOUS_LINE_PATTERNS?[1,0]:[0,0];for(let t=0;t<o.length-1;t+=2)for(const e of h){const i=3*o[t+e],r=n[i],h=n[i+1],u=n[i+2],p=a[1]*r+a[5]*h+a[9]*u+a[13],d=a[2]*r+a[6]*h+a[10]*u+a[14];c[s]=a[0]*r+a[4]*h+a[8]*u+a[12],c[s+1]=p,c[s+2]=d,s+=l}}writeUV0(t,e,i,s){const r=i.getField("uv0",Rs),o=e.indices.get("position"),n=e.vertexAttributes.get("position").data,a=t.transformation,l=r.typedBufferStride,c=r.typedBuffer;let h=0;c[s*=l]=0,c[s+1]=h,s+=l;const u=3*o[0],p=E(ah,n[u],n[u+1],n[u+2]);a&&j(p,p,a);const d=lh,f=o.length-1;for(let t=1;t<f;t+=2){const e=3*o[t];E(d,n[e],n[e+1],n[e+2]),a&&j(d,d,a),h+=W(p,d);for(let t=0;t<2;++t)c[s]=1-t,c[s+1]=h,s+=l;V(p,d)}const v=3*o[f];E(d,n[v],n[v+1],n[v+2]),a&&j(d,d,a),h+=W(p,d),c[s]=1,c[s+1]=h}}const nh={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleIntegerRepeats:!1,stippleOffColor:null,sceneHasOcludees:!1,...ee},ah=it(),lh=it(),ch=it(),hh=it(),uh=ci(),ph=ci(),dh=it(),fh=it(),vh=Ms(),mh=Ms(),gh=it(),wh=[ci(),ci(),ci(),ci()],xh=[it(),it(),it(),it()],yh=We(),Sh=We(),bh=We(),Ch=We();function Dh(t){const e=new At,i=1===t.output;return e.include(be,{linearDepth:i}),e.include(Te,t),e.vertex.uniforms.add("proj","mat4").add("view","mat4"),e.attributes.add("position","vec3"),e.varyings.add("vpos","vec3"),t.multipassTerrainEnabled&&e.varyings.add("depth","float"),i&&(e.include(ce,t),e.vertex.uniforms.add("cameraNearFar","vec2"),e.varyings.add("linearDepth","float")),e.vertex.code.add(Ct`
    void main(void) {
      vpos = position;
      forwardNormalizedVertexColor();
      ${t.multipassTerrainEnabled?"depth = (view * vec4(vpos, 1.0)).z;":""}
      gl_Position = ${i?Ct`transformPositionWithDepth(proj, view, vpos, cameraNearFar, linearDepth);`:Ct`transformPosition(proj, view, vpos);`}
    }
  `),e.include(Ot,t),e.fragment.include(Tt),t.multipassTerrainEnabled&&(e.fragment.include(zt),e.include(he,t)),e.fragment.uniforms.add("eColor","vec4"),4===t.output&&e.include(Rt),e.fragment.code.add(Ct`
  void main() {
    discardBySlice(vpos);
    ${t.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
    vec4 color = ${t.attributeColor?"vColor * eColor;":"eColor;"}

    if (color.a < ${Ct.float(Et)}) {
      discard;
    }

    ${7===t.output?Ct`gl_FragColor = vec4(color.a);`:""}

    ${0===t.output?Ct`gl_FragColor = highlightSlice(color, vpos); ${t.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    ${4===t.output?Ct`outputHighlight();`:""};
    ${1===t.output?Ct`outputDepth(linearDepth);`:""};
  }
  `),e}const Ph=Object.freeze({__proto__:null,build:Dh});class zh extends Nt{initializeProgram(t){const e=zh.shader.get(),i=this.configuration,s=e.build({output:i.output,OITEnabled:0===i.transparencyPassType,attributeColor:i.vertexColors,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new Vt(t.rctx,s,It)}bindPass(t,e){Wt(this.program,e.camera.projectionMatrix),this.program.setUniform4fv("eColor",t.color),4===this.configuration.output&&kt(this.program,e),(1===this.configuration.output||e.multipassTerrainEnabled)&&this.program.setUniform2fv("cameraNearFar",e.camera.nearFar),e.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",e.inverseViewport),$t(this.program,e))}bindDraw(t){Zt(this.program,t),this.program.rebindTextures(),Qt(this.program,this.configuration,t)}createPipeline(t,e){const i=this.configuration,s=3===t,r=2===t;return Ni({blending:0!==i.output&&7!==i.output||!i.transparent?null:s?Hi:Vi(t),culling:Qi(i.cullFace),depthTest:{func:Gi(t)},depthWrite:s||r?i.writeDepth&&Ui:null,colorWrite:Ii,stencilWrite:i.sceneHasOcludees?pe:null,stencilTest:i.sceneHasOcludees?e?de:fe:null,polygonOffset:s||r?i.polygonOffset&&Mh:ki(i.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this.createPipeline(this.configuration.transparencyPassType,!0),this.createPipeline(this.configuration.transparencyPassType,!1)}getPipelineState(t,e){return e?this._occludeePipelineState:super.getPipelineState(t,e)}}zh.shader=new Jt(Ph,(()=>import("./p-4c737b1c.js")));const Mh={factor:1,units:1};class Ah extends Lt{constructor(){super(...arguments),this.output=0,this.cullFace=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.transparent=!1,this.polygonOffset=!1,this.enableOffset=!0,this.writeDepth=!0,this.sceneHasOcludees=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}s([Ft({count:8})],Ah.prototype,"output",void 0),s([Ft({count:3})],Ah.prototype,"cullFace",void 0),s([Ft()],Ah.prototype,"slicePlaneEnabled",void 0),s([Ft()],Ah.prototype,"vertexColors",void 0),s([Ft()],Ah.prototype,"transparent",void 0),s([Ft()],Ah.prototype,"polygonOffset",void 0),s([Ft()],Ah.prototype,"enableOffset",void 0),s([Ft()],Ah.prototype,"writeDepth",void 0),s([Ft()],Ah.prototype,"sceneHasOcludees",void 0),s([Ft({count:4})],Ah.prototype,"transparencyPassType",void 0),s([Ft()],Ah.prototype,"multipassTerrainEnabled",void 0),s([Ft()],Ah.prototype,"cullAboveGround",void 0);class Oh extends Yt{constructor(t){super(t,_h),this.supportsEdges=!0,this.techniqueConfig=new Ah}getTechniqueConfig(t,e){return this.techniqueConfig.output=t,this.techniqueConfig.cullFace=this.parameters.cullFace,this.techniqueConfig.vertexColors=this.parameters.vertexColors,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.polygonOffset=this.parameters.polygonOffset,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,this.techniqueConfig.transparencyPassType=e.transparencyPassType,this.techniqueConfig.enableOffset=e.camera.relativeElevation<Zi,this.techniqueConfig.multipassTerrainEnabled=e.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=e.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.parameters}intersect(t,e,i,s,r,o,n){Me(t,e,s,r,o,void 0,n)}requiresSlot(t,e){return 20===t||(4===jr(e)?2===t:t===(this.parameters.transparent?this.parameters.writeDepth?4:7:2))}createGLMaterial(t){return 0===t.output||7===t.output||4===t.output||1===t.output&&this.parameters.writeLinearDepth?new Th(t):null}createBufferWriter(){return new xl(wl)}}class Th extends ye{updateParameters(t){return this.ensureTechnique(zh,t)}_updateOccludeeState(t){t.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:t.hasOccludees})}beginSlot(t){return 0!==this._output&&7!==this._output||this._updateOccludeeState(t),this.updateParameters(t)}bind(t,e){e.bindPass(this._material.getPassParameters(),t)}}const _h={color:[1,1,1,1],transparent:!1,writeDepth:!0,writeLinearDepth:!1,vertexColors:!1,polygonOffset:!1,slicePlaneEnabled:!1,cullFace:0,sceneHasOcludees:!1,...ee};export{rn as $,Js as A,An as B,Xs as C,Jl as D,fc as E,Qa as F,tl as G,Kl as H,_r as I,Dr as J,wc as K,tc as L,zn as M,mc as N,Bs as O,gr as P,Dn as Q,ks as R,Hs as S,_n as T,Ya as U,Uo as V,qr as W,_o as X,Zo as Y,or as Z,Ll as _,xr as a,jo as a$,Vo as a0,cn as a1,Eo as a2,qo as a3,nn as a4,Rr as a5,Lr as a6,Fr as a7,Nr as a8,Mo as a9,Er as aA,Ro as aB,No as aC,aa as aD,Lo as aE,Ho as aF,jr as aG,xl as aH,Oh as aI,bl as aJ,yl as aK,Sl as aL,Ls as aM,Zs as aN,Ns as aO,Vs as aP,Fs as aQ,Oc as aR,Jc as aS,fn as aT,zo as aU,bo as aV,gl as aW,To as aX,zc as aY,en as aZ,on as a_,$o as aa,un as ab,pn as ac,Go as ad,sn as ae,Wo as af,Dc as ag,Fo as ah,Bo as ai,Mc as aj,Io as ak,dn as al,Fc as am,Rc as an,jc as ao,Ec as ap,_c as aq,Tc as ar,Zc as as,Yc as at,ga as au,Wc as av,Ic as aw,Hc as ax,sh as ay,jn as az,yr as b,tn as b0,Wr as b1,Ir as b2,Ur as b3,Yl as b4,ha as b5,ul as b6,Xc as b7,Dh as b8,wr as c,So as d,lr as e,Ws as f,Us as g,mn as h,ar as i,wn as j,hl as k,cl as l,ol as m,ra as n,Sr as o,Ba as p,qs as q,oa as r,Pc as s,rr as t,Vc as u,Mn as v,Gs as w,$s as x,sr as y,Qs as z}