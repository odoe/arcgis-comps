import{aE as t,bw as s,A as i,r as h,C as e,af as r,V as n,E as o}from"./p-e58503d5.js";import{m as a,v as u}from"./p-b79fcce3.js";import{_ as c,d as l,a as d,o as p,v as m,j as f,L as v,B as y}from"./p-e6fe5d89.js";import{n as w,t as g,e as V}from"./p-746a9d8f.js";import{y as x,q as T,r as P,N as M,B as _,H as D,z as Z,v as b,_ as A,a as j,u as R,d as X,G as z,M as C}from"./p-2f398ed1.js";import{r as E,n as N,e as B}from"./p-d3105731.js";import{n as Y,r as k,e as O}from"./p-4d38e149.js";import{p as q,v as G,R as I,b as L,C as S,W as U}from"./p-dcdb33cf.js";import{e as F,f as H}from"./p-95909347.js";import{M as J}from"./p-f16641e7.js";class K{constructor(t){this.spatialReference=t}createVector(){return this.tag(w())}pointToVector(t){return this.tag(g(t.x,t.y))}arrayToVector(t){return this.tag(g(t[0],t[1]))}vectorToArray(t){return[t[0],t[1]]}pointToArray(t){return[t.x,t.y]}vectorToPoint(s,i=new t){return i.x=s[0],i.y=s[1],i.z=void 0,i.m=void 0,i.spatialReference=this.spatialReference,i}arrayToPoint(s,i=new t){return i.x=s[0],i.y=s[1],i.z=void 0,i.m=void 0,i.spatialReference=this.spatialReference,i}vectorToDehydratedPoint(t,s={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}){return s.x=t[0],s.y=t[1],s.z=void 0,s.m=void 0,s.hasZ=!1,s.hasM=!1,s.spatialReference=this.spatialReference,s}lerp(t,s,i,h){return c(h,t,s,i)}addDelta(t,s,i){t[0]+=s,t[1]+=i}distance(t,s){return l(t,s)}getZ(t,s){return s}hasZ(){return!1}getM(t,s){return s}hasM(){return!1}clone(t){return this.tag(V(t))}copy(t,s){return d(s,t)}fromXYZ(t){return this.tag(g(t[0],t[1]))}toXYZ(t,s=0){return E(t[0],t[1],s)}tag(t){return t}}class Q{constructor(t,s){this.valueType=t,this.spatialReference=s}createVector(){return this.tag(N())}pointToVector(t){return this.tag(E(t.x,t.y,0===this.valueType?t.z:t.m))}arrayToVector(t){return this.tag(E(t[0],t[1],t[2]||0))}vectorToArray(t){return[t[0],t[1],t[2]]}pointToArray(t){return 0===this.valueType?[t.x,t.y,t.z]:[t.x,t.y,t.m]}vectorToPoint(s,i=new t){return i.x=s[0],i.y=s[1],i.z=0===this.valueType?s[2]:void 0,i.m=1===this.valueType?s[2]:void 0,i.spatialReference=this.spatialReference,i}arrayToPoint(s,i=new t){return i.x=s[0],i.y=s[1],i.z=0===this.valueType?s[2]:void 0,i.m=1===this.valueType?s[2]:void 0,i.spatialReference=this.spatialReference,i}vectorToDehydratedPoint(t,s={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}){const i=0===this.valueType,h=1===this.valueType;return s.x=t[0],s.y=t[1],s.z=i?t[2]:void 0,s.m=h?t[2]:void 0,s.hasZ=i,s.hasM=h,s.spatialReference=this.spatialReference,s}lerp(t,s,i,h){return x(h,t,s,i)}addDelta(t,s,i,h){t[0]+=s,t[1]+=i,0===this.valueType&&(t[2]+=h)}distance(t,s){return 0===this.valueType?T(t,s):l(t,s)}getZ(t,s){return 0===this.valueType?t[2]:s}hasZ(){return 0===this.valueType}getM(t,s){return 1===this.valueType?t[2]:s}hasM(){return 1===this.valueType}clone(t){return this.tag(B(t))}copy(t,s){return P(s,t)}fromXYZ(t,s=0,i=0){return this.tag(E(t[0],t[1],0===this.valueType?t.length>2?t[2]:s:i))}toXYZ(t,s=0){return this.tag(E(t[0],t[1],0===this.valueType?t[2]:s))}tag(t){return t}}class W{constructor(t){this.spatialReference=t}createVector(){return this.tag(Y())}pointToVector(t){return this.tag(k(t.x,t.y,t.z,t.m))}arrayToVector(t){return this.tag(k(t[0],t[1],t[2]||0,t[3]||0))}vectorToArray(t){return[t[0],t[1],t[2],t[3]]}pointToArray(t){return[t.x,t.y,t.z,t.m]}vectorToPoint(s,i=new t){return i.x=s[0],i.y=s[1],i.z=s[2],i.m=s[3],i.spatialReference=this.spatialReference,i}arrayToPoint(s,i=new t){return i.x=s[0],i.y=s[1],i.z=s[2],i.m=s[3],i.spatialReference=this.spatialReference,i}vectorToDehydratedPoint(t,s={x:void 0,y:void 0,z:void 0,m:void 0,hasZ:void 0,hasM:void 0,spatialReference:void 0,type:"point"}){return s.x=t[0],s.y=t[1],s.z=t[2],s.m=t[3],s.hasZ=!0,s.hasM=!0,s.spatialReference=this.spatialReference,s}lerp(t,s,i,h){return M(h,t,s,i)}addDelta(t,s,i,h){t[0]+=s,t[1]+=i,t[2]+=h}distance(t,s){return T(t,s)}getZ(t){return t[2]}hasZ(){return!0}getM(t){return t[3]}hasM(){return!0}clone(t){return this.tag(O(t))}copy(t,s){return _(s,t)}fromXYZ(t,s=0,i=0){return this.tag(k(t[0],t[1],t.length>2?t[2]:s,i))}toXYZ(t){return E(t[0],t[1],t[2])}tag(t){return t}}function $(t,s,i){return t&&s?new W(i):s?new Q(1,i):t?new Q(0,i):new K(i)}class tt{constructor(t){this.component=t,this.leftEdge=null,this.rightEdge=null,this.type="vertex",this.index=null}get pos(){return this._pos}set pos(t){this._pos=t,this.component.unnormalizeVertexPositions()}}class st{constructor(t,s,i){this.component=t,this.leftVertex=s,this.rightVertex=i,this.type="edge",s.rightEdge=this,i.leftEdge=this}}class it{constructor(t,s){this.spatialReference=t,this.viewingMode=s,this.vertices=[],this.edges=[]}unnormalizeVertexPositions(){this.vertices.length<=1||function(t,s){if(!s.supported)return;let i=1/0,h=-1/0;const e=s.upperBoundX-s.lowerBoundX;t.forEach((t=>{let r=t.pos[0];for(;r<s.lowerBoundX;)r+=e;for(;r>s.upperBoundX;)r-=e;i=Math.min(i,r),h=Math.max(h,r),t.pos[0]=r}));const r=h-i;e-r<r&&t.forEach((t=>{t.pos[0]<0&&(t.pos[0]+=e)}))}(this.vertices,function(t,i){const h=s(t);return 1===i&&h?{supported:!0,lowerBoundX:h.valid[0],upperBoundX:h.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}(this.spatialReference,this.viewingMode))}updateVertexIndex(t,s){if(0===this.vertices.length)return;const i=this.vertices[0];let h=null,e=t,r=s;do{h=e,h.index=r++,e=h.rightEdge?h.rightEdge.rightVertex:null}while(null!=e&&e!==i);h.leftEdge&&h!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(h),this.vertices.length-1)}getFirstVertex(){return 0===this.vertices.length?null:this.vertices[0]}getLastVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].leftEdge}swapVertices(t,s){const i=this.vertices[t];this.vertices[t]=this.vertices[s],this.vertices[s]=i}iterateVertices(t){if(0===this.vertices.length)return;const s=this.vertices[0];let h=s;do{t(h,h.index),h=i(h.rightEdge)?h.rightEdge.rightVertex:null}while(h!==s&&null!=h)}}class ht extends h{constructor(t,s,i){super(),this.type=t,this.coordinateHelper=s,this.viewingMode=i,this._geometry=null,this.dirty=!0,this.components=[]}get geometry(){if(this.dirty){switch(this.type){case"point":this._geometry=this.toPoint();break;case"polyline":this._geometry=this.toPolyline();break;case"polygon":this._geometry=this.toPolygon()}this.dirty=!1}return this._geometry}get spatialReference(){return this.coordinateHelper.spatialReference}notifyChanges(t){this.dirty=!0,this.emit("change",t)}toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.vectorToPoint(this.components[0].vertices[0].pos)}toPolyline(){const t=[],s=this.coordinateHelper.vectorToArray;return this.components.forEach((i=>{const h=[];let e=i.vertices.find((t=>null==t.leftEdge));const r=e;do{h.push(s(e.pos)),e=e.rightEdge?e.rightEdge.rightVertex:null}while(e&&e!==r);t.push(h)})),new a({paths:t,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}toPolygon(){const t=[],s=this.coordinateHelper.vectorToArray;return this.components.forEach((h=>{const e=[],r=h.vertices[0];let n=r;const o=n;do{e.push(s(n.pos)),n=i(n.rightEdge)?n.rightEdge.rightVertex:null}while(n&&n!==o);h.isClosed()&&e.push(s(r.pos)),t.push(e)})),new u({rings:t,spatialReference:this.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(t,s){const i=t.spatialReference,h=$(t.hasZ,t.hasM,i),r=new ht(t.type,h,s);switch(t.type){case"polygon":{const n=t.rings;for(let t=0;t<n.length;++t){const o=n[t],a=new it(i,s),u=o.length>2&&e(o[0],o[o.length-1]),c=u?o.length-1:o.length;for(let t=0;t<c;++t){const s=h.arrayToVector(o[t]),i=new tt(a);a.vertices.push(i),i.pos=s,i.index=t}const l=a.vertices.length-1;for(let t=0;t<l;++t){const s=new st(a,a.vertices[t],a.vertices[t+1]);a.edges.push(s)}if(u){const t=new st(a,a.vertices[a.vertices.length-1],a.vertices[0]);a.edges.push(t)}r.components.push(a)}break}case"polyline":for(const e of t.paths){const t=new it(i,s),n=e.length;for(let s=0;s<n;++s){const i=h.arrayToVector(e[s]),r=new tt(t);t.vertices.push(r),r.pos=i,r.index=s}const o=t.vertices.length-1;for(let s=0;s<o;++s){const i=new st(t,t.vertices[s],t.vertices[s+1]);t.edges.push(i)}r.components.push(t)}break;case"point":{const e=new it(i,s),n=new tt(e);n.index=0,n.pos=h.pointToVector(t),e.vertices.push(n),r.components.push(e);break}}return r}}class et{constructor(t,s,i){this.editGeometry=t,this.component=s,this.pos=i,this.addedVertex=null,this.originalEdge=null,this.left=null,this.right=null}apply(){let t="redo";r(this.addedVertex)&&(t="apply",this.addedVertex=new tt(this.component));const s=this.component.getLastVertex();if(r(s))this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,this.addedVertex.index=0;else{let t=null;s.rightEdge&&(this.originalEdge=s.rightEdge,t=this.originalEdge.rightVertex,this.component.edges.splice(this.component.edges.indexOf(this.originalEdge),1)),this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,r(this.left)&&(this.left=new st(this.component,s,this.addedVertex)),this.component.edges.push(this.left),s.rightEdge=this.left,i(this.originalEdge)&&i(t)&&(r(this.right)&&(this.right=new st(this.component,this.addedVertex,t)),this.component.edges.push(this.right),t.leftEdge=this.right),this.component.updateVertexIndex(this.addedVertex,s.index+1)}this.editGeometry.notifyChanges({operation:t,addedVertices:[this.addedVertex]})}undo(){if(r(this.addedVertex))return null;this.component.vertices.splice(this.component.vertices.indexOf(this.addedVertex),1),i(this.left)&&(this.component.edges.splice(this.component.edges.indexOf(this.left),1),this.left.leftVertex.rightEdge=null),i(this.right)&&(this.component.edges.splice(this.component.edges.indexOf(this.right),1),this.right.rightVertex.leftEdge=null),i(this.originalEdge)&&(this.component.edges.push(this.originalEdge),this.originalEdge.leftVertex.rightEdge=this.originalEdge,this.originalEdge.rightVertex.leftEdge=this.originalEdge),i(this.left)?this.component.updateVertexIndex(this.left.leftVertex,this.left.leftVertex.index):this.component.updateVertexIndex(this.addedVertex,0),this.editGeometry.notifyChanges({operation:"undo",removedVertices:[this.addedVertex]})}accumulate(){return!1}}class rt{constructor(t,s,i){this.editGeometry=t,this.vertices=s,this.operation=i,this.undone=!1}apply(){this.vertices.forEach((t=>this.operation.apply(t))),this.editGeometry.components.forEach((t=>t.unnormalizeVertexPositions())),this.editGeometry.notifyChanges({operation:this.undone?"redo":"apply",updatedVertices:this.vertices})}undo(){this.vertices.forEach((t=>this.operation.undo(t))),this.editGeometry.notifyChanges({operation:"undo",updatedVertices:this.vertices}),this.undone=!0}canAccumulate(t){if(this.undone||t.vertices.length!==this.vertices.length)return!1;for(let s=0;s<t.vertices.length;++s)if(t.vertices[s]!==this.vertices[s])return!1;return this.operation.canAccumulate(t.operation)}accumulate(t){return!!(t instanceof rt&&this.canAccumulate(t))&&(this.vertices.forEach((s=>this.operation.accumulate(s,t.operation))),this.operation.accumulateParams(t.operation),this.editGeometry.components.forEach((t=>t.unnormalizeVertexPositions())),this.editGeometry.notifyChanges({operation:"apply",updatedVertices:this.vertices}),!0)}}class nt{constructor(t,s,i=0){this.editGeometry=t,this.vertices=s,this.minNumberOfVertices=i,this.removedVertices=null}apply(){let t="redo";null==this.removedVertices?(this.removedVertices=[],this.vertices.forEach((t=>{const s=this._removeVertex(t);i(s)&&this.removedVertices.push(s)})),t="apply"):this.removedVertices.forEach((t=>{this._removeVertex(t.removedVertex)})),this.editGeometry.notifyChanges({operation:t,removedVertices:this.vertices})}undo(){this.removedVertices.forEach((t=>{this._undoRemoveVertex(t)})),this.editGeometry.notifyChanges({operation:"undo",addedVertices:this.vertices})}accumulate(){return!1}_removeVertex(t){const s=t.component;if(s.vertices.length<=this.minNumberOfVertices)return null;const i={removedVertex:t,createdEdge:null},h=t.leftEdge,e=t.rightEdge;return s.vertices.splice(s.vertices.indexOf(t),1),h&&(s.edges.splice(s.edges.indexOf(h),1),h.leftVertex.rightEdge=null),e&&(s.edges.splice(s.edges.indexOf(e),1),e.rightVertex.leftEdge=null),0===t.index&&e&&this.vertices.length>0&&s.swapVertices(s.vertices.indexOf(e.rightVertex),0),h&&e&&(i.createdEdge=new st(s,h.leftVertex,e.rightVertex),s.edges.push(i.createdEdge)),e&&s.updateVertexIndex(e.rightVertex,e.rightVertex.index-1),i}_undoRemoveVertex(t){const s=t.removedVertex,i=t.removedVertex.component,h=s.leftEdge,e=s.rightEdge;t.createdEdge&&i.edges.splice(i.edges.indexOf(t.createdEdge),1),i.vertices.push(s),h&&(i.edges.push(h),h.leftVertex.rightEdge=h),e&&(i.edges.push(e),e.rightVertex.leftEdge=e),i.updateVertexIndex(s,s.index)}}class ot{constructor(t,s,i){this.editGeometry=t,this.edge=s,this.t=i,this.createdVertex=null,this.left=null,this.right=null}apply(){let t="redo";const s=this.edge,i=s.component,h=s.leftVertex,e=s.rightVertex;i.edges.splice(i.edges.indexOf(s),1),r(this.createdVertex)&&(t="apply",this.createdVertex=new tt(s.component)),i.vertices.push(this.createdVertex),this.createdVertex.pos=this.editGeometry.coordinateHelper.lerp(s.leftVertex.pos,s.rightVertex.pos,this.t,this.editGeometry.coordinateHelper.createVector()),r(this.left)&&(this.left=new st(i,h,this.createdVertex)),this.left.leftVertex.leftEdge?i.edges.push(this.left):i.edges.unshift(this.left),h.rightEdge=this.left,r(this.right)&&(this.right=new st(i,this.createdVertex,e)),i.edges.push(this.right),e.leftEdge=this.right,i.updateVertexIndex(this.createdVertex,h.index+1),this.editGeometry.notifyChanges({operation:t,addedVertices:[this.createdVertex]})}undo(){if(r(this.createdVertex)||r(this.left)||r(this.right))return null;const t=this.edge,s=t.component,i=this.createdVertex.leftEdge.leftVertex,h=this.createdVertex.rightEdge.rightVertex;s.vertices.splice(s.vertices.indexOf(this.createdVertex),1),s.edges.splice(s.edges.indexOf(this.left),1),s.edges.splice(s.edges.indexOf(this.right),1),this.edge.leftVertex.leftEdge?s.edges.push(this.edge):s.edges.unshift(this.edge),i.rightEdge=t,h.leftEdge=t,s.updateVertexIndex(i,i.index),this.editGeometry.notifyChanges({operation:"undo",removedVertices:[this.createdVertex]})}accumulate(){return!1}}class at{constructor(t,s,i){this.editGeometry=t,this.vertex=s,this.pos=i}apply(){const t=r(this.originalPosition);t&&(this.originalPosition=this.vertex.pos),this._apply(t?"apply":"redo")}undo(){this.vertex.pos=n(this.originalPosition),this.editGeometry.notifyChanges({operation:"undo",updatedVertices:[this.vertex]})}accumulate(t){return t instanceof at&&t.vertex===this.vertex&&(this.pos=t.pos,this._apply("apply"),!0)}_apply(t){this.vertex.pos=this.pos,this.editGeometry.components.forEach((t=>t.unnormalizeVertexPositions())),this.editGeometry.notifyChanges({operation:t,updatedVertices:[this.vertex]})}}class ut{constructor(t,s){this.editGeometry=t,this.component=s,this.createdEdge=null}apply(){let t="redo";if(r(this.createdEdge)){t="apply";const s=this.component.getFirstVertex(),i=this.component.getLastVertex();if(this.component.isClosed()||this.component.vertices.length<3||r(s)||r(i))return;this.createdEdge=new st(this.component,i,s)}this.createdEdge.leftVertex.rightEdge=this.createdEdge,this.createdEdge.rightVertex.leftEdge=this.createdEdge,this.component.edges.push(this.createdEdge),this.editGeometry.notifyChanges({operation:t})}undo(){r(this.createdEdge)||(o(this.component.edges,this.createdEdge),this.createdEdge.leftVertex.rightEdge=null,this.createdEdge.rightVertex.leftEdge=null,this.editGeometry.notifyChanges({operation:"undo"}))}accumulate(){return!1}}class ct{constructor(t,s,i,h){this.helper=t,this.dx=s,this.dy=i,this.dz=h}move(t,s,i,h){this.helper.addDelta(t.pos,s,i,h)}apply(t){this.move(t,this.dx,this.dy,this.dz)}undo(t){this.move(t,-this.dx,-this.dy,-this.dz)}canAccumulate(t){return t instanceof ct}accumulate(t,s){this.move(t,s.dx,s.dy,s.dz)}accumulateParams(t){this.dx+=t.dx,this.dy+=t.dy,this.dz+=t.dz}}class lt{constructor(t,s,i,h=0,e=0){this.helper=t,this.planeType=s,this.edge=i,this.distance=h,this._plane=q(),this._offsetPlane=q(),this._minDistance=-1/0,this._maxDistance=1/0,0===e&&this._initialize()}get plane(){return this._plane}get requiresSplitEdgeLeft(){return!this._left.isOriginalDirection}get requiresSplitEdgeRight(){return!this._right.isOriginalDirection}get edgeDirection(){return this._edgeDirection}_initialize(){this._initializeNeighbors(),this._initializePlane(),this._initializeDistanceConstraints()}_initializeNeighbors(){var t,s,i,h;const e=this._toXYZ(this.edge.leftVertex.pos),r=this._toXYZ(null==(t=this.edge.leftVertex.leftEdge)||null==(s=t.leftVertex)?void 0:s.pos),n=this._toXYZ(this.edge.rightVertex.pos),o=this._toXYZ(null==(i=this.edge.rightVertex.rightEdge)||null==(h=i.rightVertex)?void 0:h.pos);this._edgeDirection=D(N(),e,n),this._left=this._computeNeighbor(e,r,this._edgeDirection),this._right=this._computeNeighbor(n,o,this._edgeDirection)}_toXYZ(t){return i(t)?this.helper.toXYZ(t):null}_computeNeighbor(t,s,i){if(r(s))return{start:t,end:s,direction:E(-i[1],i[0],0),isOriginalDirection:!0};const h=D(N(),t,s),e=!this._passesBisectingAngleThreshold(h,i);return{start:t,end:s,direction:e?this._bisectVectorsPerpendicular(i,h):h,isOriginalDirection:!e}}_passesBisectingAngleThreshold(t,s){const i=Math.abs(H(s,t));return i>=dt&&i<=Math.PI-dt}_bisectVectorsPerpendicular(t,s){const i=Z(t,s)<0?t:b(N(),t),h=Math.abs(Z(i,s));if(!(h<.001||h>.999))return this._bisectDirection(i,s);const e=A(N(),i,[0,0,1]);return j(e,e)}_bisectDirection(t,s){const i=R(N(),t,s);return j(i,i)}_initializePlane(){const t=this._computeNormalDirection(this._left),s=this._computeNormalDirection(this._right);Z(t,s)<0&&b(s,s),G(this._left.start,this._bisectDirection(t,s),this._plane)}_computeNormalDirection(t){const s=A(N(),t.direction,this._edgeDirection);j(s,s);const i=A(N(),this._edgeDirection,s);return 1===this.planeType&&(i[2]=0),j(i,i)}_initializeDistanceConstraints(){i(this._left.end)&&!this.requiresSplitEdgeLeft&&this._updateDistanceConstraint(I(this._plane,this._left.end)),i(this._right.end)&&!this.requiresSplitEdgeRight&&this._updateDistanceConstraint(I(this._plane,this._right.end)),this._updateIntersectDistanceConstraint(this._plane)}_updateDistanceConstraint(t){t<=0&&(this._minDistance=Math.max(this._minDistance,t)),t>=0&&(this._maxDistance=Math.min(this._maxDistance,t))}_updateIntersectDistanceConstraint(t){const s=U(t),i=this._edgeDirection,h=R(N(),this._left.start,this._left.direction),e=R(N(),this._right.start,this._right.direction),r=this._pointInBasis2D(w(),s,i,this._left.start),n=this._pointInBasis2D(w(),s,i,h),o=this._pointInBasis2D(w(),s,i,this._right.start),a=this._pointInBasis2D(w(),s,i,e),[u]=J({start:n,end:r,type:1},{start:a,end:o,type:1});if(!u)return;const c=p(w(),r,n);m(c,c);const l=p(w(),u,n),d=f(c,l),v=R(N(),h,X(N(),this._left.direction,-d)),y=I(t,v);this._updateDistanceConstraint(y)}_pointInBasis2D(t,s,i,h){return t[0]=F(s,h),t[1]=F(i,h),t}_offset(t,s){Number.isFinite(this._minDistance)&&(s=Math.max(this._minDistance,s)),Number.isFinite(this._maxDistance)&&(s=Math.min(this._maxDistance,s)),L(this._plane,this._offsetPlane),this._offsetPlane[3]-=s;const h=(t,s,h)=>i(s)&&S(this._offsetPlane,t,R(N(),t,s),h),e=N();(t===this.edge.leftVertex?h(this._left.start,this._left.direction,e):h(this._right.start,this._right.direction,e))&&this.helper.copy(this.helper.fromXYZ(e,void 0,this.helper.getM(t.pos)),t.pos)}signedDistanceToPoint(t){return I(this.plane,this.helper.toXYZ(this.helper.pointToVector(t)))}apply(t){this._offset(t,this.distance)}undo(t){this._offset(t,0)}canAccumulate(t){return t instanceof lt&&this.edge.leftVertex.index===t.edge.leftVertex.index&&this.edge.rightVertex.index===t.edge.rightVertex.index&&this.edge.component===t.edge.component&&this._maybeEqualsVec3(this._left.direction,t._left.direction)&&this._maybeEqualsVec3(this._right.direction,t._right.direction)&&z(U(this._plane),U(t._plane))}accumulate(t,s){this._offset(t,this._plane[3]-s._plane[3]+s.distance)}accumulateParams(t){this.distance=t.distance-t._plane[3]+this._plane[3]}clone(){const t=new lt(this.helper,this.planeType,this.edge,this.distance,1);return L(this._plane,t._plane),L(this._offsetPlane,t._offsetPlane),t._maxDistance=this._maxDistance,t._minDistance=this._minDistance,t._left=this._cloneNeighbor(this._left),t._right=this._cloneNeighbor(this._right),t._edgeDirection=P(N(),this._edgeDirection),t}_maybeEqualsVec3(t,s){return r(t)&&r(s)||i(t)&&i(s)&&z(t,s)}_cloneNeighbor({start:t,end:s,direction:h,isOriginalDirection:e}){return{start:P(N(),t),end:i(s)?P(N(),s):null,direction:P(N(),h),isOriginalDirection:e}}}const dt=C(15);class pt{constructor(t,s,i=0){this.origin=t,this.angle=s,this.accumulationType=i}rotate(t,s){v(t.pos,t.pos,this.origin,s)}apply(t){this.rotate(t,this.angle)}undo(t){this.rotate(t,-this.angle)}canAccumulate(t){return t instanceof pt&&e(this.origin,t.origin)}accumulate(t,s){this.rotate(t,1===s.accumulationType?s.angle-this.angle:s.angle)}accumulateParams(t){this.angle=1===t.accumulationType?t.angle:this.angle+t.angle}}class mt{constructor(t,s,i,h,e=0){this.origin=t,this.axis1=s,this.factor1=i,this.factor2=h,this.accumulationType=e,this.axis2=g(s[1],-s[0])}scale(t,s,i){y(t.pos,t.pos,this.origin,this.axis1,s),y(t.pos,t.pos,this.origin,this.axis2,i)}apply(t){this.scale(t,this.factor1,this.factor2)}undo(t){this.scale(t,1/this.factor1,1/this.factor2)}canAccumulate(t){return t instanceof mt&&e(this.origin,t.origin)&&e(this.axis1,t.axis1)}accumulate(t,s){1===s.accumulationType?this.scale(t,s.factor1/this.factor1,s.factor2/this.factor2):this.scale(t,s.factor1,s.factor2)}accumulateParams(t){const s=1===t.accumulationType;this.factor1=s?t.factor1:this.factor1*t.factor1,this.factor2=s?t.factor2:this.factor2*t.factor2}}class ft{constructor(){this.operations=[],this.closed=!1}close(){this.closed=!0}apply(){for(const t of this.operations)t.apply()}undo(){for(let t=this.operations.length-1;t>=0;t--)this.operations[t].undo()}accumulate(t){if(this.closed)return!1;const s=this.operations.length?this.operations[this.operations.length-1]:null;return s&&s.accumulate(t)||(this.operations.push(t),t.apply()),!0}}class vt extends h{constructor(t){super(),this.data=t,this.undoStack=[],this.redoStack=[],this.listener=this.data.on("change",(t=>{t.addedVertices&&this.emit("vertex-add",{type:"vertex-add",vertices:t.addedVertices,operation:t.operation}),t.removedVertices&&this.emit("vertex-remove",{type:"vertex-remove",vertices:t.removedVertices,operation:t.operation}),t.updatedVertices&&this.emit("vertex-update",{type:"vertex-update",vertices:t.updatedVertices,operation:t.operation})}))}destroy(){this.listener.remove()}splitEdge(t,s){return this.apply(new ot(this.data,t,s))}updateVertices(t,s,i=1){return this.apply(new rt(this.data,t,s),i)}moveVertices(t,s,i,h,e=1){return this.updateVertices(t,new ct(this.data.coordinateHelper,s,i,h),e)}scaleVertices(t,s,i,h,e,r=1,n=0){return this.updateVertices(t,new mt(s,i,h,e,n),r)}rotateVertices(t,s,i,h=1,e=0){return this.updateVertices(t,new pt(s,i,e),h)}removeVertices(t){return this.apply(new nt(this.data,t,this._minNumVerticesPerType))}appendVertex(t){return 0===this.data.components.length?null:this.apply(new et(this.data,this.data.components[0],t))}setVertexPosition(t,s){return this.apply(new at(this.data,t,s))}offsetEdge(t,s,i,h=1){return this.updateVertices([s.leftVertex,s.rightVertex],new lt(this.data.coordinateHelper,t,s,i),h)}closeComponent(t){return this.data.components.includes(t)?this.apply(new ut(this.data,t)):null}canRemoveVertex(){return this.data.components[0].vertices.length>this._minNumVerticesPerType}createUndoGroup(){const t=new ft;return this.apply(t),{remove:()=>t.close()}}undo(){if(this.undoStack.length>0){const t=this.undoStack.pop();return t.undo(),this.redoStack.push(t),t}return null}redo(){if(this.redoStack.length>0){const t=this.redoStack.pop();return t.apply(),this.undoStack.push(t),t}return null}get canUndo(){return this.undoStack.length>0}get canRedo(){return this.redoStack.length>0}get lastOperation(){return this.undoStack.length>0?this.undoStack[this.undoStack.length-1]:null}get _minNumVerticesPerType(){switch(this.data.type){case"point":return 1;case"polyline":return 2;case"polygon":return 3;default:return 0}}apply(t,s=1){return 0!==s&&!r(this.lastOperation)&&this.lastOperation.accumulate(t)||(t.apply(),this.undoStack.push(t),this.redoStack=[]),t}static fromGeometry(t,s){return new vt(ht.fromGeometry(t,s))}}export{mt as a,rt as e,ht as g,pt as i,vt as l,it as p,ct as t,$ as x,lt as z}