import{c as t,I as s,b as i,af as e,T as n,_ as a,ap as r,aw as h,ax as l,dH as o,A as u,h as c,k as d,e as f,d as p,i as m}from"./p-e58503d5.js";import{n as w,a as g}from"./p-e654504b.js";import{k as y,s as x,l as v,G as b,u as A,a as M,E as I}from"./p-ea916a39.js";import{p as j}from"./p-cbbdb7db.js";import{a0 as E,m as R}from"./p-eb48bb01.js";import{P as S,u as _,I as L}from"./p-340cd100.js";import{l as z}from"./p-6f439939.js";import{h as D}from"./p-86bdfe14.js";import{u as H}from"./p-a63f7978.js";import{i as C}from"./p-07ab8db5.js";function F(t){return S.createSquareGeometry([[t[0],t[1],-1],[t[2],t[1],-1],[t[2],t[3],-1],[t[0],t[3],-1]])}function V(t,s){if(!y(t,s))return F(s);const i=[t[1]-s[1],Math.min(t[3],s[3])-Math.max(t[1],s[1]),s[3]-t[3],123456],e=[t[0]-s[0],Math.min(t[2],s[2])-Math.max(t[0],s[0]),s[2]-t[2],123456],n=s[2]-s[0],a=s[3]-s[1],r=e[0]>0&&e[2]>0?3:2,h=i[0]>0&&i[2]>0?3:2,l=(h+1)*(r+1),o=new Float64Array(3*l),u=new Float32Array(2*l),c=new Uint32Array(6*(h*r-1));let d=0,f=0,p=0,m=0,w=0;for(let t=0;t<4;t++){const h=i[t];if(h<=0)continue;let l=0;for(let i=0;i<4;i++){const h=e[i];h<=0||(o[f++]=s[0]+l,o[f++]=s[1]+d,o[f++]=-1,u[p++]=l/n,u[p++]=d/a,i<3&&t<3&&(1!==i||1!==t)&&(c[w++]=m,c[w++]=m+1,c[w++]=m+r+1,c[w++]=m+1,c[w++]=m+r+2,c[w++]=m+r+1),m++,l+=h)}d+=h}const g=new Uint32Array(c.length);return new E([["position",{size:3,data:o,exclusive:!0}],["normal",{size:3,data:q,exclusive:!0}],["uv0",{size:2,data:u,exclusive:!0}]],[["position",c],["normal",g],["uv0",c]])}const q=[0,0,1],O=t.getLogger("esri.views.3d.layers.DynamicLayerView3D");let U=class extends(C(j(H))){constructor(){super(...arguments),this.drapeSourceType=0,this.updatePolicy=1,this.fullExtentInLocalViewSpatialReference=null,this.maximumDataResolution=null,this._images=new Array,this._extents=new Array,this._overlays=new Array,this.updateWhenStationary=!0,this.refreshDebounced=s((async s=>{this.destroyed||await this.doRefresh(s).catch((s=>{i(s)||t.getLogger(this.declaredClass).error(s)}))}),2e3)}initialize(){this.addResolvingPromise(z(this).then((t=>this._set("fullExtentInLocalViewSpatialReference",t)))),this.updatingHandles.add(this,"suspended",(()=>this._suspendedChangeHandler())),this.handles.add(this.view.resourceController.scheduler.registerIdleStateCallbacks((()=>{this._isScaleRangeActive()&&this.notifyChange("suspended")}),(()=>{}))),this._isScaleRangeLayer()&&this.updatingHandles.add(this.layer,"scaleRangeId",(()=>this.notifyChange("suspended")))}destroy(){this.clear()}setDrapingExtent(t,s){this._spatialReference=s,t.forEach((t=>{this._overlays[t.index]=t,this._updateImageExtent(t)}))}_updateImageExtent(t){const s=this._clippedExtent(t.extent,P);if(e(s))return;const n=function(t,s,i){const e=x(t)/v(t),n={width:i,height:i};return e>1.0001?n.height=i/e:e<.9999&&(n.width=i*e),n.width=Math.round(n.width/(x(t)/x(s))),n.height=Math.round(n.height/(v(t)/v(s))),n}(t.extent,s,t.resolution);let a=t.pixelRatio*this.view.pixelRatio;if("imageMaxWidth"in this.layer||"imageMaxHeight"in this.layer){const t=this.layer.imageMaxWidth,s=this.layer.imageMaxHeight;if(n.width>t){const s=t/n.width;n.height=Math.floor(n.height*s),n.width=t,a*=s}if(n.height>s){const t=s/n.height;n.width=Math.floor(n.width*t),n.height=s,a*=t}}const r=this._extents[t.index];r&&b(r.extent,s)&&this._imageSizeEquals(s,r.imageSize,n)||(this._extents[t.index]={extent:A(s),imageSize:n,pixelRatio:a},this.suspended||this._fetch(t.index).catch((t=>{i(t)||O.error(t)})))}clear(){for(let t=0;t<this._images.length;t++)this._clearImage(t)}async doRefresh(t){if(this.suspended)return;const s=[];for(let i=0;i<this._extents.length;i++)this._extents[i]&&s.push(this._fetch(i,t));await n(s)}canResume(){if(!super.canResume())return!1;if(this._isScaleRangeLayer()){const{minScale:t,maxScale:s}=this.layer;if(t>0||s>0){const i=this.view.scale;if(i<s||t>0&&i>t)return!1}}return!0}isUpdating(){return this._images.some((t=>!!t.loadingPromise))}async processResult(t,s,i){(s instanceof HTMLImageElement||s instanceof HTMLCanvasElement)&&(t.image=s)}findExtentInfoAt(t){for(const s of this._extents){const i=s.extent;if(new a(i[0],i[1],i[2],i[3],this._spatialReference).contains(t))return s}return null}getFetchOptions(){}async redraw(t,s){await w(this._images,(async(i,e)=>{i&&(await t(i,s),await this._createStageObjects(e,i.image,s))}))}_imageSizeEquals(t,s,i){if(!this.maximumDataResolution)return!1;const e=x(t)/this.maximumDataResolution.x,n=v(t)/this.maximumDataResolution.y,a=n/s.height,r=n/i.height,h=Math.abs(e/s.width-e/i.width),l=Math.abs(a-r),o=L.TESTS_DISABLE_OPTIMIZATIONS?0:1.5;return h<=o&&l<=o}async _fetch(t,s){if(this.suspended)return;const e=this._extents[t],n=e.extent;this._images[t]||(this._images[t]={texture:null,material:null,renderGeometry:null,loadingPromise:null,loadingAbortController:null,image:null,pixelData:null,renderExtent:A(n)});const u=this._images[t];u.loadingAbortController&&(u.loadingAbortController.abort(),u.loadingAbortController=null);const c=new a(n[0],n[1],n[2],n[3],this._spatialReference);if(0===c.width||0===c.height)return void this._clearImage(t);const d=new AbortController;u.loadingAbortController=d,r(s,(()=>d.abort()));const f=d.signal,p=this._waitFetchReady(f).then((()=>{const s={requestAsImageElement:!0,pixelRatio:this._overlays[t].pixelRatio,...this.getFetchOptions(),signal:f},{height:i,width:n}=e.imageSize;return this.layer.fetchImage(c,n,i,s)})).then((t=>{if(h(f))throw O.warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."),l();return this.processResult(u,t)})).then((()=>M(u.renderExtent,n)));u.loadingPromise=p,o(p,(()=>{p===u.loadingPromise&&(u.loadingPromise=null,u.loadingAbortController=null)})),this.notifyChange("updating"),await p.then((async()=>{if(f.aborted)throw l();await this._createStageObjects(t,u.image,f),this.notifyChange("updating")})).catch((t=>{throw t&&!i(t)&&O.error(t),this.notifyChange("updating"),t}))}_clearImage(t){const s=this._images[t];if(s){u(s.renderGeometry)&&(this.view.basemapTerrain.overlayManager.renderer.removeGeometries([s.renderGeometry],this,2),s.renderGeometry=null);const t=this.view._stage;t.remove(s.texture),s.texture=null,t.remove(s.material),s.material=null,s.loadingAbortController&&(s.loadingAbortController.abort(),s.loadingAbortController=null),s.loadingPromise=null,s.image=null,s.pixelData=null}}async _createStageObjects(t,s,i){const n=this.view._stage,a=this._images[t],r=this.view.basemapTerrain.overlayManager.renderer,h=()=>{n.remove(a.texture),a.texture=null,u(a.renderGeometry)&&(r.removeGeometries([a.renderGeometry],this,2),a.renderGeometry=null)};if(s){const l=new R(s,{width:s.width,height:s.height,preMultiplyAlpha:!0,wrap:{s:33071,t:33071}});let o;if(await g(this._images[0===t?1:0].loadingPromise),c(i),0===t)o=F(a.renderExtent);else{const t=this._images[0].renderExtent;if(!t)return void h();o=V(t,a.renderExtent)}h(),n.add(l),n.loadSynchronous(l),a.texture=l,e(a.material)?(a.material=new D({transparent:!0,textureId:l.id}),n.add(a.material)):a.material.setParameters({textureId:l.id}),a.renderGeometry=new _(o,a.material),a.renderGeometry.origin=this._overlays[t].renderLocalOrigin,r.addGeometries([a.renderGeometry],this,2)}else h(),n.remove(a.material),a.material=null}_isScaleRangeLayer(){return"minScale"in this.layer&&"maxScale"in this.layer}_isScaleRangeActive(){return!!this._isScaleRangeLayer()&&(this.layer.minScale>0||this.layer.maxScale>0)}_clippedExtent(t,s){if("local"!==this.view.viewingMode)return M(s,t);const i=this.view.basemapTerrain;return i.ready?I(t,i.extent,s):M(s,t)}_suspendedChangeHandler(){this.suspended?this.clear():this.refreshDebounced()}async _waitFetchReady(t){await d(this.view,"stationary",t),c(t)}};f([p()],U.prototype,"layer",void 0),f([p()],U.prototype,"suspended",void 0),f([p({readOnly:!0})],U.prototype,"fullExtentInLocalViewSpatialReference",void 0),f([p()],U.prototype,"updating",void 0),U=f([m("esri.views.3d.layers.DynamicLayerView3D")],U);const P=A(),T=U;export{T as V}