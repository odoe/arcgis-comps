import{cK as e,e as t,d as s,bN as r,i,bj as n,l as o,a$ as a,aL as l,o as u,bH as c,cJ as d,k as p,ck as m,bl as h,w as v,r as f,b as y,E as g,cL as T,cM as N,bn as w,bp as A}from"./p-5420851c.js";import{a as b}from"./p-48fed6fe.js";class M{constructor(e={}){this._options=e}toQueryParams(e){if(!e)return null;const t=e.toJSON(),s={};return Object.keys(t).forEach((e=>{const r=this._options[e];if(r){const i="boolean"!=typeof r&&r.name?r.name:e,n="boolean"!=typeof r&&r.getter?r.getter(t):t[e];null!=n&&(s[i]=(e=>{if(!Array.isArray(e))return!1;const[t]=e;return"number"==typeof t||"string"==typeof t})(n)?n.join(","):"object"==typeof n?JSON.stringify(n):n)}else s[e]=t[e]}),this),s}}function S(e){return new M(e)}const j=e()({esriCentimeters:"centimeters",esriDecimalDegrees:"decimal-degrees",esriDecimeters:"decimeters",esriFeet:"feet",esriInches:"inches",esriKilometers:"kilometers",esriMeters:"meters",esriMiles:"miles",esriMillimeters:"millimeters",esriNauticalMiles:"nautical-miles",esriPoints:"points",esriYards:"yards"});e()({esriNAUCentimeters:"centimeters",esriNAUDecimalDegrees:"decimal-degrees",esriNAUDecimeters:"decimeters",esriNAUFeet:"feet",esriNAUInches:"inches",esriNAUKilometers:"kilometers",esriNAUMeters:"meters",esriNAUMiles:"miles",esriNAUMillimeters:"millimeters",esriNAUNauticalMiles:"nautical-miles",esriNAUPoints:"points",esriNAUYards:"yards"}),e()({esriDOTComplete:"complete",esriDOTCompleteNoEvents:"complete-no-events",esriDOTInstructionsOnly:"instructions-only",esriDOTStandard:"standard",esriDOTSummaryOnly:"summary-only"}),e()({esriNAOutputLineNone:"none",esriNAOutputLineStraight:"straight",esriNAOutputLineTrueShape:"true-shape",esriNAOutputLineTrueShapeWithMeasure:"true-shape-with-measure"}),e()({esriNAOutputPolygonNone:"none",esriNAOutputPolygonSimplified:"simplified",esriNAOutputPolygonDetailed:"detailed"});const O=e()({esriNFSBAllowBacktrack:"allow-backtrack",esriNFSBAtDeadEndsOnly:"at-dead-ends-only",esriNFSBNoBacktrack:"no-backtrack",esriNFSBAtDeadEndsAndIntersections:"at-dead-ends-and-intersections"});e()({esriNATravelDirectionFromFacility:"from-facility",esriNATravelDirectionToFacility:"to-facility"}),e()({esriNATimeOfDayNotUsed:"not-used",esriNATimeOfDayUseAsStartTime:"start",esriNATimeOfDayUseAsEndTime:"end"});const B=e()({AUTOMOBILE:"automobile",TRUCK:"truck",WALK:"walk",OTHER:"other"});var U;let D=U=class extends n{constructor(e){super(e),this.attributeParameterValues=null,this.description=null,this.distanceAttributeName=null,this.id=null,this.impedanceAttributeName=null,this.name=null,this.restrictionAttributeNames=null,this.simplificationTolerance=null,this.simplificationToleranceUnits=null,this.timeAttributeName=null,this.type=null,this.useHierarchy=null,this.uturnAtJunctions=null}clone(){return new U(o({attributeParameterValues:this.attributeParameterValues,description:this.description,distanceAttributeName:this.distanceAttributeName,id:this.id,impedanceAttributeName:this.impedanceAttributeName,name:this.name,restrictionAttributeNames:this.restrictionAttributeNames,simplificationTolerance:this.simplificationTolerance,simplificationToleranceUnits:this.simplificationToleranceUnits,timeAttributeName:this.timeAttributeName,type:this.type,useHierarchy:this.useHierarchy,uturnAtJunctions:this.uturnAtJunctions}))}};t([s({type:[Object],json:{write:!0}})],D.prototype,"attributeParameterValues",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"description",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"distanceAttributeName",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"id",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"impedanceAttributeName",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"name",void 0),t([s({type:[String],json:{write:!0}})],D.prototype,"restrictionAttributeNames",void 0),t([s({type:Number,json:{write:!0}})],D.prototype,"simplificationTolerance",void 0),t([r(j)],D.prototype,"simplificationToleranceUnits",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"timeAttributeName",void 0),t([r(B)],D.prototype,"type",void 0),t([s({type:Boolean,json:{write:!0}})],D.prototype,"useHierarchy",void 0),t([r(O)],D.prototype,"uturnAtJunctions",void 0),D=U=t([i("esri.rest.support.TravelMode")],D);const k=D;let R=class extends n{constructor(e){super(e),this.currentVersion=null,this.defaultTravelMode=null,this.directionsLanguage=null,this.directionsSupportedLanguages=null,this.directionsTimeAttribute=null,this.hasZ=null,this.impedance=null,this.networkDataset=null,this.supportedTravelModes=null}};t([s()],R.prototype,"currentVersion",void 0),t([s()],R.prototype,"defaultTravelMode",void 0),t([s()],R.prototype,"directionsLanguage",void 0),t([s()],R.prototype,"directionsSupportedLanguages",void 0),t([s()],R.prototype,"directionsTimeAttribute",void 0),t([s()],R.prototype,"hasZ",void 0),t([s()],R.prototype,"impedance",void 0),t([s()],R.prototype,"networkDataset",void 0),t([s({type:[k]})],R.prototype,"supportedTravelModes",void 0),R=t([i("esri.rest.support.NetworkServiceDescription")],R);const I=R,P=new a({0:"informative",1:"process-definition",2:"process-start",3:"process-stop",50:"warning",100:"error",101:"empty",200:"abort"});let F=class extends b{constructor(e){super(e),this.type=null}};t([s({type:String,json:{read:P.read,write:P.write}})],F.prototype,"type",void 0),F=t([i("esri.rest.support.NAMessage")],F);const L=F;let x=class extends l{};t([s()],x.prototype,"events",void 0),t([s()],x.prototype,"strings",void 0),x=t([i("esri.rest.support.DirectionsFeature")],x);const C=x;let E=class extends d{constructor(e){super(e),this.extent=null,this.features=null,this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null}readFeatures(e,t){var s;if(!e)return[];const r=null!=(s=t.summary.envelope.spatialReference)?s:t.spatialReference,i=r&&p.fromJSON(r);return e.map((e=>{var t,s;const r=this._decompressGeometry(e.compressedGeometry),n=new m({...r,spatialReference:i}),o=null!=(t=null==(s=e.events)?void 0:s.map((e=>{const{arriveTimeUTC:t,ETA:s,point:{x:r,y:n,z:o},strings:a}=e;return new C({geometry:new h({x:r,y:n,z:o,hasZ:void 0!==o,spatialReference:i}),attributes:{ETA:s,arriveTimeUTC:t},strings:a})})))?t:[];return new C({attributes:e.attributes,events:o,geometry:n,strings:e.strings})}))}get mergedGeometry(){if(!this.features)return null;const e=this.features.map((({geometry:e})=>v(e))),t=this.get("extent.spatialReference");return this._mergePolylinesToSinglePath(e,t)}get strings(){return this.features.map((({strings:e})=>e))}_decompressGeometry(e){let t=0,s=0,r=0,i=0;const n=[];let o,a,l,u,c,d,p,m,h=0,v=0,f=0;if(c=e.match(/((\+|\-)[^\+\-\|]+|\|)/g),c||(c=[]),0===parseInt(c[h],32)){h=2;const e=parseInt(c[h],32);h++,d=parseInt(c[h],32),h++,1&e&&(v=c.indexOf("|")+1,p=parseInt(c[v],32),v++),2&e&&(f=c.indexOf("|",v)+1,m=parseInt(c[f],32),f++)}else d=parseInt(c[h],32),h++;for(;h<c.length&&"|"!==c[h];){o=parseInt(c[h],32)+t,h++,t=o,a=parseInt(c[h],32)+s,h++,s=a;const e=[o/d,a/d];v&&(u=parseInt(c[v],32)+r,v++,r=u,e.push(u/p)),f&&(l=parseInt(c[f],32)+i,f++,i=l,e.push(l/m)),n.push(e)}return{paths:[n],hasZ:v>0,hasM:f>0}}_mergePolylinesToSinglePath(e,t){if(0===e.length)return new m({spatialReference:t});const s=[];for(const t of e)for(const e of t.paths)s.push(...e);const r=[];s.forEach(((e,t)=>{0!==t&&e[0]===s[t-1][0]&&e[1]===s[t-1][1]||r.push(e)}));const{hasM:i,hasZ:n}=e[0];return new m({hasM:i,hasZ:n,paths:[r],spatialReference:t})}};t([s({type:u,json:{read:{source:"summary.envelope"}}})],E.prototype,"extent",void 0),t([s()],E.prototype,"features",void 0),t([c("features")],E.prototype,"readFeatures",null),t([s()],E.prototype,"geometryType",void 0),t([s({readOnly:!0})],E.prototype,"mergedGeometry",null),t([s()],E.prototype,"routeId",void 0),t([s()],E.prototype,"routeName",void 0),t([s({value:null,readOnly:!0})],E.prototype,"strings",null),t([s({json:{read:{source:"summary.totalDriveTime"}}})],E.prototype,"totalDriveTime",void 0),t([s({json:{read:{source:"summary.totalLength"}}})],E.prototype,"totalLength",void 0),t([s({json:{read:{source:"summary.totalTime"}}})],E.prototype,"totalTime",void 0),E=t([i("esri.rest.support.DirectionsFeatureSet")],E);const Z=E;let J=class extends n{constructor(e){super(e),this.directions=null,this.route=null,this.routeName=null,this.stops=null}};t([s({type:Z,json:{write:!0}})],J.prototype,"directions",void 0),t([s({type:l,json:{write:!0}})],J.prototype,"route",void 0),t([s({type:String,json:{write:!0}})],J.prototype,"routeName",void 0),t([s({type:[l],json:{write:!0}})],J.prototype,"stops",void 0),J=t([i("esri.rest.support.RouteResult")],J);const K=J;function G(e){return e&&d.fromJSON(e).features.map((e=>e))}let H=class extends n{constructor(e){super(e),this.barriers=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.routeResults=null}readPointBarriers(e,t){return G(t.barriers||t.pointBarriers)}readPolylineBarriers(e){return G(e)}readPolygonBarriers(e){return G(e)}};t([s({aliasOf:"pointBarriers"})],H.prototype,"barriers",void 0),t([s({type:[L]})],H.prototype,"messages",void 0),t([s({type:[l]})],H.prototype,"pointBarriers",void 0),t([c("pointBarriers",["barriers","pointBarriers"])],H.prototype,"readPointBarriers",null),t([s({type:[l]})],H.prototype,"polylineBarriers",void 0),t([c("polylineBarriers")],H.prototype,"readPolylineBarriers",null),t([s({type:[l]})],H.prototype,"polygonBarriers",void 0),t([c("polygonBarriers")],H.prototype,"readPolygonBarriers",null),t([s({type:[K]})],H.prototype,"routeResults",void 0),H=t([i("esri.rest.support.RouteResultsContainer")],H);const $=H;function _(e,t,s,r){r[s]=[t.length,t.length+e.length],e.forEach((e=>{t.push(e.geometry)}))}function V(e,t){for(let s=0;s<t.length;s++){const r=e[t[s]];if(r&&r.length)for(const e of r)e.z=void 0}console.log("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}function z(e){const t=[],s=[],{directions:r=[],routes:{features:i=[],spatialReference:n=null}={},stops:{features:o=[],spatialReference:a=null}={},barriers:l,polygonBarriers:u,polylineBarriers:c,messages:d}=e.data,p="esri.tasks.RouteTask.NULL_ROUTE_NAME";let m,h,v=!0;const y=i&&n||o&&a||l&&l.spatialReference||u&&u.spatialReference||c&&c.spatialReference;r.forEach((e=>{t.push(m=e.routeName),s[m]={directions:e}})),i.forEach((e=>{-1===t.indexOf(m=e.attributes.Name)&&(t.push(m),s[m]={}),f(e.geometry)&&(e.geometry.spatialReference=y),s[m].route=e})),o.forEach((e=>{h=e.attributes,-1===t.indexOf(m=h.RouteName||p)&&(t.push(m),s[m]={}),m!==p&&(v=!1),f(e.geometry)&&(e.geometry.spatialReference=y),null==s[m].stops&&(s[m].stops=[]),s[m].stops.push(e)})),o.length>0&&!0===v&&(s[t[0]].stops=s[p].stops,delete s[p],t.splice(t.indexOf(p),1));const g=t.map((e=>(s[e].routeName=e===p?null:e,s[e])));return $.fromJSON({routeResults:g,pointBarriers:l,polygonBarriers:u,polylineBarriers:c,messages:d})}function W(e,t){for(let s=0;s<t.length;s++){const r=e[t[s]];if(r&&r.length)for(const e of r)if(f(e)&&e.hasZ)return!0}return!1}async function Y(e,t,s){if(!e)throw new y("network-service:missing-url","Url to Network service is missing");const r=A({f:"json",token:t},s),{data:i}=await g(e,r);i.supportedTravelModes||(i.supportedTravelModes=[]);for(let e=0;e<i.supportedTravelModes.length;e++)i.supportedTravelModes[e].id||(i.supportedTravelModes[e].id=i.supportedTravelModes[e].itemId);const n=i.currentVersion>=10.4?async function(e,t,s){try{const r=A({f:"json",token:t},s),i=T(e)+"/retrieveTravelModes",{data:{supportedTravelModes:n,defaultTravelMode:o}}=await g(i,r);return{supportedTravelModes:n,defaultTravelMode:o}}catch(e){throw new y("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:e})}}(e,t,s):async function(e,t){var s,r;const i=A({f:"json"},t),{data:n}=await g(e.replace(/\/rest\/.*$/i,"/info"),i);if(!n||!n.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:o}=n,a=T(o)+"/sharing/rest/portals/self",{data:l}=await g(a,i),u=N("helperServices.routingUtilities.url",l);if(!u)return{supportedTravelModes:[],defaultTravelMode:null};const c=w(o),d=/\/solve$/i.test(c.path)?"Route":/\/solveclosestfacility$/i.test(c.path)?"ClosestFacility":"ServiceAreas",p=A({f:"json",serviceName:d},t),m=T(u)+"/GetTravelModes/execute",h=await g(m,p),v=[];let f=null;if(null!=h&&null!=(s=h.data)&&null!=(r=s.results)&&r.length){const e=h.data.results;for(const t of e){var y;if("supportedTravelModes"===t.paramName){if(null!=(y=t.value)&&y.features)for(const{attributes:e}of t.value.features)if(e){const t=JSON.parse(e.TravelMode);v.push(t)}}else"defaultTravelMode"===t.paramName&&(f=t.value)}}return{supportedTravelModes:v,defaultTravelMode:f}}(e,s),{defaultTravelMode:o,supportedTravelModes:a}=await n;return i.defaultTravelMode=o,i.supportedTravelModes=a,I.fromJSON(i)}export{L as a,Y as b,Z as c,W as d,z as f,S as o,V as p,_ as u}