import{h as t}from"./p-54330161.js";import{c as e,A as n,al as r,aE as o,bC as s,c0 as i,bm as a,aw as l,h as c,af as f,s as u,n as p,bu as m,_ as h,e as d,d as w,i as y}from"./p-e58503d5.js";import{m as g}from"./p-efbca0ca.js";import{n as x,f as b,r as v}from"./p-d3105731.js";import{v as j}from"./p-b79fcce3.js";import{q as A,a as M,l as F,x as O,k as R}from"./p-9bdf9304.js";import{y as P,f as $,a as S}from"./p-568eb6e8.js";import{r as C,k as U,x as z,b as E,O as T}from"./p-c6ceae9e.js";import{o as k}from"./p-e72a43d7.js";import{w as L,v as B}from"./p-c93d2280.js";import{a as G}from"./p-b9aa4901.js";import{e as I}from"./p-8f986f60.js";import{e as D}from"./p-2c84c65f.js";import{u as V,L as J,a as N,o as _,c as q,I as W,d as Z}from"./p-2f398ed1.js";import{d as H}from"./p-01e5a461.js";import{v as K,F as Q,B as X,M as Y,_ as tt,R as et}from"./p-c7a58085.js";import{r as nt,f as rt}from"./p-ccdb8e80.js";import ot from"./p-dc852195.js";import"./p-93765525.js";import"./p-765e6c28.js";import"./p-a9a30646.js";import"./p-8747982c.js";import"./p-8bc9b36a.js";import"./p-7a658388.js";import"./p-e273719b.js";import"./p-74de0937.js";import"./p-fb38a9d0.js";import"./p-f94762ac.js";import"./p-ea916a39.js";import"./p-8a919d07.js";import"./p-c048b814.js";import"./p-53bb6ab4.js";import"./p-a3955219.js";import"./p-de5b11d6.js";import"./p-f06611ed.js";import"./p-e6fe5d89.js";import"./p-2f5c7e83.js";import"./p-97ec6ae5.js";import"./p-382f7028.js";import"./p-fea9512d.js";import"./p-a131049b.js";import"./p-a2324023.js";const st=e.getLogger("esri.geometry.support.meshUtils.centerAt");const it=x(),at=x();function lt(t){const e=i(t.url);return n=>{var r;const o=s(n,e,e),i=o?o.replace(/^ *\.\//,""):null;return null!=(r=t.files.get(i))?r:n}}async function ct(t,e){return t instanceof Blob?ut.fromBlob(t):"string"==typeof t?new ut(t):Array.isArray(t)?ft(t,e):async function(t,e){const{default:n}=await r(import("./p-e58503d5.js").then((function(t){return t.dY})),e),o="string"==typeof t.multipart[0]?await Promise.all(t.multipart.map((async t=>(await n(t,{responseType:"array-buffer"})).data))):t.multipart;return ut.fromBlob(new Blob(o))}(t,e)}async function ft(t,e){const n=new Map;let r=null;const o=await a(t.map((async t=>({name:t.name,source:await ct(t instanceof Blob?t:t.source,e)})))),s=[];for(const t of o)t&&(l(e)?t.source.dispose():s.push(t));c(e);for(const{name:t,source:e}of s)(f(r)||/\.(gltf|glb)/i.test(t))&&(r=e.url),n.set(t,e.url),e.files&&e.files.forEach(((t,e)=>n.set(e,t)));if(f(r))throw new u("mesh-load-external:missing-files","Missing files to load external mesh source");return new ut(r,(()=>s.forEach((({source:t})=>t.dispose()))),n)}class ut{constructor(t,e=(()=>{}),n=new Map){this.url=t,this.dispose=e,this.files=n}static fromBlob(t){const e=URL.createObjectURL(t);return new ut(e,(()=>URL.revokeObjectURL(e)))}}const pt=e.getLogger("esri.geometry.support.meshUtils.offset");function mt(t,e,r){t.vertexAttributes&&t.vertexAttributes.position&&(n(t.transform)?(null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&pt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e){const n=t.origin;t.origin=V(x(),n,e)}(t.transform,e)):C(t.spatialReference,r)?function(t,e){const r=t.spatialReference,o=t.vertexAttributes.position,s=t.vertexAttributes.normal,i=t.vertexAttributes.tangent,a=new Float64Array(o.length),l=n(s)?new Float32Array(s.length):null,c=n(i)?new Float32Array(i.length):null,f=t.extent.center,u=dt;B(r,[f.x,f.y,f.z],wt,H(r)),G(yt,wt),J(u,e,yt),K(o,r,a),n(s)&&Q(s,o,a,r,l),n(i)&&X(i,o,a,r,c),ht(a,u),Y(a,o,r),n(s)&&tt(l,o,a,r,s),n(i)&&et(c,o,a,r,i),t.vertexAttributesChanged()}(t,e):function(t,e){ht(t.vertexAttributes.position,e),t.vertexAttributesChanged()}(t,e))}function ht(t,e){if(t)for(let n=0;n<t.length;n+=3)for(let r=0;r<3;r++)t[n+r]+=e[r]}const dt=x(),wt=D(),yt=I(),gt={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function xt(t,e,n){(function(t){for(let e=0;e<t.position.length;e+=3)t.position[e+2]+=.5})(t),function(t,e){if(null==e)return;const n="number"==typeof e?[e,e,e]:[null!=e.width?e.width:1,null!=e.depth?e.depth:1,null!=e.height?e.height:1];At[0]=n[0],At[4]=n[1],At[8]=n[2];for(let e=0;e<t.position.length;e+=3){for(let n=0;n<3;n++)jt[n]=t.position[e+n];J(jt,jt,At);for(let n=0;n<3;n++)t.position[e+n]=jt[n]}if(n[0]!==n[1]||n[1]!==n[2]){At[0]=1/n[0],At[4]=1/n[1],At[8]=1/n[2];for(let e=0;e<t.normal.length;e+=3){for(let n=0;n<3;n++)jt[n]=t.normal[e+n];J(jt,jt,At),N(jt,jt);for(let n=0;n<3;n++)t.normal[e+n]=jt[n]}}}(t,n&&n.size);const{vertexAttributes:r,transform:o}=E(t,e,n);return{vertexAttributes:new P({...r,uv:t.uv}),transform:o,components:[new $({faces:t.faces,material:n&&n.material||null})],spatialReference:e.spatialReference}}const bt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},vt={south:0,east:1,north:2,west:3,up:4,down:5},jt=x(),At=I(),Mt=e.getLogger("esri.geometry.support.meshUtils.rotate");function Ft(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const o=t.spatialReference;if(n(t.transform)){var s;null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&Mt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const n=null!=(s=null==r?void 0:r.origin)?s:t.transform.getOriginPoint(o);Ot(t.transform,e,n)}else{var i;const n=null!=(i=null==r?void 0:r.origin)?i:t.origin;C(t.spatialReference,r)?Rt(t,e,n):function(t,e,n){const r=Et;if(!L(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,Mt.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Pt(t.vertexAttributes.position,e,3,r),Pt(t.vertexAttributes.normal,e,3),Pt(t.vertexAttributes.tangent,e,4),t.vertexAttributesChanged()}(t,e,n)}}function Ot(t,e,n){const r=_($t,n.x,n.y,n.z),o=q($t,r,t.origin);t.applyLocalInverse(o,St),t.rotation=A(t.rotation,e,M()),t.applyLocalInverse(o,o),q(o,o,St),t.translation=V(x(),t.translation,o)}function Rt(t,e,r){const o=t.spatialReference,s=H(o),i=Et;L(r,i,s)||L(t.origin,i,s);const a=t.vertexAttributes.position,l=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,f=new Float64Array(a.length),u=n(l)?new Float32Array(l.length):null,p=n(c)?new Float32Array(c.length):null;B(s,i,Ut,s),G(zt,Ut);const m=Ct;J(F(Ct),F(e),zt),m[3]=e[3],K(a,o,f),n(l)&&Q(l,a,f,o,u),n(c)&&X(c,a,f,o,p),Pt(f,m,3,i),Y(f,a,o),n(l)&&(Pt(u,m,3),tt(u,a,f,o,l)),n(c)&&(Pt(p,m,4),et(p,a,f,o,c)),t.vertexAttributesChanged()}function Pt(t,e,n,r=b){if(!f(t)){nt(Ut),rt(Ut,Ut,O(e),F(e));for(let e=0;e<t.length;e+=n){for(let n=0;n<3;n++)$t[n]=t[e+n]-r[n];W($t,$t,Ut);for(let n=0;n<3;n++)t[e+n]=$t[n]+r[n]}}}const $t=x(),St=x(),Ct=M(),Ut=D(),zt=I(),Et=x(),Tt=e.getLogger("esri.geometry.support.meshUtils.scale");function kt(t,e,n){const r=_(Bt,n.x,n.y,n.z),o=q(Bt,r,t.origin);t.applyLocalInverse(o,Gt);const s=Z(x(),t.scale,e);t.scale=s,t.applyLocalInverse(o,o),q(o,o,Gt),t.translation=V(x(),t.translation,o)}function Lt(t,e,n=b){if(t)for(let r=0;r<t.length;r+=3){for(let e=0;e<3;e++)Bt[e]=t[r+e]-n[e];Z(Bt,Bt,e);for(let e=0;e<3;e++)t[r+e]=Bt[e]+n[e]}}const Bt=x(),Gt=x(),It=x();var Dt;const Vt=e.getLogger("esri.geometry.Mesh");let Jt=Dt=class extends(g.LoadableMixin(p(m))){constructor(t){super(t),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new S,this.type="mesh"}initialize(){(f(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded")}get hasExtent(){return!this.loaded&&n(this.external)&&n(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const t=this.vertexAttributes.position,e=this.spatialReference;if(0===t.length||this.components&&0===this.components.length)return{extent:new h({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:e}),center:new o({x:0,y:0,z:0,spatialReference:e})};const r=n(this.transform)?this.transform.project(t,e):t;let s=1/0,i=1/0,a=1/0,l=-1/0,c=-1/0,f=-1/0,u=0,p=0,m=0;const d=r.length,w=1/(d/3);let y=0;for(;y<d;){const t=r[y++],e=r[y++],n=r[y++];s=Math.min(s,t),i=Math.min(i,e),a=Math.min(a,n),l=Math.max(l,t),c=Math.max(c,e),f=Math.max(f,n),u+=w*t,p+=w*e,m+=w*n}return{extent:new h({xmin:s,ymin:i,zmin:a,xmax:l,ymax:c,zmax:f,spatialReference:e}),center:new o({x:u,y:p,z:m,spatialReference:e})}}get anchor(){if(n(this.transform))return this.transform.getOriginPoint(this.spatialReference);const t=this.boundingInfo;return new o({x:t.center.x,y:t.center.y,z:t.extent.zmin,spatialReference:this.spatialReference})}get origin(){return n(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&n(this.external)&&n(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(t){this.loaded?(this.components||(this.components=[]),this.components.push($.from(t)),this.notifyChange("components")):Vt.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(t){if(this.loaded){if(this.components){const e=this.components.indexOf(t);if(-1!==e)return this.components.splice(e,1),void this.notifyChange("components")}Vt.error("removeComponent()","Provided component is not part of the list of components")}else Vt.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(t,e,n,r){return R(Nt.x,t,_t),R(Nt.y,e,qt),R(Nt.z,n,Wt),A(_t,qt,_t),A(_t,Wt,_t),Ft(this,_t,r),this}offset(t,e,n,r){return this.loaded?(Zt[0]=t,Zt[1]=e,Zt[2]=n,mt(this,Zt,r),this):(Vt.error("offset()","Mesh must be loaded before applying operations"),this)}scale(t,e){return this.loaded?(function(t,e,r){if(!t.vertexAttributes||!t.vertexAttributes.position)return;const o=t.spatialReference;if(n(t.transform)){var s;null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&Tt.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const n=null!=(s=null==r?void 0:r.origin)?s:t.transform.getOriginPoint(o);kt(t.transform,e,n)}else{const o=C(t.spatialReference,r),s=r&&r.origin||t.origin;o?function(t,e,r){const o=t.spatialReference,s=H(o),i=It;L(r,i,s)||L(t.origin,i,s);const a=t.vertexAttributes.position,l=t.vertexAttributes.normal,c=t.vertexAttributes.tangent,f=new Float64Array(a.length),u=n(l)?new Float32Array(l.length):null,p=n(c)?new Float32Array(c.length):null;K(a,o,f),n(l)&&Q(l,a,f,o,u),n(c)&&X(c,a,f,o,p),Lt(f,e,i),Y(f,a,o),n(l)&&tt(u,a,f,o,l),n(c)&&et(p,a,f,o,c),t.vertexAttributesChanged()}(t,e,s):function(t,e,n){const r=It;if(!L(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,Tt.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}Lt(t.vertexAttributes.position,e,r),t.vertexAttributesChanged()}(t,e,s)}}(this,t,e),this):(Vt.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(t,e){return this.loaded?(function(t,e,r){var o;if(!t.vertexAttributes||!t.vertexAttributes.position)return;const s=null!=(o=null==r?void 0:r.origin)?o:t.origin;n(t.transform)?(null!=(null==r?void 0:r.geographic)&&r.geographic!==t.transform.geographic&&st.warn(`Specifying the 'geographic' parameter (${r.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`),function(t,e,n){const r=t.origin;t.origin=[r[0]+(e.x-n.x),r[1]+(e.y-n.y),r[2]+(e.hasZ&&n.hasZ?e.z-n.z:0)]}(t.transform,e,s)):C(t.spatialReference,r)?function(t,e,n){const r=U(t.vertexAttributes,n,{geographic:!0}),{position:o,normal:s,tangent:i}=z(r,e,{geographic:!0});t.vertexAttributes.position=o,t.vertexAttributes.normal=s,t.vertexAttributes.tangent=i,t.vertexAttributesChanged()}(t,e,s):function(t,e,n){const r=at,o=it;if(L(e,o,t.spatialReference)){if(!L(n,r,t.spatialReference)){const e=t.origin;r[0]=e.x,r[1]=e.y,r[2]=e.z,st.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}(function(t,e,n){if(t)for(let r=0;r<t.length;r+=3)for(let o=0;o<3;o++)t[r+o]+=e[o]-n[o]})(t.vertexAttributes.position,o,r),t.vertexAttributesChanged()}else st.error(`Failed to project centerAt location (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid})`)}(t,e,s)}(this,t,e),this):(Vt.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(t){return n(this.external)&&this.addResolvingPromise(async function(t,e,s){const{loadGLTFMesh:i}=await r(import("./p-2399a8bd.js"),s),a=await ct(e,s),l=i(new o({x:0,y:0,z:0,spatialReference:t.spatialReference}),a.url,{resolveFile:lt(a),useTransform:!0,signal:n(s)?s.signal:null});l.then((()=>a.dispose()),(()=>a.dispose()));const{vertexAttributes:c,components:f}=await l;t.vertexAttributes=c,t.components=f}(this,this.external.source,t)),Promise.resolve(this)}clone(){const t=this.components?new Map:null,e=this.components?new Map:null,r={components:this.components?this.components.map((n=>n.cloneWithDeduplication(t,e))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:n(this.transform)?this.transform.clone():null,external:n(this.external)?{source:this.external.source,extent:n(this.external.extent)?this.external.extent.clone():null}:null};return new Dt(r)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(t){const{toBinaryGLTF:e}=await import("./p-f2a28ce5.js");return e(this,t)}static createBox(t,e){if(!(t instanceof o))return Vt.error(".createBox()","expected location to be a Point instance"),null;const r=new Dt(xt(function(){const{faceDescriptions:t,faceVertexOffsets:e,uvScales:n}=bt,r=4*t.length,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array(2*t.length*3);let l=0,c=0,f=0,u=0;for(let r=0;r<t.length;r++){const p=t[r],m=l/3;for(const t of e)a[u++]=m+t;const h=p.corners;for(let t=0;t<4;t++){const e=h[t];let r=0;i[f++]=.25*n[t][0]+p.uvOrigin[0],i[f++]=p.uvOrigin[1]-.25*n[t][1];for(let t=0;t<3;t++)0!==p.axis[t]?(o[l++]=.5*p.axis[t],s[c++]=p.axis[t]):(o[l++]=.5*e[r++],s[c++]=0)}}return{position:o,normal:s,uv:i,faces:a}}(),t,e));return e&&e.imageFace&&"all"!==e.imageFace?function(t,e){const r=t.components[0],o=r.faces,s=vt[e],i=6*s,a=new Uint32Array(6),l=new Uint32Array(o.length-6);let c=0,f=0;for(let t=0;t<o.length;t++)t>=i&&t<i+6?a[c++]=o[t]:l[f++]=o[t];if(n(t.vertexAttributes.uv)){const e=new Float32Array(t.vertexAttributes.uv),n=4*s*2,r=[0,1,1,1,1,0,0,0];for(let t=0;t<r.length;t++)e[n+t]=r[t];t.vertexAttributes.uv=e}return t.components=[new $({faces:a,material:r.material}),new $({faces:l})],t}(r,e.imageFace):r}static createSphere(t,e){return t instanceof o?new Dt(xt(function(t=0){const e=Math.round(8*2**t),n=2*e,r=(e-1)*(n+1)+2*n,o=new Float64Array(3*r),s=new Float32Array(3*r),i=new Float32Array(2*r),a=new Uint32Array((e-1)*n*2*3);let l=0,c=0,f=0,u=0;for(let t=0;t<=e;t++){const r=t/e*Math.PI+.5*Math.PI,p=Math.cos(r),m=Math.sin(r);jt[2]=m;const h=0===t||t===e,d=h?n-1:n;for(let r=0;r<=d;r++){const m=r/d*2*Math.PI;jt[0]=-Math.sin(m)*p,jt[1]=Math.cos(m)*p;for(let t=0;t<3;t++)o[l]=.5*jt[t],s[l]=jt[t],++l;i[c++]=(r+(h?.5:0))/n,i[c++]=t/e,0!==t&&r!==n&&(t!==e&&(a[f++]=u,a[f++]=u+1,a[f++]=u-n),1!==t&&(a[f++]=u,a[f++]=u-n,a[f++]=u-n-1)),u++}}return{position:o,normal:s,uv:i,faces:a}}(e&&e.densificationFactor||0),t,e)):(Vt.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(t,e){return t instanceof o?new Dt(xt(function(t=0){const e=Math.round(16*2**t),n=4*(e+1)+2*e,r=new Float64Array(3*n),o=new Float32Array(3*n),s=new Float32Array(2*n),i=new Uint32Array(4*e*3);let a=0,l=0,c=0,f=0,u=0;for(let t=0;t<=5;t++){const n=0===t||5===t,p=t<=1||t>=4,m=2===t||4===t,h=n?e-1:e;for(let d=0;d<=h;d++){const w=d/h*2*Math.PI,y=n?0:.5;jt[0]=y*Math.sin(w),jt[1]=y*-Math.cos(w),jt[2]=t<=2?.5:-.5;for(let e=0;e<3;e++)r[a++]=jt[e],o[l++]=p?2===e?t<=1?1:-1:0:2===e?0:jt[e]/y;s[c++]=(d+(n?.5:0))/e,s[c++]=t<=1?1*t/3:t<=3?1*(t-2)/3+1/3:1*(t-4)/3+2/3,m||0===t||d===e||(5!==t&&(i[f++]=u,i[f++]=u+1,i[f++]=u-e),1!==t&&(i[f++]=u,i[f++]=u-e,i[f++]=u-e-1)),u++}}return{position:r,normal:o,uv:s,faces:i}}(e&&e.densificationFactor||0),t,e)):(Vt.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(t,e){return t instanceof o?new Dt(xt(function(t){const e=gt.facingAxisOrderSwap[t],n=gt.position,r=gt.normal,o=new Float64Array(n.length),s=new Float32Array(r.length);let i=0;for(let t=0;t<4;t++){const t=i;for(let a=0;a<3;a++){const l=e[a],c=Math.abs(l)-1,f=l>=0?1:-1;o[i]=n[t+c]*f,s[i]=r[t+c]*f,i++}}return{position:o,normal:s,uv:new Float32Array(gt.uv),faces:new Uint32Array(gt.faces)}}(e&&e.facing||"up"),t,e)):(Vt.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(t,e){if(!(t instanceof j))return Vt.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=k(t);return new Dt({vertexAttributes:new S({position:n.position}),components:[new $({faces:n.faces,shading:"flat",material:e&&e.material||null})],spatialReference:t.spatialReference})}static async createFromGLTF(t,e,n){if(!(t instanceof o))throw Vt.error(".createfromGLTF()","expected location to be a Point instance"),new u("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:s}=await r(import("./p-2399a8bd.js"),n);return new Dt(await s(t,e,n))}static createWithExternalSource(t,e,n){var r,o,s;const i=null!=(r=null==n?void 0:n.extent)?r:null,a=null!=(o=null==n?void 0:n.transform.clone())?o:new T;return a.origin=[t.x,t.y,null!=(s=t.z)?s:0],new Dt({external:{source:e,extent:i},transform:a,spatialReference:t.spatialReference})}static createIncomplete(t,e){var n,r;const o=null!=(n=null==e?void 0:e.transform.clone())?n:new T;o.origin=[t.x,t.y,null!=(r=t.z)?r:0];const s=new Dt({transform:o,spatialReference:t.spatialReference});return s.addResolvingPromise(Promise.reject(new u("mesh-incomplete","Mesh resources are not complete"))),s}};d([w({type:[$],json:{write:!0}})],Jt.prototype,"components",void 0),d([w({type:T,json:{write:!0}})],Jt.prototype,"transform",void 0),d([w({constructOnly:!0})],Jt.prototype,"external",void 0),d([w({readOnly:!0})],Jt.prototype,"hasExtent",null),d([w({readOnly:!0})],Jt.prototype,"boundingInfo",null),d([w({readOnly:!0})],Jt.prototype,"anchor",null),d([w({readOnly:!0})],Jt.prototype,"origin",null),d([w({readOnly:!0,json:{read:!1}})],Jt.prototype,"extent",null),d([w({readOnly:!0,json:{read:!1,write:!0,default:!0}})],Jt.prototype,"hasZ",void 0),d([w({readOnly:!0,json:{read:!1,write:!0,default:!1}})],Jt.prototype,"hasM",void 0),d([w({type:S,nonNullable:!0,json:{write:!0}})],Jt.prototype,"vertexAttributes",void 0),Jt=Dt=d([y("esri.geometry.Mesh")],Jt);const Nt={x:v(1,0,0),y:v(0,1,0),z:v(0,0,1)},_t=M(),qt=M(),Wt=M(),Zt=x(),Ht=Jt;function Kt(e,r,o){const s=o.features;o.features=[],delete o.geometryType;const i=ot.fromJSON(o);i.geometryType="mesh";const a=i.spatialReference,l=f(e.outFields)||!e.outFields.length?()=>({}):function(t){return({attributes:e})=>{if(!e)return{};if(!t)return e;for(const n in e)t.has(n)||delete e[n];return e}}(e.outFields.includes("*")?null:new Set(e.outFields));for(const e of s){const o=Qt(e,a,r);n(o)&&i.features.push(new t({geometry:o,attributes:l(e)}))}return i}function Qt(t,e,n){const{status:r,source:s}=function(t){if(!t.assetMappings)return{status:0};const e=[],n=new Map;for(const r of t.assetMappings){const t=r.seqNo,o=r.assetName,s=r.assetURL,i=r.conversionStatus;if("FAILED"===i)return{status:0};if("COMPLETED"!==i)return{status:1};if(null==t)e.push({name:o,source:s});else{const r=n.get(o);let i;r?i=r.multipart:(i=[],e.push({name:o,source:{multipart:i}}),n.set(o,{multipart:i})),i[t]=s}}return{status:2,source:e}}(t);if(0===r)return null;const i=function({attributes:t},e,{transformFieldRoles:n}){return new o({x:t[n.originX],y:t[n.originY],z:t[n.originZ],spatialReference:e})}(t,e,n),a=h.fromJSON(t.geometry);a.spatialReference=e;const l=function({attributes:t,assetMappings:e},{transformFieldRoles:n}){var r;return new T({translation:[t[n.translationX],t[n.translationY],t[n.translationZ]],rotation:R([t[n.rotationX],t[n.rotationY],t[n.rotationZ]],t[n.rotationDeg]),scale:[t[n.scaleX],t[n.scaleY],t[n.scaleZ]],geographic:!(null!=(r=e.flags)&&r.includes("PROJECT_VERTICES"))})}(t,n);return 1===r?Ht.createIncomplete(i,{extent:a,transform:l}):Ht.createWithExternalSource(i,s,{extent:a,transform:l})}export{Kt as meshFeatureSetFromJSON}