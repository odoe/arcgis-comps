import{A as t,V as s,af as i}from"./p-e58503d5.js";import{r as h,M as n,h as e,f as r}from"./p-b9aa4901.js";import{C as o}from"./p-6484267b.js";import{h as a,f as c}from"./p-19bc1e3d.js";import"./p-0bb84768.js";import{e as l}from"./p-4414d64f.js";import{r as u}from"./p-1ccb0bf6.js";class f{constructor(t){this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=t}}class w{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}}function y(t,s,i,h,n,e){const r=i-n;if(r>=0)return(s>>r)+(h-(e<<r))*(t>>r);const o=-r;return s-(e-(h<<o))*(t>>o)<<o}class d{constructor(t,s,i){this._rows=Math.ceil(s/i),this._columns=Math.ceil(t/i),this._cellSize=i,this.cells=new Array(this._rows);for(let t=0;t<this._rows;t++){this.cells[t]=new Array(this._columns);for(let s=0;s<this._columns;s++)this.cells[t][s]=[]}}getCell(t,s){const i=Math.min(Math.max(Math.floor(s/this._cellSize),0),this._rows-1),h=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._columns-1);return this.cells[i]&&this.cells[i][h]||null}getCellSpan(t,s,i,h){return[Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(i/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(h/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function p(t,s,i,h,n,e){const r=s[h++];for(let o=0;o<r;o++){const r=new f(e);r.xTile=s[h++],r.yTile=s[h++],r.hash=s[h++],r.priority=s[h++];const o=s[h++];for(let t=0;t<o;t++){const t=s[h++],n=s[h++],e=s[h++],o=s[h++],a=!!s[h++],c=s[h++],l=i[h++],u=i[h++],f=s[h++],w=s[h++];r.colliders.push({xTile:t,yTile:n,dxPixels:e,dyPixels:o,hard:a,partIndex:c,width:f,height:w,minLod:l,maxLod:u})}const a=t[h++];for(let s=0;s<a;s++)r.textVertexRanges.push([t[h++],t[h++]]);const c=t[h++];for(let s=0;s<c;s++)r.iconVertexRanges.push([t[h++],t[h++]]);n.push(r)}return h}function g(t,s,i){for(const[h,n]of t.symbols)m(t,s,i,n,h)}function m(t,s,i,h,n){const e=t.layerData.get(n);if(3===e.type){for(const s of h){const h=s.unique;let n;if(s.selectedForRendering){const s=h.parts[0],e=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*e)|r<<7:r?255:0;n=o<<24|o<<16|o<<8|o}else n=0;for(const[t,i]of s.iconVertexRanges)for(let s=t;s<t+i;s+=4)e.iconOpacity[s/4]=n;if(s.selectedForRendering){const s=h.parts[1],e=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*e)|r<<7:r?255:0;n=o<<24|o<<16|o<<8|o}else n=0;for(const[t,i]of s.textVertexRanges)for(let s=t;s<t+i;s+=4)e.textOpacity[s/4]=n}e.lastOpacityUpdate=s,e.opacityChanged=!0}}class A{constructor(t,s){this.layerUIDs=[],this.isDestroyed=!1,this.data=t,this.memoryUsed=t.byteLength;let i=1;const h=new Uint32Array(t);this.layerUIDs=[];const n=h[i++];for(let t=0;t<n;t++)this.layerUIDs[t]=h[i++];this.bufferDataOffset=i,s&&(this.layer=s.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return i(this.data)}get offset(){return this.bufferDataOffset}destroy(){this.isDestroyed||(this.doDestroy(),this.isDestroyed=!0)}prepareForRendering(t){i(this.data)||(this.doPrepareForRendering(t,this.data,this.bufferDataOffset),this.data=null)}}class M extends A{constructor(t,s){super(t,s),this.type=2,this.lineIndexStart=0,this.lineIndexCount=0;const i=new Uint32Array(t);let h=this.bufferDataOffset;this.lineIndexStart=i[h++],this.lineIndexCount=i[h++];const n=i[h++];if(n>0){const t=new Map;for(let s=0;s<n;s++){const s=i[h++],n=i[h++],e=i[h++];t.set(s,[n,e])}this.patternMap=t}this.bufferDataOffset=h}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){t(this.lineVertexArrayObject)&&this.lineVertexArrayObject.dispose(),t(this.lineVertexBuffer)&&this.lineVertexBuffer.dispose(),t(this.lineIndexBuffer)&&this.lineIndexBuffer.dispose(),this.lineVertexArrayObject=null,this.lineVertexBuffer=null,this.lineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(t,s,i){const h=new Uint32Array(s),n=new Int32Array(h.buffer),e=h[i++];this.lineVertexBuffer=a.createVertex(t,35044,new Int32Array(n.buffer,4*i,e)),i+=e;const r=h[i++];this.lineIndexBuffer=a.createIndex(t,35044,new Uint32Array(h.buffer,4*i,r)),i+=r;const o=this.layer.lineMaterial;this.lineVertexArrayObject=new c(t,o.getAttributeLocations(),o.getLayoutInfo(),{geometry:this.lineVertexBuffer},this.lineIndexBuffer)}}class U extends A{constructor(t,s){super(t,s),this.type=1,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const i=new Uint32Array(t);let h=this.bufferDataOffset;this.fillIndexStart=i[h++],this.fillIndexCount=i[h++],this.outlineIndexStart=i[h++],this.outlineIndexCount=i[h++];const n=i[h++];if(n>0){const t=new Map;for(let s=0;s<n;s++){const s=i[h++],n=i[h++],e=i[h++];t.set(s,[n,e])}this.patternMap=t}this.bufferDataOffset=h}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){t(this.fillVertexArrayObject)&&this.fillVertexArrayObject.dispose(),t(this.fillVertexBuffer)&&this.fillVertexBuffer.dispose(),t(this.fillIndexBuffer)&&this.fillIndexBuffer.dispose(),this.fillVertexArrayObject=null,this.fillVertexBuffer=null,this.fillIndexBuffer=null,t(this.outlineVertexArrayObject)&&this.outlineVertexArrayObject.dispose(),t(this.outlineVertexBuffer)&&this.outlineVertexBuffer.dispose(),t(this.outlineIndexBuffer)&&this.outlineIndexBuffer.dispose(),this.outlineVertexArrayObject=null,this.outlineVertexBuffer=null,this.outlineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(t,s,i){const h=new Uint32Array(s),n=new Int32Array(h.buffer),e=h[i++];this.fillVertexBuffer=a.createVertex(t,35044,new Int32Array(n.buffer,4*i,e)),i+=e;const r=h[i++];this.fillIndexBuffer=a.createIndex(t,35044,new Uint32Array(h.buffer,4*i,r)),i+=r;const o=h[i++];this.outlineVertexBuffer=a.createVertex(t,35044,new Int32Array(n.buffer,4*i,o)),i+=o;const l=h[i++];this.outlineIndexBuffer=a.createIndex(t,35044,new Uint32Array(h.buffer,4*i,l)),i+=l;const u=this.layer,f=u.fillMaterial,w=u.outlineMaterial;this.fillVertexArrayObject=new c(t,f.getAttributeLocations(),f.getLayoutInfo(),{geometry:this.fillVertexBuffer},this.fillIndexBuffer),this.outlineVertexArrayObject=new c(t,w.getAttributeLocations(),w.getLayoutInfo(),{geometry:this.outlineVertexBuffer},this.outlineIndexBuffer)}}class I extends A{constructor(t,s,i){super(t,s),this.type=3,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const h=new Uint32Array(t),n=new Int32Array(t),e=new Float32Array(t);let r=this.bufferDataOffset;this.isIconSDF=!!h[r++];const o=h[r++];for(let t=0;t<o;t++){const t=h[r++],s=h[r++],i=h[r++];this.iconPerPageElementsMap.set(t,[s,i])}const a=h[r++];for(let t=0;t<a;t++){const t=h[r++],s=h[r++],i=h[r++];this.glyphPerPageElementsMap.set(t,[s,i])}const c=h[r++],l=h[r++];this.iconOpacity=new Int32Array(c),this.textOpacity=new Int32Array(l),r=p(h,n,e,r,this.symbols,i),this.bufferDataOffset=r}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let t=0;for(const[s,i]of this.iconPerPageElementsMap)t+=i[1];for(const[s,i]of this.glyphPerPageElementsMap)t+=i[1];return t/3}doDestroy(){t(this.iconVertexArrayObject)&&this.iconVertexArrayObject.dispose(),t(this.iconVertexBuffer)&&this.iconVertexBuffer.dispose(),t(this.iconOpacityBuffer)&&this.iconOpacityBuffer.dispose(),t(this.iconIndexBuffer)&&this.iconIndexBuffer.dispose(),this.iconVertexArrayObject=null,this.iconVertexBuffer=null,this.iconOpacityBuffer=null,this.iconIndexBuffer=null,t(this.textVertexArrayObject)&&this.textVertexArrayObject.dispose(),t(this.textVertexBuffer)&&this.textVertexBuffer.dispose(),t(this.textOpacityBuffer)&&this.textOpacityBuffer.dispose(),t(this.textIndexBuffer)&&this.textIndexBuffer.dispose(),this.textVertexArrayObject=null,this.textVertexBuffer=null,this.textOpacityBuffer=null,this.textIndexBuffer=null,this.memoryUsed=0}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const t=s(this.iconOpacity),i=s(this.iconOpacityBuffer);t.length>0&&t.byteLength===i.size&&i.setSubData(t);const h=s(this.textOpacity),n=s(this.textOpacityBuffer);h.length>0&&h.byteLength===n.size&&n.setSubData(h)}doPrepareForRendering(t,i,h){const n=new Uint32Array(i),e=new Int32Array(n.buffer),r=n[h++];this.iconVertexBuffer=a.createVertex(t,35044,new Int32Array(e.buffer,4*h,r)),h+=r;const o=n[h++];this.iconIndexBuffer=a.createIndex(t,35044,new Uint32Array(n.buffer,4*h,o)),h+=o;const l=n[h++];this.textVertexBuffer=a.createVertex(t,35044,new Int32Array(e.buffer,4*h,l)),h+=l;const u=n[h++];this.textIndexBuffer=a.createIndex(t,35044,new Uint32Array(n.buffer,4*h,u)),h+=u,this.iconOpacityBuffer=a.createVertex(t,35044,s(this.iconOpacity).buffer),this.textOpacityBuffer=a.createVertex(t,35044,s(this.textOpacity).buffer);const f=this.layer,w=f.iconMaterial,y=f.textMaterial;this.iconVertexArrayObject=new c(t,w.getAttributeLocations(),w.getLayoutInfo(),{geometry:this.iconVertexBuffer,opacity:this.iconOpacityBuffer},this.iconIndexBuffer),this.textVertexArrayObject=new c(t,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:this.textVertexBuffer,opacity:this.textOpacityBuffer},this.textIndexBuffer)}}class b extends A{constructor(t,s){super(t,s),this.type=4,this.circleIndexStart=0,this.circleIndexCount=0;const i=new Uint32Array(t);let h=this.bufferDataOffset;this.circleIndexStart=i[h++],this.circleIndexCount=i[h++],this.bufferDataOffset=h}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){t(this.circleVertexArrayObject)&&this.circleVertexArrayObject.dispose(),t(this.circleVertexBuffer)&&this.circleVertexBuffer.dispose(),t(this.circleIndexBuffer)&&this.circleIndexBuffer.dispose(),this.circleVertexArrayObject=null,this.circleVertexBuffer=null,this.circleIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(t,s,i){const h=new Uint32Array(s),n=new Int32Array(h.buffer),e=h[i++];this.circleVertexBuffer=a.createVertex(t,35044,new Int32Array(n.buffer,4*i,e)),i+=e;const r=h[i++];this.circleIndexBuffer=a.createIndex(t,35044,new Uint32Array(h.buffer,4*i,r)),i+=r;const o=this.layer.circleMaterial;this.circleVertexArrayObject=new c(t,o.getAttributeLocations(),o.getLayoutInfo(),{geometry:this.circleVertexBuffer},this.circleIndexBuffer)}}class x extends u{constructor(t,s,i,h,n,e,r=null){super(t,s,i,h,n,4096,4096),this._memCache=r,this.type="vector-tile",this._referenced=0,this._hasSymbolBuckets=!1,this._memoryUsedByLayerData=0,this.layerData=new Map,this.layerCount=0,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.invalidating=!1,this.parentTile=null,this.childrenTiles=new Set,this._processed=!1,this._referenced=1,this.styleRepository=e,this.id=t.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<l}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<l)}get wasRequested(){return"errored"===this.status||"loaded"===this.status||"reloading"===this.status}setData(t){this.changeDataImpl(t),this.requestRender(),this.ready(),this.invalidating=!1,this._processed=!0}deleteLayerData(s){let i=!1;for(const t of s)if(this.layerData.has(t)){const s=this.layerData.get(t);this._memoryUsedByLayerData-=s.memoryUsed,3===s.type&&this.symbols.has(t)&&(this.symbols.delete(t),i=!0),s.destroy(),this.layerData.delete(t),this.layerCount--}t(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData),i&&this.emit("symbols-changed"),this.requestRender()}processed(){return this._processed}hasData(){return this.layerCount>0}dispose(){"unloaded"!==this.status&&(D.delete(this),x._destroyRenderBuckets(this.layerData),this.layerData=null,this.layerCount=0,this._memoryUsedByLayerData=0,this.destroy(),this.status="unloaded")}release(){return 0==--this._referenced&&(this.dispose(),this.stage=null,!0)}retain(){++this._referenced}get referenced(){return this._referenced}get memoryUsage(){return(this._memoryUsedByLayerData+256)/(this._referenced||1)}changeDataImpl(s){let i=!1;if(s){const h=this._createRenderBuckets(s);for(const[t,s]of h){if(this.layerData.has(t)){const i=this.layerData.get(t);this._memoryUsedByLayerData-=s.memoryUsed,i.destroy(),this.layerData.delete(t),this.layerCount--}3===s.type&&(this.symbols.set(t,s.symbols),i=!0),this._memoryUsedByLayerData+=s.memoryUsed,this.layerData.set(t,s),this.layerCount++}t(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData)}this._hasSymbolBuckets=!1;for(const[t,s]of this.layerData)3===s.type&&(this._hasSymbolBuckets=!0);i&&this.emit("symbols-changed")}attachWithContext(t){this.stage={context:t,trashDisplayObject(t){t.processDetach()},untrashDisplayObject:()=>!1}}setTransform(t,s){super.setTransform(t,s);const i=s/(t.resolution*t.pixelRatio),o=this.width/this.rangeX*i,a=this.height/this.rangeY*i,c=[0,0];t.toScreen(c,[this.x,this.y]);const l=this.transforms.tileUnitsToPixels;h(l),n(l,l,c),e(l,l,Math.PI*t.rotation/180),r(l,l,[o,a,1])}_createTransforms(){return{dvs:o(),tileMat3:o(),tileUnitsToPixels:o()}}static _destroyRenderBuckets(t){if(!t)return;const s=new Set;t.forEach((t=>{s.has(t)||(t.destroy(),s.add(t))})),t.clear()}_createRenderBuckets(t){const s=new Map,i=new Map;for(const h of t){const t=this._deserializeBucket(h,i);for(const i of t.layerUIDs)s.set(i,t)}return s}_deserializeBucket(t,s){let i=s.get(t);if(i)return i;switch(new Uint32Array(t)[0]){case 1:i=new U(t,this.styleRepository);break;case 2:i=new M(t,this.styleRepository);break;case 3:i=new I(t,this.styleRepository,this);break;case 4:i=new b(t,this.styleRepository)}return s.set(t,i),i}}const D=new Map;function F(){D.forEach(((t,s)=>{console.log(`\n${s.key}:`),t[0].forEach((t=>console.log(t))),console.log("========"),t[1].forEach((t=>console.log(t)))}))}export{x as d,g as h,y as l,d as o,w as s,F as u}