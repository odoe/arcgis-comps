import{N as t,e,d as o,a2 as r,a3 as i,a0 as s,i as n,a1 as l,A as p,V as a}from"./p-e58503d5.js";import{i as u}from"./p-b79fcce3.js";import{h as m}from"./p-54330161.js";import{d as c,c as f}from"./p-c048b814.js";import{y}from"./p-a131049b.js";import"./p-53bb6ab4.js";import"./p-93765525.js";import"./p-765e6c28.js";import"./p-a9a30646.js";import"./p-8747982c.js";import"./p-8bc9b36a.js";import"./p-7a658388.js";import"./p-e273719b.js";import"./p-74de0937.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-fb38a9d0.js";import"./p-f94762ac.js";import"./p-ea916a39.js";import"./p-8a919d07.js";import"./p-efbca0ca.js";import"./p-a2324023.js";const d=new t({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let h=class extends l{constructor(t){super(t),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(t,e){const o=s.fromJSON(e.spatialReference),r=[];for(let e=0;e<t.length;e++){const i=t[e],s=m.fromJSON(i),n=i.geometry&&i.geometry.spatialReference;p(s.geometry)&&!n&&(s.geometry.spatialReference=o),r.push(s)}return r}writeGeometryType(t,e,o,r){if(t)return void d.write(t,e,o,r);const{features:i}=this;if(i)for(const t of i)if(t&&p(t.geometry))return void d.write(t.geometry.type,e,o,r)}readQueryGeometry(t,e){if(!t)return null;const o=!!t.spatialReference,r=c(t);return!o&&e.spatialReference&&(r.spatialReference=s.fromJSON(e.spatialReference)),r}writeSpatialReference(t,e){if(t)return void(e.spatialReference=t.toJSON());const{features:o}=this;if(o)for(const t of o)if(t&&p(t.geometry)&&t.geometry.spatialReference)return void(e.spatialReference=t.geometry.spatialReference.toJSON())}toJSON(t){const e=this.write();if(e.features&&Array.isArray(t)&&t.length>0)for(let o=0;o<e.features.length;o++){const r=e.features[o];if(r.geometry){const e=t&&t[o];r.geometry=e&&e.toJSON()||r.geometry}}return e}quantize(t){const{scale:[e,o],translate:[r,i]}=t,s=this.features,n=this._getQuantizationFunction(this.geometryType,(t=>Math.round((t-r)/e)),(t=>Math.round((i-t)/o)));for(let t=0,e=s.length;t<e;t++)n(a(s[t].geometry))||(s.splice(t,1),t--,e--);return this.transform=t,this}unquantize(){const{geometryType:t,features:e,transform:o}=this;if(!o)return this;const{translate:[r,i],scale:[s,n]}=o,l=this._getHydrationFunction(t,(t=>t*s+r),(t=>i-t*n));for(const{geometry:t}of e)p(t)&&l(t);return this.transform=null,this}_quantizePoints(t,e,o){let r,i;const s=[];for(let n=0,l=t.length;n<l;n++){const l=t[n];if(n>0){const t=e(l[0]),n=o(l[1]);t===r&&n===i||(s.push([t-r,n-i]),r=t,i=n)}else r=e(l[0]),i=o(l[1]),s.push([r,i])}return s.length>0?s:null}_getQuantizationFunction(t,e,o){return"point"===t?t=>(t.x=e(t.x),t.y=o(t.y),t):"polyline"===t||"polygon"===t?t=>{const r=f(t)?t.rings:t.paths,i=[];for(let t=0,s=r.length;t<s;t++){const s=this._quantizePoints(r[t],e,o);s&&i.push(s)}return i.length>0?(f(t)?t.rings=i:t.paths=i,t):null}:"multipoint"===t?t=>{const r=this._quantizePoints(t.points,e,o);return r.length>0?(t.points=r,t):null}:"extent"===t?t=>t:null}_getHydrationFunction(t,e,o){return"point"===t?t=>{t.x=e(t.x),t.y=o(t.y)}:"polyline"===t||"polygon"===t?t=>{const r=f(t)?t.rings:t.paths;let i,s;for(let t=0,n=r.length;t<n;t++){const n=r[t];for(let t=0,r=n.length;t<r;t++){const r=n[t];t>0?(i+=r[0],s+=r[1]):(i=r[0],s=r[1]),r[0]=e(i),r[1]=o(s)}}}:"extent"===t?t=>{t.xmin=e(t.xmin),t.ymin=o(t.ymin),t.xmax=e(t.xmax),t.ymax=o(t.ymax)}:"multipoint"===t?t=>{const r=t.points;let i,s;for(let t=0,n=r.length;t<n;t++){const n=r[t];t>0?(i+=n[0],s+=n[1]):(i=n[0],s=n[1]),n[0]=e(i),n[1]=o(s)}}:void 0}};e([o({type:String,json:{write:!0}})],h.prototype,"displayFieldName",void 0),e([o({type:Boolean,json:{write:{overridePolicy:t=>({enabled:t})}}})],h.prototype,"exceededTransferLimit",void 0),e([o({type:[m],json:{write:!0}})],h.prototype,"features",void 0),e([r("features")],h.prototype,"readFeatures",null),e([o({type:[y],json:{write:!0}})],h.prototype,"fields",void 0),e([o({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:d.read}}})],h.prototype,"geometryType",void 0),e([i("geometryType")],h.prototype,"writeGeometryType",null),e([o({type:Boolean,json:{write:{overridePolicy:t=>({enabled:t})}}})],h.prototype,"hasM",void 0),e([o({type:Boolean,json:{write:{overridePolicy:t=>({enabled:t})}}})],h.prototype,"hasZ",void 0),e([o({types:u,json:{write:!0}})],h.prototype,"queryGeometry",void 0),e([r("queryGeometry")],h.prototype,"readQueryGeometry",null),e([o({type:s,json:{write:!0}})],h.prototype,"spatialReference",void 0),e([i("spatialReference")],h.prototype,"writeSpatialReference",null),e([o({json:{write:!0}})],h.prototype,"transform",void 0),h=e([n("esri.rest.support.FeatureSet")],h),h.prototype.toJSON.isDefaultToJSON=!0;const j=h;export default j;