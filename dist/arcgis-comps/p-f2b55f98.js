import{b as t,c as e,e as s,i as r,K as i,h as o,a0 as p,c9 as a,af as n,A as c,bT as l,dX as d,V as h}from"./p-e58503d5.js";import{n as m}from"./p-1a7268a2.js";import{m as f,a as u}from"./p-889f7a78.js";import{o as j,l as b,b as y,t as g,E as w}from"./p-c232e25f.js";import{p as T}from"./p-a13ee19e.js";import{B as M}from"./p-cd36fe2a.js";import"./p-53bb6ab4.js";import"./p-e273719b.js";import"./p-74de0937.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-2d0c34e5.js";import"./p-025c0c8e.js";import"./p-fb38a9d0.js";import"./p-ea916a39.js";import"./p-b79fcce3.js";import"./p-c048b814.js";import"./p-47e1bd73.js";import"./p-1e473dab.js";import"./p-d1d9dbe4.js";import"./p-e6fe5d89.js";import"./p-56ed1c7a.js";import"./p-b392deaf.js";import"./p-9790d1b4.js";import"./p-6448f4dc.js";import"./p-75cd09f2.js";import"./p-f3659a34.js";import"./p-77b9a0fc.js";import"./p-285c6a34.js";import"./p-5e833dfc.js";import"./p-7a5bfd29.js";import"./p-a9a30646.js";import"./p-a131049b.js";import"./p-a2324023.js";import"./p-e3500fdc.js";import"./p-0bb84768.js";import"./p-237460e0.js";import"./p-f94ceb31.js";import"./p-a617738c.js";import"./p-9b76ac50.js";import"./p-3a6cfd25.js";import"./p-b9c93bb2.js";import"./p-5032dfbd.js";import"./p-182bb5be.js";import"./p-db87794e.js";import"./p-2e8ad983.js";import"./p-97ec6ae5.js";import"./p-dc15ecc1.js";import"./p-765e6c28.js";import"./p-9e860e7b.js";import"./p-0923eebd.js";import"./p-4019eec3.js";import"./p-8acbca5b.js";import"./p-b05e75b2.js";import"./p-efbca0ca.js";import"./p-8a919d07.js";import"./p-81b9df84.js";import"./p-e9bae5e9.js";import"./p-b0565d49.js";import"./p-7731c620.js";import"./p-5d962998.js";import"./p-c0f84cd3.js";import"./p-8925cd73.js";import"./p-612de336.js";class R{constructor(t){this._remoteClient=t,this._resourceMap=new Map,this._inFlightResourceMap=new Map}destroy(){}async fetchResource(e,s){const r=this._resourceMap,i=r.get(e);if(i)return i;let o=this._inFlightResourceMap.get(e);if(o)return o;try{o=this._remoteClient.invoke("tileRenderer.fetchResource",{url:e},{...s}),this._inFlightResourceMap.set(e,o),o.then((t=>(this._inFlightResourceMap.delete(e),r.set(e,t),t)))}catch(e){return t(e)?null:{width:0,height:0}}return o}getResource(t){var e;return null!=(e=this._resourceMap.get(t))?e:null}}function v(t,e){return(!t.minScale||t.minScale>=e)&&(!t.maxScale||t.maxScale<=e)}function _(t){const e=t.message,s={message:{data:{},tileKey:e.tileKey,tileKeyOrigin:e.tileKeyOrigin},transferList:new Array};for(const t in e.data){const r=e.data[t];if(s.message.data[t]=null,c(r)){const e=r.stride,i=r.indices.slice(0),o=r.vertices.slice(0),p=r.records.slice(0),n={stride:e,indices:i,vertices:o,records:p,metrics:a(r.metrics,(t=>t.slice(0)))};s.transferList.push(i,o,p),s.message.data[t]=n}}return s}e.getLogger("esri.views.2d.layers.features.processors.SymbolProcessor");let K=class extends T{constructor(){super(...arguments),this.type="symbol",this._matchers={feature:null,aggregate:null},this._bufferData=new Map,this._bufferIds=new Map}initialize(){this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this))]),this._resourceManagerProxy=new R(this.remoteClient)}destroy(){this._resourceManagerProxy.destroy()}get supportsTileUpdates(){return!0}forEachBufferId(t){this._bufferIds.forEach((e=>{e.forEach(t)}))}async update(t,e){const s=e.schema.processors[0];if("symbol"!==s.type)return;const r=f(this._schema,s);u(r,"mesh")&&(i("esri-2d-update-debug")&&console.debug("Applying Update - Processor:",r),t.mesh=!0,t.why.mesh.push("Symbology changed"),this._schema=s,this._factory=this._createFactory(s),this._factory.update(s,this.tileStore.tileScheme.tileInfo))}onTileMessage(t,e,s,r){return o(r),this._onTileData(t,e,s,r)}onTileClear(t){return this._bufferData.delete(t.key.id),this._bufferIds.delete(t.key.id),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:{clear:!0}})}onTileError(t,e,s){return this.remoteClient.invoke("tileRenderer.onTileError",{tileKey:t.id,error:e},{signal:s.signal})}onTileUpdate(t){for(const e of t.removed)this._bufferData.has(e.key.id)&&this._bufferData.delete(e.key.id),this._bufferIds.has(e.key.id)&&this._bufferIds.delete(e.key.id);for(const e of t.added)this._bufferData.forEach((t=>{for(const s of t)s.message.tileKey===e.id&&this._updateTileMesh("append",e,_(s),[],!1,!1,null)}))}_addBufferData(t,e){this._bufferData.has(t)||this._bufferData.set(t,[]),this._bufferData.get(t).push(_(e))}_createFactory(t){const{geometryType:e,objectIdField:s,fields:r}=this.service,i={geometryType:e,fields:r,spatialReference:p.fromJSON(this.spatialReference)},o=new w(((t,e)=>this.remoteClient.invoke("tileRenderer.getMaterialItems",t,e)),this.tileStore.tileScheme.tileInfo),{matcher:n,aggregateMatcher:c}=t.mesh;return this._store=o,this._matchers.feature=j(n,o,i,this._resourceManagerProxy),this._matchers.aggregate=a(c,(t=>j(t,o,i,this._resourceManagerProxy))),new b(e,s,o)}async _onTileData(t,e,s,r){o(r);const{type:i,addOrUpdate:p,remove:a}=e,d=e.end,h=!!this._schema.mesh.sortKey;if(!p)return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:{type:i,addOrUpdate:null,remove:a,clear:!1,end:d,sort:h}},r);const m=this._processFeatures(t,p,s,r);try{const s=await m;if(n(s))return this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:t.id,data:{type:i,addOrUpdate:null,remove:a,clear:!1,end:d,sort:h}},r);const o=[];for(const e of s){let s=!1;const r=e.message.bufferIds,i=t.key.id,p=e.message.tileKey;if(i!==p&&c(r)){if(!this.tileStore.get(p)){this._addBufferData(i,e),o.push(e);continue}let t=this._bufferIds.get(p);t||(t=new Set,this._bufferIds.set(p,t));const a=Array.from(r);for(const e of a){if(t.has(e)){s=!0;break}t.add(e)}}s||(this._addBufferData(i,e),o.push(e))}await l(o.map((s=>{const o=t.key.id===s.message.tileKey;return this._updateTileMesh(i,t,s,o?e.remove:[],o&&e.end,e.clear,r.signal)})))}catch(e){this._handleError(t,e,r)}}async _updateTileMesh(t,e,s,r,i,p,n){const c=t,l=s.message.tileKey,d=!!this._schema.mesh.sortKey;l!==e.key.id&&(i=!1);const m=a(s,(t=>t.message)),f=a(s,(t=>t.transferList))||[],u={type:c,addOrUpdate:m,remove:r,clear:!1,end:i,sort:d},j={transferList:h(f)||[],signal:n};return o(j),this.remoteClient.invoke("tileRenderer.onTileData",{tileKey:l,data:u},j)}async _processFeatures(t,e,s,r){if(n(e)||!e.hasFeatures)return null;const i={transform:t.transform,hasZ:!1,hasM:!1},p=this._factory,a={viewingMode:"",scale:t.scale},c=await this._matchers.feature,l=await this._matchers.aggregate;o(r);const d=this._getLabelInfos(t,e);return await p.analyze(e.getCursor(),this._resourceManagerProxy,c,l,i,a),o(r),this._writeFeatureSet(t,e,i,d,p,s)}_writeFeatureSet(t,e,s,r,i,o){const p=e.getSize(),a=new y(t.key.id,{features:p,records:p,metrics:0},"simple"===this._schema.mesh.matcher.type&&this._schema.mesh.matcher.isDotDensity,o,!0),n={viewingMode:"",scale:t.scale},l=e.getCursor();for(;l.next();)try{const e=l.getDisplayId(),o=c(r)?r.get(e):null;i.writeCursor(a,l,s,n,t.level,o)}catch(t){}return a.serialize(t.tileInfoView.tileInfo.isWrappable)}_handleError(e,s,r){if(!t(s))return this.remoteClient.invoke("tileRenderer.onTileError",{tileKey:e.id,error:s.message},{signal:r.signal})}_getLabelingSchemaForScale(t){const e=this._schema.mesh.labels;if(n(e))return null;if("subtype"===e.type){const s={type:"subtype",classes:{}};let r=!1;for(const i in e.classes){const o=e.classes[i].filter((e=>v(e,t.scale)));r=r||!!o.length,s.classes[i]=o}return r?s:null}const s=e.classes.filter((e=>v(e,t.scale)));return s.length?{type:"simple",classes:s}:null}_getLabels(t,e){if("subtype"===e.type){var s;const r=d(this.service.subtypeField,"Expected to find subtype Field"),i=t.readAttribute(r);return null==i?[]:null!=(s=e.classes[i])?s:[]}return e.classes}_getLabelInfos(t,e){const s=this._getLabelingSchemaForScale(t);if(n(s))return null;const r=new Map,i=e.getCursor();for(;i.next();){const t=i.getDisplayId(),e=[],o=M(t),p=o&&1!==i.readAttribute("cluster_count")?"aggregate":"feature",a=this._getLabels(i,s);for(const s of a){if(s.target!==p)continue;const r=i.getStorage().getComputedStringAtIndex(o&&"feature"===p?i.readAttribute("referenceId"):t,s.fieldIndex);if(!r)continue;const a=m(r.toString()),n=a[1];this._store.getMosaicItem(s.symbol,g(a[0])).then((t=>{e[s.index]={glyphs:t.glyphMosaicItems,rtl:n,index:s.index}}))}r.set(t,e)}return r}};K=s([r("esri.views.2d.layers.features.processors.SymbolProcessor")],K);const E=K;export default E;