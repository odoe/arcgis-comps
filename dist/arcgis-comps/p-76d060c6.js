import{c as e,e as t,d as s,i as r,p as n,k as i,af as o,A as a,ar as c,a0 as u,dr as l,ds as h,u as d,_ as f,s as p,r as y}from"./p-e58503d5.js";import"./p-b79fcce3.js";import{z as m}from"./p-01e5a461.js";import{L as g,u as w,o as b}from"./p-2f398ed1.js";import{WhereClause as j}from"./p-61f47d2b.js";import{F as v,J as O,O as S,b as x}from"./p-c93d2280.js";import{a as F,G as R}from"./p-f94762ac.js";import{o as I,x as M,h as E,k as Q,u as k}from"./p-ea916a39.js";import{y as V}from"./p-6a92ecb9.js";import{e as C,_ as G,c as A}from"./p-85e8677e.js";import{V as T}from"./p-bfea9714.js";import q from"./p-dc852195.js";import{b as B}from"./p-5e833dfc.js";import{e as W}from"./p-8925cd73.js";import{t as _}from"./p-182bb5be.js";import{n as J}from"./p-4d38e149.js";const L=e.getLogger("esri.views.3d.layers.i3s.I3SMeshViewFilter");let Z,z=class extends n{constructor(e){super(e),this._projectionEngineLoaded=!1}initialize(){i(this,"filter.geometry").then((()=>this.loadAsyncModule(async function(){return!!Z||(Z=await import("./p-2f16d655.js")),Z}().then((e=>{this.destroyed||(this._geometryEngine=e,this.applyFilters())})))))}get sortedObjectIds(){if(o(this.filter.objectIds))return null;const e=new Float64Array(this.filter.objectIds);return e.sort(),e}get parsedWhereClause(){const e=a(this.filter)?this.filter.where:null;if(o(e)||!e)return null;try{return j.create(e,this.layerFieldsIndex)}catch(e){L.error(`Failed to parse filter where clause: ${e}`)}return null}addFilters(e,t,s,r){const n=this.sortedObjectIds;a(n)&&e.push((e=>C(n,!0,e))),this.addSqlFilter(e,this.parsedWhereClause);const i=this.parsedGeometry;if(a(i)){const n=this.spatialRelationship;e.push(((e,o)=>function(e,t,s,r,n,i,o){const a=i[0].spatialReference||r.spatialReference;if(!v(t.node.mbs,n,D,a))return void L.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");const c=P(D,a),u=function(e,t,s,r,n){const i=t.renderSpatialReference,o=new Map,a={rings:[[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]],hasZ:!1,hasM:!1,type:"polygon",spatialReference:s};a.rings[0][3]=a.rings[0][0];let c,u;switch(e){case"intersects":c=(e,t)=>Z.intersects(e,t)?0:2,u=K;break;case"contains":c=(e,t)=>Z.contains(e,t)?2:1,u=K;break;default:c=(e,t)=>Z.disjoint(e,t)?2:1,u=U}return{collection:r,object:n,type:e,maskSR:s,renderSR:i,aabbCache:o,triangle:a,positions:{indices:null,data:null,stride:0,startIndex:0,endIndex:0},triangleTest:c,geometryTest:u}}(o,r,a,s,t.objectHandle);for(const s of i){if(0===e.length)return;switch(H(s,c,o)){case 1:return void(e.length=0);case 0:continue}G(e,t.featureIds,(e=>X(s,e,u)))}}(e,o,r,t,s,i,n)))}}isMBSGeoemtryVisible(e,t,s){const r=this.parsedGeometry;if(a(r)){const n=this.spatialRelationship,i=r[0].spatialReference||t;return v(e,s,D,i)?function(e,t,s,r){const n=P(D,s);return t.every((e=>1!==H(e,n,r)))}(0,r,i,n):(L.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0)}return!0}get parsedGeometry(){if(o(this.filter))return null;if(!this._geometryEngine)return null;const{geometry:e}=this.filter;if(o(e))return null;const{distance:t,units:s}=this.filter,r=this.spatialRelationship,n="mesh"===e.type?e.extent:e;if(o(t)||0===t)return $(n,r);const i=s||m(n.spatialReference);if(n.spatialReference.isWGS84)return $(this._geometryEngine.geodesicBuffer(n,t,i),r);const l=c(n,u.WGS84);if(a(l))return $(c(this._geometryEngine.geodesicBuffer(l,t,i),n.spatialReference),r);if(!this._projectionEngineLoaded&&(this.loadAsyncModule(O().then((()=>this._projectionEngineLoaded=!0))),!this._projectionEngineLoaded))return null;let h=null;try{h=S(n,u.WGS84)}catch(e){}if(h)try{h=S(this._geometryEngine.geodesicBuffer(h,t,i),n.spatialReference)}catch(e){h=null}return h||L.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${n.spatialReference.wkid}) to WGS84.`),$(h,r)}get spatialRelationship(){return a(this.filter)?this.filter.spatialRelationship:"intersects"}static checkSupport(e){return e.timeExtent?(L.warn("Filters with a timeExtent are not supported for mesh scene layers"),!1):!!function(e){return null!=e&&N.indexOf(e)>=0}(e.spatialRelationship)||(L.warn(`Filters with spatialRelationship other than ${N.join(", ")} are not supported for mesh scene layers`),!1)}};t([s({type:V})],z.prototype,"filter",void 0),t([s()],z.prototype,"layerFieldsIndex",void 0),t([s()],z.prototype,"loadAsyncModule",void 0),t([s()],z.prototype,"applyFilters",void 0),t([s()],z.prototype,"addSqlFilter",void 0),t([s({readOnly:!0})],z.prototype,"sortedObjectIds",null),t([s({readOnly:!0})],z.prototype,"parsedWhereClause",null),t([s({readOnly:!0})],z.prototype,"parsedGeometry",null),t([s({readOnly:!0})],z.prototype,"spatialRelationship",null),t([s()],z.prototype,"_projectionEngineLoaded",void 0),t([s()],z.prototype,"_geometryEngine",void 0),z=t([r("esri.views.3d.layers.i3s.I3SMeshViewFilter")],z);const N=["contains","intersects","disjoint"];function $(e,t){if(o(e))return null;if("disjoint"===t&&"polygon"===e.type){const t=new Array(e.rings.length);for(let s=0;s<e.rings.length;++s){const r=I(1/0,1/0,-1/0,-1/0);M(r,e.rings[s]),t[s]={type:"polygon",rings:[e.rings[s]],spatialReference:e.spatialReference,aabr:r}}t.sort(((e,t)=>e.aabr[0]-t.aabr[0]));const s=new Set,r=new h;for(let e=0;e<t.length;++e){const n=t[e];for(let r=e+1;r<t.length;++r){const e=t[r];if(e.aabr[0]>=n.aabr[2])break;s.add(e)}s.forEach((e=>{if(n!==e)if(e.aabr[2]<=n.aabr[0])s.delete(e);else if(Z.intersects(n,e)){n.rings=n.rings.concat(e.rings),E(n.aabr,e.aabr,n.aabr),delete n._geVersion,s.delete(e);const i=l(t,e,t.length,r);t.splice(i,1)}})),s.add(n)}for(const e of t)delete e.aabr;return t}return[e]}const D=[0,0,0,0];function P(e,t){const s={x:e[0],y:e[1],hasZ:!1,hasM:!1,type:"point",spatialReference:t},r=t.isWGS84||t.isWebMercator?Z.geodesicBuffer(s,e[3],1):Z.buffer(s,e[3],1);return r.type="polygon",r}function H(e,t,s){switch(s){case"intersects":case"contains":return K(e,t);case"disjoint":return U(e,t)}}function K(e,t){return Z.intersects(e,t)?Z.contains(e,t)?0:2:1}function U(e,t){return Z.intersects(e,t)?Z.contains(e,t)?1:2:0}function X(e,t,s){const{collection:r,object:n,renderSR:i,maskSR:o,geometryTest:a,aabbCache:c}=s;let u=c.get(t);if(!u){const e=r.getObjectTransform(n);r.getComponentAabb(n,t,Y);const s=[[Y[0],Y[1],0],[Y[0],Y[4],0],[Y[3],Y[4],0],[Y[3],Y[1],0]];for(let t=0;t<4;++t)g(s[t],s[t],e.rotationScale),w(s[t],s[t],e.position),x(s[t],i,s[t],o);u={rings:[s],hasZ:!1,hasM:!1,type:"polygon",spatialReference:o},u.rings[0][4]=u.rings[0][0],c.set(t,u)}switch(a(e,u)){case 1:return!1;case 0:return!0}const{triangle:l,triangleTest:h,positions:d}=s,f=l.rings[0][0],p=l.rings[0][1],y=l.rings[0][2],m=r.getObjectTransform(n);r.getComponentPositions(n,t,d);const{indices:j,data:v,stride:O,startIndex:S,endIndex:F}=d;for(let t=S;t<F;t+=3){const s=O*j[t+0],r=O*j[t+1],n=O*j[t+2];if(b(f,v[s+0],v[s+1],v[s+2]),b(p,v[r+0],v[r+1],v[r+2]),b(y,v[n+0],v[n+1],v[n+2]),g(f,f,m.rotationScale),g(p,p,m.rotationScale),g(y,y,m.rotationScale),w(f,f,m.position),w(p,p,m.position),w(y,y,m.position),x(f,i,f,o),x(p,i,p,o),x(y,i,y,o),!(Math.abs((p[0]-f[0])*(y[1]-f[1])-(p[1]-f[1])*(y[0]-f[0]))<2.3283064365386963e-10))switch(delete l._geVersion,h(e,l)){case 1:return!1;case 0:return!0}}return"intersects"!==s.type}const Y=F(),ee=T;let te=class extends n{constructor(e){super(e),this._dataQueryEngineInstance=null,this._handles=new d}get defaultQueryJSON(){return new B({outSpatialReference:this.spatialReference}).toJSON()}get dataQueryEngine(){return this.ensureDataQueryEngine()}initialize(){this._handles.add(this.layerView.on("visible-geometry-changed",(()=>this.spatialIndex.events.emit("changed"))))}destroy(){this._dataQueryEngineInstance&&(this._dataQueryEngineInstance.destroy(),this._dataQueryEngineInstance=null),this._handles&&(this._handles.destroy(),this._handles=null),this._set("layerView",null)}async executeQueryForCount(e,t){return this.dataQueryEngine.executeQueryForCount(this._ensureQueryJSON(e),t)}async executeQueryForExtent(e,t){const{count:s,extent:r}=await this.dataQueryEngine.executeQueryForExtent(this._ensureQueryJSON(e),t);return{count:s,extent:f.fromJSON(r)}}async executeQueryForIds(e,t){return this.dataQueryEngine.executeQueryForIds(this._ensureQueryJSON(e),t)}async executeQuery(e,t){const s=this._ensureQueryJSON(e);if(s.returnGeometry)throw new p("feature-store:unsupported-query","returnGeometry is not yet supported for mesh scene layer queries");if(s.returnCentroid)throw new p("feature-store:unsupported-query","returnCentroid is not yet supported for mesh scene layer queries");const r=await this.dataQueryEngine.executeQuery(s,t),n=q.fromJSON(r);return n.features.forEach((e=>{e.geometry=null})),n}_ensureQueryJSON(e){if(o(e))return this.defaultQueryJSON;const t=e.toJSON();return t.outSpatialReference||(e.outSpatialReference=this.spatialReference),t}ensureDataQueryEngine(){if(this._dataQueryEngineInstance)return this._dataQueryEngineInstance;const e=this.layer.objectIdField||"OBJECTID",t=this.layer.fields.map((e=>e.toJSON())),s=this.layerView.view.resourceController.scheduler,r=this.spatialReference.toJSON();return this._dataQueryEngineInstance=new ee({hasZ:!0,hasM:!1,geometryType:"esriGeometryPolygon",fields:t,timeInfo:null,spatialReference:r,objectIdField:e,featureStore:this.spatialIndex,scheduler:s,priority:this.priority}),this._dataQueryEngineInstance}};t([s({constructOnly:!0})],te.prototype,"layerView",void 0),t([s({constructOnly:!0})],te.prototype,"priority",void 0),t([s({constructOnly:!0})],te.prototype,"spatialIndex",void 0),t([s({readOnly:!0,aliasOf:"layerView.view.spatialReference"})],te.prototype,"spatialReference",void 0),t([s({readOnly:!0,aliasOf:"layerView.i3slayer"})],te.prototype,"layer",void 0),t([s({readOnly:!0})],te.prototype,"defaultQueryJSON",null),te=t([r("esri.views.3d.layers.i3s.I3SQueryEngine")],te);const se=te;class re{constructor(e){this.objectIdField=e.objectIdField,this.getFeatureExtent=e.getFeatureExtent}getObjectId(e){return e.id}getAttributes(e){const{meta:t,index:s}=e,r={};this.objectIdField&&(r[this.objectIdField]=e.id);const n=a(t.attributeInfo)&&t.attributeInfo.attributeData;if(a(n))for(const e of Object.keys(n))r[e]=A(n[e],s);return r}getAttribute(e,t){if(t===this.objectIdField)return e.id;const{meta:s,index:r}=e,n=a(s.attributeInfo)&&s.attributeInfo.attributeData;return a(n)?A(n[t],r):null}getGeometry(e){if(e.geometry)return e.geometry;const[t,s,r,n,i]=this.getFeatureExtent(e,ne);return new _([5],[t,s,r,n,s,r,n,i,r,t,i,r,t,s,r])}getCentroid(e,t){if(e.geometry)return W(new _,e.geometry,t.hasZ,t.hasM);const[s,r,n,i,o,a]=this.getFeatureExtent(e,ne);return new _([0],[(s+i)/2,(r+o)/2,(n+a)/2])}cloneWithGeometry(e,t){const{id:s,index:r,meta:n}=e;return{id:s,index:r,meta:n,geometry:t}}}const ne=F();let ie=class extends n{constructor(e){super(e),this.events=new y}forEach(e){this.forAllFeatures((t=>(e(t),1)))}forEachBounds(e,t,s){const r=this.getFeatureExtent;for(const n of e)t(r(n,s))}forEachInBounds(e,t){this.forAllFeatures((s=>{const r=this.getFeatureExtent(s,ae);return Q(e,R(r,ce))&&t(s),1}),(t=>{if(v(t.node.mbs,this.sourceSpatialReference,oe,this.viewSpatialReference),oe[0]>=e[0]&&oe[2]<=e[2]&&oe[1]>=e[1]&&oe[3]<=e[3])return 1;const s=Math.max(e[0],Math.min(oe[0],e[2])),r=Math.max(e[1],Math.min(oe[1],e[3])),n=oe[0]-s,i=oe[1]-r;return n*n+i*i<=oe[3]*oe[3]?1:2}))}};t([s({constructOnly:!0})],ie.prototype,"featureAdapter",void 0),t([s({constructOnly:!0})],ie.prototype,"forAllFeatures",void 0),t([s({constructOnly:!0})],ie.prototype,"getFeatureExtent",void 0),t([s({constructOnly:!0})],ie.prototype,"sourceSpatialReference",void 0),t([s({constructOnly:!0})],ie.prototype,"viewSpatialReference",void 0),ie=t([r("esri.views.3d.layers.i3s.I3SQueryFeatureStore")],ie);const oe=J(),ae=F(),ce=k(),ue=ie;export{z as O,ue as a,se as d,re as n}