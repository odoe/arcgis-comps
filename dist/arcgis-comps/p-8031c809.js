import{U as t,O as n,v as e,t as o,r as s,m as r,a5 as i}from"./p-9ae46e68.js";import{b2 as c,k as f,aC as a,I as u,aH as l,aG as p,v as m,R as y,l as g,a9 as w}from"./p-566b0715.js";const h={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new c({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:f.WebMercator}),minus180Line:new c({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:f.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new c({paths:[[[180,-180],[180,180]]],spatialReference:f.WGS84}),minus180Line:new c({paths:[[[-180,-180],[-180,180]]],spatialReference:f.WGS84})}};function R(t,n){return Math.ceil((t-n)/(2*n))}function x(t,n){const e=N(t);for(const t of e)for(const e of t)e[0]+=n;return t}function N(t){return a(t)?t.rings:t.paths}function O(t){const n=(null==t?void 0:t.isWebMercator)?102100:4326;return[h[n].minX,h[n].maxX]}async function v(e,o,s,r){const i="string"==typeof e?t(e):e,c=o[0].spatialReference,f={...r,query:{...i.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:l(o[0]),geometries:o}),cutter:JSON.stringify(s)}},a=await n(i.path+"/cut",f),{cutIndexes:p,geometries:m=[]}=a.data;return{cutIndexes:p,geometries:m.map((t=>{const n=u(t);return n.spatialReference=c,n}))}}async function J(e,o,s){const r="string"==typeof e?t(e):e,i=o[0].spatialReference,c=l(o[0]),f={...s,query:{...r.query,f:"json",sr:i.wkid?i.wkid:JSON.stringify(i),geometries:JSON.stringify(L(o))}};return function(t,n,e){const o=p(n);return t.map((t=>{const n=o.fromJSON(t);return n.spatialReference=e,n}))}((await n(r.path+"/simplify",f)).data,c,i)}function L(t){return{geometryType:l(t[0]),geometries:t.map((t=>t.toJSON()))}}const S=e.getLogger("esri.geometry.support.normalizeUtils");function d(t){return"polygon"===t[0].type}function j(t){return"polyline"===t[0].type}function X(t,n,e){if(n){const n=function(t,n){if(!(t instanceof c||t instanceof m)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw S.error(t),new r(t)}const e=N(t),o=[];for(const t of e){const e=[];o.push(e),e.push([t[0][0],t[0][1]]);for(let o=0;o<t.length-1;o++){const s=t[o][0],r=t[o][1],i=t[o+1][0],c=t[o+1][1],f=Math.sqrt((i-s)*(i-s)+(c-r)*(c-r)),a=(c-r)/f,u=(i-s)/f,l=f/n;if(l>1){for(let t=1;t<=l-1;t++){const o=t*n;e.push([u*o+s,a*o+r])}const t=(f+Math.floor(l-1)*n)/2;e.push([u*t+s,a*t+r])}e.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new m({rings:o,spatialReference:t.spatialReference}):new c({paths:o,spatialReference:t.spatialReference})}(t,1e6);t=g(n,!0)}return e&&(t=x(t,e)),t}function b(t,n,e){if(Array.isArray(t)){const o=t[0];if(o>n){const e=R(o,n);t[0]=o+e*(-2*n)}else if(o<e){const n=R(o,e);t[0]=o+n*(-2*e)}}else{const o=t.x;if(o>n){const e=R(o,n);t=t.clone().offset(e*(-2*n),0)}else if(o<e){const n=R(o,e);t=t.clone().offset(n*(-2*e),0)}}return t}function I(t,n){let e=-1;for(let o=0;o<n.cutIndexes.length;o++){const s=n.cutIndexes[o],r=n.geometries[o],i=N(r);for(let t=0;t<i.length;t++){const n=i[t];n.some((e=>{if(e[0]<180)return!0;{let e=0;for(let t=0;t<n.length;t++){const o=n[t][0];e=o>e?o:e}e=Number(e.toFixed(9));const o=-360*R(e,180);for(let e=0;e<n.length;e++){const n=r.getPoint(t,e);r.setPoint(t,e,n.clone().offset(o,0))}return!0}}))}if(s===e){if(d(t))for(const n of N(r))t[s]=t[s].addRing(n);else if(j(t))for(const n of N(r))t[s]=t[s].addPath(n)}else e=s,t[s]=r}return t}async function M(t,n,e){var r;if(!Array.isArray(t))return M([t],n);const f=null!=(r=null==n?void 0:n.url)?r:i.geometryServiceUrl;let a,u,l,p,g,N,O,L,S=0;const d=[],j=[];for(const n of t)if(o(n))j.push(n);else if(a||(a=n.spatialReference,u=w(a),l=a.isWebMercator,N=l?102100:4326,p=h[N].maxX,g=h[N].minX,O=h[N].plus180Line,L=h[N].minus180Line),u)if("mesh"===n.type)j.push(n);else if("point"===n.type)j.push(b(n.clone(),p,g));else if("multipoint"===n.type){const t=n.clone();t.points=t.points.map((t=>b(t,p,g))),j.push(t)}else if("extent"===n.type){const t=n.clone()._normalize(!1,!1,u);j.push(t.rings?new m(t):t)}else if(n.extent){const t=n.extent,e=R(t.xmin,g)*(2*p);let o=0===e?n.clone():x(n.clone(),e);t.offset(e,0),t.intersects(O)&&t.xmax!==p?(S=t.xmax>S?t.xmax:S,o=X(o,l),d.push(o),j.push("cut")):t.intersects(L)&&t.xmin!==g?(S=t.xmax*(2*p)>S?t.xmax*(2*p):S,o=X(o,l,360),d.push(o),j.push("cut")):j.push(o)}else j.push(n.clone());else j.push(n);let q=R(S,p),A=-90;const T=q,U=new c;for(;q>0;){const t=360*q-180;U.addPath([[t,A],[t,-1*A]]),A*=-1,q--}if(d.length>0&&T>0){const n=I(d,await v(f,d,U,e)),o=[],r=[];for(let e=0;e<j.length;e++){const i=j[e];if("cut"!==i)r.push(i);else{const i=n.shift(),c=t[e];s(c)&&"polygon"===c.type&&c.rings&&c.rings.length>1&&i.rings.length>=c.rings.length?(o.push(i),r.push("simplify")):r.push(l?y(i):i)}}if(!o.length)return r;const i=await J(f,o,e),c=[];for(let t=0;t<r.length;t++){const n=r[t];c.push("simplify"!==n?n:l?y(i.shift()):i.shift())}return c}const z=[];for(let t=0;t<j.length;t++){const n=j[t];if("cut"!==n)z.push(n);else{const t=d.shift();z.push(!0===l?y(t):t)}}return Promise.resolve(z)}function q(t,n){const e=w(n);if(e){const[n,o]=e.valid,s=o-n;if(t<n)for(;t<n;)t+=s;if(t>o)for(;t>o;)t-=s}return t}export{q as U,O as a,R as i,h as r,N as s,M as v}