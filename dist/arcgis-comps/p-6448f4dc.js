import{e as t,d as s,i,p as e}from"./p-e58503d5.js";import{d as n,q as h}from"./p-e6fe5d89.js";import{a as r,b as o}from"./p-75cd09f2.js";import{q as c,u}from"./p-ea916a39.js";import{e as a}from"./p-77b9a0fc.js";const l=new Set,p=[],f=new Map,d=[0,0];let g=class extends e{constructor(t){super(t),this._keyToItem=new Map,this.concurrency=6,this.strategy="scale-first",this.tileInfoView=null}initialize(){const{concurrency:t,process:s}=this;this._queue=new r({concurrency:t,process:(t,i)=>{const e=this._keyToItem.get(t);return s(e,{signal:i})},peeker:t=>t.values().next().value})}destroy(){this.clear(),this._queue.destroy(),this._queue=null}get length(){return this._queue?this._queue.length:0}get onGoingCount(){return this._keyToItem.size}get updating(){return this.length>0||this.onGoingCount>0}abort(t){this._queue.abort("string"==typeof t?t:t.id)}clear(){this._queue.clear(),this._keyToItem.clear(),this.notifyChange("updating")}has(t){return this._keyToItem.has("string"==typeof t?t:t.id)}isOngoing(t){const s="string"==typeof t?t:t.id;return this.has(s)&&this._queue.isOngoing(s)}pause(){this._queue.pause()}push(t,s){const i=t.key.id+"-"+s;if(this.has(i))return this.get(i);const e=this._queue.push(i),n=()=>{this._keyToItem.delete(i),this.notifyChange("updating")};return this._keyToItem.set(i,t),e.then(n,n),this.notifyChange("updating"),e}reset(){this._queue.reset(),this.notifyChange("updating")}resume(){this._queue.resume()}_peekByScaleFirst(t){if(!this.state)return t.values().next().value;const s=this.tileInfoView;let i=Number.NEGATIVE_INFINITY,e=Number.POSITIVE_INFINITY;t.forEach((t=>{const s=this._keyToItem.get(t),n=this.tileInfoView.getTileScale(s.key);f.has(n)||(f.set(n,[]),i=Math.max(n,i),e=Math.min(n,e)),f.get(n).push(s.key),l.add(n)}));let n=this.state.scale;f.has(n)||(function(t,s){t.length=0,s.forEach((s=>t.push(s)))}(p,l),p.sort(((t,s)=>t-s)),n=p.reduce(((t,s)=>Math.abs(s-n)<Math.abs(t-n)?s:t),p[0])),n=Math.min(n,i),n=Math.max(n,e);const h=f.get(n),r=s.getClosestInfoForScale(n),o=r.getColumnForX(this.state.center[0]),c=r.getRowForY(this.state.center[1]);return h.sort(((t,s)=>{const i=r.denormalizeCol(t.col,t.world),e=r.denormalizeCol(s.col,s.world);return Math.sqrt((o-i)*(o-i)+(c-t.row)*(c-t.row))-Math.sqrt((o-e)*(o-e)+(c-s.row)*(c-s.row))})),l.clear(),f.clear(),h[0].id}_peekByCenterFirst(t){if(!this.state)return t.values().next().value;const s=this.tileInfoView,i=this.state.center;let e=Number.POSITIVE_INFINITY,h=null;return t.forEach((t=>{const r=this._keyToItem.get(t);s.getTileCoords(d,r.key);const o=n(d,i);o<e&&(e=o,h=r.key)})),h.id}};t([s({constructOnly:!0})],g.prototype,"concurrency",void 0),t([s({constructOnly:!0})],g.prototype,"process",void 0),t([s()],g.prototype,"state",void 0),t([s({constructOnly:!0})],g.prototype,"strategy",void 0),t([s({constructOnly:!0})],g.prototype,"tileInfoView",void 0),t([s({readOnly:!0})],g.prototype,"updating",null),g=t([i("esri.views.2d.tiling.PagedTileQueue")],g);const y=new Set,m=[],M=new Map,w=[0,0];let b=class extends e{constructor(t){super(t),this._keyToItem=new Map,this.concurrency=6,this.strategy="scale-first",this.tileInfoView=null}initialize(){const{concurrency:t,process:s,strategy:i}=this;this._queue=new r({concurrency:t,process:(t,i)=>{const e=this._keyToItem.get(t);return s(e,{signal:i})},peeker:"scale-first"===i?t=>this._peekByScaleFirst(t):t=>this._peekByCenterFirst(t)})}destroy(){this.clear(),this._queue.destroy(),this._queue=null}get length(){return this._queue?this._queue.length:0}get onGoingCount(){return this._keyToItem.size}get updating(){return this.length>0||this.onGoingCount>0}abort(t){this._queue.abort("string"==typeof t?t:t.id)}clear(){this._queue.clear(),this._keyToItem.clear(),this.notifyChange("updating")}has(t){return this._keyToItem.has("string"==typeof t?t:t.id)}isOngoing(t){const s="string"==typeof t?t:t.id;return this.has(s)&&this._queue.isOngoing(s)}pause(){this._queue.pause()}push(t){const s=t.key.id;if(this._queue.has(s))return this._queue.get(s);const i=this._queue.push(s),e=()=>{this._keyToItem.delete(s),this.notifyChange("updating")};return this._keyToItem.set(s,t),i.then(e,e),this.notifyChange("updating"),i}reset(){this._queue.reset()}resume(){this._queue.resume()}_peekByScaleFirst(t){if(!this.state)return t.values().next().value;const s=this.tileInfoView;let i=Number.NEGATIVE_INFINITY,e=Number.POSITIVE_INFINITY;t.forEach((t=>{const s=this._keyToItem.get(t),n=this.tileInfoView.getTileScale(s.key);M.has(n)||(M.set(n,[]),i=Math.max(n,i),e=Math.min(n,e)),M.get(n).push(s.key),y.add(n)}));let n=this.state.scale;M.has(n)||(function(t,s){t.length=0,s.forEach((s=>t.push(s)))}(m,y),m.sort(((t,s)=>t-s)),n=m.reduce(((t,s)=>Math.abs(s-n)<Math.abs(t-n)?s:t),m[0])),n=Math.min(n,i),n=Math.max(n,e);const h=M.get(n),r=s.getClosestInfoForScale(n),o=r.getColumnForX(this.state.center[0]),c=r.getRowForY(this.state.center[1]);return h.sort(((t,s)=>{const i=r.denormalizeCol(t.col,t.world),e=r.denormalizeCol(s.col,s.world);return Math.sqrt((o-i)*(o-i)+(c-t.row)*(c-t.row))-Math.sqrt((o-e)*(o-e)+(c-s.row)*(c-s.row))})),y.clear(),M.clear(),h[0].id}_peekByCenterFirst(t){if(!this.state)return t.values().next().value;const s=this.tileInfoView,i=this.state.center;let e=Number.POSITIVE_INFINITY,h=null;return t.forEach((t=>{const r=this._keyToItem.get(t);s.getTileCoords(w,r.key);const o=n(w,i);o<e&&(e=o,h=r.key)})),h.id}};t([s({constructOnly:!0})],b.prototype,"concurrency",void 0),t([s({constructOnly:!0})],b.prototype,"process",void 0),t([s()],b.prototype,"state",void 0),t([s({constructOnly:!0})],b.prototype,"strategy",void 0),t([s({constructOnly:!0})],b.prototype,"tileInfoView",void 0),t([s({readOnly:!0})],b.prototype,"updating",null),b=t([i("esri.views.2d.tiling.TileQueue")],b);const v=b;class O{constructor(t,s,i){this.maxSize=t,this.tileInfoView=s,this.removedFunc=i,this._tilePerId=new Map,this._tileKeysPerLevel=[]}has(t){return this._tilePerId.has(t)}get(t){return this._tilePerId.get(t)}pop(t){const s=this._tilePerId.get(t);if(!s)return null;const i=this._tileKeysPerLevel[s.key.level];k(this._tilePerId,t);for(let s=0;s<i.length;s++)if(i[s].id===t){i.splice(s,1);break}return s.visible=!0,s}add(t){t.visible=!1;const s=t.key,i=s.id;if(this._tilePerId.has(i))return;this._tilePerId.set(i,t);const e=s.level;this._tileKeysPerLevel[e]||(this._tileKeysPerLevel[e]=[]),this._tileKeysPerLevel[e].push(s)}prune(t,s,i){let e=this._tilePerId.size;if(e<=this.maxSize)return;let n=this._tileKeysPerLevel.length-1;for(;e>this.maxSize&&n>=0;)n!==t&&(e=this._pruneAroundCenterTile(e,s,i,n)),n--;e>this.maxSize&&(e=this._pruneAroundCenterTile(e,s,i,t))}_pruneAroundCenterTile(t,s,i,e){const n=this._tileKeysPerLevel[e];if(!n||0===n.length)return t;const{size:r,origin:o}=this.tileInfoView.tileInfo,c=i*r[0],u=i*r[1],a=[0,0],l=[0,0];for(n.sort(((t,i)=>(a[0]=o.x+c*(t.col+.5),a[1]=o.y-u*(t.row+.5),l[0]=o.x+c*(i.col+.5),l[1]=o.y-u*(i.row+.5),h(a,s)-h(l,s))));n.length>0;){const s=n.pop();if(this._removeTile(s.id),--t===this.maxSize)break}return t}_removeTile(t){const s=this._tilePerId.get(t);this.removedFunc&&this.removedFunc(s),k(this._tilePerId,t)}}function k(t,s){t.delete(s)}const _=new a(0,0,0,0),N=new Map,S=[],x=[];class C{constructor(t){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=t.acquireTile,this.releaseTile=t.releaseTile,this.tileInfoView=t.tileInfoView,this.resampling=null==t.resampling||!!t.resampling,t.cachePolicy&&(this.cachePolicy=t.cachePolicy),t.coveragePolicy&&(this.coveragePolicy=t.coveragePolicy),null!=t.buffer&&(this.buffer=t.buffer),t.cacheSize&&(this._tileCache=new O(t.cacheSize,this.tileInfoView,(t=>{this.releaseTile(t)})))}destroy(){this.tileIndex.clear()}update(t){const{resampling:s,tileIndex:i}=this,e=this.tileInfoView.getTileCoverage(t.state,this.buffer,this.coveragePolicy);if(x.length=0,S.length=0,N.clear(),!e)return;const{minScale:n,maxScale:h}=this.tileInfoView.tileInfo,{spans:r,lodInfo:c}=e,{level:u}=c,{scale:a,center:l,resolution:p}=t.state,f=!t.stationary&&a>this._previousScale;if(this._previousScale=a,this.tiles.length=0,!s&&(a>n||a<h))return this.tiles.length=0,N.clear(),i.forEach((t=>{this.releaseTile(t)})),i.clear(),x.length=0,S.length=0,N.clear(),o.pool.release(e),!0;i.forEach((t=>t.visible=!0));let d=0,g=0;if(r.length>0)for(const{row:t,colFrom:s,colTo:e}of r)for(let n=s;n<=e;n++){d++;const s=_.set(u,t,c.normalizeCol(n),c.getWorldForColumn(n)).id;if(i.has(s)){const t=i.get(s);t.isReady?(N.set(s,t),g++):f||this._addParentTile(s,N)}else{let t;if(this._tileCache&&this._tileCache.has(s)){if(t=this._tileCache.pop(s),this.tileIndex.set(s,t),t.isReady){N.set(s,t),g++;continue}}else t=this.acquireTile(_),this.tileIndex.set(s,t);f||this._addParentTile(s,N)}}const y=g===d;i.forEach(((t,s)=>{if(_.set(s),N.has(s))return;const i=this.tileInfoView.intersects(e,_),n="purge"===this.cachePolicy?_.level!==u:_.level>u;!i||!f&&y?!n&&i||S.push(s):t.isReady?n&&"purge"===this.cachePolicy&&this._hasReadyAncestor(_,u)?S.push(s):x.push(s):n&&S.push(s)}));for(const t of x){const s=i.get(t);s&&s.isReady&&N.set(t,s)}for(const t of S){const s=i.get(t);this._tileCache?this._tileCache.add(s):this.releaseTile(s),i.delete(t)}return N.forEach((t=>this.tiles.push(t))),i.forEach((t=>{N.has(t.key.id)||(t.visible=!1)})),this._tileCache&&this._tileCache.prune(u,l,p),o.pool.release(e),N.clear(),y}clear(t=!0){const{tileIndex:s}=this;t&&s.forEach((t=>{this.releaseTile(t)})),s.clear()}updateCacheSize(t){this._tileCache&&(this._tileCache.maxSize=t)}_addParentTile(t,s){let i=t,e=null;for(;i=this.tileInfoView.getTileParentId(i),i;)if(this.tileIndex.has(i)){if(e=this.tileIndex.get(i),e&&e.isReady){s.has(e.key.id)||s.set(e.key.id,e);break}}else if(this._tileCache&&this._tileCache.has(i)&&(e=this._tileCache.pop(i),this.tileIndex.set(i,e),e&&e.isReady)){s.has(e.key.id)||s.set(e.key.id,e);break}}_hasReadyAncestor(t,s){const i=u();this.tileInfoView.getTileBounds(i,t,!0);for(const e of this.tileIndex.values())if(e.isReady&&e.key.level>=s&&e.key.level<t.level){const t=u();if(this.tileInfoView.getTileBounds(t,e.key,!0),c(t,i))return!0}return!1}}export{v as p,C as r}