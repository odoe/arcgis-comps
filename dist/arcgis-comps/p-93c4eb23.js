import{m as t,b_ as e,N as s,v as i,r,O as a}from"./p-9ae46e68.js";import{aQ as o,a2 as n,bL as p,aH as l}from"./p-566b0715.js";import{e as c,n as u,W as d,t as h,Q as f}from"./p-4003c7ae.js";import{m}from"./p-dc35ec83.js";import{f as y,g as j}from"./p-47f143cb.js";import{V as g}from"./p-574af054.js";import{T as b,L as w,O as I}from"./p-59312e26.js";import{i as F,n as T,u as R}from"./p-f8afda5b.js";import{y as S,d as _,c as v,u as E,h as O}from"./p-a19e89a5.js";import{d as D}from"./p-5a0fe1d0.js";import{i as Q}from"./p-32462343.js";import"./p-84bf99cb.js";import"./p-fe01b82b.js";import"./p-b2d0e2de.js";import"./p-db87794e.js";import"./p-81e5b36e.js";import"./p-cb4bfb58.js";import"./p-285c6a34.js";import"./p-2a252a78.js";import"./p-bae36c84.js";import"./p-138c2b2c.js";import"./p-50ff864e.js";import"./p-3a2e88bf.js";import"./p-8031c809.js";import"./p-27ef204b.js";import"./p-b74f39e0.js";import"./p-06d309e6.js";import"./p-685003b3.js";import"./p-007111db.js";import"./p-0659cf81.js";import"./p-8ac97b63.js";import"./p-5ee2f7e2.js";import"./p-8d03d70f.js";import"./p-4fd6e394.js";import"./p-e5429b9e.js";const x={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};export default class{constructor(){this._queryEngine=null,this._snapshotFeatures=async t=>{const e=await this._fetch(t);return this._createFeatures(e)}}destroy(){var t;null==(t=this._queryEngine)||t.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(e,s={}){this.loadOptions={url:e.url,customParameters:e.customParameters};const i=[];await this._checkProjection(e.spatialReference);let r=null;e.url&&(r=await this._fetch(null==s?void 0:s.signal));const a=b(r,{geometryType:e.geometryType}),n=e.fields||a.fields||[],l=null!=e.hasZ?e.hasZ:a.hasZ,c=a.geometryType,u=e.objectIdField||a.objectIdFieldName||"__OBJECTID",d=e.spatialReference||p;let h=e.timeInfo;n===a.fields&&a.unknownFields.length>0&&i.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:a.unknownFields}});let f=n.find((t=>t.name===u));f?("esriFieldTypeString"!==f.type&&(f.type="esriFieldTypeOID"),f.editable=!1,f.nullable=!1):(f={alias:u,name:u,type:"string"===a.objectIdFieldType?"esriFieldTypeString":"esriFieldTypeOID",editable:!1,nullable:!1},n.unshift(f));const y={};for(const e of n){if(null==e.name&&(e.name=e.alias),null==e.alias&&(e.alias=e.name),!e.name)throw new t("geojson-layer:invalid-field-name","field name is missing",{field:e});if(!Q.jsonValues.includes(e.type))throw new t("geojson-layer:invalid-field-type",`invalid type for field "${e.name}"`,{field:e});if(e.name!==f.name){const t=o(e);void 0!==t&&(y[e.name]=t)}}if(this._fieldsIndex=new D(n),h){if(h.startTimeField){const t=this._fieldsIndex.get(h.startTimeField);t?(h.startTimeField=t.name,t.type="esriFieldTypeDate"):h.startTimeField=null}if(h.endTimeField){const t=this._fieldsIndex.get(h.endTimeField);t?(h.endTimeField=t.name,t.type="esriFieldTypeDate"):h.endTimeField=null}if(h.trackIdField){const t=this._fieldsIndex.get(h.trackIdField);t?h.trackIdField=t.name:(h.trackIdField=null,i.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:h}}))}h.startTimeField||h.endTimeField||(i.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:h}}),h=null)}const j=c?R(c):null,w={warnings:i,featureErrors:[],layerDefinition:{...x,drawingInfo:j,templates:F(y),extent:null,geometryType:c,objectIdField:u,fields:n,hasZ:!!l,timeInfo:h}};this._queryEngine=new g({fields:n,geometryType:c,hasM:!1,hasZ:l,objectIdField:u,spatialReference:d,timeInfo:h,featureStore:new m({geometryType:c,hasM:!1,hasZ:l}),cacheSpatialQueries:!0}),this._createDefaultAttributes=T(y,u);const I=await this._createFeatures(r);this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,I);const S=this._normalizeFeatures(I,w.warnings,w.featureErrors);if(this._queryEngine.featureStore.addMany(S),w.layerDefinition.extent=this._queryEngine.fullExtent,w.layerDefinition.timeInfo){const{start:t,end:e}=this._queryEngine.timeExtent;w.layerDefinition.timeInfo.timeExtent=[t,e]}return w}async applyEdits(t){const{spatialReference:e,geometryType:s}=this._queryEngine;return await Promise.all([S(e,s),y(t.adds,e),y(t.updates,e)]),await this._waitSnapshotComplete(),this._applyEdits(t)}async queryFeatures(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(t,e.signal)}async queryFeatureCount(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(t,e.signal)}async queryObjectIds(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(t,e.signal)}async queryExtent(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(t,e.signal)}async querySnapping(t,e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(t,e.signal)}async refresh(r){var a;return this.loadOptions.customParameters=r,null==(a=this._snapshotTask)||a.abort(),this._snapshotTask=e(this._snapshotFeatures),this._snapshotTask.promise.then((t=>{this._queryEngine.featureStore.clear(),this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,t);const e=this._normalizeFeatures(t);e&&this._queryEngine.featureStore.addMany(e)}),(e=>{this._queryEngine.featureStore.clear(),s(e)||i.getLogger("esri.layers.GeoJSONLayer").error(new t("geojson-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete(),{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent}}async _createFeatures(t){const{geometryType:e,hasZ:s,objectIdField:i}=this._queryEngine,a=w(t,{geometryType:e,hasZ:s,objectIdField:i});if(!n(this._queryEngine.spatialReference,p))for(const t of a)r(t.geometry)&&(t.geometry=c(j(u(t.geometry,this._queryEngine.geometryType,this._queryEngine.hasZ,!1),p,this._queryEngine.spatialReference)));return a}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(t){const{url:e,customParameters:s}=this.loadOptions,i=(await a(e,{responseType:"json",query:{...s},signal:t})).data;return await I(i),i}_normalizeFeatures(t,e,s){const{objectIdField:i}=this._queryEngine,r=[];for(const a of t){const t=this._createDefaultAttributes(),o=_(this._fieldsIndex,t,a.attributes,!0,e);o?null==s||s.push(o):(this._assignObjectId(t,a.attributes,!0),a.attributes=t,a.objectId=t[i],r.push(a))}return r}_applyEdits(t){const{adds:e,updates:s,deletes:i}=t,r={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(e&&e.length&&this._applyAddEdits(r,e),s&&s.length&&this._applyUpdateEdits(r,s),i&&i.length){for(const t of i)r.deleteResults.push(v(t));this._queryEngine.featureStore.removeManyById(i)}return{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:r}}_applyAddEdits(t,e){const{addResults:s}=t,{geometryType:i,hasM:a,hasZ:o,objectIdField:n,spatialReference:p,featureStore:c}=this._queryEngine,u=[];for(const a of e){if(a.geometry&&i!==l(a.geometry)){s.push(E("Incorrect geometry type."));continue}const e=this._createDefaultAttributes(),o=_(this._fieldsIndex,e,a.attributes);o?s.push(o):(this._assignObjectId(e,a.attributes),a.attributes=e,null!=a.uid&&(t.uidToObjectId[a.uid]=a.attributes[n]),r(a.geometry)&&(a.geometry=j(O(a.geometry,p),a.geometry.spatialReference,p)),u.push(a),s.push(v(a.attributes[n])))}c.addMany(d([],u,i,o,a,n))}_applyUpdateEdits({updateResults:t},e){const{geometryType:s,hasM:i,hasZ:a,objectIdField:o,spatialReference:n,featureStore:p}=this._queryEngine;for(const c of e){const{attributes:e,geometry:u}=c,d=e&&e[o];if(null==d){t.push(E(`Identifier field ${o} missing`));continue}if(!p.has(d)){t.push(E(`Feature with object id ${d} missing`));continue}const m=h(p.getFeature(d),s,a,i);if(r(u)){if(s!==l(u)){t.push(E("Incorrect geometry type."));continue}m.geometry=j(O(u,n),u.spatialReference,n)}if(e){const s=_(this._fieldsIndex,m.attributes,e);if(s){t.push(s);continue}}p.add(f(m,s,a,i,o)),t.push(v(d))}}_createObjectIdGenerator(t,e){const s=t.fieldsIndex.get(t.objectIdField);if("esriFieldTypeString"===s.type)return()=>s.name+"-"+Date.now().toString(16);let i=Number.NEGATIVE_INFINITY;for(const t of e)t.objectId&&(i=Math.max(i,t.objectId));return i=Math.max(0,i)+1,()=>i++}_assignObjectId(t,e,s=!1){const i=this._queryEngine.objectIdField;t[i]=s&&i in e?e[i]:this._objectIdGenerator()}async _checkProjection(e){try{await y(p,e)}catch{throw new t("geojson-layer","Projection not supported")}}}