import{s as t,ac as e,et as s,a9 as i,eu as n,g as o,cH as a,ev as r,dr as l,W as c,a7 as h,dk as u,ew as f,ex as y,ey as m,cY as p,T as w,ez as d,eA as v,bq as x,eB as T}from"./p-c8bc3433.js";import"./p-84bf99cb.js";const q=t.getLogger("esri.layers.support.ElevationSampler");class g{queryElevation(t){return function(t,e){const s=M(t,e.spatialReference);if(!s)return null;switch(t.type){case"point":!function(t,e,s){t.z=l(s.elevationAt(e),0)}(t,s,e);break;case"polyline":!function(t,e,s){A.spatialReference=e.spatialReference;const i=t.hasM&&!t.hasZ;for(let n=0;n<t.paths.length;n++){const o=t.paths[n],a=e.paths[n];for(let t=0;t<o.length;t++){const e=o[t],n=a[t];A.x=n[0],A.y=n[1],i&&(e[3]=e[2]),e[2]=l(s.elevationAt(A),0)}}t.hasZ=!0}(t,s,e);break;case"multipoint":!function(t,e,s){A.spatialReference=e.spatialReference;const i=t.hasM&&!t.hasZ;for(let n=0;n<t.points.length;n++){const o=t.points[n],a=e.points[n];A.x=a[0],A.y=a[1],i&&(o[3]=o[2]),o[2]=l(s.elevationAt(A),0)}t.hasZ=!0}(t,s,e)}return t}(t.clone(),this)}on(){return $}projectIfRequired(t,e){return M(t,e)}}class _ extends g{constructor(t,e,n){super(),this.tile=t,this.noDataValue=n,this.extent=s(t.tile.extent,e.spatialReference);const o=i(e.spatialReference),a=e.lodAt(t.tile.level).resolution*o;this.demResolution={min:a,max:a}}get spatialReference(){return this.extent.spatialReference}contains(t){const e=this.projectIfRequired(t,this.spatialReference);return n(this.extent,e)}elevationAt(t){const e=this.projectIfRequired(t,this.spatialReference);if(o(e))return null;if(!this.contains(t)){const e=this.extent;return q.warn("#elevationAt()",`Point used to sample elevation (${t.x}, ${t.y}) is outside of the sampler extent (${e.xmin}, ${e.ymin}, ${e.xmax}, ${e.ymax})`),this.noDataValue}return this.tile.sample(e.x,e.y)}}class E extends g{constructor(t,e,i){let n;super(),"number"==typeof e?(this.noDataValue=e,n=null):(n=e,this.noDataValue=i),this.samplers=n?t.map((t=>new _(t,n,this.noDataValue))):t;const o=this.samplers[0];if(o){this.extent=o.extent.clone();const{min:t,max:e}=o.demResolution;this.demResolution={min:t,max:e};for(let t=1;t<this.samplers.length;t++){const e=this.samplers[t];this.extent.union(e.extent),this.demResolution.min=Math.min(this.demResolution.min,e.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,e.demResolution.max)}}else this.extent=s(a(),n.spatialReference),this.demResolution={min:0,max:0}}get spatialReference(){return this.extent.spatialReference}elevationAt(t){const e=this.projectIfRequired(t,this.spatialReference);if(!e)return null;for(const t of this.samplers)if(t.contains(e))return t.elevationAt(e);return q.warn("#elevationAt()",`Point used to sample elevation (${t.x}, ${t.y}) is outside of the sampler`),this.noDataValue}}function M(t,e){if(o(t))return null;const s=t.spatialReference;if(s.equals(e))return t;const i=r(t,e);return i||q.error(`Cannot project geometry spatial reference (wkid:${s.wkid}) to elevation sampler spatial reference (wkid:${e.wkid})`),i}const A=new e,$={remove(){}};class R{constructor(t,e=null){if(this.tile=t,c(e)){const s=t.extent;this.samplerData={pixelData:e.values,width:e.width,height:e.height,safeWidth:.99999999*(e.width-1),noDataValue:e.noDataValue,dx:(e.width-1)/(s[2]-s[0]),dy:(e.width-1)/(s[3]-s[1]),x0:s[0],y1:s[3]}}}sample(t,e){if(o(this.samplerData))return;const{safeWidth:s,width:i,pixelData:n,noDataValue:a,dx:r,dy:l,y1:c,x0:h}=this.samplerData,u=b(l*(c-e),0,s),f=b(r*(t-h),0,s),y=Math.floor(u),m=Math.floor(f),p=y*i+m,w=p+i,d=n[p],v=n[w],x=n[p+1],T=n[w+1];if(d!==a&&v!==a&&x!==a&&T!==a){const t=f-m,e=d+(x-d)*t;return e+(v+(T-v)*t-e)*(u-y)}}}function b(t,e,s){return t<e?e:t>s?s:t}class D{async queryAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new h("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");const i=F.fromGeometry(e);let n=!1;s&&s.returnSampleInfo||(n=!0);const o={...z,...s,returnSampleInfo:!0},a=await this.query(t[t.length-1],i,o),r=await this._queryAllContinue(t,a,o);return r.geometry=r.geometry.export(),n&&delete r.sampleInfo,r}async query(t,e,s){if(!t)throw new h("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||!(e instanceof F)&&"point"!==e.type&&"multipoint"!==e.type&&"polyline"!==e.type)throw new h("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const i={...z,...s},n=new C(t,e.spatialReference,i),o=i.signal;return await t.load({signal:o}),await this._createGeometryDescriptor(n,e,o),await this._selectTiles(n,o),await this._populateElevationTiles(n,o),this._sampleGeometryWithElevation(n),this._createQueryResult(n,o)}async createSampler(t,e,s){if(!t)throw new h("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new h("elevation-query:invalid-extent","Invalid or undefined extent");const i={...z,...s};return this._createSampler(t,e,i)}async createSamplerAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new h("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new h("elevation-query:invalid-extent","Invalid or undefined extent");const i={...z,...s,returnSampleInfo:!0},n=await this._createSampler(t[t.length-1],e,i);return this._createSamplerAllContinue(t,e,n,i)}async _createSampler(t,e,s,i){const n=s.signal;await t.load({signal:n});const o=e.spatialReference,a=t.tileInfo.spatialReference;o.equals(a)||(await u([{source:o,dest:a}],{signal:n}),e=f(e,a));const r=new S(t,e,s,i);return await this._selectTiles(r,n),await this._populateElevationTiles(r,n),new E(r.elevationTiles,r.layer.tileInfo,r.options.noDataValue)}async _createSamplerAllContinue(t,e,s,i){if(t.pop(),!t.length)return s;const n=s.samplers.map((t=>y(t.extent))),o=await this._createSampler(t[t.length-1],e,i,n);if(0===o.samplers.length)return s;const a=s.samplers.concat(o.samplers),r=new E(a,i.noDataValue);return this._createSamplerAllContinue(t,e,r,i)}async _queryAllContinue(t,e,s){const i=t.pop(),n=e.geometry.coordinates,o=[],a=[];for(let s=0;s<n.length;s++){const r=e.sampleInfo[s];r.demResolution>=0?r.source||(r.source=i):t.length&&(o.push(n[s]),a.push(s))}if(!t.length||0===o.length)return e;const r=e.geometry.clone(o),l=await this.query(t[t.length-1],r,s);return a.forEach(((t,s)=>{n[t].z=l.geometry.coordinates[s].z,e.sampleInfo[t].demResolution=l.sampleInfo[s].demResolution})),this._queryAllContinue(t,e,s)}async _createQueryResult(t,e){const s={geometry:(await t.geometry.project(t.outSpatialReference,e)).export(),noDataValue:t.options.noDataValue};return t.options.returnSampleInfo&&(s.sampleInfo=this._extractSampleInfo(t)),t.geometry.coordinates.forEach((t=>{t.tile=null,t.elevationTile=null})),s}async _createGeometryDescriptor(t,e,s){let i;const n=t.layer.tileInfo.spatialReference;if(e instanceof F?i=await e.project(n,s):(await u([{source:e.spatialReference,dest:n}],{signal:s}),i=f(e,n)),!i)throw new h("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${e.spatialReference.wkid}' on an elevation service in '${n.wkid}'`);t.geometry=F.fromGeometry(i)}async _selectTiles(t,e){const s=t.options.demResolution;if("geometry"===t.type&&this._preselectOutsideLayerExtent(t),"number"==typeof s)this._selectTilesClosestResolution(t);else if("finest-contiguous"===s)await this._selectTilesFinestContiguous(t,e);else{if("auto"!==s)throw new h("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${s}', expected a number, "finest-contiguous" or "auto"`);await this._selectTilesAuto(t,e)}}_preselectOutsideLayerExtent(t){if(o(t.layer.fullExtent))return;const e=new R(null);e.sample=()=>t.options.noDataValue,t.outsideExtentTile=e;const s=t.layer.fullExtent;t.geometry.coordinates.forEach((t=>{const i=t.x,n=t.y;(i<s.xmin||i>s.xmax||n<s.ymin||n>s.ymax)&&(t.elevationTile=e)}))}_selectTilesClosestResolution(t){const e=this._findNearestDemResolutionLODIndex(t.layer.tileInfo,t.options.demResolution);t.selectTilesAtLOD(e)}_findNearestDemResolutionLODIndex(t,e){const s=e/i(t.spatialReference);let n=t.lods[0],o=0;for(let e=1;e<t.lods.length;e++){const i=t.lods[e];Math.abs(i.resolution-s)<Math.abs(n.resolution-s)&&(n=i,o=e)}return o}async _selectTilesFinestContiguous(t,e){const s=k(t.layer.tileInfo,t.options.minDemResolution);await this._selectTilesFinestContiguousAt(t,s,e)}async _selectTilesFinestContiguousAt(t,e,s){const i=t.layer;if(t.selectTilesAtLOD(e),e<0)return;const n=i.tilemapCache,o=t.getTilesToFetch();try{if(n)await m(Promise.all(o.map((t=>n.fetchAvailability(t.level,t.row,t.col,{signal:s})))),s);else if(await this._populateElevationTiles(t,s),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new h("elevation-query:has-unavailable-tiles")}catch(i){p(i),await this._selectTilesFinestContiguousAt(t,e-1,s)}}async _populateElevationTiles(t,e){const s=t.getTilesToFetch(),i={},n=t.options.cache,o=t.options.noDataValue,a=s.map((async s=>{const a=`${t.layer.uid}:${s.id}:${o}`,r=c(n)?n.get(a):null,l=c(r)?r:await t.layer.fetchTile(s.level,s.row,s.col,{noDataValue:o,signal:e});c(n)&&n.put(a,l),i[s.id]=new R(s,l)}));await m(w(a),e),t.populateElevationTiles(i)}async _selectTilesAuto(t,e){this._selectTilesAutoFinest(t),this._reduceTilesForMaximumRequests(t);const s=t.layer.tilemapCache;if(!s)return this._selectTilesAutoPrefetchUpsample(t,e);const i=t.getTilesToFetch(),n={},o=i.map((async t=>{const i={id:null,level:0,row:0,col:0,extent:a()},o=await d(s.fetchAvailabilityUpsample(t.level,t.row,t.col,i,{signal:e}));!1===o.ok?p(o.error):n[t.id]=i}));await m(Promise.all(o),e),t.remapTiles(n)}_reduceTilesForMaximumRequests(t){const e=t.layer.tileInfo;let s=0;const i={},n=t=>{t.id in i?i[t.id]++:(i[t.id]=1,s++)},o=t=>{const e=i[t.id];1===e?(delete i[t.id],s--):i[t.id]=e-1};t.forEachTileToFetch(n,o);let a=!0;for(;a&&(a=!1,t.forEachTileToFetch((i=>{s<=t.options.maximumAutoTileRequests||(o(i),e.upsampleTile(i)&&(a=!0),n(i))}),o),a););}_selectTilesAutoFinest(t){const e=k(t.layer.tileInfo,t.options.minDemResolution);t.selectTilesAtLOD(e,t.options.maximumAutoTileRequests)}async _selectTilesAutoPrefetchUpsample(t,e){const s=t.layer.tileInfo;await this._populateElevationTiles(t,e);let i=!1;t.forEachTileToFetch(((t,e)=>{s.upsampleTile(t)?i=!0:e()})),i&&await this._selectTilesAutoPrefetchUpsample(t,e)}_sampleGeometryWithElevation(t){t.geometry.coordinates.forEach((e=>{const s=e.elevationTile;let i=t.options.noDataValue;if(s){const t=s.sample(e.x,e.y);c(t)?i=t:e.elevationTile=null}e.z=i}))}_extractSampleInfo(t){const e=t.layer.tileInfo,s=i(e.spatialReference);return t.geometry.coordinates.map((i=>{let n=-1;return i.elevationTile&&i.elevationTile!==t.outsideExtentTile&&(n=e.lodAt(i.elevationTile.tile.level).resolution*s),{demResolution:n}}))}}class F{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(t){const e=new F;return e.geometry=this.geometry,e.spatialReference=this.spatialReference,e.coordinates=t||this.coordinates.map((t=>this._cloneCoordinate(t))),e._exporter=this._exporter,e}async project(t,e){if(this.spatialReference.equals(t))return this.clone();await u([{source:this.spatialReference,dest:t}],{signal:e});const s=new v({spatialReference:this.spatialReference,points:this.coordinates.map((t=>[t.x,t.y]))}),i=f(s,t);if(!i)return null;const n=this.coordinates.map(((t,e)=>{const s=this._cloneCoordinate(t),n=i.points[e];return s.x=n[0],s.y=n[1],s})),o=this.clone(n);return o.spatialReference=t,o}_cloneCoordinate(t){return{x:t.x,y:t.y,z:t.z,m:t.m,tile:null,elevationTile:null}}static fromGeometry(t){const s=new F;if(s.geometry=t,s.spatialReference=t.spatialReference,t instanceof F)s.coordinates=t.coordinates.map((t=>s._cloneCoordinate(t))),s._exporter=(e,s)=>{const i=t.clone(e);return i.spatialReference=s,i};else switch(t.type){case"point":{const i=t,{hasZ:n,hasM:o}=i;s.coordinates=n&&o?[{x:i.x,y:i.y,z:i.z,m:i.m}]:n?[{x:i.x,y:i.y,z:i.z}]:o?[{x:i.x,y:i.y,m:i.m}]:[{x:i.x,y:i.y}],s._exporter=(s,i)=>t.hasM?new e(s[0].x,s[0].y,s[0].z,s[0].m,i):new e(s[0].x,s[0].y,s[0].z,i);break}case"multipoint":{const e=t,{hasZ:i,hasM:n}=e;s.coordinates=e.points.map(i&&n?t=>({x:t[0],y:t[1],z:t[2],m:t[3]}):i?t=>({x:t[0],y:t[1],z:t[2]}):n?t=>({x:t[0],y:t[1],m:t[2]}):t=>({x:t[0],y:t[1]})),s._exporter=(e,s)=>t.hasM?new v({points:e.map((t=>[t.x,t.y,t.z,t.m])),hasZ:!0,hasM:!0,spatiaReference:s}):new v(e.map((t=>[t.x,t.y,t.z])),s);break}case"polyline":{const e=t,i=[],n=[],{hasZ:o,hasM:a}=t;let r=0;for(const t of e.paths)if(n.push([r,r+t.length]),r+=t.length,o&&a)for(const e of t)i.push({x:e[0],y:e[1],z:e[2],m:e[3]});else if(o)for(const e of t)i.push({x:e[0],y:e[1],z:e[2]});else if(a)for(const e of t)i.push({x:e[0],y:e[1],m:e[2]});else for(const e of t)i.push({x:e[0],y:e[1]});s.coordinates=i,s._exporter=(e,s)=>{const i=e.map(t.hasM?t=>[t.x,t.y,t.z,t.m]:t=>[t.x,t.y,t.z]),o=n.map((t=>i.slice(t[0],t[1])));return new x({paths:o,hasM:t.hasM,hasZ:!0,spatialReference:s})};break}}return s}}class I{constructor(t,e){this.layer=t,this.options=e}}class C extends I{constructor(t,e,s){super(t,s),this.outSpatialReference=e,this.type="geometry"}selectTilesAtLOD(t){if(t<0)this.geometry.coordinates.forEach((t=>t.tile=null));else{const e=this.layer.tileInfo,s=e.lods[t].level;this.geometry.coordinates.forEach((t=>{t.tile=e.tileAt(s,t.x,t.y)}))}}allElevationTilesFetched(){return!this.geometry.coordinates.some((t=>!t.elevationTile))}clearElevationTiles(){for(const t of this.geometry.coordinates)t.elevationTile!==this.outsideExtentTile&&(t.elevationTile=null)}populateElevationTiles(t){for(const e of this.geometry.coordinates)!e.elevationTile&&e.tile&&(e.elevationTile=t[e.tile.id])}remapTiles(t){for(const e of this.geometry.coordinates)e.tile=t[e.tile.id]}getTilesToFetch(){const t={},e=[];for(const s of this.geometry.coordinates){const i=s.tile;s.elevationTile||!s.tile||t[i.id]||(t[i.id]=i,e.push(i))}return e}forEachTileToFetch(t){for(const e of this.geometry.coordinates)e.tile&&!e.elevationTile&&t(e.tile,(()=>e.tile=null))}}class S extends I{constructor(t,e,s,i){super(t,s),this.type="extent",this.elevationTiles=[],this.candidateTiles=[],this.fetchedCandidates=new Set,this.extent=e.intersection(t.fullExtent),this.maskExtents=i}selectTilesAtLOD(t,e){const s=this._maximumLodForRequests(e),i=Math.min(s,t);i<0?this.candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(i)}_maximumLodForRequests(t){const e=this.layer.tileInfo;if(!t)return e.lods.length-1;const s=this.extent;if(o(s))return-1;for(let i=e.lods.length-1;i>=0;i--){const n=e.lods[i],o=n.resolution*e.size[1];if(Math.ceil(s.width/(n.resolution*e.size[0]))*Math.ceil(s.height/o)<=t)return i}return-1}allElevationTilesFetched(){return this.candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this.fetchedCandidates.clear()}populateElevationTiles(t){for(const e of this.candidateTiles){const s=t[e.id];s&&(this.fetchedCandidates.add(e),this.elevationTiles.push(s))}}remapTiles(t){this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles.map((e=>t[e.id])))}getTilesToFetch(){return this.candidateTiles}forEachTileToFetch(t,e){const s=this.candidateTiles;this.candidateTiles=[],s.forEach((s=>{if(this.fetchedCandidates.has(s))return void(e&&e(s));let i=!1;t(s,(()=>i=!0)),i?e&&e(s):this.candidateTiles.push(s)})),this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles,e)}_uniqueNonOverlappingTiles(t,e){const s={},i=[];for(const n of t)s[n.id]?e&&e(n):(s[n.id]=n,i.push(n));const n=i.sort(((t,e)=>t.level-e.level));return n.filter(((t,s)=>{for(let i=0;i<s;i++)if(T(n[i].extent,t.extent))return e&&e(t),!1;return!0}))}_selectCandidateTilesCoveringExtentAt(t){this.candidateTiles.length=0;const e=this.extent;if(o(e))return;const s=this.layer.tileInfo,i=s.lods[t],n=s.tileAt(i.level,e.xmin,e.ymin),a=i.resolution*s.size[1],r=Math.ceil((e.xmax-n.extent[0])/(i.resolution*s.size[0])),l=Math.ceil((e.ymax-n.extent[1])/a);for(let t=0;t<l;t++)for(let e=0;e<r;e++){const i={id:null,level:n.level,row:n.row-t,col:n.col+e};s.updateTileInfo(i),this._tileIsMasked(i)||this.candidateTiles.push(i)}}_tileIsMasked(t){return!!this.maskExtents&&this.maskExtents.some((e=>T(e,t.extent)))}}function k(t,e){let s=t.lods.length-1;if(e>0){const i=t.lods.findIndex((t=>t.resolution<e));0===i?s=0:i>0&&(s=i-1)}return s}const z={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};export default D;export{D as ElevationQuery,F as GeometryDescriptor,k as getFinestLodIndex}