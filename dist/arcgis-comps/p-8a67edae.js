import{e as r,d as e,i as s,cd as t,r as i,_ as a,O as o}from"./p-9ae46e68.js";import{a as n,u as l,d as u,b as c,p,o as d}from"./p-38c85cb2.js";import{v as m}from"./p-8031c809.js";import{e as y}from"./p-41655335.js";import{E as f,o as v,b2 as B,v as P,h as b,I as g,k as j}from"./p-566b0715.js";import{a as A}from"./p-fe01b82b.js";import{l as h}from"./p-a7080451.js";import"./p-84bf99cb.js";import"./p-98a14d68.js";import"./p-8e03c038.js";import"./p-32462343.js";import"./p-ec378dda.js";function S(r){return r.features.map((e=>{const s=j.fromJSON(r.spatialReference),t=b.fromJSON(e);return a(t.geometry).spatialReference=s,t}))}function k(r){return t(r.features.map((e=>(i(e.geometry)&&(e.geometry.spatialReference=r.spatialReference),g(e.geometry)))))}let w=class extends A{constructor(r){super(r),this.facilities=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.serviceAreaPolylines=null,this.serviceAreaPolygons=null}readFacilities(r){return k(r)}readPointBarriers(r,e){return k(e.barriers)}readPolylineBarriers(r){return k(r)}readPolygonBarriers(r){return k(r)}readIncidents(r,e){return S(e.saPolylines)}readServiceAreaPolygons(r,e){return S(e.saPolygons)}};r([e({type:[f]})],w.prototype,"facilities",void 0),r([v("facilities")],w.prototype,"readFacilities",null),r([e({type:[n]})],w.prototype,"messages",void 0),r([e({type:[f]})],w.prototype,"pointBarriers",void 0),r([v("pointBarriers",["barriers"])],w.prototype,"readPointBarriers",null),r([e({type:[B]})],w.prototype,"polylineBarriers",void 0),r([v("polylineBarriers")],w.prototype,"readPolylineBarriers",null),r([e({type:[P]})],w.prototype,"polygonBarriers",void 0),r([v("polygonBarriers")],w.prototype,"readPolygonBarriers",null),r([e({type:[b]})],w.prototype,"serviceAreaPolylines",void 0),r([v("serviceAreaPolylines",["saPolylines"])],w.prototype,"readIncidents",null),r([e({type:[b]})],w.prototype,"serviceAreaPolygons",void 0),r([v("serviceAreaPolygons",["saPolygons"])],w.prototype,"readServiceAreaPolygons",null),w=r([s("esri.rest.support.ServiceAreaSolveResult")],w);const x=w,I=d({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,defaultBreaks:!0,facilities:!0,outSpatialReference:{name:"outSR",getter:r=>r.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},returnPointBarriers:{name:"returnBarriers"},travelMode:!0});let R=class extends h{constructor(r){super(r),this.url=null}solve(r,e){return async function(r,e,s){const t=[],i=[],a={},n={},d=y(r),{path:f}=d;e.facilities&&e.facilities.features&&l(e.facilities.features,i,"facilities.features",a),e.pointBarriers&&e.pointBarriers.features&&l(e.pointBarriers.features,i,"pointBarriers.features",a),e.polylineBarriers&&e.polylineBarriers.features&&l(e.polylineBarriers.features,i,"polylineBarriers.features",a),e.polygonBarriers&&e.polygonBarriers.features&&l(e.polygonBarriers.features,i,"polygonBarriers.features",a);const v=await m(i);for(const r in a){const e=a[r];t.push(r),n[r]=v.slice(e[0],e[1])}if(u(n,t)){let r=null;try{r=await c(f,e.apiKey,s)}catch{}r&&!r.hasZ&&p(n,t)}for(const r in n)n[r].forEach(((s,t)=>{e.get(r)[t].geometry=s}));const B={...s,query:{...d.query,...I.toQueryParams(e),f:"json"}},{data:P}=await o(`${f}/solveServiceArea`,B);return x.fromJSON(P)}(this.url,r,e)}};r([e()],R.prototype,"url",void 0),R=r([s("esri.tasks.ServiceAreaTask")],R);const F=R;export default F;