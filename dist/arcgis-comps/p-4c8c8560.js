import{a as t}from"./p-e654504b.js";import{A as e,af as s,s as i,al as n,aj as o,T as a,aE as r}from"./p-e58503d5.js";import{H as l}from"./p-01e5a461.js";import{b as c,m as h}from"./p-b79fcce3.js";import{r as u,O as f}from"./p-c93d2280.js";import{c as m,q as p,u as y}from"./p-ea916a39.js";import{u as w}from"./p-954786fa.js";import"./p-53bb6ab4.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-ccdb8e80.js";import"./p-fea9512d.js";class d{constructor(t,s=null){if(this.tile=t,e(s)){const e=t.extent;this.samplerData={pixelData:s.values,width:s.width,height:s.height,safeWidth:.99999999*(s.width-1),noDataValue:s.noDataValue,dx:(s.width-1)/(e[2]-e[0]),dy:(s.width-1)/(e[3]-e[1]),x0:e[0],y1:e[3]}}}sample(t,e){if(s(this.samplerData))return;const{safeWidth:i,width:n,pixelData:o,noDataValue:a,dx:r,dy:l,y1:c,x0:h}=this.samplerData,u=v(l*(c-e),0,i),f=v(r*(t-h),0,i),m=Math.floor(u),p=Math.floor(f),y=m*n+p,w=y+n,d=o[y],x=o[w],T=o[y+1],q=o[w+1];if(d!==a&&x!==a&&T!==a&&q!==a){const t=f-p,e=d+(T-d)*t;return e+(x+(q-x)*t-e)*(u-m)}}}function v(t,e,s){return t<e?e:t>s?s:t}class x{async queryAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new i("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");const n=T.fromGeometry(e);let o=!1;s&&s.returnSampleInfo||(o=!0);const a={...M,...s,returnSampleInfo:!0},r=await this.query(t[t.length-1],n,a),l=await this._queryAllContinue(t,r,a);return l.geometry=l.geometry.export(),o&&delete l.sampleInfo,l}async query(t,e,s){if(!t)throw new i("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||!(e instanceof T)&&"point"!==e.type&&"multipoint"!==e.type&&"polyline"!==e.type)throw new i("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const n={...M,...s},o=new g(t,e.spatialReference,n),a=n.signal;return await t.load({signal:a}),await this._createGeometryDescriptor(o,e,a),await this._selectTiles(o,a),await this._populateElevationTiles(o,a),this._sampleGeometryWithElevation(o),this._createQueryResult(o,a)}async createSampler(t,e,s){if(!t)throw new i("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new i("elevation-query:invalid-extent","Invalid or undefined extent");const n={...M,...s};return this._createSampler(t,e,n)}async createSamplerAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new i("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new i("elevation-query:invalid-extent","Invalid or undefined extent");const n={...M,...s,returnSampleInfo:!0},o=await this._createSampler(t[t.length-1],e,n);return this._createSamplerAllContinue(t,e,o,n)}async _createSampler(t,e,s,i){const n=s.signal;await t.load({signal:n});const o=e.spatialReference,a=t.tileInfo.spatialReference;o.equals(a)||(await u([{source:o,dest:a}],{signal:n}),e=f(e,a));const r=new _(t,e,s,i);return await this._selectTiles(r,n),await this._populateElevationTiles(r,n),new w(r.elevationTiles,r.layer.tileInfo,r.options.noDataValue)}async _createSamplerAllContinue(t,e,s,i){if(t.pop(),!t.length)return s;const n=s.samplers.map((t=>m(t.extent))),o=await this._createSampler(t[t.length-1],e,i,n);if(0===o.samplers.length)return s;const a=s.samplers.concat(o.samplers),r=new w(a,i.noDataValue);return this._createSamplerAllContinue(t,e,r,i)}async _queryAllContinue(t,e,s){const i=t.pop(),n=e.geometry.coordinates,o=[],a=[];for(let s=0;s<n.length;s++){const r=e.sampleInfo[s];r.demResolution>=0?r.source||(r.source=i):t.length&&(o.push(n[s]),a.push(s))}if(!t.length||0===o.length)return e;const r=e.geometry.clone(o),l=await this.query(t[t.length-1],r,s);return a.forEach(((t,s)=>{n[t].z=l.geometry.coordinates[s].z,e.sampleInfo[t].demResolution=l.sampleInfo[s].demResolution})),this._queryAllContinue(t,e,s)}async _createQueryResult(t,e){const s={geometry:(await t.geometry.project(t.outSpatialReference,e)).export(),noDataValue:t.options.noDataValue};return t.options.returnSampleInfo&&(s.sampleInfo=this._extractSampleInfo(t)),t.geometry.coordinates.forEach((t=>{t.tile=null,t.elevationTile=null})),s}async _createGeometryDescriptor(t,e,s){let n;const o=t.layer.tileInfo.spatialReference;if(e instanceof T?n=await e.project(o,s):(await u([{source:e.spatialReference,dest:o}],{signal:s}),n=f(e,o)),!n)throw new i("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${e.spatialReference.wkid}' on an elevation service in '${o.wkid}'`);t.geometry=T.fromGeometry(n)}async _selectTiles(t,e){const s=t.options.demResolution;if("geometry"===t.type&&this._preselectOutsideLayerExtent(t),"number"==typeof s)this._selectTilesClosestResolution(t);else if("finest-contiguous"===s)await this._selectTilesFinestContiguous(t,e);else{if("auto"!==s)throw new i("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${s}', expected a number, "finest-contiguous" or "auto"`);await this._selectTilesAuto(t,e)}}_preselectOutsideLayerExtent(t){if(s(t.layer.fullExtent))return;const e=new d(null);e.sample=()=>t.options.noDataValue,t.outsideExtentTile=e;const i=t.layer.fullExtent;t.geometry.coordinates.forEach((t=>{const s=t.x,n=t.y;(s<i.xmin||s>i.xmax||n<i.ymin||n>i.ymax)&&(t.elevationTile=e)}))}_selectTilesClosestResolution(t){const e=this._findNearestDemResolutionLODIndex(t.layer.tileInfo,t.options.demResolution);t.selectTilesAtLOD(e)}_findNearestDemResolutionLODIndex(t,e){const s=e/l(t.spatialReference);let i=t.lods[0],n=0;for(let e=1;e<t.lods.length;e++){const o=t.lods[e];Math.abs(o.resolution-s)<Math.abs(i.resolution-s)&&(i=o,n=e)}return n}async _selectTilesFinestContiguous(t,e){const s=E(t.layer.tileInfo,t.options.minDemResolution);await this._selectTilesFinestContiguousAt(t,s,e)}async _selectTilesFinestContiguousAt(t,e,s){const a=t.layer;if(t.selectTilesAtLOD(e),e<0)return;const r=a.tilemapCache,l=t.getTilesToFetch();try{if(r)await n(Promise.all(l.map((t=>r.fetchAvailability(t.level,t.row,t.col,{signal:s})))),s);else if(await this._populateElevationTiles(t,s),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new i("elevation-query:has-unavailable-tiles")}catch(i){o(i),await this._selectTilesFinestContiguousAt(t,e-1,s)}}async _populateElevationTiles(t,s){const i=t.getTilesToFetch(),o={},r=t.options.cache,l=t.options.noDataValue,c=i.map((async i=>{const n=`${t.layer.uid}:${i.id}:${l}`,a=e(r)?r.get(n):null,c=e(a)?a:await t.layer.fetchTile(i.level,i.row,i.col,{noDataValue:l,signal:s});e(r)&&r.put(n,c),o[i.id]=new d(i,c)}));await n(a(c),s),t.populateElevationTiles(o)}async _selectTilesAuto(e,s){this._selectTilesAutoFinest(e),this._reduceTilesForMaximumRequests(e);const i=e.layer.tilemapCache;if(!i)return this._selectTilesAutoPrefetchUpsample(e,s);const a=e.getTilesToFetch(),r={},l=a.map((async e=>{const n={id:null,level:0,row:0,col:0,extent:y()},a=await t(i.fetchAvailabilityUpsample(e.level,e.row,e.col,n,{signal:s}));!1===a.ok?o(a.error):r[e.id]=n}));await n(Promise.all(l),s),e.remapTiles(r)}_reduceTilesForMaximumRequests(t){const e=t.layer.tileInfo;let s=0;const i={},n=t=>{t.id in i?i[t.id]++:(i[t.id]=1,s++)},o=t=>{const e=i[t.id];1===e?(delete i[t.id],s--):i[t.id]=e-1};t.forEachTileToFetch(n,o);let a=!0;for(;a&&(a=!1,t.forEachTileToFetch((i=>{s<=t.options.maximumAutoTileRequests||(o(i),e.upsampleTile(i)&&(a=!0),n(i))}),o),a););}_selectTilesAutoFinest(t){const e=E(t.layer.tileInfo,t.options.minDemResolution);t.selectTilesAtLOD(e,t.options.maximumAutoTileRequests)}async _selectTilesAutoPrefetchUpsample(t,e){const s=t.layer.tileInfo;await this._populateElevationTiles(t,e);let i=!1;t.forEachTileToFetch(((t,e)=>{s.upsampleTile(t)?i=!0:e()})),i&&await this._selectTilesAutoPrefetchUpsample(t,e)}_sampleGeometryWithElevation(t){t.geometry.coordinates.forEach((s=>{const i=s.elevationTile;let n=t.options.noDataValue;if(i){const t=i.sample(s.x,s.y);e(t)?n=t:s.elevationTile=null}s.z=n}))}_extractSampleInfo(t){const e=t.layer.tileInfo,s=l(e.spatialReference);return t.geometry.coordinates.map((i=>{let n=-1;return i.elevationTile&&i.elevationTile!==t.outsideExtentTile&&(n=e.lodAt(i.elevationTile.tile.level).resolution*s),{demResolution:n}}))}}class T{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(t){const e=new T;return e.geometry=this.geometry,e.spatialReference=this.spatialReference,e.coordinates=t||this.coordinates.map((t=>this._cloneCoordinate(t))),e._exporter=this._exporter,e}async project(t,e){if(this.spatialReference.equals(t))return this.clone();await u([{source:this.spatialReference,dest:t}],{signal:e});const s=new c({spatialReference:this.spatialReference,points:this.coordinates.map((t=>[t.x,t.y]))}),i=f(s,t);if(!i)return null;const n=this.coordinates.map(((t,e)=>{const s=this._cloneCoordinate(t),n=i.points[e];return s.x=n[0],s.y=n[1],s})),o=this.clone(n);return o.spatialReference=t,o}_cloneCoordinate(t){return{x:t.x,y:t.y,z:t.z,m:t.m,tile:null,elevationTile:null}}static fromGeometry(t){const e=new T;if(e.geometry=t,e.spatialReference=t.spatialReference,t instanceof T)e.coordinates=t.coordinates.map((t=>e._cloneCoordinate(t))),e._exporter=(e,s)=>{const i=t.clone(e);return i.spatialReference=s,i};else switch(t.type){case"point":{const s=t,{hasZ:i,hasM:n}=s;e.coordinates=i&&n?[{x:s.x,y:s.y,z:s.z,m:s.m}]:i?[{x:s.x,y:s.y,z:s.z}]:n?[{x:s.x,y:s.y,m:s.m}]:[{x:s.x,y:s.y}],e._exporter=(e,s)=>t.hasM?new r(e[0].x,e[0].y,e[0].z,e[0].m,s):new r(e[0].x,e[0].y,e[0].z,s);break}case"multipoint":{const s=t,{hasZ:i,hasM:n}=s;e.coordinates=s.points.map(i&&n?t=>({x:t[0],y:t[1],z:t[2],m:t[3]}):i?t=>({x:t[0],y:t[1],z:t[2]}):n?t=>({x:t[0],y:t[1],m:t[2]}):t=>({x:t[0],y:t[1]})),e._exporter=(e,s)=>t.hasM?new c({points:e.map((t=>[t.x,t.y,t.z,t.m])),hasZ:!0,hasM:!0,spatiaReference:s}):new c(e.map((t=>[t.x,t.y,t.z])),s);break}case"polyline":{const s=t,i=[],n=[],{hasZ:o,hasM:a}=t;let r=0;for(const t of s.paths)if(n.push([r,r+t.length]),r+=t.length,o&&a)for(const e of t)i.push({x:e[0],y:e[1],z:e[2],m:e[3]});else if(o)for(const e of t)i.push({x:e[0],y:e[1],z:e[2]});else if(a)for(const e of t)i.push({x:e[0],y:e[1],m:e[2]});else for(const e of t)i.push({x:e[0],y:e[1]});e.coordinates=i,e._exporter=(e,s)=>{const i=e.map(t.hasM?t=>[t.x,t.y,t.z,t.m]:t=>[t.x,t.y,t.z]),o=n.map((t=>i.slice(t[0],t[1])));return new h({paths:o,hasM:t.hasM,hasZ:!0,spatialReference:s})};break}}return e}}class q{constructor(t,e){this.layer=t,this.options=e}}class g extends q{constructor(t,e,s){super(t,s),this.outSpatialReference=e,this.type="geometry"}selectTilesAtLOD(t){if(t<0)this.geometry.coordinates.forEach((t=>t.tile=null));else{const e=this.layer.tileInfo,s=e.lods[t].level;this.geometry.coordinates.forEach((t=>{t.tile=e.tileAt(s,t.x,t.y)}))}}allElevationTilesFetched(){return!this.geometry.coordinates.some((t=>!t.elevationTile))}clearElevationTiles(){for(const t of this.geometry.coordinates)t.elevationTile!==this.outsideExtentTile&&(t.elevationTile=null)}populateElevationTiles(t){for(const e of this.geometry.coordinates)!e.elevationTile&&e.tile&&(e.elevationTile=t[e.tile.id])}remapTiles(t){for(const e of this.geometry.coordinates)e.tile=t[e.tile.id]}getTilesToFetch(){const t={},e=[];for(const s of this.geometry.coordinates){const i=s.tile;s.elevationTile||!s.tile||t[i.id]||(t[i.id]=i,e.push(i))}return e}forEachTileToFetch(t){for(const e of this.geometry.coordinates)e.tile&&!e.elevationTile&&t(e.tile,(()=>e.tile=null))}}class _ extends q{constructor(t,e,s,i){super(t,s),this.type="extent",this.elevationTiles=[],this.candidateTiles=[],this.fetchedCandidates=new Set,this.extent=e.intersection(t.fullExtent),this.maskExtents=i}selectTilesAtLOD(t,e){const s=this._maximumLodForRequests(e),i=Math.min(s,t);i<0?this.candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(i)}_maximumLodForRequests(t){const e=this.layer.tileInfo;if(!t)return e.lods.length-1;const i=this.extent;if(s(i))return-1;for(let s=e.lods.length-1;s>=0;s--){const n=e.lods[s],o=n.resolution*e.size[1];if(Math.ceil(i.width/(n.resolution*e.size[0]))*Math.ceil(i.height/o)<=t)return s}return-1}allElevationTilesFetched(){return this.candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this.fetchedCandidates.clear()}populateElevationTiles(t){for(const e of this.candidateTiles){const s=t[e.id];s&&(this.fetchedCandidates.add(e),this.elevationTiles.push(s))}}remapTiles(t){this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles.map((e=>t[e.id])))}getTilesToFetch(){return this.candidateTiles}forEachTileToFetch(t,e){const s=this.candidateTiles;this.candidateTiles=[],s.forEach((s=>{if(this.fetchedCandidates.has(s))return void(e&&e(s));let i=!1;t(s,(()=>i=!0)),i?e&&e(s):this.candidateTiles.push(s)})),this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles,e)}_uniqueNonOverlappingTiles(t,e){const s={},i=[];for(const n of t)s[n.id]?e&&e(n):(s[n.id]=n,i.push(n));const n=i.sort(((t,e)=>t.level-e.level));return n.filter(((t,s)=>{for(let i=0;i<s;i++)if(p(n[i].extent,t.extent))return e&&e(t),!1;return!0}))}_selectCandidateTilesCoveringExtentAt(t){this.candidateTiles.length=0;const e=this.extent;if(s(e))return;const i=this.layer.tileInfo,n=i.lods[t],o=i.tileAt(n.level,e.xmin,e.ymin),a=n.resolution*i.size[1],r=Math.ceil((e.xmax-o.extent[0])/(n.resolution*i.size[0])),l=Math.ceil((e.ymax-o.extent[1])/a);for(let t=0;t<l;t++)for(let e=0;e<r;e++){const s={id:null,level:o.level,row:o.row-t,col:o.col+e};i.updateTileInfo(s),this._tileIsMasked(s)||this.candidateTiles.push(s)}}_tileIsMasked(t){return!!this.maskExtents&&this.maskExtents.some((e=>p(e,t.extent)))}}function E(t,e){let s=t.lods.length-1;if(e>0){const i=t.lods.findIndex((t=>t.resolution<e));0===i?s=0:i>0&&(s=i-1)}return s}const M={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};export default x;export{x as ElevationQuery,T as GeometryDescriptor,E as getFinestLodIndex}