import{dT as t,dU as s,dV as i,dW as e,dX as n,dY as r,dZ as o,d_ as h,d$ as c,e0 as a,e1 as l,e2 as u,u as f,r as d,e3 as p,c6 as m,t as w,e4 as y,e5 as x,e6 as g,e7 as v,e8 as _,D as M,e9 as b,ea as B,eb as A,ec as D,bh as T,ed as F,ee as I,e as C,d as j,i as P,bi as z,bs as S,af as L,p as U,ef as G,d8 as R,h as O,eg as V,eh as k,k as q,cT as E,ei as N,a as X,ej as H,ek as Y,el as K,dw as J,em as Q,en as Z,eo as W,ep as $,eq as tt,er as st}from"./p-5420851c.js";import{N as it,z as et,a as nt,n as rt}from"./p-ba8c567b.js";import{f as ot,g as ht}from"./p-6df976c7.js";import{P as ct}from"./p-47e1bd73.js";import{B as at,k as lt,U as ut,K as ft,q as dt,j as pt,I as mt,E as wt,C as yt,r as xt,t as gt}from"./p-54db165f.js";import{f as vt,h as _t,e as Mt}from"./p-def8d692.js";import"./p-4d140ee3.js";import{f as bt,i as Bt,o as At}from"./p-297addf1.js";import{a as Dt,o as Tt,E as Ft,l as It,b as Ct}from"./p-78327456.js";import{h as jt,p as Pt,u as zt,y as St,_ as Lt,z as Ut,d as Gt,c as Rt,g as Ot}from"./p-baad017f.js";import{d as Vt,u as kt,P as qt}from"./p-9315e4d7.js";import{A as Et}from"./p-dcac8868.js";import{O as Nt,U as Xt}from"./p-8bf8e457.js";import{l as Ht}from"./p-7e5e535f.js";import{t as Yt}from"./p-b1c9647c.js";import{a as Kt}from"./p-e2fe661c.js";function Jt(t,s,i){if(Array.isArray(t)){const e=t[0];if(e>s){const i=a(e,s);t[0]=e+i*(-2*s)}else if(e<i){const s=a(e,i);t[0]=e+s*(-2*i)}}else{const e=t.x;if(e>s){const i=a(e,s);t.x+=i*(-2*s)}else if(e<i){const s=a(e,i);t.x+=s*(-2*i)}}return t}function Qt(t,s){const[i,e]=s.valid,n=2*e;let r,o=0;return t>e?(r=Math.ceil(Math.abs(t-e)/n),t-=r*n,o=r):t<i&&(r=Math.ceil(Math.abs(t-i)/n),t+=r*n,o=-r),{x:t,frameId:o}}function Zt(t,s){const{xmin:i,ymin:e,xmax:n,ymax:r}=s;return Wt(t,i,e)&&Wt(t,i,r)&&Wt(t,n,r)&&Wt(t,n,e)}function Wt(t,s,i){return s>=t.xmin&&s<=t.xmax&&i>=t.ymin&&i<=t.ymax}class $t{cut(t,s){let i;if(t.rings)this.closed=!0,i=t.rings,this.minPts=4;else{if(!t.paths)return null;this.closed=!1,i=t.paths,this.minPts=2}const e=i.length,n=-2*s;for(let t=0;t<e;t++){const s=i[t];if(s&&s.length>=this.minPts){const t=[];for(const i of s)t.push([i[0]+n,i[1]]);i.push(t)}}return this.closed?t.rings=i:t.paths=i,t}}const ts=f();class ss{constructor(){this._dirties=[{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1}]}hasDirty(){return this._dirties.some((t=>-1!==t.indexCount||t.allDirty))}markAllClean(){for(const t of this._dirties)t.indexFrom=-1,t.indexCount=-1,t.vertexFrom=-1,t.vertexCount=-1,t.allDirty=!1}markAllDirty(){for(const t of this._dirties)t.allDirty=!0}forEach(t){for(let s=0;s<this._dirties.length;++s){const{indexCount:i,indexFrom:e,vertexCount:n,vertexFrom:r,allDirty:o}=this._dirties[s],h={};let c,a=!1;(o||-1!==r&&n>0)&&(h.geometry={count:n,from:r,allDirty:o},a=!0),(o||-1!==e&&i>0)&&(c={count:i,from:e,allDirty:o},a=!0),a&&t({indices:c,vertices:h},s)}}markDirtyIndices(t,s,i){const e=this._dirties[t],n=s,r=i;if(!e.allDirty)if(-1!==e.indexCount){const t=Math.min(e.indexFrom,n),s=Math.max(e.indexFrom+e.indexCount,n+r)-t;e.indexFrom=t,e.indexCount=s}else e.indexFrom=n,e.indexCount=r}markDirtyVertices(t,s,i,e){const n=this._dirties[t],r=i,o=e;if(!n.allDirty)if(-1!==n.vertexCount){const t=Math.min(n.vertexFrom,r),s=Math.max(n.vertexFrom+n.vertexCount,r+o)-t;n.vertexFrom=t,n.vertexCount=s}else n.vertexFrom=r,n.vertexCount=o}}class is{constructor(t){this._largestRange=null,this._parent=t,this._updateLargestRange()}get largestRange(){return this._largestRange}rangeCreated(t){(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}rangeResized(t,s){t===this._largestRange?t.count<s&&this._updateLargestRange():(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}findBestRange(t){let s=this._parent._freeHead,i=null;for(;null!==s;)s.count>=t&&(!i||s.count-t<i.count-t)&&(i=s),s=s.next;return i}findAdjacentRanges(t,s){let i=!0,e=!1,n=null,r=this._parent._freeHead;for(;i&&!e;){const o=null!==r?r.from:this._parent._size;t>=(null!==n?n.from+n.count:0)&&t+s<=o?(i=!1,e=!0):null!==r?(n=r,r=r.next):i=!1}return[n,r]}_updateLargestRange(){let t=null,s=this._parent._freeHead;for(;null!==s;)(!t||s.count>t.count)&&(t=s),s=s.next;this._largestRange=t}}class es{constructor(t,s){this._allocated=0,this._size=t,this._freeHead=t>0?{from:0,count:t,prev:null,next:null}:null,this._bookKeeper=s||new is(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(t){const s=this._bookKeeper.findBestRange(t);if(null===s)return-1;const i=s.from,e=s.count;if(s.from+=t,s.count-=t,this._bookKeeper.rangeResized(s,i,e),this._allocated+=t,0===s.count){const t=null!==s.prev?this._freeHead:s.next;es._removeRange(s),this._freeHead=t}return i}free(t,s){const[i,e]=this._bookKeeper.findAdjacentRanges(t,s),n={from:t,count:s,prev:i,next:e};if(null!==i&&(i.next=n),null!==e&&(e.prev=n),this._bookKeeper.rangeCreated(n),this._allocated-=s,null!==e&&n.from+n.count===e.from){const t=n.from,s=n.count;es._fuse(n,e),es._removeRange(e),this._bookKeeper.rangeResized(n,t,s),this._bookKeeper.rangeResized(e,void 0,0)}if(null!==i&&i.from+i.count===n.from){const t=i.from,s=i.count;es._fuse(i,n),es._removeRange(n),this._bookKeeper.rangeResized(i,t,s),this._bookKeeper.rangeResized(n,void 0,0)}this._freeHead=null!==n.prev?this._freeHead:n}get fragmentation(){const t=this._size-this._allocated;return 0===t?0:1-this._bookKeeper.largestRange.count/t}static _removeRange(t){null!==t.prev?null!==t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null:null!==t.next&&(t.next.prev=null)}static _fuse(t,s){t.count+=s.count,t.next=s.next,s.from+=s.count,s.count=0,null!==s.next&&(s.next.prev=t)}}const ns=["FILL","LINE","MARKER","TEXT","LABEL"];class rs{constructor(t,s,i,e){this._strides=t,this._displayList=s,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=i;for(const s in t){this._freeListsAndStorage[s]={vtxFreeList:e?new es(e):null,idxFreeList:e?new es(e):null,vertexBuffers:{},indexBuffer:e?new Uint32Array(e):null};for(const i in t[s])this._freeListsAndStorage[s].vertexBuffers[i]={data:e?at(e,t[s][i]):null,stride:t[s][i]}}}static fromTileData(t,s){const i=function(t){const s=t.getStrides(),i={};for(let t=0;t<s.length;t++)i[ns[t]]=s[t];return i}(t),e=[0,0,0,0,0],n=[0,0,0,0,0],r=t.tileDisplayData.displayObjects;for(const t of r)for(const s of t.displayRecords)e[s.geometryType]=Math.max(e[s.geometryType],s.vertexFrom+s.vertexCount),n[s.geometryType]=Math.max(n[s.geometryType],s.indexFrom+s.indexCount);const o=new rs(i,t.tileDisplayData.displayList,s,null);for(let s=0;s<t.tileBufferData.geometries.length;++s){const i=e[s],r=n[s],h=t.tileBufferData.geometries[s],c=o._storageFor(ns[s]),a=t.tileBufferData.geometries[s].indexBuffer;let l;c.indexBuffer=a,c.idxFreeList=new es(a.length),c.idxFreeList.allocate(r);for(const i in h.vertexBuffer){const e=t.tileBufferData.geometries[s].vertexBuffer[i];c.vertexBuffers[i].data=e.data,c.vertexBuffers[i].stride=e.stride;const n=ut(e.stride),r=e.data.length*n/e.stride;l||(l=r)}c.vtxFreeList=new es(l),c.vtxFreeList.allocate(i)}return o}delete(t){const s=ns[t.geometryType];this._freeVertices(s,t.vertexFrom,t.vertexCount),this._freeIndices(s,t.indexFrom,t.indexCount),this._displayList.removeFromList(t),t.vertexFrom=void 0,t.indexFrom=void 0}setMeshData(t,s,i,e,n){const r=ns[t.geometryType];let o,h;t.meshData=null,void 0===t.vertexFrom?(h=s.vertexCount,o=this._allocateVertices(r,h)):s.vertexCount>t.vertexCount?(this._freeVertices(r,t.vertexFrom,t.vertexCount),h=s.vertexCount,o=this._allocateVertices(r,h)):s.vertexCount===t.vertexCount?(o=t.vertexFrom,h=t.vertexCount):(this._freeVertices(r,t.vertexFrom+s.vertexCount,t.vertexCount-s.vertexCount),o=t.vertexFrom,h=s.vertexCount);let c,a,l,u=!0;if(void 0===t.indexFrom?(c=n,l=s.indexCount,a=this._allocateIndices(r,l)):s.indexCount>t.indexCount?(c=this._displayList.removeFromList(t),this._freeIndices(r,t.indexFrom,t.indexCount),l=s.indexCount,a=this._allocateIndices(r,l)):s.indexCount===t.indexCount?(u=!1,a=t.indexFrom,l=t.indexCount):(c=this._displayList.removeFromList(t),this._freeIndices(r,t.indexFrom+s.indexCount,t.indexCount-s.indexCount),a=t.indexFrom,l=s.indexCount),-1!==o&&-1!==a){const n=this._storageFor(r);if(lt(o,a,n.vertexBuffers,n.indexBuffer,s,i,e),t.vertexFrom=o,t.indexFrom=a,t.vertexCount=s.vertexCount,t.indexCount=s.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const s in i)this._dirtyMap.markDirtyVertices(t.geometryType,s,t.vertexFrom,t.vertexCount)}return u&&this._displayList.addToList(t,c),!0}return-1!==o&&this._freeVertices(r,o,h),-1!==a&&this._freeIndices(r,a,l),t.setMeshDataFromBuffers(s,i,e),t.vertexFrom=void 0,t.vertexCount=0,t.indexFrom=void 0,t.indexCount=0,!1}tryAddMeshData(t,s){const i=s.vertexBuffer,e=s.indexBuffer,n=ns[t.geometryType],r=this._allocateVertices(n,t.vertexCount);if(-1===r)return this._freeVertices(n,r,t.vertexCount),!1;const o=this._allocateIndices(n,t.indexCount);if(-1===o)return this._freeVertices(n,r,t.vertexCount),this._freeIndices(n,o,t.indexCount),!1;const h=this._storageFor(n);if(lt(r,o,h.vertexBuffers,h.indexBuffer,t,i,e),t.vertexFrom=r,t.indexFrom=o,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const s in i)this._dirtyMap.markDirtyVertices(t.geometryType,s,r,t.vertexCount)}return this._displayList.addToList(t),!0}_allocateVertices(t,s){const i=this._storageFor(t),e=i.vtxFreeList.allocate(s);return-1===e||i.vtxFreeList.fragmentation>.5?-1:e}_freeVertices(t,s,i){this._storageFor(t).vtxFreeList.free(s,i)}_freeIndices(t,s,i){this._storageFor(t).idxFreeList.free(s,i)}_allocateIndices(t,s){const i=this._storageFor(t),e=i.idxFreeList.allocate(s);return-1===e||i.idxFreeList.fragmentation>.5?-1:e}_storageFor(t){return this._freeListsAndStorage[t]}_stridesFor(t,s){return this._strides[t][s]}}class os{constructor(t){this.geometryMap=ft((()=>({indexBuffer:_t.createIndex(t,35044),vao:null})),((s,i)=>({vertexBuffer:_t.createVertex(t,dt[i])})))}dispose(){for(let t=0;t<5;t++){const s=this.geometryMap[t];if(s){s.data.vao&&s.data.vao.dispose(!1),s.data.indexBuffer&&s.data.indexBuffer.dispose();for(const t in s.buffers)s.buffers[t]&&s.buffers[t].data.vertexBuffer.dispose()}}}get(t){const s=this.geometryMap[t];return{draw(t,i,e,n,r){if(!s.data.vao){const n={};for(const t in s.buffers)n[t]=s.buffers[t].data.vertexBuffer;s.data.vao=new vt(t,e,i,n,s.data.indexBuffer)}t.bindVAO(s.data.vao),t.drawElements(4,r,5125,Uint32Array.BYTES_PER_ELEMENT*n),t.bindVAO(null)}}}has(t){return null!=this.geometryMap[t]}upload(t,s){s.forEach(((s,i)=>{this._upload(s,i,t)}))}_upload(t,s,i){if(t.indices&&(t.indices.allDirty?this._uploadIndices(i,s):null!=t.indices.from&&null!=t.indices.count&&this._uploadIndices(i,s,t.indices.from,t.indices.count)),t.vertices){const e=t.vertices;for(const t in e){const n=e[t];n.allDirty?this._uploadVertices(i,s,t):null!=n.from&&null!=n.count&&this._uploadVertices(i,s,t,n.from,n.count)}}}_uploadVertices(t,s,i,e,n){const r=this.geometryMap[s];if(!r)return;const o=t.geometries[s].vertexBuffer[i];if(!o)return;const h=o.stride,c=o.data.buffer;r.buffers[i]&&c.byteLength>0&&(null!=e&&null!=n?r.buffers[i].data.vertexBuffer.setSubData(c,e*h,e*h,(e+n)*h):r.buffers[i].data.vertexBuffer.setData(c))}_uploadIndices(t,s,i,e){const n=this.geometryMap[s];if(!n)return;const r=t.geometries[s].indexBuffer.buffer;n.data.indexBuffer&&r.byteLength>0&&(null!=i&&null!=e?n.data.indexBuffer.setSubData(r,4*i,4*i,4*(i+e)):n.data.indexBuffer.setData(r))}}class hs extends bt{constructor(){super(...arguments),this._data=null,this._displayList=null,this._lastCommitTime=0,this._hasData=!1,this._invalidated=!1,this._wglBuffers=null,this._dirtyMap=new ss}destroy(){super.destroy(),this.clear()}get hasData(){return!!this._hasData}get displayObjects(){var t;return null!=(t=this._displayObjects)?t:[]}getGeometry(t){return this._wglBuffers&&this._wglBuffers.has(t)?this._wglBuffers.get(t):null}getDisplayList(){return this._displayList}patch(t){if(!0===t.clear)return this.clear(),void(this._hasData=!1);const s=t.addOrUpdate,i=t.remove;!this._data&&s&&s.tileDisplayData.displayObjects.length?(s.tileDisplayData.computeDisplayList(),this._dirtyMap=new ss,this._dispRecStore=rs.fromTileData(s,this._dirtyMap),this._data=s,this._dirtyMap.markAllDirty(),this._hasData=!0,t.end&&this.ready()):this._data&&(s&&s.tileDisplayData.displayObjects.length||i.length)?this._doPatchData(t):t.end&&this.ready(),t.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}commit(t){t.time&&t.time===this._lastCommitTime||(this._lastCommitTime=t.time,this.visible&&this._data&&(this._wglBuffers||(this._wglBuffers=new os(t.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._dirtyMap.markAllClean())))}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(t){this._invalidated=!0,this._patchData(t)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=rs.fromTileData(this._data,this._dirtyMap)),this.requestRender()}_patchData(t){let s=!0;const i=t.addOrUpdate&&t.addOrUpdate.tileDisplayData&&t.addOrUpdate.tileDisplayData.displayObjects||[],e=(t.remove||[]).slice();for(const t of i)null!=t.insertAfter&&e.push(t.id);for(const t of e){const s=this._data.tileDisplayData.displayObjectRegistry.get(t);if(s){this._data.tileDisplayData.displayList.removeFromList(s.displayRecords);for(const t of s.displayRecords)this._dispRecStore.delete(t);this._data.tileDisplayData.displayObjectRegistry.delete(t);const i=this._data.tileDisplayData.displayObjects.indexOf(s);this._data.tileDisplayData.displayObjects.splice(i,1)}}for(const e of i){let i,n=this._data.tileDisplayData.displayObjectRegistry.get(e.id);if(n){const t=n.displayRecords;n.set(e),n.displayRecords=t;const s=n.displayRecords.length;for(let t=0;t<s;++t){const s=n.displayRecords[t],i=e.displayRecords[t];(t>=e.displayRecords.length||s.geometryType!==i.geometryType||s.symbolLevel!==i.symbolLevel||s.zOrder!==i.zOrder||s.materialKey!==i.materialKey)&&(this._dispRecStore.delete(n.displayRecords[t]),t<e.displayRecords.length&&(n.displayRecords[t]=void 0))}n.displayRecords.length=e.displayRecords.length}else{let t;n=e.copy(),n.displayRecords=[],this._data.tileDisplayData.displayObjectRegistry.set(e.id,n);const s=this._data.tileDisplayData.displayObjects;if(null!=n.insertAfter)if(i={},n.insertAfter>=0){const i=this._data.tileDisplayData.displayObjectRegistry.get(n.insertAfter);i?(t=s.indexOf(i)+1,t<s.length?s.splice(t,0,n):(s.push(n),t=s.length)):(s.push(n),t=s.length)}else s.unshift(n),t=0;else s.push(n),t=s.length;if(i){const n=e.displayRecords.length>0?1:0;let r=0;for(let e=t-1;e>=0&&r<n;--e)for(let t=s[e].displayRecords.length-1;t>=0&&r<n;--t){const n=s[e].displayRecords[t],o=this._data.tileDisplayData.displayList.getDPInfoType();i[o]||(i[o]=n,++r)}}}const r=e.displayRecords.length;for(let o=0;o<r;++o){const r=e.displayRecords[o];let h=n.displayRecords[o];h?(h.meshData=r.meshData,h.materialKey=r.materialKey):(h=r.copy(),h.vertexFrom=void 0,h.indexFrom=void 0,n.displayRecords[o]=h);const c=r.geometryType,a=this._data.tileDisplayData.displayList.getDPInfoType(),l=t.addOrUpdate.tileBufferData.geometries[c],u=l.vertexBuffer,f=l.indexBuffer;let d;i&&(d=i[a]?this._data.tileDisplayData.displayList.splitAfter(i[a]):-1),s=this._dispRecStore.setMeshData(h,r,u,f,d)&&s,i&&null!=h.indexFrom&&null!=h.indexFrom&&(i[a]=h)}}return s}}class cs{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(t){return this._byGeometryType?this._byGeometryType[t].vertices:0}indicesFor(t){return this._byGeometryType?this._byGeometryType[t].indices:0}needMore(t,s,i){if(!s&&!i)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const e=this._byGeometryType[t];e.vertices+=s,e.indices+=i}}class as{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const t=new as;for(let s=0;s<this.geometries.length;s++){const i=this.geometries[s],e=t.geometries[s];e.indexBuffer=i.indexBuffer.slice(),e.vertexBuffer={};for(const t in i.vertexBuffer){const{data:s,stride:n}=i.vertexBuffer[t];e.vertexBuffer[t]={data:s.slice(),stride:n}}}return t}static deserialize(t){const s=new as;for(let i=0;i<5;++i){s.geometries[i].indexBuffer=new Uint32Array(t.geometries[i].indexBuffer),s.geometries[i].vertexBuffer={};for(const e in t.geometries[i].vertexBuffer)s.geometries[i].vertexBuffer[e]={data:pt(t.geometries[i].vertexBuffer[e].data,t.geometries[i].vertexBuffer[e].stride),stride:t.geometries[i].vertexBuffer[e].stride}}return s}serialize(){const t={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let s=0;s<5;++s)for(const i in this.geometries[s].vertexBuffer)t.geometries[s].vertexBuffer[i]={data:this.geometries[s].vertexBuffer[i].data.buffer,stride:this.geometries[s].vertexBuffer[i].stride};return t}getBuffers(){const t=[];for(let s=0;s<5;++s){t.push(this.geometries[s].indexBuffer.buffer);for(const i in this.geometries[s].vertexBuffer)t.push(this.geometries[s].vertexBuffer[i].data.buffer)}return t}}function ls(t,s,i,...e){s<t.length?t.splice(s,i,...e):t.push(...e)}const us=new Map;us.set(mt.MAP,[wt.FILL,wt.LINE,wt.MARKER,wt.TEXT]),us.set(mt.LABEL,[wt.LABEL]),us.set(mt.LABEL_ALPHA,[wt.LABEL]);class fs{constructor(){this.symbolLevels=[]}replay(t,s,i){for(const e of this.symbolLevels)for(const n of e.zLevels){const e=n.geometryDPInfo.unified;if(e)for(const n of e){const e=t.painter.getGeometryBrush(n.geometryType),r=s.getGeometry(n.geometryType),o={geometryType:n.geometryType,materialKey:n.materialKey,indexFrom:n.indexFrom,indexCount:n.indexCount,draw:(t,s,i)=>{r.draw(t,s,i,n.indexFrom,n.indexCount)}};e.prepareState(t,s),e.drawGeometry(t,s,o,i)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(t,s){if(Array.isArray(t))for(const i of t)this._addToList(i,s);else this._addToList(t,s)}removeFromList(t){Array.isArray(t)||(t=[t]);let s=null;for(const i of t)s=this._removeFromList(i);return s}clone(){const t=new fs;for(const s of this.symbolLevels)t.symbolLevels.push(s.clone());return t}splitAfter(t){const s=this._getDisplayList(t.symbolLevel,t.zOrder),i=s.length,e=t.indexFrom+t.indexCount;for(let n=0;n<i;++n){const i=s[n];if(i.geometryType===t.geometryType&&e>i.indexFrom&&e<=i.indexFrom+i.indexCount){if(e<i.indexFrom+i.indexCount){const t=new ds;t.geometryType=i.geometryType,t.materialKey=i.materialKey,t.indexFrom=e,t.indexCount=i.indexFrom+i.indexCount-e,s.splice(n+1,0,t),i.indexCount=e-i.indexFrom}return n}}}_addToList(t,s){const i=this._getDisplayList(t.symbolLevel,t.zOrder),e=null!=s?s:i.length-1,n=e>=0&&e<i.length?i[e]:null;if(null!==n&&n.materialKey===t.materialKey&&n.indexFrom+n.indexCount===t.indexFrom&&n.geometryType===t.geometryType)n.indexCount+=t.indexCount;else{const s=new ds;s.indexFrom=t.indexFrom,s.indexCount=t.indexCount,s.materialKey=t.materialKey,s.geometryType=t.geometryType,ls(i,e+1,0,s)}}_removeFromList(t){const s=this._getDisplayList(t.symbolLevel,t.zOrder),i=s.length;let e;for(let n=0;n<i;++n){const i=s[n];if(t.indexFrom+t.indexCount>i.indexFrom&&t.indexFrom<i.indexFrom+i.indexCount&&i.geometryType===t.geometryType){e=n;break}}if(void 0!==e){const i=s[e];if(t.indexFrom===i.indexFrom)return i.indexCount-=t.indexCount,i.indexFrom+=t.indexCount,0===i.indexCount&&ls(s,e,1),e-1;if(t.indexFrom+t.indexCount===i.indexFrom+i.indexCount)return i.indexCount-=t.indexCount,0===i.indexCount?(ls(s,e,1),e-1):e;{const n=i.indexFrom,r=t.indexFrom-i.indexFrom,o=t.indexCount,h=i.indexFrom+i.indexCount-(t.indexFrom+t.indexCount);i.indexCount=r;const c=new ds;return c.geometryType=i.geometryType,c.materialKey=i.materialKey,c.indexFrom=n+r+o,c.indexCount=h,ls(s,e+1,0,c),e}}return null}_getDisplayList(t,s){let i;const e=this.symbolLevels.length;for(let s=0;s<e;s++)if(this.symbolLevels[s].symbolLevel===t){i=this.symbolLevels[s];break}let n;i||(i=new ws,i.symbolLevel=t,this.symbolLevels.push(i));const r=i.zLevels.length;for(let t=0;t<r;t++)if(i.zLevels[t].zLevel===s){n=i.zLevels[t];break}return n||(n=new ms,n.geometryDPInfo=new ps,n.zLevel=s,i.zLevels.push(n)),n.geometryDPInfo.unified||(n.geometryDPInfo.unified=[]),n.geometryDPInfo.unified}getDPInfoType(){return"unified"}}class ds{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const t=new ds;return t.geometryType=this.geometryType,t.materialKey=this.materialKey,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t}}class ps{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const t=new ps;return t.fill=this.fill&&this.fill.map((t=>t.clone())),t.line=this.line&&this.line.map((t=>t.clone())),t.marker=this.marker&&this.marker.map((t=>t.clone())),t.text=this.text&&this.text.map((t=>t.clone())),t.label=this.label&&this.label.map((t=>t.clone())),t.unified=this.unified&&this.unified.map((t=>t.clone())),t}}class ms{constructor(){this.geometryDPInfo=new ps}clone(){const t=new ms;return t.zLevel=this.zLevel,t.geometryDPInfo=this.geometryDPInfo.clone(),t}}class ws{constructor(){this.zLevels=[]}clone(){const t=new ws;t.symbolLevel=this.symbolLevel;for(const s of this.zLevels)t.zLevels.push(s.clone());return t}}class ys{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(t,s,i){for(const s in t)this.vertexData.set(s,t[s]);for(const s in this.vertexData)null===t[s]&&this.vertexData.delete(s);this.vertexCount=s,this.indexData=i}}class xs{constructor(t,s,i,e=0,n=0){this.id=t,this.geometryType=s,this.materialKey=i,this.minZoom=e,this.maxZoom=n,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0}get sortKey(){return void 0===this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const t=new xs(this.id,this.geometryType,this.materialKey);return t.vertexFrom=this.vertexFrom,t.vertexCount=this.vertexCount,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t.zOrder=this.zOrder,t.symbolLevel=this.symbolLevel,t.meshData=this.meshData,t.minZoom=this.minZoom,t.maxZoom=this.maxZoom,t}setMeshDataFromBuffers(t,s,i){const e=new ys;for(const i in s){const n=s[i].stride,r=s[i].data,o=[],h=ut(n);for(let s=0;s<n*t.vertexCount/h;++s)o[s]=r[s+n*t.vertexFrom/h];e.vertexData.set(i,o)}e.indexData.length=0;for(let s=0;s<t.indexCount;++s)e.indexData[s]=i[s+t.indexFrom]-t.vertexFrom;e.vertexCount=t.vertexCount,this.meshData=e}readMeshDataFromBuffers(t,s){this.meshData?this.meshData.clear():this.meshData=new ys;for(const s in t){const i=t[s].stride,e=t[s].data,n=[],r=ut(i);for(let t=0;t<i*this.vertexCount/r;++t)n[t]=e[t+i*this.vertexFrom/r];this.meshData.vertexData.set(s,n)}this.meshData.indexData.length=0;for(let t=0;t<this.indexCount;++t)this.meshData.indexData[t]=s[t+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(t,s,i,e){for(const i in s){const e=s[i].stride,n=this.meshData.vertexData.get(i),r=s[i].data,o=ut(e);for(let s=0;s<e*this.meshData.vertexCount/o;++s)r[s+e*t/o]=n[s]}for(let s=0;s<this.meshData.indexData.length;++s)e[s+i]=this.meshData.indexData[s]+t;this.vertexFrom=t,this.vertexCount=this.meshData.vertexCount,this.indexFrom=i,this.indexCount=this.meshData.indexData.length}static writeAllMeshDataToBuffers(t,s,i){let e=0,n=0;for(const r of t)r.writeMeshDataToBuffers(e,s,n,i),e+=r.vertexCount,n+=r.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(t){return t.push(this.geometryType),t.push(this.materialKey),t.push(this.vertexFrom),t.push(this.vertexCount),t.push(this.indexFrom),t.push(this.indexCount),t.push(this.minZoom),t.push(this.maxZoom),t}static deserialize(t,s){const i=t.readInt32(),e=t.readInt32(),n=new xs(s.id,i,e);return n.vertexFrom=t.readInt32(),n.vertexCount=t.readInt32(),n.indexFrom=t.readInt32(),n.indexCount=t.readInt32(),n.minZoom=t.readInt32(),n.maxZoom=t.readInt32(),n}}function gs(t,s){if(null!==s){t.push(s.length);for(const i of s)i.serialize(t);return t}t.push(0)}class vs{constructor(t){this.insertAfter=null,this.id=t,this.displayRecords=[]}copy(){const t=new vs(this.id);return t.set(this),t}clone(){const t=new vs(this.id);return t.displayRecords=this.displayRecords.map((t=>t.clone())),t.insertAfter=this.insertAfter,t}set(t){this.id=t.id,this.displayRecords=t.displayRecords,this.insertAfter=t.insertAfter}serialize(t){return t.push(this.id),gs(t,this.displayRecords),t}static deserialize(t){const s=t.readInt32(),i=new vs(s);return i.displayRecords=function(t,s,i){const e=t.readInt32(),n=new Array(e);for(let e=0;e<n.length;e++)n[e]=s.deserialize(t,i);return n}(t,xs,{id:s}),i}}class _s{constructor(){}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const t of this.displayObjects)this._displayObjectRegistry.set(t.id,t)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(){this._displayList=new fs;for(const t of this.displayObjects)for(const s of t.displayRecords)this._displayList.addToList(s)}clone(){const t=new _s;return this.displayObjects&&(t.displayObjects=this.displayObjects.map((t=>t.clone()))),t}serialize(t){return gs(t,this.displayObjects),t}_deserializeObjects(t){const s=t.readInt32(),i=new Array(s),e=new Map;for(let s=0;s<i.length;++s){const n=vs.deserialize(t);i[s]=n,e.set(n.id,n)}this.displayObjects=i,this._displayList=null,this._displayObjectRegistry=e}static deserialize(t){const s=new _s;return s._deserializeObjects(t),s}}class Ms{constructor(t,s){this.data=t,this.stride=s}static decode(t){const s=pt(t.data,t.stride);return new Ms(s,t.stride)}static fromVertexVector(t){const s=pt(t.data.buffer(),t.stride);return new Ms(s,t.stride)}}class bs{constructor(t,s,i){this.geometryType=t,this.indexBuffer=new Uint32Array(s),this.namedBuffers=i}static decode(t){const s=t.geometryType,i=t.indexBuffer,e={};for(const s in t.namedBuffers)e[s]=Ms.decode(t.namedBuffers[s]);return new bs(s,i,e)}static fromVertexData(t,s){const i=t.indices,e=pt(t.vertices,t.stride),n={geometry:new Ms(e,t.stride)};return new bs(s,i,n)}static fromVertexVectors(t){const s=t.geometryType,i=t.indexVector.buffer(),e={};for(const s in t.namedVectors)e[s]=Ms.fromVertexVector(t.namedVectors[s]);return new bs(s,i,e)}}class Bs{constructor(t,s){this.data=t,this.stride=s}get vertexCount(){const t=this.data.length/(this.stride/4);return t!==(0|t)&&console.debug("Corrupted stride"),t}transfer(t,s){const i=this.data.buffer();t.vertexCount=this.vertexCount,t.data=i,t.stride=this.stride,s.push(i)}}class As{constructor(t,s,i=!1){this.geometryType=t,this.indexVector=new Dt(Uint32Array,6*s),this.namedVectors={};const e=yt(t,i);for(const t in e){const i=e[t];let n;switch(i%4){case 0:case 2:n=new Dt(Uint32Array,i*s);break;case 1:case 3:n=new Dt(Uint8Array,i*s)}this.namedVectors[t]=new Bs(n,i)}}get(t){return this.namedVectors[t].data}getVector(t){return this.namedVectors[t]}transfer(t,s){const i=this.indexVector.buffer(),e={};s.push(i);for(const t in this.namedVectors){const i=this.namedVectors[t];e[t]={},i.transfer(e[t],s)}t.geometryType=this.geometryType,t.indexBuffer=i,t.namedBuffers=e,this.destroy()}intoBuffers(){const t=bs.fromVertexVectors(this);return this.destroy(),t}destroy(){this.indexVector=null,this.namedVectors=null}}const Ds=new cs,Ts=new cs;function Fs(t,s){const i={};for(const e in t){const n={data:at(s,t[e]),stride:t[e]};i[e]=n}return i}class Is{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){Ds.reset();const t=function(t){const s=[[],[],[],[],[]],i=t;for(const t of i)for(const i of t.displayRecords)s[i.geometryType].push(i);return s}(this.tileDisplayData.displayObjects);for(const s of t)for(const t of s)t&&Ds.needMore(t.geometryType,t.meshData?t.meshData.vertexCount:t.vertexCount,t.meshData?t.meshData.indexData.length:t.indexCount);const s=t.length,i=new as;for(let t=0;t<s;++t){i.geometries[t].indexBuffer=new Uint32Array(Math.round(1.5*Ds.indicesFor(t)));const s=[];for(const i in this.tileBufferData.geometries[t].vertexBuffer)s.push(this.tileBufferData.geometries[t].vertexBuffer[i].stride);const e=Is._computeVertexAlignment(s),n=Math.round(1.5*Ds.verticesFor(t)),r=Is._align(n,e);for(const s in this.tileBufferData.geometries[t].vertexBuffer){const e=this.tileBufferData.geometries[t].vertexBuffer[s].stride;i.geometries[t].vertexBuffer[s]={stride:e,data:at(r,e)}}}Ts.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<s;++e){const s=t[e];for(const t of s){if(t.meshData)t.writeMeshDataToBuffers(Ts.verticesFor(e),i.geometries[e].vertexBuffer,Ts.indicesFor(e),i.geometries[e].indexBuffer),t.meshData=null;else{const s=this.tileBufferData.geometries[e].vertexBuffer,n=this.tileBufferData.geometries[e].indexBuffer,r=i.geometries[e].vertexBuffer,o=i.geometries[e].indexBuffer,h=Ts.verticesFor(e),c=Ts.indicesFor(e);lt(h,c,r,o,t,s,n),t.vertexFrom=h,t.indexFrom=c}Ts.needMore(e,t.vertexCount,t.indexCount)}}for(const t of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(t.displayRecords);this.tileBufferData=i}getStrides(){const t=[];for(let s=0;s<this.tileBufferData.geometries.length;++s){const i=this.tileBufferData.geometries[s];t[s]={};for(const e in i.vertexBuffer)t[s][e]=i.vertexBuffer[e].stride}return t}clone(){const t=new Is;return t.tileBufferData=this.tileBufferData.clone(),t.tileDisplayData=this.tileDisplayData.clone(),t}_guessSize(){const{displayObjects:t}=this.tileDisplayData,s=Math.min(t.length,4);let i=0;for(let e=0;e<s;e++)i=Math.max(i,t[e].displayRecords.length);return 2*(12*t.length+t.length*i*40)}serialize(){const t=this.tileBufferData.serialize(),s=this.tileBufferData.getBuffers(),i=this.tileDisplayData.serialize(new Dt(Int32Array,this._guessSize())).buffer();return s.push(i),{result:{displayData:i,bufferData:t},transferList:s}}static fromVertexData(t,s){const i={},e=new Map;for(const t of s)e.set(t.id,t);return xt((s=>{const n=t.data[s];if(d(n)){const t=Bt.from(n.records).getCursor();for(;t.next();){const i=t.id,n=t.materialKey,r=t.indexFrom,o=t.indexCount,h=t.vertexFrom,c=t.vertexCount,a=e.get(i),l=new xs(i,s,n);l.indexFrom=r,l.indexCount=o,l.vertexFrom=h,l.vertexCount=c,a.displayRecords.push(l)}i[s]=bs.fromVertexData(n,s)}else i[s]=new As(s,0).intoBuffers()})),Is.fromMeshData({displayObjects:s,vertexBuffersMap:i})}static fromMeshData(t){const s=new Is,i=new _s,e=new as;i.displayObjects=t.displayObjects;for(const s in t.vertexBuffersMap){const i=t.vertexBuffersMap[s];e.geometries[s].indexBuffer=i.indexBuffer,e.geometries[s].vertexBuffer=i.namedBuffers}return s.tileDisplayData=i,s.tileBufferData=e,s}static bind(t,s){const i=new Is;return i.tileDisplayData=t,i.tileBufferData=s,i}static create(t,s){const i=new Is;i.tileDisplayData=new _s,i.tileDisplayData.displayObjects=t;const e=[0,0,0,0,0],n=[0,0,0,0,0],r=[[],[],[],[],[]];for(const s of t)for(const t of s.displayRecords)r[t.geometryType].push(t),e[t.geometryType]+=t.meshData.vertexCount,n[t.geometryType]+=t.meshData.indexData.length;const o=new as,h=function(t){return[t.fill||{},t.line||{},t.icon||{},t.text||{},t.label||{}]}(s);for(let t=0;t<5;t++){const s=new Uint32Array(n[t]),i=Fs(h[t],e[t]);xs.writeAllMeshDataToBuffers(r[t],i,s),o.geometries[t]={indexBuffer:s,vertexBuffer:i}}return i.tileBufferData=o,i}static _align(t,s){const i=t%s;return 0===i?t:t+(s-i)}static _computeVertexAlignment(t){let s=!1,i=!1;for(const e of t)e%4==2?s=!0:e%4!=0&&(i=!0);return i?4:s?2:1}}class Cs extends Vt{constructor(t,s){super(t,s,null)}static from(t){const s=Et.createInstance(),i=[],e=t.filter((t=>!!t.geometry));for(const t of e){const s=m(t.geometry);p(i,[t],s,!1,!1,"uid")}return new Cs(s,i)}get geometryType(){const t=this._current;return t?t.geometryType:null}get insertAfter(){return this._current.insertAfter}readGraphic(){return this._current}getCursor(){return this.copy()}copy(){const t=new Cs(this.instance,this._features);return this.copyInto(t),t}}const js=new b,Ps=new b,zs="esriGeometryPolyline";function Ss(t){t.coords.length=0,t.lengths.length=0}class Ls{constructor(){this.bounds=f(),this.graphic=null}static acquire(t=null,s,i,e,n){let r;return 0===Ls._pool.length?r=new Ls:(r=Ls._pool.pop(),this._set.delete(r)),r.acquire(t,s,i,e,n),r}static release(t){t&&!this._set.has(t)&&(t.release(),this._pool.push(t),this._set.add(t))}static getCentroidQuantized(t,s){if(e(t.geometry)){const i=t.symbol;if(w(i))return null;if(jt(i.type)||Pt(i.type)){const i=y(t.geometry);return Nt(s,{},{x:i[0],y:i[1]},!1,!1)}}return null}acquire(t=null,s,i,e,n){t&&this.set(t,s,i,e,n)}release(){this.graphic=null,this.symbolResource=null,this.geometry=null}get symbol(){return this.symbolResource.symbol}set(t,s,i,e,n){this.graphic=t,this.geometry=i,this.symbolResource=s,this.bounds=e,n&&(this.size=n)}getGeometryQuantized(t,i,r,o){const h=this.geometry;if(e(h)){const s=h.rings;if(1===s.length&&2===s[0].length)return Xt(t,{paths:[[s[0][0],s[0][1]]]})}else{if(n(h))return Ss(js),Ss(Ps),x(js,h),g(Ps,js,h.hasZ,h.hasM,zs,t.scale[0]),v(js,Ps,h.hasZ,h.hasM,zs,t),_(js,h.hasZ,h.hasM);if(s(h)){const s=.5*o*Math.max(Math.abs(this.size[0])+this.size[2]-this.size[0],Math.abs(this.size[1])+this.size[3]-this.size[1]),[e,n]=B(r),c=n-e,a=h.points.filter((t=>{if(t[0]+s>n||t[0]-s<e){const e=[...t];return t[0]+s>n?e[0]-=c:e[0]+=c,M(i,t,s)||M(i,e,s)}return M(i,t,s)}));return 0===a.length?{points:a}:Xt(t,{points:a})}}return Xt(t,this.geometry)}}Ls._pool=[],Ls._set=new Set;const Us={minX:0,minY:0,maxX:0,maxY:0},Gs=f();function Rs(t,s,i,e,n){return Us.minX=s,Us.minY=i,Us.maxX=e,Us.maxY=n,t.search(Us)}function Os(t){return{minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]}}class Vs{constructor(t,s,i,e,n,r,o){this._graphics=e,this._onAdd=n,this._onRemove=r,this._hashToCIM=o,this._index=A(9,Os),this._itemByGraphic=new Map,this._inflatedSizeHelper=new it,this._tileInfoView=t,this._uidFieldName=i;const h=t.getClosestInfoForScale(s);h&&(this._resolution=this._tileInfoView.getTileResolution(h.level))}setResourceManager(t){this._cimResourceManager=t,this._hittestDrawHelper=new et(t)}hitTest(t,s,i,e,n){t=F(t,this._tileInfoView.spatialReference);const r=.5*e*window.devicePixelRatio*i;Gs[0]=t-r,Gs[1]=s-r,Gs[2]=t+r,Gs[3]=s+r;const o=.5*e*(i+zt),h=Rs(this._index,t-o,s-o,t+o,s+o);if(!h||0===h.length)return[];const c=[],a=f(),l=f();for(const t of h){const{geometry:s,symbolResource:i}=t;this._getSymbolBounds(a,i,s,l,n),l[3]=l[2]=l[1]=l[0]=0,D(a,Gs)&&t.graphic.visible&&c.push(t)}if(0===c.length)return[];const u=this._hittestDrawHelper,d=[];for(const t of c){const{geometry:s,symbolResource:i}=t,{hash:r,textInfo:o}=i,h=this._hashToCIM.get(r);h&&u.hitTest(Gs,h.symbol,s,o,n,e)&&d.push(t)}return d.sort(ks),d.map((t=>t.graphic))}getGraphicsData(t,s,i){const e=this._searchForItems(s);if(0===e.length||0===i.length)return[];e.sort(((t,s)=>t.zorder-s.zorder)),e[0].insertAfter=-1;for(let t=1;t<e.length;t++)e[t].insertAfter=e[t-1].graphic.uid;e.sort(((t,s)=>t.graphic.uid-s.graphic.uid)),i.sort(((t,s)=>t.uid-s.uid));let n,r=0,o=0;const h=s.resolution,c=[],a={originPosition:"upperLeft",scale:[h,h],translate:[s.bounds[0],s.bounds[3]]};for(const l of i){for(o=-2;r<e.length;)if(n=e[r],r++,l.uid===n.graphic.uid){o=n.insertAfter;break}if(!n.geometry||-2===o)continue;const i=n.getGeometryQuantized(a,s.bounds,this._tileInfoView.spatialReference,h),u={...n.graphic.attributes};u[this._uidFieldName]=l.uid,null==n.groupId&&(n.groupId=t.createTemplateGroup(n.symbol,null)),c.push({centroid:Ls.getCentroidQuantized(n,a),geometry:i,attributes:u,symbol:n.symbol,groupId:n.groupId,insertAfter:o,zorder:n.zorder})}return c.sort(((t,s)=>t.zorder-s.zorder)),c}queryTileData(t,s){if(0===this._graphics.length)return[];const{bounds:i,resolution:e}=s,n=this._searchForItems(s),r=[];return 0===n.length||this._createTileGraphics(r,t,n,{originPosition:"upperLeft",scale:[e,e],translate:[i[0],i[3]]},s),r}has(t){return this._itemByGraphic.has(t)}getBounds(t){const s=this._itemByGraphic.get(t);return s?s.bounds:null}getAllBounds(){return Array.from(this._itemByGraphic.values()).filter((t=>t.graphic.visible)).map((t=>t.bounds))}addOrModify(t,s,i){if(!t||w(s))return;this.has(t)&&this.remove(t),this._onAdd(t);const e=[0,0,0,0],n=this._getSymbolBounds(null,s,i,e,0),r=Ls.acquire(t,s,i,d(n)?n:null,e);return this._itemByGraphic.set(t,r),i&&this._index.insert(r),r.bounds}remove(t){if(!this._itemByGraphic.has(t))return;this._onRemove(t);const s=this._itemByGraphic.get(t);this._index.remove(s),this._itemByGraphic.delete(t)}updateZ(){const t=this._graphics.items;let s,i;for(let e=0;e<t.length;e++)i=t[e],s=this._itemByGraphic.get(i),s&&(s.zorder=e)}update(t,s,i){const e=this._itemByGraphic.get(t);e.groupId=null;const n=I(e.bounds);this._index.remove(e);const r=this._getSymbolBounds(e.bounds,s,i,e.size,0);return d(r)&&e.set(t,s,i,r,e.size),i&&this._index.insert(e),{oldBounds:n,newBounds:e.bounds}}updateLevel(t){if(this._resolution===t)return;this._resolution=t,this._index.clear();const s=this._itemByGraphic,i=[];for(const[t,e]of s){const t=this._getSymbolBounds(e.bounds,e.symbolResource,e.geometry,e.size,0);e.geometry&&d(t)&&(e.bounds=t,i.push(e))}this._index.load(i)}clear(){this._itemByGraphic.clear(),this._index.clear()}_createTileGraphics(t,s,i,e,n){const r=this._uidFieldName,o=this._tileInfoView.spatialReference,{bounds:h,resolution:c}=n;let a,l,u,f;i.sort(((t,s)=>t.zorder-s.zorder));for(let n=0;n<i.length;n++){u=i[n],a=u.graphic,l=u.getGeometryQuantized(e,h,o,c),f=0===n?-1:i[n-1].graphic.uid;const d={...u.graphic.attributes};d[r]=a.uid,null==u.groupId&&(u.groupId=s.createTemplateGroup(u.symbol,null)),t.push({centroid:Ls.getCentroidQuantized(u,e),geometry:l,attributes:d,symbol:u.symbol,groupId:u.groupId,insertAfter:f,zorder:u.zorder})}}_searchForItems(t){const s=this._tileInfoView.spatialReference,i=t.bounds;if(s.isWrappable){const[e,n]=B(s),r=Math.abs(i[2]-n)<1e-5,o=Math.abs(i[0]-e)<1e-5;if((!r||!o)&&(r||o)){const s=t.resolution;let o;o=f(r?[e,i[1],e+s*zt,i[3]]:[n-s*zt,i[1],n,i[3]]);const h=Rs(this._index,i[0],i[1],i[2],i[3]),c=Rs(this._index,o[0],o[1],o[2],o[3]);return[...new Set([...h,...c])]}}return Rs(this._index,i[0],i[1],i[2],i[3])}_getSymbolBounds(t,s,i,e,n){if(!s||!s.symbol)return null;if(t||(t=f()),r(t,i),!e||0===e[0]&&0===e[1]&&0===e[2]&&0===e[3]){const{hash:t,textInfo:i}=s,r=this._hashToCIM.get(t);if(!r)return null;e||(e=[0,0,0,0]);const o=this._inflatedSizeHelper.getSymbolInflateSize(e,r.symbol,this._cimResourceManager,n,i);e[0]=window.devicePixelRatio*T(o[0]),e[1]=window.devicePixelRatio*T(o[1]),e[2]=window.devicePixelRatio*T(o[2]),e[3]=window.devicePixelRatio*T(o[3])}const o=this._resolution,h=it.SafeSize(e);return t[0]-=h*o,t[1]-=h*o,t[2]+=h*o,t[3]+=h*o,t}}const ks=(t,s)=>{const i=St(t.graphic),e=St(s.graphic);return i===e?s.zorder-t.zorder:i-e},qs=t=>{let s=class extends(z(t)){constructor(){super(...arguments),this.graphics=null,this.renderer=null}};return C([j()],s.prototype,"graphics",void 0),C([j()],s.prototype,"renderer",void 0),C([j()],s.prototype,"updating",void 0),C([j()],s.prototype,"view",void 0),s=C([P("esri.views.layers.GraphicsView")],s),s},Es=S("esri-2d-graphic-debug");function Ns(t,s,i){if(i.has(t))return i.get(t);const e={tile:s,addedOrModified:[],removed:[]};return i.set(t,e),e}let Xs=class extends(qs(L(U))){constructor(t){super(t),this._storage=new kt,this._displayIds=new Map,this._controller=new AbortController,this._tiles=new Map,this._graphicStoreUpdate=!1,this._graphicsSet=new Set,this._matcher=Promise.resolve(null),this._tileUpdateSet=new Set,this._tilesToUpdate=new Map,this._graphicIdToAbortController=new Map,this._attached=!1,this._highlightIds=new Map,this._updatingGraphicsTimer=null,this._hashToExpandedSymbol=new Map,this._hashToExpandedSymbolPromise=new Map,this._hashToCIMSymbolPromise=new Map,this._hashToCIM=new Map,this._processing=!1,this._needsProcessing=!1,this._pendingUpdate={added:new Set,updated:new Set,removed:new Set},this.lastUpdateId=-1,this.updateRequested=!1,this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}_createMatcher(t,s,i){if(t){const e=Lt({indexCount:0,fields:{}},"feature",t);this._matcher=Tt(e,s,null,i)}}_createDisplayId(t){return this._displayIds.has(t)||this._displayIds.set(t,this._storage.createDisplayId()),this._displayIds.get(t)}initialize(){this._attributeStore=new qt({type:"local",initialize:t=>Promise.resolve(this.container.attributeView.initialize(t)),update:t=>this.container.attributeView.requestUpdate(t),render:()=>this.container.requestRender()},G()),this.container.hasHighlight=()=>!!this._highlightIds.size;const t=new Ft(this.container.getMaterialItems.bind(this.container),this.view.featuresTilingScheme.tileInfo);this._graphicStore=new Vs(this.view.featuresTilingScheme,this.view.state.scale,this.uid,this.graphics,(t=>{this._createDisplayId(t.uid),this._setFilterState(t.uid,t.visible)}),(t=>{const s=this._displayIds.get(t.uid);this._displayIds.delete(t.uid),this._storage.releaseDisplayId(s)}),this._hashToCIM),this._meshFactory=new It(null,this.uid,t),this._templateStore=t,this.handles.add([this.watch("renderer",(s=>{this._createMatcher(s,t,this.container.stage.resourceManager);for(const t of this.graphics)this._pendingUpdate.updated.add(t);this.requestUpdate()})),this.view.graphicsTileStore.on("update",(t=>this._onTileUpdate(t))),this.container.on("attach",(()=>{Es&&this.container.enableRenderingBounds((()=>this._graphicStore.getAllBounds())),this.graphics.items.length>0&&this._graphicsChangeHandler({target:this.graphics,added:this.graphics.items,removed:[],moved:[]}),this.handles.add(this.graphics.on("change",(t=>this._graphicsChangeHandler(t))),"graphics");const s=this.container.stage.resourceManager;this._createMatcher(this.renderer,t,s),this._graphicStore.setResourceManager(s),this._attached=!0,this.notifyChange("updating")}))]),this._onTileUpdate({added:this.view.graphicsTileStore.tiles,removed:[]})}destroy(){this._updatingGraphicsTimer&&(clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=null,this.notifyChange("updating")),this._controller.abort(),this.container.destroy(),this._set("graphics",null),this._graphicStore.clear(),this._attributeStore=null,this._hashToExpandedSymbol.clear(),this.view=null,this.renderer=null,this._hashToCIM.clear(),this._hashToCIMSymbolPromise.clear(),this._hashToExpandedSymbolPromise.clear()}get updating(){return!this._attached||null!==this._updatingGraphicsTimer||this._tileUpdateSet.size>0||this._tilesToUpdate.size>0}hitTest(t,s){if(!this.view||!this.view.position)return Promise.resolve(null);const i=this.view.toMap(R(t,s));return this.searchFeatures(i).then((t=>t&&t.length?t[0]:null))}async searchFeatures(t,s=2){const{resolution:i,rotation:e}=this.view.state;return this._graphicStore.hitTest(t.x,t.y,s,i,e)}update(t){O(this._controller.signal);const s=t.state,{resolution:i}=s;if(this._graphicStore.updateLevel(i),this._graphicStoreUpdate=!0,this.updateRequested=!1,this._pendingUpdate.updated.size>0){if(!this._processing)return void this._updateGraphics();this._needsProcessing=!0}}viewChange(){this.requestUpdate()}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback())}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}graphicUpdateHandler(t){const{graphic:s,property:i,newValue:e}=t;switch(i){case"attributes":break;case"geometry":case"symbol":this._pendingUpdate.updated.add(s),this.requestUpdate();break;case"visible":this._setFilterState(s.uid,e),this._attributeStore.sendUpdates()}}addHighlight(t){for(const s of t)if(this._highlightIds.has(s)){const t=this._highlightIds.get(s);this._highlightIds.set(s,t+1)}else this._highlightIds.set(s,1);this._updateHighlight()}removeHighlight(t){for(const s of t)if(this._highlightIds.has(s)){const t=this._highlightIds.get(s)-1;0===t?this._highlightIds.delete(s):this._highlightIds.set(s,t)}this._updateHighlight()}_updateHighlight(){const t=Array.from(this._highlightIds.keys()),s=t.map((t=>this._displayIds.get(t)));this._attributeStore.setHighlight(t,s)}_getIntersectingTiles(t){const s=this._graphicStore.getBounds(t);if(!s||0===V(s)||0===k(s))return[];const i=Ot(s,this.view.spatialReference);return d(i)?[...new Set([...this.view.graphicsTileStore.boundsIntersections(i[0]),...this.view.graphicsTileStore.boundsIntersections(i[1])])]:this.view.graphicsTileStore.boundsIntersections(s)}async _updateTile(t){O(this._controller.signal);const s=t.tile,i=this._getGraphicsData(this._templateStore,s,t.addedOrModified),e=await this._processGraphics(s,i);return O(this._controller.signal),this._patchTile(s.key,{type:"update",addOrUpdate:e,remove:t.removed,end:!0,clear:!1,sort:!1}),e}_patchTile(t,s){if(!this._tiles.has(t))return;const i=this._tiles.get(t);this.container.onTileData(i,s),this.container.requestRender()}_graphicsChangeHandler(t){const s=this._pendingUpdate;for(const i of t.added)s.added.add(i);for(const i of t.moved)s.updated.add(i);for(const i of t.removed)this._pendingUpdate.added.has(i)?s.added.delete(i):s.removed.add(i);this._processing?this._needsProcessing=!0:this._updateGraphics()}_getGraphicsToUpdate(){const t={added:[],removed:[],updated:[]};if(!this.graphics)return t;const s=this._pendingUpdate;for(const i of this.graphics.items)s.added.has(i)?t.added.push(i):s.updated.has(i)&&t.updated.push(i);for(const i of s.removed)this._graphicStore.has(i)&&t.removed.push(i);return s.added.clear(),s.removed.clear(),s.updated.clear(),t}async _updateGraphics(){this._processing=!0;const{added:t,removed:s,updated:i}=this._getGraphicsToUpdate(),e=this._tilesToUpdate;let n;try{if(!this._graphicStoreUpdate){const t=this.view.state,{resolution:s}=t;this._graphicStore.updateLevel(s)}const r=[],o=new Array(t.length+s.length);for(let t=0;t<i.length;t++){const s=i[t],h=this._getIntersectingTiles(s);for(const t of h)n=t.id,Ns(n,t,e).removed.push(this._displayIds.get(s.uid));r.push(this._updateGraphic(s,null)),o[t]=s}const h=i.length;for(let s=0;s<t.length;s++){const i=t[s];o[h+s]=i,this._graphicsSet.add(i),r.push(this._addGraphic(i))}for(const t of s){this._abortProcessingGraphic(t.uid);const s=this._getIntersectingTiles(t);for(const i of s)n=i.id,Ns(n,i,e).removed.push(this._displayIds.get(t.uid));this._graphicsSet.delete(t),this._graphicStore.remove(t)}let c;this._flipUpdatingGraphics(),await Promise.all(r);for(let t=0;t<o.length;t++){c=o[t];const s=this._getIntersectingTiles(c);for(const t of s)n=t.id,Ns(n,t,e).addedOrModified.push(c)}this._graphicStore.updateZ();const a=[];for(const[t,s]of e)a.push(this._updateTile(s));await Promise.all(a)}catch(t){}for(const t of s)try{const s=await this._getSymbolForGraphic(t,{});if(s){const t=s.hash();this._hashToExpandedSymbol.delete(t)}}catch(t){}e.clear(),this.notifyChange("updating"),this._processing=!1,this._needsProcessing&&(this._needsProcessing=!1,this._updateGraphics())}_getArcadeInfo(t){const s=(t.attributes?Object.keys(t.attributes):[]).map((s=>({name:s,alias:s,type:"string"==typeof t.attributes[s]?"esriFieldTypeString":"esriFieldTypeDouble"})));return w(t.geometry)?null:{geometryType:m(t.geometry),spatialReference:q.fromJSON(t.geometry.spatialReference),fields:s}}_getSymbolForGraphic(t,s){return O(this._controller.signal),d(t.symbol)?Promise.resolve(t.symbol):d(this.renderer)?this.renderer.getSymbolAsync(t,{scale:this.view.scale,abortOptions:s}):Promise.resolve(this._getNullSymbol(t))}_getCIMSymbol(t,s,i){let e=this._hashToCIM.get(s);if(e)return Promise.resolve(e);const n=nt(t);if(d(n)){if("CIMSymbolReference"===n.type)return e=n,this._hashToCIM.set(s,e),Promise.resolve(e);let t=this._hashToCIMSymbolPromise.get(s);return t||(t=n.fetchCIMSymbol(i).then((t=>(this._hashToCIM.set(s,t.data),this._hashToCIMSymbolPromise.delete(s),t))).catch((t=>(this._hashToCIMSymbolPromise.delete(s),E(t),null))),this._hashToCIMSymbolPromise.set(s,t),t)}return Promise.resolve(null)}_expandCIMSymbol(t,s,i,e){const n=this._hashToExpandedSymbol.get(i);if(n)return Promise.resolve(n);let r=this._hashToExpandedSymbolPromise.get(i);if(r)return r;const o=this.container.stage,h=this._getArcadeInfo(s),c=Ut(t);return r=Ht(c,h,o.resourceManager,e),this._hashToExpandedSymbolPromise.set(i,r),r.then((t=>(this._hashToExpandedSymbol.set(i,t),this._hashToExpandedSymbolPromise.delete(i),t))),r}async _getSymbolResources(t,s){return O(this._controller.signal),this.container.stage?this._getSymbolForGraphic(t,s).then((i=>{const e=i.hash();return this._getCIMSymbol(i,e,s).then((i=>w(i)?null:this._expandCIMSymbol(i,t,e,s).then((t=>{const s=t.layers.filter((t=>"text"===t.type&&"string"==typeof t.text));if(s&&s.length>0){const i=new Array(s.length);for(let t=0;t<s.length;t++){const e=s[t],n=[],[r]=rt(e.text);for(let t=0;t<r.length;t++)n.push(r.charCodeAt(t));i[t]={symbol:e,id:t,glyphIds:n}}const n=new Map;return this.container.getMaterialItems(i).then((i=>{for(let t=0;t<s.length;t++){const e=s[t];n.set(e.cim,{text:e.text,mosaicItem:i[t].mosaicItem})}return{symbol:t,textInfo:n,hash:e}}))}return{symbol:t,hash:e}}))))})).catch((t=>(E(t),null))):null}async _projectAndNormalizeGeometry(f,d){if(O(this._controller.signal),w(f.geometry)||"mesh"===f.geometry.type)return null;let p=f.geometry;if(e(p))p.rings=p.rings;else if(n(p))p.paths=p.paths;else if(i(p)){const t=await this._getSymbolForGraphic(f,d);O(this._controller.signal),p=jt(t.type)||Pt(t.type)?p.center:Gt(p)}await ot(p.spatialReference,this.view.spatialReference);const m=function(f){if(!f)return null;let d=null;const p=f.spatialReference,m=h(p);if(!m)return"toJSON"in f?f.toJSON():f;const w=u(p)?102100:4326,y=c[w].maxX,x=c[w].minX,g=c[w].plus180Line,v=c[w].minus180Line;let _;const M="toJSON"in f?f.toJSON():f;if(t(M))_=Jt(M,y,x);else if(s(M))M.points=M.points.map((t=>Jt(t,y,x))),_=M;else if(i(M))_=function(t,s){if(!s)return t;const i=function(t,s){const i=[],{ymin:e,ymax:n}=t,r=t.xmax-t.xmin,o=t.xmin,h=t.xmax;let c;const[a,l]=s.valid;c=Qt(t.xmin,s);const u=c.x,f=c.frameId;c=Qt(t.xmax,s);const d=c.x,p=c.frameId,m=u===d&&r>0;if(r>2*l){const t={xmin:o<h?u:d,ymin:e,xmax:l,ymax:n},s={xmin:a,ymin:e,xmax:o<h?d:u,ymax:n},r={xmin:0,ymin:e,xmax:l,ymax:n},c={xmin:a,ymin:e,xmax:0,ymax:n},m=[],w=[];Zt(t,r)&&m.push(f),Zt(t,c)&&w.push(f),Zt(s,r)&&m.push(p),Zt(s,c)&&w.push(p);for(let t=f+1;t<p;t++)m.push(t),w.push(t);i.push({extent:t,frameIds:[f]},{extent:s,frameIds:[p]},{extent:r,frameIds:m},{extent:c,frameIds:w})}else u>d||m?i.push({extent:{xmin:u,ymin:e,xmax:l,ymax:n},frameIds:[f]},{extent:{xmin:a,ymin:e,xmax:d,ymax:n},frameIds:[p]}):i.push({extent:{xmin:u,ymin:e,xmax:d,ymax:n},frameIds:[f]});return i}(t,s).map((t=>t.extent));return i.length<2?i[0]||t:i.length>2?(t.xmin=s.valid[0],t.xmax=s.valid[1],t):{rings:i.map((t=>[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]))}}(M,m);else if(e(M)||n(M)){const t=ts;r(t,M);const s={xmin:t[0],ymin:t[1],xmax:t[2],ymax:t[3]},i=a(s.xmin,x)*(2*y),e=0===i?M:function(t,s){const i=l(t);for(const t of i)for(const i of t)i[0]+=s;return t}(M,i);s.xmin+=i,s.xmax+=i,o(s,g)&&s.xmax!==y||o(s,v)&&s.xmin!==x?d=e:_=e}else _=M;return null!==d?(new $t).cut(d,y):_}(p),y=ht(m,p.spatialReference,this.view.spatialReference);return N(y),y}_onTileUpdate(t){const s=h(this.view.spatialReference);if(t.added&&t.added.length>0)for(const i of t.added)this._addNewTile(i,s);if(t.removed&&t.removed.length>0)for(const s of t.removed)this._removeTile(s.key)}async _addGraphic(t){this._abortProcessingGraphic(t.uid),O(this._controller.signal);const s=new AbortController;this._graphicIdToAbortController.set(t.uid,s);const i={signal:s.signal};try{await this._addOrUpdateGraphic(t,i),O(this._controller.signal),this._graphicIdToAbortController.delete(t.uid)}catch(s){if(this._graphicIdToAbortController.delete(t.uid),!X(s))throw s}}_updateGraphic(t,s){O(this._controller.signal);const i=this._projectAndNormalizeGeometry(t,s),e=this._getSymbolResources(t,s);return Promise.all([i,e]).then((([s,i])=>{O(this._controller.signal),this._graphicStore.addOrModify(t,i,s)}))}_addOrUpdateGraphic(t,s){O(this._controller.signal);const i=this._projectAndNormalizeGeometry(t,s),e=this._getSymbolResources(t,s);return Promise.all([i,e]).then((([s,i])=>{O(this._controller.signal),this._graphicsSet.has(t)&&this._graphicStore.addOrModify(t,i,s)}))}_addTile(t){const s=this.view.featuresTilingScheme.getTileBounds(f(),t),i=new hs(t,s[0],s[3]);return this._tiles.set(t,i),this.container.addChild(i),i}async _addNewTile(i,e){const n=this._addTile(i.key),r=this._graphicStore.queryTileData(this._templateStore,i);if(0===r.length)return;if(e){const n=Math.round((e.valid[1]-e.valid[0])/i.resolution);for(const i of r)i.geometry&&(t(i.geometry)||s(i.geometry))&&this._wrapPoints(i,n)}const o=i.key;this._tileUpdateSet.add(i.key),this.notifyChange("updating");try{const t={type:"update",clear:!1,addOrUpdate:await this._processGraphics(i,r),remove:[],end:!0,sort:!1};n.patch(t),this._tileUpdateSet.delete(o),this.notifyChange("updating")}catch(t){if(this._tileUpdateSet.delete(o),this.notifyChange("updating"),!X(t))throw t}}_removeTile(t){if(!this._tiles.has(t))return;const s=this._tiles.get(t);this.container.removeChild(s),s.destroy(),this._tiles.delete(t)}_setFilterState(t,s){const i=this._displayIds.get(t),e=this._attributeStore.getHighlightFlag(t);this._attributeStore.setData(i,0,0,e|(s?ct:0))}_getGraphicsData(i,e,n){const r=h(this.view.spatialReference),o=this._graphicStore.getGraphicsData(i,e,n);if(r){const i=Math.round((r.valid[1]-r.valid[0])/e.resolution);for(const e of o)e.geometry&&(t(e.geometry)||s(e.geometry))&&this._wrapPoints(e,i)}return o}_wrapPoints(t,i){const e=t.geometry;s(e)?this._wrapMultipoint(e,i):this._wrapPoint(t,i)}_wrapMultipoint(t,s){const i=t.points,e=[];let n=0,r=0;for(const[t,o]of i){if(e.push([t+n,o]),n=0,s===Rt){const i=5*zt;t+r<i?(e.push([s,0]),n=-s):t+r>Rt-i&&(e.push([-s,0]),n=s)}else t+r<-zt?(e.push([s,0]),n=-s):t+r>Rt+zt&&(e.push([-s,0]),n=s);r+=t}t.points=e}_wrapPoint(t,s){const i=t.geometry;if(s===Rt){const e=5*zt;i.x<e?t.geometry={points:[[i.x,i.y],[s,0]]}:i.x>Rt-e&&(t.geometry={points:[[i.x,i.y],[-s,0]]})}else i.x<-zt?t.geometry={points:[[i.x,i.y],[s,0]]}:i.x>Rt+zt&&(t.geometry={points:[[i.x,i.y],[-s,0]]})}_processGraphics(t,s,i){if(!s||!s.length||!this._meshFactory)return null;const e=Cs.from(s),n=this._meshFactory;return this._matcher.then((s=>n.analyzeGraphics(e,this.container.stage.resourceManager,s,null,null,i).then((()=>(this._attributeStore.sendUpdates(),this._processAnalyzedGraphics(t,e))))))}_processAnalyzedGraphics(t,s){const i=this._meshFactory,e=s.getSize(),n=s.getCursor(),r=new Ct(t.key.id,{features:e,records:e,metrics:0},!1,!1,!1),o=[];for(;n.next();){const s=n.readGraphic();s.insertAfter=-1===s.insertAfter?-1:this._displayIds.get(s.insertAfter),s.displayId=this._displayIds.get(s.attributes[this.uid]);const e=new vs(s.displayId);e.insertAfter=s.insertAfter,o.push(e),i.writeGraphic(r,n,t.level)}const h=r.serialize(t.tileInfoView.tileInfo.isWrappable);return 1!==h.length?new Is:Is.fromVertexData(h[0].message,o)}_abortProcessingGraphic(t){this._graphicIdToAbortController.has(t)&&this._graphicIdToAbortController.get(t).abort()}_getNullSymbol(t){const s=t.geometry;return n(s)?H:e(s)||i(s)?Y:K}_flipUpdatingGraphics(){this._updatingGraphicsTimer&&clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=setTimeout((()=>{this._updatingGraphicsTimer=null,this.notifyChange("updating")}),160),this.notifyChange("updating")}};C([j({constructOnly:!0})],Xs.prototype,"requestUpdateCallback",void 0),C([j()],Xs.prototype,"container",void 0),C([j({constructOnly:!0})],Xs.prototype,"graphics",void 0),C([j()],Xs.prototype,"updating",null),C([j()],Xs.prototype,"view",void 0),C([j()],Xs.prototype,"updateRequested",void 0),Xs=C([P("esri.views.2d.layers.support.GraphicsView2D")],Xs);const Hs=Xs,Ys=Math.PI/180;class Ks extends Kt{constructor(t){super(),this._dvsMat3=J(),this._localOrigin={x:0,y:0},this._getBounds=t}destroy(){this._vao&&(this._vao.dispose(!0),this._vao=null,this._vertexBuffer=null,this._indexBuffer=null),this._program&&(this._program.dispose(),this._program=null)}doRender(t){const{context:s}=t,i=this._getBounds();if(i.length<1)return;this._createShaderProgram(s),this._updateMatricesAndLocalOrigin(t),this._updateBufferData(s,i),s.setBlendingEnabled(!0),s.setDepthTestEnabled(!1),s.setStencilWriteMask(0),s.setStencilTestEnabled(!1),s.setBlendFunction(1,771),s.setColorMask(!0,!0,!0,!0);const e=this._program;s.bindVAO(this._vao),s.useProgram(e),e.setUniformMatrix3fv("u_dvsMat3",this._dvsMat3),s.gl.lineWidth(1),s.drawElements(1,8*i.length,5125,0),s.bindVAO()}_createTransforms(){return{dvs:J()}}_createShaderProgram(t){this._program||(this._program=new Mt(t,"precision highp float;\n        uniform mat3 u_dvsMat3;\n\n        attribute vec2 a_position;\n\n        void main() {\n          mediump vec3 pos = u_dvsMat3 * vec3(a_position, 1.0);\n          gl_Position = vec4(pos.xy, 0.0, 1.0);\n        }","precision mediump float;\n      void main() {\n        gl_FragColor = vec4(0.75, 0.0, 0.0, 0.75);\n      }",Js().attributes))}_updateMatricesAndLocalOrigin(t){const{state:s}=t,{displayMat3:i,size:e,resolution:n,pixelRatio:r,rotation:o,viewpoint:h}=s,c=Ys*o,{x:a,y:l}=h.targetGeometry,u=F(a,s.spatialReference);this._localOrigin.x=u,this._localOrigin.y=l;const f=r*e[0],d=r*e[1],p=n*f,m=n*d,w=Q(this._dvsMat3);Z(w,w,i),W(w,w,$(f/2,d/2)),tt(w,w,Yt(e[0]/p,-d/m,1)),st(w,w,-c)}_updateBufferData(t,s){const{x:i,y:e}=this._localOrigin,n=new Float32Array(8*s.length),r=new Uint32Array(8*s.length);let o=0,h=0;for(const t of s)n[2*o+0]=t[0]-i,n[2*o+1]=t[1]-e,n[2*o+2]=t[0]-i,n[2*o+3]=t[3]-e,n[2*o+4]=t[2]-i,n[2*o+5]=t[3]-e,n[2*o+6]=t[2]-i,n[2*o+7]=t[1]-e,r[h+0]=o+0,r[h+1]=o+3,r[h+2]=o+3,r[h+3]=o+2,r[h+4]=o+2,r[h+5]=o+1,r[h+6]=o+1,r[h+7]=o+0,o+=4,h+=8;if(this._vertexBuffer?this._vertexBuffer.setData(n.buffer):this._vertexBuffer=_t.createVertex(t,35048,n.buffer),this._indexBuffer?this._indexBuffer.setData(r):this._indexBuffer=_t.createIndex(t,35048,r),!this._vao){const s=Js();this._vao=new vt(t,s.attributes,s.bufferLayouts,{geometry:this._vertexBuffer},this._indexBuffer)}}}const Js=()=>gt("bounds",{geometry:[{location:0,name:"a_position",count:2,type:5126}]});class Qs extends At{constructor(t){super(t),this.hasHighlight=()=>!0}destroy(){super.destroy(),this._boundsRenderer&&(this._boundsRenderer.destroy(),this._boundsRenderer=null)}enableRenderingBounds(t){this._boundsRenderer=new Ks(t),this.requestRender()}get hasLabels(){return!1}onTileData(t,s){t.patch(s),this.contains(t)||this.addChild(t),this.requestRender()}onTileError(t){t.clear(),this.contains(t)||this.addChild(t)}_renderChildren(t,s){for(const i of this.children)i.isReady&&i.hasData&&(i.commit(t),t.context.setStencilFunction(514,i.stencilRef,255),i._displayList.replay(t,i,s))}}export{Hs as r,Qs as t}