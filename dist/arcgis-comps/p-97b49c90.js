import{s as t,cu as e,b as s,c as i,br as r,dl as o,A as a,Q as n}from"./p-e58503d5.js";import{v as p}from"./p-c048b814.js";import{e as d,n as c,W as l,t as u,Q as h}from"./p-5032dfbd.js";import{m}from"./p-e06c6cf3.js";import{f,g as y}from"./p-e49308c6.js";import{V as j}from"./p-bfea9714.js";import{T as b,L as g,O as w}from"./p-48c5edb1.js";import{i as I,n as F,u as T}from"./p-ed18725d.js";import{y as R,d as S,c as E,u as _,h as v}from"./p-6ba45bbf.js";import{d as D}from"./p-612de336.js";import{i as O}from"./p-a2324023.js";import{P as Q}from"./p-765e6c28.js";import"./p-53bb6ab4.js";import"./p-b79fcce3.js";import"./p-182bb5be.js";import"./p-db87794e.js";import"./p-f94762ac.js";import"./p-ea916a39.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-58386239.js";import"./p-285c6a34.js";import"./p-f8414adc.js";import"./p-8925cd73.js";import"./p-c93d2280.js";import"./p-01e5a461.js";import"./p-ccdb8e80.js";import"./p-fea9512d.js";import"./p-50ff864e.js";import"./p-b0565d49.js";import"./p-c1cd5521.js";import"./p-9f58a277.js";import"./p-61f47d2b.js";import"./p-06d309e6.js";import"./p-4019eec3.js";import"./p-292d2320.js";import"./p-8bcb4bb3.js";import"./p-e0d9ff4c.js";import"./p-e273719b.js";import"./p-74de0937.js";import"./p-a9a30646.js";import"./p-7a658388.js";import"./p-85a6d41b.js";import"./p-ca295674.js";import"./p-5d962998.js";import"./p-41f2b2dd.js";import"./p-2e8ad983.js";const x={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};export default class{constructor(){this._queryEngine=null,this._snapshotFeatures=async t=>{const e=await this._fetch(t);return this._createFeatures(e)}}destroy(){var t;null==(t=this._queryEngine)||t.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(e,s={}){this.loadOptions={url:e.url,customParameters:e.customParameters};const i=[];await this._checkProjection(e.spatialReference);let r=null;e.url&&(r=await this._fetch(null==s?void 0:s.signal));const a=b(r,{geometryType:e.geometryType}),n=e.fields||a.fields||[],p=null!=e.hasZ?e.hasZ:a.hasZ,d=a.geometryType,c=e.objectIdField||a.objectIdFieldName||"__OBJECTID",l=e.spatialReference||o;let u=e.timeInfo;n===a.fields&&a.unknownFields.length>0&&i.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:a.unknownFields}});let h=n.find((t=>t.name===c));h?("esriFieldTypeString"!==h.type&&(h.type="esriFieldTypeOID"),h.editable=!1,h.nullable=!1):(h={alias:c,name:c,type:"string"===a.objectIdFieldType?"esriFieldTypeString":"esriFieldTypeOID",editable:!1,nullable:!1},n.unshift(h));const f={};for(const e of n){if(null==e.name&&(e.name=e.alias),null==e.alias&&(e.alias=e.name),!e.name)throw new t("geojson-layer:invalid-field-name","field name is missing",{field:e});if(!O.jsonValues.includes(e.type))throw new t("geojson-layer:invalid-field-type",`invalid type for field "${e.name}"`,{field:e});if(e.name!==h.name){const t=Q(e);void 0!==t&&(f[e.name]=t)}}if(this._fieldsIndex=new D(n),u){if(u.startTimeField){const t=this._fieldsIndex.get(u.startTimeField);t?(u.startTimeField=t.name,t.type="esriFieldTypeDate"):u.startTimeField=null}if(u.endTimeField){const t=this._fieldsIndex.get(u.endTimeField);t?(u.endTimeField=t.name,t.type="esriFieldTypeDate"):u.endTimeField=null}if(u.trackIdField){const t=this._fieldsIndex.get(u.trackIdField);t?u.trackIdField=t.name:(u.trackIdField=null,i.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:u}}))}u.startTimeField||u.endTimeField||(i.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:u}}),u=null)}const y=d?T(d):null,g={warnings:i,featureErrors:[],layerDefinition:{...x,drawingInfo:y,templates:I(f),extent:null,geometryType:d,objectIdField:c,fields:n,hasZ:!!p,timeInfo:u}};this._queryEngine=new j({fields:n,geometryType:d,hasM:!1,hasZ:p,objectIdField:c,spatialReference:l,timeInfo:u,featureStore:new m({geometryType:d,hasM:!1,hasZ:p}),cacheSpatialQueries:!0}),this._createDefaultAttributes=F(f,c);const w=await this._createFeatures(r);this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,w);const R=this._normalizeFeatures(w,g.warnings,g.featureErrors);if(this._queryEngine.featureStore.addMany(R),g.layerDefinition.extent=this._queryEngine.fullExtent,g.layerDefinition.timeInfo){const{start:t,end:e}=this._queryEngine.timeExtent;g.layerDefinition.timeInfo.timeExtent=[t,e]}return g}async applyEdits(t){const{spatialReference:e,geometryType:s}=this._queryEngine;return await Promise.all([R(e,s),f(t.adds,e),f(t.updates,e)]),await this._waitSnapshotComplete(),this._applyEdits(t)}async queryFeatures(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(t,e.signal)}async queryFeatureCount(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(t,e.signal)}async queryObjectIds(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(t,e.signal)}async queryExtent(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(t,e.signal)}async querySnapping(t,e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(t,e.signal)}async refresh(r){var o;return this.loadOptions.customParameters=r,null==(o=this._snapshotTask)||o.abort(),this._snapshotTask=e(this._snapshotFeatures),this._snapshotTask.promise.then((t=>{this._queryEngine.featureStore.clear(),this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,t);const e=this._normalizeFeatures(t);e&&this._queryEngine.featureStore.addMany(e)}),(e=>{this._queryEngine.featureStore.clear(),s(e)||i.getLogger("esri.layers.GeoJSONLayer").error(new t("geojson-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete(),{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent}}async _createFeatures(t){const{geometryType:e,hasZ:s,objectIdField:i}=this._queryEngine,n=g(t,{geometryType:e,hasZ:s,objectIdField:i});if(!r(this._queryEngine.spatialReference,o))for(const t of n)a(t.geometry)&&(t.geometry=d(y(c(t.geometry,this._queryEngine.geometryType,this._queryEngine.hasZ,!1),o,this._queryEngine.spatialReference)));return n}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(t){const{url:e,customParameters:s}=this.loadOptions,i=(await n(e,{responseType:"json",query:{...s},signal:t})).data;return await w(i),i}_normalizeFeatures(t,e,s){const{objectIdField:i}=this._queryEngine,r=[];for(const o of t){const t=this._createDefaultAttributes(),a=S(this._fieldsIndex,t,o.attributes,!0,e);a?null==s||s.push(a):(this._assignObjectId(t,o.attributes,!0),o.attributes=t,o.objectId=t[i],r.push(o))}return r}_applyEdits(t){const{adds:e,updates:s,deletes:i}=t,r={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(e&&e.length&&this._applyAddEdits(r,e),s&&s.length&&this._applyUpdateEdits(r,s),i&&i.length){for(const t of i)r.deleteResults.push(E(t));this._queryEngine.featureStore.removeManyById(i)}return{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:r}}_applyAddEdits(t,e){const{addResults:s}=t,{geometryType:i,hasM:r,hasZ:o,objectIdField:n,spatialReference:d,featureStore:c}=this._queryEngine,u=[];for(const r of e){if(r.geometry&&i!==p(r.geometry)){s.push(_("Incorrect geometry type."));continue}const e=this._createDefaultAttributes(),o=S(this._fieldsIndex,e,r.attributes);o?s.push(o):(this._assignObjectId(e,r.attributes),r.attributes=e,null!=r.uid&&(t.uidToObjectId[r.uid]=r.attributes[n]),a(r.geometry)&&(r.geometry=y(v(r.geometry,d),r.geometry.spatialReference,d)),u.push(r),s.push(E(r.attributes[n])))}c.addMany(l([],u,i,o,r,n))}_applyUpdateEdits({updateResults:t},e){const{geometryType:s,hasM:i,hasZ:r,objectIdField:o,spatialReference:n,featureStore:d}=this._queryEngine;for(const c of e){const{attributes:e,geometry:l}=c,m=e&&e[o];if(null==m){t.push(_(`Identifier field ${o} missing`));continue}if(!d.has(m)){t.push(_(`Feature with object id ${m} missing`));continue}const f=u(d.getFeature(m),s,r,i);if(a(l)){if(s!==p(l)){t.push(_("Incorrect geometry type."));continue}f.geometry=y(v(l,n),l.spatialReference,n)}if(e){const s=S(this._fieldsIndex,f.attributes,e);if(s){t.push(s);continue}}d.add(h(f,s,r,i,o)),t.push(E(m))}}_createObjectIdGenerator(t,e){const s=t.fieldsIndex.get(t.objectIdField);if("esriFieldTypeString"===s.type)return()=>s.name+"-"+Date.now().toString(16);let i=Number.NEGATIVE_INFINITY;for(const t of e)t.objectId&&(i=Math.max(i,t.objectId));return i=Math.max(0,i)+1,()=>i++}_assignObjectId(t,e,s=!1){const i=this._queryEngine.objectIdField;t[i]=s&&i in e?e[i]:this._objectIdGenerator()}async _checkProjection(e){try{await f(o,e)}catch{throw new t("geojson-layer","Projection not supported")}}}