import{j as t}from"./p-db63fa0e.js";import{d5 as e,s as i,D as s,Q as a,c as n,a as r,ap as l,b as o,d6 as h,aw as c,d4 as u,cg as m,e as f,d as p,f as v,i as d,p as w,ax as b}from"./p-e58503d5.js";import{a as y}from"./p-7731c620.js";import{e as g}from"./p-e9bae5e9.js";const $={type:t,json:{origins:{service:{read:{source:["tileInfo","minScale","maxScale","minLOD","maxLOD"],reader:O}}}}};function O(e,i,s,a){if(!e)return null;const{minScale:n,maxScale:r,minLOD:l,maxLOD:o}=i;if(null!=l&&null!=o)return t.fromJSON(a&&a.ignoreMinMaxLOD?e:{...e,lods:e.lods.filter((({level:t})=>null!=t&&t>=l&&t<=o))});if(0!==n&&0!==r){const i=t=>Math.round(1e4*t)/1e4,s=n?i(n):1/0,a=r?i(r):-1/0;return t.fromJSON({...e,lods:e.lods.filter((t=>{const e=i(t.scale);return e<=s&&e>=a}))})}return t.fromJSON(e)}class A{constructor(){this.location={left:0,top:0,width:0,height:0},this._allAvailability="unknown",this.byteSize=40}getAvailability(t,e){if("unknown"!==this._allAvailability)return this._allAvailability;const i=(t-this.location.top)*this.location.width+(e-this.location.left),s=i>>3,a=this._tileAvailabilityBitSet;return s<0||s>a.length?"unknown":a[s]&1<<i%8?"available":"unavailable"}_updateFromData(t){let e=!0,i=!0;const s=Math.ceil(this.location.width*this.location.height/8),a=new Uint8Array(s);let n=0;for(let s=0;s<t.length;s++){const r=s%8;t[s]?(i=!1,a[n]|=1<<r):e=!1,7===r&&++n}i?this._allAvailability="unavailable":e?this._allAvailability="available":(this._allAvailability="unknown",this._tileAvailabilityBitSet=a,this.byteSize+=a.length)}static fromDefinition(t,s){const n=t.service.request||a,{row:r,col:l,width:o,height:h}=t,c={query:{f:"json"}};return s=s?{...c,...s}:c,n(function(t){let e;if("vector-tile"===t.service.type)e=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;else{const i=t.service.tileServers;e=`${i&&i.length?i[t.row%i.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}const i=t.service.query;return i&&(e=`${e}?${i}`),e}(t),s).then((t=>t.data)).catch((t=>{if(t&&t.details&&422===t.details.httpStatus)return{location:{top:r,left:l,width:o,height:h},valid:!0,data:e(o*h,0)};throw t})).then((t=>{if(t.location&&(t.location.top!==r||t.location.left!==l||t.location.width!==o||t.location.height!==h))throw new i("tilemap:location-mismatch","Tilemap response for different location than requested",{response:t,definition:{top:r,left:l,width:o,height:h}});return A.fromJSON(t)}))}static fromJSON(t){A.validateJSON(t);const e=new A;return e.location=Object.freeze(s(t.location)),e._updateFromData(t.data),Object.freeze(e)}static validateJSON(t){if(!t||!t.location)throw new i("tilemap:missing-location","Location missing from tilemap response");if(!1===t.valid)throw new i("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new i("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new i("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new i("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function D(t){return`${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}var L;const S=n.getLogger("esri.layers.support.TilemapCache");let T=L=class extends(y(w)){constructor(t){super(t),this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2097152,this.request=a,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new g(this.cacheByteSize),this.handles.add([this.watch(["layer.parsedUrl","layer.tileServers?","layer.apiKey?","layer.customParameters?"],(()=>this._initializeTilemapDefinition())),r(this,"layer.tileInfo.lods",(t=>this._initializeAvailableLevels(t)),!0)]),this._initializeTilemapDefinition()}castLevels(t){return t<=2?(S.error("Minimum levels for Tilemap is 3, but got ",t),3):t}get size(){return 1<<this.levels}fetchTilemap(t,e,s,a){if(!this._availableLevels[t])return Promise.reject(new i("tilemap-cache:level-unavailable",`Level ${t} is unavailable in the service`));const n=this._tmpTilemapDefinition,r=this._tilemapFromCache(t,e,s,n);if(r)return Promise.resolve(r);const o=a&&a.signal;return a={...a,signal:null},new Promise(((t,e)=>{l(o,(()=>e(b())));const i=D(n);let s=this._pendingTilemapRequests[i];if(!s){s=A.fromDefinition(n,a).then((t=>(this._tilemapCache.put(i,t,t.byteSize),t)));const t=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=s,s.then(t,t)}s.then(t,e)}))}getAvailability(t,e,i){if(!this._availableLevels[t])return"unavailable";const s=this._tilemapFromCache(t,e,i,this._tmpTilemapDefinition);return s?s.getAvailability(e,i):"unknown"}getAvailabilityUpsample(t,e,i,s){s.level=t,s.row=e,s.col=i;const a=this.layer.tileInfo;for(a.updateTileInfo(s);;){const t=this.getAvailability(s.level,s.row,s.col);if("unavailable"!==t)return t;if(!a.upsampleTile(s))return"unavailable"}}fetchAvailability(t,e,s,a){return this._availableLevels[t]?this.fetchTilemap(t,e,s,a).catch((t=>t)).then((a=>{if(a instanceof A){const n=a.getAvailability(e,s);return"unavailable"===n?Promise.reject(new i("tile-map:tile-unavailable","Tile is not available",{level:t,row:e,col:s})):n}if(o(a))throw a;return"unknown"})):Promise.reject(new i("tilemap-cache:level-unavailable",`Level ${t} is unavailable in the service`))}fetchAvailabilityUpsample(t,e,i,s,a){s.level=t,s.row=e,s.col=i;const n=this.layer.tileInfo;n.updateTileInfo(s);const r=this.fetchAvailability(t,e,i,a).catch((t=>{if(o(t))throw t;if(n.upsampleTile(s))return this.fetchAvailabilityUpsample(s.level,s.row,s.col,s);throw t}));return this._fetchAvailabilityUpsamplePrefetch(s.id,t,e,i,a,r),r}async _fetchAvailabilityUpsamplePrefetch(t,e,i,s,a,n){if(!this._prefetchingEnabled)return;const r=`prefetch-${t}`;if(this.handles.has(r))return;const l=new AbortController;n.then((()=>l.abort()),(()=>l.abort()));let o=!1;if(this.handles.add({remove(){o||(o=!0,l.abort())}},r),await h(10,l.signal).catch((()=>{})),o||(o=!0,this.handles.remove(r)),c(l))return;const u={id:t,level:e,row:i,col:s},m={...a,signal:l.signal},f=this.layer.tileInfo;for(let t=0;L._prefetches.length<L._maxPrefetch&&f.upsampleTile(u);++t){const t=this.fetchAvailability(u.level,u.row,u.col,m);L._prefetches.push(t);const e=()=>{L._prefetches.removeUnordered(t)};t.then(e,e)}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const{parsedUrl:t,apiKey:e,customParameters:i}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:t.path,query:u({...t.query,...i,apiKey:e}),tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(t,e,i,s){s.level=t,s.row=e-e%this.size,s.col=i-i%this.size;const a=D(s);return this._tilemapCache.get(a)}_initializeAvailableLevels(t){this._availableLevels={},t&&t.forEach((t=>this._availableLevels[t.level]=!0))}get test(){const t=this;return{get prefetchingEnabled(){return t._prefetchingEnabled},set prefetchingEnabled(e){t._prefetchingEnabled=e},hasTilemap:(e,i,s)=>!!t._tilemapFromCache(e,i,s,t._tmpTilemapDefinition)}}};T._maxPrefetch=4,T._prefetches=new m({initialSize:L._maxPrefetch}),f([p({constructOnly:!0,type:Number})],T.prototype,"levels",void 0),f([v("levels")],T.prototype,"castLevels",null),f([p({readOnly:!0,type:Number})],T.prototype,"size",null),f([p({constructOnly:!0,type:Number})],T.prototype,"cacheByteSize",void 0),f([p({constructOnly:!0})],T.prototype,"layer",void 0),f([p({constructOnly:!0})],T.prototype,"request",void 0),T=L=f([d("esri.layers.support.TilemapCache")],T);export{T,O as n,$ as r}