import{e,d as r,i as n}from"./p-9ae46e68.js";import{f as t,o as i,d as s,E as o,M as f}from"./p-566b0715.js";import{a as l}from"./p-fe01b82b.js";let a=class extends l{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};e([r()],a.prototype,"affectsPixelSize",null),e([r({json:{write:!0}})],a.prototype,"spatialReference",void 0),a=e([n("esri.layers.support.rasterTransforms.BaseRasterTransform")],a);const c=a;let u=class extends c{constructor(){super(...arguments),this.type="identity"}};e([t({IdentityXform:"identity"})],u.prototype,"type",void 0),u=e([n("esri.layers.support.rasterTransforms.IdentityTransform")],u);const d=u;function m(e,r,n){const{x:t,y:i}=r;if(n<2)return{x:e[0]+t*e[2]+i*e[4],y:e[1]+t*e[3]+i*e[5]};if(2===n){const r=t*t,n=i*i,s=t*i;return{x:e[0]+t*e[2]+i*e[4]+r*e[6]+s*e[8]+n*e[10],y:e[1]+t*e[3]+i*e[5]+r*e[7]+s*e[9]+n*e[11]}}const s=t*t,o=i*i,f=t*i,l=s*t,a=s*i,c=t*o,u=i*o;return{x:e[0]+t*e[2]+i*e[4]+s*e[6]+f*e[8]+o*e[10]+l*e[12]+a*e[14]+c*e[16]+u*e[18],y:e[1]+t*e[3]+i*e[5]+s*e[7]+f*e[9]+o*e[11]+l*e[13]+a*e[15]+c*e[17]+u*e[19]}}function y(e,r,n){const{xmin:t,ymin:i,xmax:s,ymax:o,spatialReference:l}=r;let a=[];if(n<2)a.push({x:t,y:o}),a.push({x:s,y:o}),a.push({x:t,y:i}),a.push({x:s,y:i});else{let e=10;for(let r=0;r<e;r++)a.push({x:t,y:i+(o-i)*r/(e-1)}),a.push({x:s,y:i+(o-i)*r/(e-1)});e=8;for(let r=1;r<=e;r++)a.push({x:t+(s-t)*r/e,y:i}),a.push({x:t+(s-t)*r/e,y:o})}a=a.map((r=>m(e,r,n)));const c=a.map((e=>e.x)),u=a.map((e=>e.y));return new f({xmin:Math.min.apply(null,c),xmax:Math.max.apply(null,c),ymin:Math.min.apply(null,u),ymax:Math.max.apply(null,u),spatialReference:l})}let x=class extends c{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,r){const{coeffX:n,coeffY:t}=r;if(null==n||!n.length||null==t||!t.length||n.length!==t.length)return null;const i=[];for(let e=0;e<n.length;e++)i.push(n[e]),i.push(t[e]);return i}writeForwardCoefficients(e,r,n){const t=[],i=[];for(let r=0;r<(null==e?void 0:e.length);r++)r%2==0?t.push(e[r]):i.push(e[r]);r.coeffX=t,r.coeffY=i}get inverseCoefficients(){let e=this._get("inverseCoefficients");const r=this._get("forwardCoefficients");return!e&&r&&this.polynomialOrder<2&&(e=function(e){const[r,n,t,i,s,o]=e,f=t*o-s*i,l=s*i-t*o;return[(s*n-r*o)/f,(t*n-r*i)/l,o/f,i/l,-s/f,-t/l]}(r)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,r){const{inverseCoeffX:n,inverseCoeffY:t}=r;if(null==n||!n.length||null==t||!t.length||n.length!==t.length)return null;const i=[];for(let e=0;e<n.length;e++)i.push(n[e]),i.push(t[e]);return i}writeInverseCoefficients(e,r,n){const t=[],i=[];for(let r=0;r<(null==e?void 0:e.length);r++)r%2==0?t.push(e[r]):i.push(e[r]);r.inverseCoeffX=t,r.inverseCoeffY=i}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const r=m(this.forwardCoefficients,e,this.polynomialOrder);return new o({x:r.x,y:r.y,spatialReference:e.spatialReference})}return y(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const r=m(this.inverseCoefficients,e,this.polynomialOrder);return new o({x:r.x,y:r.y,spatialReference:e.spatialReference})}return y(this.inverseCoefficients,e,this.polynomialOrder)}};e([r({json:{write:!0}})],x.prototype,"polynomialOrder",void 0),e([r()],x.prototype,"forwardCoefficients",void 0),e([i("forwardCoefficients",["coeffX","coeffY"])],x.prototype,"readForwardCoefficients",null),e([s("forwardCoefficients")],x.prototype,"writeForwardCoefficients",null),e([r({json:{write:!0}})],x.prototype,"inverseCoefficients",null),e([i("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],x.prototype,"readInverseCoefficients",null),e([s("inverseCoefficients")],x.prototype,"writeInverseCoefficients",null),e([r()],x.prototype,"affectsPixelSize",null),e([t({PolynomialXform:"polynomial"})],x.prototype,"type",void 0),x=e([n("esri.layers.support.rasterTransforms.PolynomialTransform")],x);const p=x,v={PolynomialXform:p,IdentityXform:d},C=Object.keys(v);function w(e){return!e||C.includes(null==e?void 0:e.type)}function h(e){if(!(null==e?void 0:e.type))return null;const r=v[null==e?void 0:e.type];if(r){const n=new r;return n.read(e),n}return null}export{c as a,w as e,h as l,p as m}