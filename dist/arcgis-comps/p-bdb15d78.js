import{s as t}from"./p-7ec84656.js";import{e}from"./p-2f398ed1.js";import{af as s,A as i,V as n,r as o,e as r,i as c,c as h,d as a,R as u,s as l,aF as f,bE as d,Q as p,aW as w,bv as m,a0 as y}from"./p-e58503d5.js";import"./p-b79fcce3.js";import{d as g}from"./p-7731c620.js";import{t as v}from"./p-bba8b671.js";import{y as b}from"./p-9087b4d3.js";import{b as _}from"./p-5e833dfc.js";import{d as S}from"./p-c048b814.js";const k="__esri_timestamp__";class F{constructor(t,e,s,i,n=128){this._trackIdToObservations=new Map,this._idCounter=0,this._lastPurge=performance.now(),this._addOrUpdated=new Map,this._removed=[],this._maxAge=0,this._timeInfo=s,this._purgeOptions=i,this.store=t,this.objectIdField=e,this.purgeInterval=n,this._useGeneratedIds="__esri_stream_id__"===this.objectIdField}add(n){if(this._useGeneratedIds){const t=this._nextId();n.attributes[this.objectIdField]=t,n.objectId=t}else n.objectId=n.attributes[this.objectIdField];if(this._addOrUpdated.set(n.objectId,n),this._maxAge=Math.max(this._maxAge,n.attributes[this._timeInfo.startTimeField]),!this._timeInfo.trackIdField)return s(this._trackIdLessObservations)&&(this._trackIdLessObservations=new t(1e5)),void this._trackIdLessObservations.enqueue(n.objectId);const o=n.attributes[this._timeInfo.trackIdField];if(!this._trackIdToObservations.has(o)){const s=i(this._purgeOptions)&&null!=this._purgeOptions.maxObservations?this._purgeOptions.maxObservations:1e3,n=e(s,0,1e3);this._trackIdToObservations.set(o,new t(n))}const r=this._trackIdToObservations.get(o).enqueue(n.objectId);i(r)&&(this._addOrUpdated.has(r)?this._addOrUpdated.delete(r):this._removed.push(r))}checkForUpdates(){const t=this._getToAdd(),e=this._getToRemove(),s=performance.now();s-this._lastPurge>=this.purgeInterval&&(this._purge(s),this._lastPurge=s);const n=[];if(i(e))for(const t of e){const e=this.store.removeById(t);i(e)&&n.push(e)}if(i(t))for(const e of t)e.attributes[k]=s,this.store.add(e);(t||n)&&this.store.update(t,n)}_getToAdd(){if(!this._addOrUpdated.size)return null;const t=new Array(this._addOrUpdated.size);let e=0;return this._addOrUpdated.forEach((s=>t[e++]=s)),this._addOrUpdated.clear(),t}_getToRemove(){const t=this._removed;return this._removed.length?(this._removed=[],t):null}_nextId(){const t=this._idCounter;return this._idCounter=(this._idCounter+1)%4294967294+1,t}_purge(t){const e=this._purgeOptions;i(e)&&(this._purgeSomeByDisplayCount(e),this._purgeByAge(e),this._purgeByAgeReceived(t,e),this._purgeTracks())}_purgeSomeByDisplayCount(t){if(!t.displayCount)return;let e=this.store.size;if(e>t.displayCount){if(this._timeInfo.trackIdField)for(const s of this._trackIdToObservations.values())if(e>t.displayCount&&s.size){const t=n(s.dequeue());this._removed.push(t),e--}if(i(this._trackIdLessObservations)){let s=e-t.displayCount;for(;s-- >0;){const t=this._trackIdLessObservations.dequeue();i(t)&&this._removed.push(t)}}}}_purgeByAge(t){var e;if(!t.age||null==(e=this._timeInfo)||!e.startTimeField)return;const s=this._maxAge-60*t.age*1e3;this.store.forEach((t=>{t.attributes[this._timeInfo.startTimeField]<s&&this._removed.push(t.objectId)}))}_purgeByAgeReceived(t,e){if(!e.ageReceived)return;const s=t-60*e.ageReceived*1e3;this.store.forEach((t=>{t.attributes[k]<s&&this._removed.push(t.objectId)}))}_purgeTracks(){this._trackIdToObservations.forEach(((t,e)=>{0===t.size&&this._trackIdToObservations.delete(e)}))}}let x=class extends(o.EventedMixin(g)){onFeature(t){this.emit("feature",t)}};x=r([c("esri.layers.graphics.sources.connections.StreamConnection")],x);const R=x,j=h.getLogger("esri.layers.graphics.sources.connections.WebSocketConnection");var C;!function(t){t[t.CONNECTING=0]="CONNECTING",t[t.OPEN=1]="OPEN",t[t.CLOSING=2]="CLOSING",t[t.CLOSED=3]="CLOSED"}(C||(C={}));let E=class extends R{constructor(t){super(),this.errorString=null;const{geometryType:e,spatialReference:s,sourceSpatialReference:i}=t;this._config=t,this._featureZScaler=v(e,i,s),this._open()}async _open(){await this._tryCreateWebSocket(),this.destroyed||await this._handshake()}destroy(){i(this._websocket)&&(this._websocket.onopen=null,this._websocket.onclose=null,this._websocket.onerror=null,this._websocket.onmessage=null,this._websocket.close()),this._websocket=null}get connectionStatus(){if(s(this._websocket))return"disconnected";switch(this._websocket.readyState){case C.CONNECTING:case C.OPEN:return"connected";case C.CLOSING:case C.CLOSED:return"disconnected"}}async _tryCreateWebSocket(t=this._config.source.path,e=1e3,s=0){try{if(this.destroyed)return;const e=u(t,this._config.customParameters);this._websocket=await this._createWebSocket(e),this.notifyChange("connectionStatus")}catch(i){const n=e/1e3;return this._config.maxReconnectionAttempts&&s>=this._config.maxReconnectionAttempts?(j.error(new l("websocket-connection","Exceeded maxReconnectionAttempts attempts. No further attempts will be made")),void this.destroy()):(j.error(new l("websocket-connection",`Failed to connect. Attempting to reconnect in ${n}s`,i)),await f(e),this._tryCreateWebSocket(t,Math.min(1.5*e,1e3*this._config.maxReconnectionInterval),s+1))}}_createWebSocket(t){return new Promise(((e,s)=>{const i=new WebSocket(t);i.onopen=()=>{if(i.onopen=null,this.destroyed)return i.onclose=null,void i.close();i.onclose=t=>this._onClose(t),i.onerror=t=>this._onError(t),i.onmessage=t=>this._onMessage(t),e(i)},i.onclose=t=>{i.onopen=i.onclose=null,s(t)}}))}async _handshake(t=1e4){const e=this._websocket;if(s(e))return;const i=d(),n=e.onmessage,{filter:o,outFields:r,spatialReference:c}=this._config;return i.timeout(t),e.onmessage=t=>{var s;let h=null;try{h=JSON.parse(t.data)}catch(t){}h&&"object"==typeof h||(j.error(new l("websocket-connection","Protocol violation. Handshake failed - malformed message",t.data)),i.reject(),this.destroy()),(null==(s=h.spatialReference)?void 0:s.wkid)!==(null==c?void 0:c.wkid)&&(j.error(new l("websocket-connection",`Protocol violation. Handshake failed - expected wkid of ${c.wkid}`,t.data)),i.reject(),this.destroy()),"json"!==h.format&&(j.error(new l("websocket-connection","Protocol violation. Handshake failed - format is not set",t.data)),i.reject(),this.destroy()),o&&h.filter!==o&&j.error(new l("websocket-connection","Tried to set filter, but server doesn't support it")),r&&h.outFields!==r&&j.error(new l("websocket-connection","Tried to set outFields, but server doesn't support it")),e.onmessage=n,i.resolve()},e.send(JSON.stringify({filter:o,outFields:r,format:"json",spatialReference:{wkid:c.wkid}})),i.promise}_onMessage(t){try{const e=JSON.parse(t.data);if("featureResult"!==e.type)throw new l("websocket-connection","Protocol violation - Expected to find message of type 'featureResult'",e);for(const t of e.features)i(this._featureZScaler)&&this._featureZScaler(t.geometry),this.onFeature(t)}catch(t){return j.error(new l("websocket-connection","Failed to parse message",t)),void this.destroy()}}_onError(t){const e="Encountered an error over WebSocket connection";this._set("errorString",e),j.error("websocket-connection",e)}_onClose(t){this._websocket=null,this.notifyChange("connectionStatus"),1e3!==t.code&&j.error("websocket-connection",`WebSocket closed unexpectedly with error code ${t.code}`),this.destroyed||this._open()}};r([a()],E.prototype,"connectionStatus",null),r([a()],E.prototype,"errorString",void 0),E=r([c("esri.layers.graphics.sources.connections.WebSocketConnection")],E);const N=h.getLogger("esri.layers.graphics.sources.connections.GeoEventConnection"),O={maxQueryDepth:5,maxRecordCountFactor:3};let T=class extends E{constructor(t){super({...O,...t})}async _open(){const t=await this._fetchServiceDefinition(this._config.source);t.timeInfo.trackIdField||N.warn("GeoEvent service was configured without a TrackIdField. This may result in certain functionality being disabled. The purgeOptions.maxObservations property will have no effect.");const e=this._fetchWebSocketUrl(t.streamUrls,this._config.spatialReference);this._buddyServicesQuery||(this._buddyServicesQuery=this._queryBuddyServices()),await this._buddyServicesQuery,await this._tryCreateWebSocket(e);const{filter:s,outFields:i}=this._config;this.destroyed||this._setFilter(s,i)}_onMessage(t){let e;try{e=this._enrich(JSON.parse(t.data)),i(this._featureZScaler)&&this._featureZScaler(e.geometry)}catch(t){return void N.error(new l("geoevent-connection","Failed to parse message",t))}this.onFeature(e)}async _fetchServiceDefinition(t){const e={f:"json",...this._config.customParameters},s=p(t.path,{query:e,responseType:"json"}),i=(await s).data;return this._serviceDefinition=i,i}_fetchWebSocketUrl(t,e){const s=t[0],{urls:i,token:n}=s,o=this._inferWebSocketBaseUrl(i);return u(`${o}/subscribe`,{outSR:""+e.wkid,token:n})}_inferWebSocketBaseUrl(t){if(1===t.length)return t[0];for(const e of t)if(-1!==e.indexOf("wss"))return e;return N.error(new l("geoevent-connection","Unable to infer WebSocket url",t)),null}async _setFilter(t,e){const i=this._websocket;if(s(i)||s(t)&&s(e))return;const n=JSON.stringify({filter:this._serializeFilter(t,e)});let o=!1;const r=d();return i.onmessage=t=>{const e=JSON.parse(t.data);e.filter&&(e.error&&(N.error(new l("geoevent-connection","Failed to set service filter",e.error)),this._set("errorString",`Could not set service filter - ${e.error}`),r.reject(e.error)),i.onmessage=this._onMessage.bind(this),o=!0,r.resolve())},i.send(n),setTimeout((()=>{o||(this.destroyed||this._websocket!==i||N.error(new l("geoevent-connection","Server timed out when setting filter")),r.reject())}),1e4),r.promise}_serializeFilter(t,e){const n={};if(s(t)&&s(e))return n;if(i(t)&&t.geometry)try{const e=S(t.geometry);if("extent"!==e.type)throw new l(`Expected extent but found type ${e.type}`);n.geometry=JSON.stringify(e.shiftCentralMeridian())}catch(t){N.error(new l("geoevent-connection","Encountered an error when setting connection geometryDefinition",t))}return i(t)&&t.where&&"1 = 1"!==t.where&&(n.where=t.where),i(e)&&(n.outFields=e.join(",")),n}_enrich(t){if(!this._relatedFeatures)return t;const e=t.attributes[this._serviceDefinition.relatedFeatures.joinField];if(!this._relatedFeatures.has(e))return N.warn("geoevent-connection","Feature join failed. Is the join field configured correctly?",t),t;const{attributes:s,geometry:i}=this._relatedFeatures.get(e);for(const e in s)t.attributes[e]=s[e];return i&&(t.geometry=i),t.geometry||t.centroid||N.error(new l("geoevent-connection","Found malformed feature - no geometry found",t)),t}async _queryBuddyServices(){try{const{relatedFeatures:t,keepLatestArchive:e}=this._serviceDefinition,s=this._queryRelatedFeatures(t),i=this._queryArchive(e);await s;const n=await i;if(!n)return;for(const t of n.features)this.onFeature(this._enrich(t))}catch(t){N.error(new l("geoevent-connection","Encountered an error when querying buddy services",{error:t}))}}async _queryRelatedFeatures(t){if(!t)return;const e=await this._queryBuddy(t.featuresUrl);this._addRelatedFeatures(e)}async _queryArchive(t){if(t)return this._queryBuddy(t.featuresUrl)}async _queryBuddy(t){const e=new((await import("./p-dae095dd.js").then((function(t){return t.F}))).default)({url:t}),{capabilities:s}=await e.load(),i=s.query.supportsMaxRecordCountFactor,n=s.query.supportsPagination,o=s.query.supportsCentroid,r=this._config.maxRecordCountFactor,c=e.capabilities.query.maxRecordCount,h=i?c*r:c,a=new _;if(a.outFields=w(this._config.outFields,["*"]),a.where=w(m(this._config.filter,"where"),"1=1"),a.returnGeometry=!0,a.returnExceededLimitFeatures=!0,a.outSpatialReference=y.fromJSON(this._config.spatialReference),o&&(a.returnCentroid=!0),i&&(a.maxRecordCountFactor=r),n)return a.num=h,e.destroy(),this._queryPages(t,a);const u=await b(t,a,this._config.sourceSpatialReference);return e.destroy(),u.data}async _queryPages(t,e,s=[],n=0){e.start=i(e.num)?n*e.num:null;const{data:o}=await b(t,e,this._config.sourceSpatialReference);return o.exceededTransferLimit&&n<this._config.maxQueryDepth?(o.features.forEach((t=>s.push(t))),this._queryPages(t,e,s,n+1)):(s.forEach((t=>o.features.push(t))),o)}_addRelatedFeatures(t){const e=new Map,s=t.features,i=this._serviceDefinition.relatedFeatures.joinField;for(const t of s)e.set(t.attributes[i],t);this._relatedFeatures=e}};T=r([c("esri.layers.graphics.sources.connections.GeoEventConnection")],T);const W=T;function A(t,e,s,i,n,o,r,c){const h=0===t.path.indexOf("wss://")||0===t.path.indexOf("ws://"),a={source:t,sourceSpatialReference:e,spatialReference:s,geometryType:i,filter:n,maxReconnectionAttempts:o,maxReconnectionInterval:r,customParameters:c};return h?new E(a):new W(a)}export{F as h,A as t}