import{h as e,D as r}from"./p-566b0715.js";import{v as n,r as a,t as i}from"./p-9ae46e68.js";import{m as s}from"./p-c5b7f7c3.js";import{n as t,e as o}from"./p-dfc6337f.js";import"./p-fe01b82b.js";import"./p-84bf99cb.js";const l=n.getLogger("esri.renderers.visualVariables.support.visualVariableUtils"),u=new e,c=Math.PI,f=/^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;function d(e,n,i){const s="visualVariables"in e&&e.visualVariables?e.visualVariables.filter((e=>"color"===e.type))[0]:e;if(!s)return;if("esri.renderers.visualVariables.ColorVariable"!==s.declaredClass)return void l.warn("The visualVariable should be an instance of esri.renderers.visualVariables.ColorVariable");const t="number"==typeof n,o=t?null:n,u=o&&o.attributes;let c=t?n:null;const f=s.field,{ipData:d,hasExpression:b}=s.cache;let p=s.cache.compiledFunc;if(!f&&!b){const e=s.stops;return e&&e[0]&&e[0].color}if("number"!=typeof c)if(b){if(!a(i)||!a(i.arcade))return void l.error("Use of arcade expressions requires an arcade context");const e=i.arcade.arcadeUtils,r=e.getViewInfo({viewingMode:i.viewingMode,scale:i.scale,spatialReference:i.spatialReference}),n=e.createExecContext(o,r);if(!p){const r=e.createSyntaxTree(s.valueExpression);p=e.createFunction(r),s.cache.compiledFunc=p}c=e.executeFunction(p,n)}else u&&(c=u[f]);const v=s.normalizationField,h=u?parseFloat(u[v]):void 0;if(null!=c&&(!v||t||!isNaN(h)&&0!==h)){isNaN(h)||t||(c/=h);const e=z(c,d);if(e){const n=e[0],t=e[1],o=n===t?s.stops[n].color:r.blendColors(s.stops[n].color,s.stops[t].color,e[2],a(i)?i.color:void 0);return new r(o)}}}function b(e,r,n){const a="visualVariables"in e&&e.visualVariables?e.visualVariables.filter((e=>"opacity"===e.type))[0]:e;if(!a)return;if("esri.renderers.visualVariables.OpacityVariable"!==a.declaredClass)return void l.warn("The visualVariable should be an instance of esri.renderers.visualVariables.OpacityVariable");const s="number"==typeof r,t=s?null:r,o=t&&t.attributes;let u=s?r:null;const c=a.field,{ipData:f,hasExpression:d}=a.cache;let b=a.cache.compiledFunc;if(!c&&!d){const e=a.stops;return e&&e[0]&&e[0].opacity}if("number"!=typeof u)if(d){if(i(n)||i(n.arcade))return void l.error("Use of arcade expressions requires an arcade context");const e=n.arcade.arcadeUtils,r=e.getViewInfo({viewingMode:n.viewingMode,scale:n.scale,spatialReference:n.spatialReference}),s=e.createExecContext(t,r);if(!b){const r=e.createSyntaxTree(a.valueExpression);b=e.createFunction(r),a.cache.compiledFunc=b}u=e.executeFunction(b,s)}else o&&(u=o[c]);const p=a.normalizationField,v=o?parseFloat(o[p]):void 0;if(null!=u&&(!p||s||!isNaN(v)&&0!==v)){isNaN(v)||s||(u/=v);const e=z(u,f);if(e){const r=e[0],n=e[1];if(r===n)return a.stops[r].opacity;{const i=a.stops[r].opacity;return i+(a.stops[n].opacity-i)*e[2]}}}}function p(e,r,n){const a="visualVariables"in e&&e.visualVariables?e.visualVariables.filter((e=>"rotation"===e.type))[0]:e;if(!a)return;if("esri.renderers.visualVariables.RotationVariable"!==a.declaredClass)return void l.warn("The visualVariable should be an instance of esri.renderers.visualVariables.RotationVariable");const s=a.axis||"heading",t="heading"===s&&"arithmetic"===a.rotationType?90:0,o="heading"===s&&"arithmetic"===a.rotationType?-1:1,u="number"==typeof r?null:r,c=u&&u.attributes,f=a.field,{hasExpression:d}=a.cache;let b=a.cache.compiledFunc,p=0;if(!f&&!d)return p;if(d){if(i(n)||i(n.arcade))return void l.error("Use of arcade expressions requires an arcade context");const e=n.arcade.arcadeUtils,r=e.getViewInfo({viewingMode:n.viewingMode,scale:n.scale,spatialReference:n.spatialReference}),s=e.createExecContext(u,r);if(!b){const r=e.createSyntaxTree(a.valueExpression);b=e.createFunction(r),a.cache.compiledFunc=b}p=e.executeFunction(b,s)}else c&&(p=c[f]||0);return p="number"!=typeof p||isNaN(p)?null:t+o*p,p}function v(e,r,n){const s="number"==typeof r,t=s?null:r,u=t&&t.attributes;let c=s?r:null;const{isScaleDriven:f}=e.cache;let d=e.cache.compiledFunc;if(f){const r=a(n)?n.scale:void 0,i=a(n)?n.view:void 0;c=null==r||"3d"===i?function(e){let r=null,n=null;const a=e.stops;return a?(r=a[0].value,n=a[a.length-1].value):(r=e.minDataValue||0,n=e.maxDataValue||0),(r+n)/2}(e):r}else if(!s)switch(e.inputValueType){case"expression":{if(i(n)||i(n.arcade))return void l.error("Use of arcade expressions requires an arcade context");const r=n.arcade.arcadeUtils,a=r.getViewInfo({viewingMode:n.viewingMode,scale:n.scale,spatialReference:n.spatialReference}),s=r.createExecContext(t,a);if(!d){const n=r.createSyntaxTree(e.valueExpression);d=r.createFunction(n),e.cache.compiledFunc=d}c=r.executeFunction(d,s);break}case"field":u&&(c=u[e.field]);break;case"unknown":c=null}if(!o(c))return null;if(s||!e.normalizationField)return c;const b=u?parseFloat(u[e.normalizationField]):null;return o(b)&&0!==b?c/b:null}function h(e,r,n){const a="visualVariables"in e&&e.visualVariables?e.visualVariables.filter((e=>"size"===e.type))[0]:e;if(!a)return;if("esri.renderers.visualVariables.SizeVariable"!==a.declaredClass)return void l.warn("The visualVariable should be an instance of esri.renderers.visualVariables.SizeVariable");const i=y(v(a,r,n),a,r,n,a.cache.ipData);return null==i||isNaN(i)?0:i}function V(e,r,n){return null==e?null:t(e)?h(e,r,n):o(e)?e:null}function m(e,r,n){return o(n)&&e>n?n:o(r)&&e<r?r:e}function g(e,r,n,i){const s=(e-r.minDataValue)/(r.maxDataValue-r.minDataValue),t=V(r.minSize,n,i),o=V(r.maxSize,n,i),l=a(i)?i.shape:void 0;if(e<=r.minDataValue)return t;if(e>=r.maxDataValue)return o;if("area"===r.scaleBy&&l){const e="circle"===l,r=e?c*(t/2)**2:t*t,n=r+s*((e?c*(o/2)**2:o*o)-r);return e?2*Math.sqrt(n/c):Math.sqrt(n)}return t+s*(o-t)}function w(e,r,n,i){const s=a(i)?i.shape:void 0,t=e/r.minDataValue,o=V(r.minSize,n,i),l=V(r.maxSize,n,i);let u=null;return u="circle"===s?2*Math.sqrt(t*(o/2)**2):"square"===s||"diamond"===s||"image"===s?Math.sqrt(t*o**2):t*o,m(u,o,l)}function x(e,r,n,i){const t=(a(i)&&i.resolution?i.resolution:1)*s[r.valueUnit],o=V(r.minSize,n,i),l=V(r.maxSize,n,i),{valueRepresentation:u}=r;let f=null;return f="area"===u?2*Math.sqrt(e/c)/t:"radius"===u||"distance"===u?2*e/t:e/t,m(f,o,l)}function y(e,r,n,a,i){switch(r.transformationType){case"additive":return function(e,r,n,a){return e+(V(r.minSize,n,a)||r.minDataValue)}(e,r,n,a);case"constant":return function(e,r,n){const a=e.stops;let i=a&&a.length&&a[0].size;return null==i&&(i=e.minSize),V(i,r,n)}(r,n,a);case"clamped-linear":return g(e,r,n,a);case"proportional":return w(e,r,n,a);case"stops":return function(e,r,n,a,i){const[s,t,o]=z(e,i);if(s===t)return V(r.stops[s].size,n,a);{const e=V(r.stops[s].size,n,a);return e+(V(r.stops[t].size,n,a)-e)*o}}(e,r,n,a,i);case"real-world-size":return x(e,r,n,a);case"identity":return e;case"unknown":return null}}function N(e,r,n){const{isScaleDriven:a}=e.cache;if(!(a&&"3d"===n||r))return null;const i={scale:r,view:n};let s=V(e.minSize,u,i),t=V(e.maxSize,u,i);if(null!=s||null!=t){if(s>t){const e=t;t=s,s=e}return{minSize:s,maxSize:t}}}function S(e,r,n){if(!e.visualVariables)return;const a=[],i=[],s=[],t=[],o=[];for(const r of e.visualVariables)switch(r.type){case"color":i.push(r);break;case"opacity":s.push(r);break;case"rotation":o.push(r);break;case"size":t.push(r)}return i.forEach((e=>{const i=d(e,r,n);a.push({variable:e,value:i})})),s.forEach((e=>{const i=b(e,r,n);a.push({variable:e,value:i})})),o.forEach((e=>{const i=p(e,r,n);a.push({variable:e,value:i})})),t.forEach((e=>{const i=h(e,r,n);a.push({variable:e,value:i})})),a.filter((e=>null!=e.value))}function z(e,r){if(!r)return;let n=0,a=r.length-1;return r.some(((r,i)=>e<r?(a=i,!0):(n=i,!1))),[n,a,(e-r[n])/(r[a]-r[n])]}function k(e,r,n){const a=["proportional","proportional","proportional"];for(const i of e){const e=i.useSymbolValue?"symbol-value":h(i,r,n);switch(i.axis){case"width":a[0]=e;break;case"depth":a[1]=e;break;case"height":a[2]=e;break;case"width-and-depth":a[0]=e,a[1]=e;break;case"all":case void 0:case null:a[0]=e,a[1]=e,a[2]=e}}return a}export{k as getAllSizes,d as getColor,b as getOpacity,p as getRotationAngle,h as getSize,y as getSizeForValue,V as getSizeFromNumberOrVariable,N as getSizeRangeAtScale,S as getVisualVariableValues,f as viewScaleRE}