import{s as t,c as s,af as e,A as i,K as r,V as n,r as h,bE as a,bm as o,T as c,h as u,aW as l,b as d,Q as p,J as f,d0 as y,aF as g,ca as m,a0 as w,c9 as b,bw as v,bs as M,e as j,d as x,i as _,bd as q,P as I}from"./p-e58503d5.js";import{d as A}from"./p-7731c620.js";import{j as S}from"./p-db63fa0e.js";import{n as F,m as k,c as C,u as R,i as P,Q as T,a as U,M as E}from"./p-5032dfbd.js";import{V as O}from"./p-bfea9714.js";import{d as D}from"./p-612de336.js";import{r as G,o as L,l as z}from"./p-7a225e61.js";import{y as N}from"./p-da33e926.js";import{l as V}from"./p-480e5606.js";import{s as Q}from"./p-4019eec3.js";import{q as X}from"./p-ede205d0.js";import{d as Y,y as B}from"./p-9087b4d3.js";import{d as $,u as H,P as J}from"./p-cd36fe2a.js";import{a as Z}from"./p-9d34911e.js";import{s as K,t as W,o as tt}from"./p-182bb5be.js";import{A as st}from"./p-c0f84cd3.js";import{q as et,c as it}from"./p-ca4492df.js";import{y as rt}from"./p-7a5bfd29.js";import{m as nt,a as ht,y as at}from"./p-889f7a78.js";import{b as ot}from"./p-5e833dfc.js";import{s as ct}from"./p-7ec84656.js";import{a as ut,i as lt,h as dt,l as pt}from"./p-75cd09f2.js";import{h as ft,t as yt}from"./p-bdb15d78.js";import"./p-b79fcce3.js";import{f as gt,g as mt}from"./p-e49308c6.js";import{o as wt}from"./p-47e1bd73.js";import"./p-53bb6ab4.js";import"./p-5d962998.js";import"./p-01e5a461.js";import"./p-ea916a39.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-c048b814.js";import"./p-db87794e.js";import"./p-b0565d49.js";import"./p-f94762ac.js";import"./p-c1cd5521.js";import"./p-9f58a277.js";import"./p-61f47d2b.js";import"./p-06d309e6.js";import"./p-292d2320.js";import"./p-8bcb4bb3.js";import"./p-e0d9ff4c.js";import"./p-e273719b.js";import"./p-74de0937.js";import"./p-a9a30646.js";import"./p-7a658388.js";import"./p-85a6d41b.js";import"./p-765e6c28.js";import"./p-ca295674.js";import"./p-41f2b2dd.js";import"./p-8a919d07.js";import"./p-48c5edb1.js";import"./p-ed18725d.js";import"./p-2e8ad983.js";import"./p-a2324023.js";import"./p-2db4840f.js";import"./p-bba8b671.js";import"./p-e3500fdc.js";import"./p-0bb84768.js";import"./p-9b76ac50.js";import"./p-fb38a9d0.js";import"./p-b392deaf.js";import"./p-3a6cfd25.js";import"./p-8925cd73.js";import"./p-a131049b.js";import"./p-f3659a34.js";import"./p-77b9a0fc.js";import"./p-285c6a34.js";import"./p-c93d2280.js";import"./p-ccdb8e80.js";import"./p-fea9512d.js";import"./p-50ff864e.js";const bt=268435455;class vt{constructor(){this.fieldMap=new Map,this.fields=[],this.hasFeatures=!1,this.fieldCount=0,this.featureCount=0,this.objectIdFieldIndex=0,this.vertexCount=0,this.offsets={attributes:new Array,geometry:new Array},this.centroid=new Array}hasField(t){return this.fieldMap.has(t)}isDateField(t){var s;return null==(s=this.fieldMap.get(t))?void 0:s.isDate}getFieldIndex(t){var s;return null==(s=this.fieldMap.get(t))?void 0:s.index}}function Mt(t){const s=t.getLength(),e=t.pos()+s,i={name:"",isDate:!1};for(;t.pos()<e&&t.next();)switch(t.tag()){case 1:i.name=t.getString();break;case 2:"esriFieldTypeDate"===it(t.getEnum())&&(i.isDate=!0);break;default:t.skip()}return i}function jt(t){return t.toLowerCase().trim()}function xt(s,e,i=!1){const r=s.pos(),n=new vt;let h=0,a=0,o=null,c=null,u=null,l=!1;for(;s.next();)switch(s.tag()){case 1:o=s.getString();break;case 3:c=s.getString();break;case 12:u=s.processMessage(et);break;case 9:if(n.exceededTransferLimit=s.getBool(),n.exceededTransferLimit){n.offsets.geometry=i?new Float64Array(8e3):new Int32Array(8e3),n.centroid=i?new Float64Array(16e3):new Int32Array(16e3);for(let t=0;t<n.centroid.length;t++)n.centroid[t]=bt}break;case 13:{const t=Mt(s),e=t.name,i=jt(t.name),r={fieldName:e,index:h++,isDate:t.isDate};n.fields.push(r),n.fieldMap.set(t.name,r),n.fieldMap.set(i,r);break}case 15:{const t=s.getLength(),r=s.pos()+t;if(!n.exceededTransferLimit){const t=n.centroid;n.offsets.geometry.push(0),t.push(bt),t.push(bt)}!l&&n.exceededTransferLimit&&(l=!0,n.offsets.attributes=i?new Float64Array(8e3*h):new Uint32Array(8e3*h));let o=a*h;for(;s.pos()<r&&s.next();)switch(s.tag()){case 1:{l?n.offsets.attributes[o++]=s.pos():n.offsets.attributes.push(s.pos());const t=s.getLength();s.skipLen(t);break}case 2:if(e){const t=s.getLength(),e=s.pos()+t;for(;s.pos()<e&&s.next();)switch(s.tag()){case 3:{s.getUInt32();const t=s.getSInt64(),e=s.getSInt64();n.centroid[2*a]=t,n.centroid[2*a+1]=e;break}default:s.skip()}}else{n.offsets.geometry[a]=s.pos();const t=s.getLength();n.vertexCount+=t,s.skipLen(t)}break;case 4:{const t=s.getLength(),e=s.pos()+t;for(;s.pos()<e&&s.next();)switch(s.tag()){case 3:{s.getUInt32();const t=s.getSInt64(),e=s.getSInt64();n.centroid[2*a]=t,n.centroid[2*a+1]=e;break}default:s.skip()}break}default:s.skip()}a++,n.hasFeatures=!0;break}default:s.skip()}const d=o||c;if(!d)throw new t("FeatureSet has no objectId or globalId field name");return n.featureCount=a,n.fieldCount=h,n.objectIdFieldIndex=n.getFieldIndex(d),n.transform=u,n.displayIds=new Uint32Array(n.featureCount),n.groupIds=new Uint16Array(n.featureCount),s.move(r),n}const _t=s.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF"),qt=268435455,It={small:{delta:new Int32Array(128),decoded:new Int32Array(128)},large:{delta:new Int32Array(128e3),decoded:new Int32Array(128e3)}};function At(t){return t<=It.small.delta.length?It.small:(t<=It.large.delta.length||(It.large.delta=new Int32Array(Math.round(1.25*t)),It.large.decoded=new Int32Array(Math.round(1.25*t))),It.large)}function St(s){try{const t=2,e=new Z(new Uint8Array(s),new DataView(s));for(;e.next();){if(e.tag()===t)return Ft(e.getMessage());e.skip()}}catch(s){const e=new t("query:parsing-pbf","Error while parsing FeatureSet PBF payload",{error:s});_t.error(e)}return null}function Ft(t){for(;t.next();){if(1===t.tag())return t.getMessage();t.skip()}return null}function kt(t,s,e,i,r,n){return.5*Math.abs(t*i+e*n+r*s-t*n-e*s-r*i)}function Ct(t,s,e,i){return 0==t*i-e*s&&t*e+s*i>0}class Rt extends st{constructor(t,s,e,i){super(t),this._hasNext=!1,this._isPoints=!1,this._featureIndex=-1,this._featureOffset=0,this._cache={area:0,unquantGeometry:void 0,geometry:void 0,centroid:void 0,legacyFeature:void 0,optFeature:void 0},this._geometryType=i,this._reader=s,this._header=e,this._hasNext=e.hasFeatures,this._isPoints="esriGeometryPoint"===i}static fromBuffer(t,s,e=!1){const i=St(t),r=xt(i,"esriGeometryPoint"===s,e),n=st.createInstance();return new Rt(n,i,r,s)}get geometryType(){return this._geometryType}get size(){return this._header.featureCount}get hasZ(){return!1}get hasM(){return!1}get stride(){return 2+(this.hasZ?1:0)+(this.hasM?1:0)}get hasFeatures(){return this._header.hasFeatures}get hasNext(){return this._hasNext}get exceededTransferLimit(){return this._header.exceededTransferLimit}getSize(){return this.size}getQuantizationTransform(){return this._header.transform}getCursor(){return this.copy()}getIndex(){return this._featureIndex}setIndex(t){this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0,this._featureIndex=t}getAttributeHash(){let t="";return this._header.fields.forEach((({index:s})=>{t+=this._readAttributeAtIndex(s)+"."})),t}getObjectId(){return this._readAttributeAtIndex(this._header.objectIdFieldIndex)}getDisplayId(){return this._header.displayIds[this._featureIndex]}setDisplayId(t){this._header.displayIds[this._featureIndex]=t}getGroupId(){return this._header.groupIds[this._featureIndex]}setGroupId(t){this._header.groupIds[this._featureIndex]=t}readLegacyFeature(){if(void 0===this._cache.legacyFeature){var t;const s=this.readCentroid(),e={attributes:this.readAttributes(),geometry:this._isPoints?this.readLegacyPointGeometry():this.readLegacyGeometry(),centroid:null!=(t=s&&{x:s.coords[0],y:s.coords[1]})?t:null};return this._cache.legacyFeature=e,e}return this._cache.legacyFeature}readOptimizedFeature(){if(void 0===this._cache.optFeature){const t=new K(this.readGeometry(),this.readAttributes(),this.readCentroid());return t.objectId=this.getObjectId(),t.displayId=this.getDisplayId(),this._cache.optFeature=t,t}return this._cache.optFeature}getXHydrated(){const t=this._header.centroid[2*this._featureIndex],s=this.getQuantizationTransform();return e(s)?t:t*s.scale[0]+s.translate[0]}getYHydrated(){const t=this._header.centroid[2*this._featureIndex+1],s=this.getQuantizationTransform();return e(s)?t:s.translate[1]-t*s.scale[1]}getX(){return this._header.centroid[2*this._featureIndex]*this._sx+this._tx}getY(){return this._header.centroid[2*this._featureIndex+1]*this._sy+this._ty}readLegacyPointGeometry(){return{x:this.getX(),y:this.getY()}}readLegacyGeometry(t){const s=this.readGeometry(t);return F(s,this.geometryType,!1,!1)}readLegacyCentroid(){const t=this.readCentroid();if(!t)return null;const[s,e]=t.coords;return{x:s,y:e}}readGeometryArea(){return this._cache.area||this.readGeometry(!0),this._cache.area}readUnquantizedGeometry(t=!1){if(void 0===this._cache.unquantGeometry){const s=this.readGeometry(t);if(!s)return this._cache.unquantGeometry=null,null;const e=At(s.coords.length).decoded,i=s.clone(e),r=i.coords;let n=0;for(const t of i.lengths){for(let s=1;s<t;s++){const t=2*(n+s),e=2*(n+s-1);r[t]+=r[e],r[t+1]+=r[e+1]}n+=t}return this._cache.unquantGeometry=i,i}return this._cache.unquantGeometry}readHydratedGeometry(){if(this._isPoints){if(this._header.centroid[2*this._featureIndex]===qt)return null;const t=this.getXHydrated(),s=this.getYHydrated();return new W([],[t,s])}const t=this.readGeometry();if(!t)return null;const s=t.clone(),e=this.getQuantizationTransform();return i(e)&&k(s,s,this.hasZ,this.hasM,e),s}readGeometry(t=!1){if(void 0===this._cache.geometry){let s=null;if(this._isPoints){if(this._header.centroid[2*this._featureIndex]===qt)return null;const t=this.getX(),e=this.getY();s=new W([],[t,e])}else{const e=this._header.offsets.geometry[this._featureIndex],i=this._reader;if(0===e)return null;i.move(e);try{s=t?this._parseGeometryForDisplay(i):this._parseGeometry(i)}catch(t){return console.error("Failed to parse geometry!",t),null}}return this._cache.geometry=s,s}return this._cache.geometry}readCentroid(){if(void 0===this._cache.centroid){let t=null;const s=this._header.centroid[2*this._featureIndex]+this._tx,e=this._header.centroid[2*this._featureIndex+1]+this._ty;return s===qt?(t=this._computeCentroid(),t&&(this._header.centroid[2*this._featureIndex]=t.coords[0]-this._tx,this._header.centroid[2*this._featureIndex+1]=t.coords[1]-this._ty)):t=new W([],[s,e]),this._cache.centroid=t,t}return this._cache.centroid}copy(){const t=this._reader.clone(),s=new Rt(this.instance,t,this._header,this.geometryType);return this.copyInto(s),s}next(){for(this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0;++this._featureIndex<this.size&&!this._getExists(););return this._featureIndex<this.size}_readAttribute(t,s){const e=this._header.hasField(t)?t:function(t){return t.toLowerCase().trim()}(t),i=this._header.getFieldIndex(e);if(null==i)return;const r=this._readAttributeAtIndex(i);return s?null==r?r:this._header.isDateField(e)?new Date(r):r:r}_readAttributes(){const t={};return this._header.fields.forEach((({fieldName:s,index:e})=>{t[s]=this._readAttributeAtIndex(e)})),t}copyInto(t){super.copyInto(t),t._featureIndex=this._featureIndex,t._featureOffset=this._featureOffset,t._hasNext=this._hasNext}_readAttributeAtIndex(t){const s=this._reader;return s.move(this._header.offsets.attributes[this._featureIndex*this._header.fieldCount+t]),function(t){const s=t.getLength(),e=t.pos()+s;for(;t.pos()<e&&t.next();)switch(t.tag()){case 1:return t.getString();case 2:return t.getFloat();case 3:return t.getDouble();case 4:return t.getSInt32();case 5:return t.getUInt32();case 6:return t.getInt64();case 7:return t.getUInt64();case 8:return t.getSInt64();case 9:return t.getBool();default:return t.skip(),null}return null}(s)}_parseGeometry(t){const s=t.getLength(),e=t.pos()+s,i=[],r=[];for(;t.pos()<e&&t.next();)switch(t.tag()){case 2:{const s=t.getUInt32(),e=t.pos()+s;for(;t.pos()<e;)r.push(t.getUInt32());break}case 3:{const s=t.getUInt32(),e=t.pos()+s;for(i.push(t.getSInt32()+this._tx),i.push(t.getSInt32()+this._ty),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();t.pos()<e;)i.push(t.getSInt32()),i.push(t.getSInt32()),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();break}default:t.skip()}return new W(r,i)}_parseGeometryForDisplay(t){const s=t.getLength(),e=t.pos()+s,i=[],r=[];let n=0,h=0,a=null,o=0;const c="esriGeometryPolygon"===this.geometryType;for(;t.pos()<e&&t.next();)switch(t.tag()){case 2:{const s=t.getUInt32(),e=t.pos()+s;for(;t.pos()<e;){const s=t.getUInt32();i.push(s),n+=s}a=At(2*n).delta;break}case 3:{t.getUInt32();const s=2+(this.hasZ?1:0)+(this.hasM?1:0);for(const e of i)if(h+s*e>a.length)for(let s=0;s<e;s++)t.getSInt32(),t.getSInt32(),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();else if(c){const s=this.getAreaSimplificationThreshold(e,this._header.vertexCount);let i=2,n=1;const c=!1;let u=t.getSInt32(),l=t.getSInt32();a[h++]=u,a[h++]=l,this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();let d=t.getSInt32(),p=t.getSInt32();for(this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();i<e;){let e=t.getSInt32(),r=t.getSInt32();this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();const c=u+d,f=l+p;kt(u,l,c,f,c+e,f+r)>=s?(o+=-.5*(c-u)*(f+l),n>1&&Ct(a[h-2],a[h-1],d,p)?(a[h-2]+=d,a[h-1]+=p):(a[h++]=d,a[h++]=p,n++),u=c,l=f):(e+=d,r+=p),d=e,p=r,i++}n<3||c?h-=2*n:(o+=-.5*(u+d-u)*(l+p+l),Ct(a[h-2],a[h-1],d,p)?(a[h-2]+=d,a[h-1]+=p,r.push(n)):(a[h++]=d,a[h++]=p,r.push(++n)))}else{let s=0,i=t.getSInt32(),n=t.getSInt32();this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32(),a[h++]=i,a[h++]=n,s+=1;for(let r=1;r<e;r++){const e=t.getSInt32(),c=t.getSInt32(),u=i+e,l=n+c;o+=-.5*(u-i)*(l+n),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32(),r>2&&Ct(a[h-2],a[h-1],e,c)?(a[h-2]+=e,a[h-1]+=c):(a[h++]=e,a[h++]=c,s+=1),i=u,n=l}r.push(s)}break}default:t.skip()}if(this._cache.area=o,!r.length)return null;if(this._tx||this._ty){let t=0;for(const s of r)a[2*t]+=this._tx,a[2*t+1]+=this._ty,t+=s}return new W(r,a)}}class Pt{constructor(t){this.service=t}destroy(){}}class Tt extends Pt{constructor(t){super(t),this._portsOpen=async function(t){const s=new V;return await s.open(t,{}),s}(t.source).then((t=>this.client=t))}destroy(){this.client.close(),this.client=null}async executeQuery(t,s){await this._portsOpen;const e=await this.client.invoke("queryFeatures",t.toJSON(),s);return $.fromFeatureSet(e,this.service.objectIdField)}}class Ut extends Pt{async executeQuery(t,s){const{data:e}=await Y(this.service.source,t,s);return Rt.fromBuffer(e,this.service.geometryType,!t.quantizationParameters)}}class Et extends Pt{async executeQuery(t,s){const{source:e,capabilities:r,spatialReference:h,objectIdField:a,geometryType:o}=this.service;if(i(t.quantizationParameters)&&!r.query.supportsQuantization){const i=t.clone(),r=Q(n(i.quantizationParameters));i.quantizationParameters=null;const{data:o}=await B(e,i,h,s),c=C(o,a);return R(r,c),$.fromOptimizedFeatureSet(c)}const{data:c}=await B(e,t,this.service.spatialReference,s);return"esriGeometryPoint"===o&&(c.features=c.features.filter((t=>{if(i(t.geometry)){const s=t.geometry;return Number.isFinite(s.x)&&Number.isFinite(s.y)}return!0}))),$.fromFeatureSet(c,this.service.objectIdField)}}class Ot extends Pt{async executeQuery(t,s){const{capabilities:e}=this.service;if(t.quantizationParameters&&!e.query.supportsQuantization){const e=t.clone(),i=Q(n(e.quantizationParameters));e.quantizationParameters=null;const r=await X(this.service.source,t,s);return R(i,r),$.fromOptimizedFeatureSet(r)}const i=await X(this.service.source,t,s);return $.fromOptimizedFeatureSet(i)}}class Dt{constructor(){this.source=!1,this.targets={feature:!1,aggregate:!1},this.storage={filters:!1,data:!1},this.mesh=!1,this.queryFilter=!1,this.why={mesh:[],source:[]}}static create(t){const s=new Dt;for(const e in t){const i=t[e];if("object"==typeof i)for(const t in i)s[e][t]=i[t];s[e]=i}return s}static empty(){return Dt.create({})}static all(){return Dt.create({source:!0,targets:{feature:!0,aggregate:!0},storage:{filters:!0,data:!0},mesh:!0})}unset(t){t.source&&(this.source=!1),t.targets.feature&&(this.targets.feature=!1),t.targets.aggregate&&(this.targets.aggregate=!1),t.storage.filters&&(this.storage.filters=!1),t.storage.data&&(this.storage.data=!1),t.mesh&&(this.mesh=!1),t.queryFilter&&(this.queryFilter=!1)}any(){return this.source||this.mesh||this.storage.filters||this.storage.data||this.targets.feature||this.targets.aggregate||this.queryFilter}describe(){let t=0,s="";if(this.mesh){t+=20,s+="-> (20) Mesh needs update\n";for(const t of this.why.mesh)s+=`    + ${t}\n`}if(this.source){t+=10,s+="-> (10) The source needs update\n";for(const t of this.why.source)s+=`    + ${t}\n`}this.targets.feature&&(t+=5,s+="-> (5) Feature target parameters changed\n"),this.storage.filters&&(t+=5,s+="-> (5) Feature filter parameters changed\n"),this.targets.aggregate&&(t+=4,s+="-> (4) Aggregate target parameters changed\n"),this.storage.data&&(t+=1,s+="-> (1) Texture storage parameters changed"),console.debug(`Applying ${t<5?"Fastest":t<10?"Fast":t<15?"Moderate":t<20?"Slow":"Very Slow"} update of cost ${t}/45 `),console.debug(s)}toJSON(){return{queryFilter:this.queryFilter,source:this.source,targets:this.targets,storage:this.storage,mesh:this.mesh}}}class Gt{constructor(t){this.requests={done:new Array,stream:new ct(10)},this._edits=null,this._abortController=new AbortController,this._done=!1,this.didSend=!1,this.tile=t}get signal(){return this._abortController.signal}get options(){return{signal:this._abortController.signal}}get empty(){return!this.requests.done.length}get edits(){return this._edits}get done(){return this._done}end(){this._done=!0}clear(){this.requests.done=[]}applyUpdate(t){this.requests.done.forEach((s=>s.message.status.unset(t))),i(this._edits)&&this._edits.status.unset(t)}add(t){var s;t.message.status=null!=(s=t.message.status)?s:Dt.empty(),t.message.end&&this.requests.done.forEach((t=>{i(t.message)&&t.message.end&&(t.message.end=!1)})),this.requests.done.push(t)}edit(t,s){const i=t.getQuantizationTransform(),r=t.geometryType,h=Array.from(t.features()),a=[...s,...h.map((t=>t.objectId))];this.removeIds(a),this._invalidate(),e(this._edits)?this._edits={type:"append",addOrUpdate:$.fromOptimizedFeatures(h,r,n(i)),id:this.tile.id,status:Dt.empty(),end:!0}:(this.requests.done.forEach((t=>t.message.end=!1)),n(this._edits.addOrUpdate).append(t.features()))}*readers(){for(const{message:t}of this.requests.done)i(t.addOrUpdate)&&(yield t.addOrUpdate);i(this._edits)&&i(this._edits.addOrUpdate)&&(yield this._edits.addOrUpdate)}_invalidate(){for(const t of this.requests.done)t.message.status=Dt.empty();i(this._edits)&&(this._edits.status=Dt.empty())}removeIds(t){this._invalidate();for(const{message:s}of this.requests.done){const e=s.addOrUpdate;i(e)&&(e.removeIds(t),e.isEmpty&&(s.addOrUpdate=null))}i(this._edits)&&i(this._edits.addOrUpdate)&&this._edits.addOrUpdate.removeIds(t),this.requests.done=this.requests.done.filter((t=>t.message.addOrUpdate||t.message.end))}abort(){this._abortController.abort()}}class Lt{constructor(t){this.events=new h,this._resolver=a(),this._didEdit=!1,this._subscriptions=new Map,this._outSR=t.outSR,this._serviceInfo=t.serviceInfo,this._onTileUpdateMessage=t.onMessage}destroy(){}async _onMessage(t){var s;const e=this._subscriptions.get(t.id);if(!e)return;const i={...t,remove:null!=(s=t.remove)?s:[],status:t.status};return this._onTileUpdateMessage(i,e.options)}update(t,s){var e;const i=s.fields.length;s.outFields=function(t,s){const e=new Set;return t&&t.forEach((t=>e.add(t))),s&&s.forEach((t=>e.add(t))),e.has("*")?["*"]:Array.from(e)}(null==(e=this._schema)?void 0:e.outFields,s.outFields),s.outFields=s.outFields.length>=.75*i?["*"]:s.outFields,s.outFields.sort();const n=nt(this._schema,s);if(!n)return;r("esri-2d-update-debug")&&console.debug("Applying Update - Source:",n);const h="orderByFields"in this._serviceInfo&&this._serviceInfo.orderByFields?this._serviceInfo.orderByFields:this._serviceInfo.objectIdField+" ASC",a={returnCentroid:r("esri-2d-query-centroid-enabled")&&"esriGeometryPolygon"===this._serviceInfo.geometryType,returnGeometry:!0,timeReferenceUnknownClient:"stream"!==this._serviceInfo.type&&this._serviceInfo.timeReferenceUnknownClient,outFields:s.outFields,outSpatialReference:this._outSR,orderByFields:[h],where:s.definitionExpression||"1=1",gdbVersion:s.gdbVersion,historicMoment:s.historicMoment,timeExtent:rt.fromJSON(s.timeExtent),customParameters:s.customParameters},o=this._schema&&ht(n,"outFields");this._schema&&at(n,["timeExtent","definitionExpression","gdbVersion","historicMoment","customParameters"])&&(t.why.mesh.push("Layer filter and/or custom parameters changed"),t.why.source.push("Layer filter and/or custom parameters changed"),t.mesh=!0,t.source=!0,t.queryFilter=!0),o&&(t.why.source.push("Layer required fields changed"),t.source=!0),nt(a,this._queryInfo)&&(this._queryInfo=a),this._schema=s,this._resolver.resolve()}whenInitialized(){return this._resolver.promise}async applyUpdate(t){if(t.queryFilter||t.source&&this._didEdit)return this.refresh(),void(this._didEdit=!1);this._subscriptions.forEach((s=>s.applyUpdate(t))),await this.resend()}refresh(){for(const t of this._tiles())this.unsubscribe(t),this.subscribe(t)}subscribe(t){const s=new Gt(t);this._subscriptions.set(t.id,s)}unsubscribe(t){const s=this.get(t.id);i(s)&&s.abort(),this._subscriptions.delete(t.id)}createQuery(t={}){const s=this._queryInfo.historicMoment?new Date(this._queryInfo.historicMoment):null;return new ot({...this._queryInfo,historicMoment:s,...t})}get(t){return this._subscriptions.has(t)?this._subscriptions.get(t):null}async queryLastEditDate(){throw new Error("Service does not support query type")}async query(t){throw new Error("Service does not support query")}*_tiles(){const t=Array.from(this._subscriptions.values());for(const s of t)yield s.tile}async edit(t,s){const e=Array.from(this._subscriptions.values()),i=e.map((({tile:t})=>t));for(const t of e)t.removeIds(s);if(t.length){const e=i.map((s=>{const e=this.createTileQuery(s);return e.objectIds=t,{tile:s,query:e}})).map((async({tile:t,query:s})=>({tile:t,result:await this.query(s),query:s}))),r=(await o(e)).map((async({tile:e,result:i})=>{if(!i.hasFeatures&&!s.length&&!t.length)return;const r=this._subscriptions.get(e.key.id);r&&r.edit(i,t)}));await c(r)}this._didEdit=!0}}const zt=s.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource");class Nt extends Lt{constructor(t){super(t),this.type="feature",this.mode="on-demand",this._adapter=function(t){const{capabilities:s}=t;return function(t){return t&&t.capabilities&&t.collection&&t.layerDefinition}(t.source)?new Ot(t):function(t){return Array.isArray(t.source)}(t)?new Tt(t):s.query.supportsFormatPBF&&r("featurelayer-pbf")?new Ut(t):new Et(t)}(t.serviceInfo),this._queue=new ut({concurrency:8,process:async t=>{if(u(t),i(t.tile)){const s=t.tile.key.id,{signal:e}=t,i=r("esri-tiles-debug")?{tile:s.replace(/\//g,"."),depth:t.depth}:void 0,n=await this._adapter.executeQuery(t.query,{signal:e,query:{...i,...this._schema.customParameters}});return n.level=t.tile.key.level,n}return this._adapter.executeQuery(t.query,{...t,query:this._schema.customParameters})}}),this._patchQueue=new ut({concurrency:8,process:async t=>{if(u(t),i(t.tile)){const s=t.tile.key.id,{signal:e}=t,i=r("esri-tiles-debug")?{tile:s.replace(/\//g,"."),depth:t.depth}:void 0,n=await this._adapter.executeQuery(t.query,{signal:e,query:{...i,...this._schema.customParameters}});return n.level=t.tile.key.level,n}return this._adapter.executeQuery(t.query,{...t,query:this._schema.customParameters})}})}destroy(){super.destroy(),this._adapter.destroy(),this._queue.destroy(),this._patchQueue.destroy()}get updating(){return!!this._queue.length||Array.from(this._subscriptions.values()).some((t=>!t.done))}get maxRecordCountFactor(){const{query:t}=this._serviceInfo.capabilities;return t.supportsMaxRecordCountFactor?4:null}get maxPageSize(){var t;const{query:s}=this._serviceInfo.capabilities;return(null!=(t=s.maxRecordCount)?t:8e3)*l(this.maxRecordCountFactor,1)}get pageSize(){return Math.min(8e3,this.maxPageSize)}enableEvent(t,s){}subscribe(s){super.subscribe(s);const e=this._subscriptions.get(s.id);this._fetchDataTile(s).catch((e=>{d(e)||zt.error(new t("mapview-query-error","Encountered error when fetching tile",{tile:s,error:e}))})).then((()=>e.end()))}unsubscribe(t){super.unsubscribe(t)}readers(t){return this._subscriptions.get(t).readers()}async query(t){return this._adapter.executeQuery(t,{query:this._schema.customParameters})}async queryLastEditDate(){const t=this._serviceInfo.source,s={...t.query,f:"json"};return(await p(t.path,{query:s,responseType:"json"})).data.editingInfo.lastEditDate}createTileQuery(t,s={}){var e;const i=this.createQuery(s);return i.quantizationParameters=null!=(e=s.quantizationParameters)?e:t.getQuantizationParameters(),i.resultType="tile",i.geometry=t.extent,i.quantizationParameters&&"esriGeometryPolyline"===this._serviceInfo.geometryType&&(i.maxAllowableOffset=t.resolution),i}async _executePatchQuery(t,s,e,r){const n=s.clone();n.outFields=[this._serviceInfo.objectIdField,...e],n.returnCentroid=!1,n.returnGeometry=!1;const h=i(n.start)?n.start/8e3:0;return this._patchQueue.push({tile:t,query:n,signal:r.signal,depth:h})}async _resend(t,s){const{query:r,message:n}=t,h=i(r.outFields)?r.outFields:[],a=this._queryInfo.outFields,o=a.filter((t=>-1===h.indexOf(t)));if(e(n.addOrUpdate))this._onMessage({...n,type:"append"});else if(o.length)try{const t=this._subscriptions.get(n.id).tile,e=await this._executePatchQuery(t,r,o,s);u(s),r.outFields=a,n.addOrUpdate.joinAttributes(e),this._onMessage({...n,end:n.end,type:"append"})}catch(t){}else this._onMessage({...n,type:"append"})}async _resendSubscription(t){if(t.empty)return this._onMessage({id:t.tile.id,addOrUpdate:null,end:!1,type:"append"});const s=t.signal;for(const e of t.requests.done)await this._resend(e,{signal:s});return i(t.edits)?this._onMessage(t.edits):void 0}async resend(){const t=Array.from(this._subscriptions.values());await Promise.all(t.map((t=>this._resendSubscription(t))))}}const Vt=r("esri-mobile"),Qt={maxDrillLevel:Vt?1:4,maxRecordCountFactor:Vt?1:3};class Xt extends Nt{constructor(t){super(t)}async _fetchDataTile(t){const s=this._serviceInfo.capabilities.query.supportsMaxRecordCountFactor,e=this._subscriptions.get(t.key.id),i=e.signal,r=t.getQuantizationParameters();let n=0;const h=async(a,o)=>{const c=this._queryInfo,l=this.createTileQuery(a,{maxRecordCountFactor:s?Qt.maxRecordCountFactor:void 0,returnExceededLimitFeatures:!1,quantizationParameters:r});n++;try{const s=await this._queue.push({tile:t,query:l,signal:i,depth:o});if(n--,u(i),!s)return;if(c!==this._queryInfo)return void h(a,o);if(s.exceededTransferLimit&&o<Qt.maxDrillLevel){for(const t of a.createChildTiles())h(t,o+1);return}const r={id:t.id,addOrUpdate:s,end:0===n,type:"append"};e.add({query:l,message:r}),this._onMessage(r)}catch(s){d(s)||this._onMessage({id:t.id,addOrUpdate:null,end:!0,type:"append"})}};h(t,0)}}function Yt(t,s){const e=t.weakClone();if(i(t.geometry)){const i=U(s,t.geometry.coords[0]),r=E(s,t.geometry.coords[1]);e.geometry=new W([],[i,r])}return e}class Bt{constructor(t,s){this.onUpdate=t,this._geometryType=s,this._objectIdToFeature=new Map}get _features(){const t=[];return this._objectIdToFeature.forEach((s=>t.push(s))),t}add(t){this._objectIdToFeature.set(t.objectId,t),this._index=null}get(t){return this._objectIdToFeature.has(t)?this._objectIdToFeature.get(t):null}forEach(t){this._objectIdToFeature.forEach(t)}search(t){return this._index||(this._index=function(t,s){const e=lt(9,function(t){return"esriGeometryPoint"===t?t=>i(t.geometry)?{minX:t.geometry.coords[0],minY:t.geometry.coords[1],maxX:t.geometry.coords[0],maxY:t.geometry.coords[1]}:{minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}:t=>{let s=1/0,e=1/0,r=-1/0,n=-1/0;return i(t.geometry)&&t.geometry.forEachVertex(((t,i)=>{s=Math.min(s,t),e=Math.min(e,i),r=Math.max(r,t),n=Math.max(n,i)})),{minX:s,minY:e,maxX:r,maxY:n}}}(s));return e.load(t),e}(this._features,this._geometryType)),function(t,s){return t.search({minX:s.bounds[0],minY:s.bounds[1],maxX:s.bounds[2],maxY:s.bounds[3]})}(this._index,t)}removeById(t){const s=this._objectIdToFeature.get(t);return s?(this._objectIdToFeature.delete(t),this._index=null,s):null}update(t,s){this.onUpdate(t,s)}get size(){return this._objectIdToFeature.size}}class $t extends Lt{constructor(t){super(t),this.type="geoevent",this._dataReceiveEventEnabled=!1,this._level=0,this._updateInfo={websocket:0,client:0};const{outSR:s}=t,{geometryType:e,objectIdField:i,timeInfo:r,purgeOptions:n,source:h,spatialReference:a,serviceFilter:o,maxReconnectionAttempts:c,maxReconnectionInterval:u,updateInterval:l,enableDataReceived:d,customParameters:p}=t.serviceInfo,f=new Bt(this._onUpdate.bind(this),e),y=new ft(f,i,r,n),g=yt(h,a,s,e,o,c,u,p);this._store=f,this._manager=y,this._connection=g,this._quantize=function(t){return"esriGeometryPoint"===t?Yt:(s,e)=>{const i=s.weakClone(),r=new W,n=P(r,s.geometry,!1,!1,t,e,!1,!1);return i.geometry=n,i}}(e),this._dataReceiveEventEnabled=d,this._handles=[this._connection.on("feature",(t=>this._onFeature(t))),this._connection.watch("connectionStatus",(t=>this.events.emit("connectionStatus",t))),this._connection.watch("errorString",(t=>this.events.emit("errorString",t)))];let m=performance.now();this._updateIntervalId=setInterval((()=>{const s=performance.now(),e=s-m;if(e>2500){m=s;const t=Math.round(this._updateInfo.client/(e/1e3)),i=Math.round(this._updateInfo.websocket/(e/1e3));this._updateInfo.client=0,this._updateInfo.websocket=0,this.events.emit("updateRate",{client:t,websocket:i})}t.canAcceptRequest()&&this._manager.checkForUpdates()}),l)}destroy(){super.destroy(),clearInterval(this._updateIntervalId),this._handles.forEach((t=>t.remove())),this._connection.destroy()}_fetchDataTile(){}resume(){}enableEvent(t,s){"data-received"===t&&(this._dataReceiveEventEnabled=s)}get updating(){return!1}subscribe(t){super.subscribe(t);const s=this._subscriptions.get(t.id);this._level=t.level;const e=this._getTileFeatures(t);this._onMessage({type:"append",id:t.key.id,addOrUpdate:e,end:!0}),s.didSend=!0}unsubscribe(t){super.unsubscribe(t)}*readers(t){const s=this._subscriptions.get(t),{tile:e}=s;yield this._getTileFeatures(e);for(const t of s.requests.stream.entries)i(t)&&i(t.addOrUpdate)&&(yield t.addOrUpdate)}createTileQuery(t){throw new Error("Service does not support tile  queries")}async resend(){this._subscriptions.forEach((t=>{const{tile:s}=t,e={type:"append",id:s.id,addOrUpdate:this._getTileFeatures(s),end:!0};this._onMessage(e)}))}_getTileFeatures(t){const s=this._store.search(t).map((s=>this._quantize(s,t.transform)));return $.fromOptimizedFeatures(s,this._serviceInfo.geometryType,t.transform)}_onFeature(t){this._updateInfo.websocket++;try{this._dataReceiveEventEnabled&&this.events.emit("feature",t);const s=T(t,this._serviceInfo.geometryType,!1,!1,this._serviceInfo.objectIdField);this._manager.add(s)}catch(t){}}_onUpdate(t,s){i(t)&&(this._updateInfo.client+=t.length),this._subscriptions.forEach(((t,s)=>{t.didSend&&t.tile.level===this._level&&this._onMessage({type:"append",id:s,addOrUpdate:null,clear:!0,end:!1})})),this._subscriptions.forEach(((t,s)=>{if(!t.didSend||t.tile.level!==this._level)return;const e={type:"append",id:s,addOrUpdate:this._getTileFeatures(t.tile),remove:[],end:!0,status:Dt.empty()};t.requests.stream.enqueue(e),this._onMessage(e)}))}}const Ht=s.getLogger("esri.views.2d.layers.features.sources.FeatureSource");class Jt extends Nt{constructor(t){super(t)}async _fetchDataTile(s){const e=this._subscriptions.get(s.key.id);let i=!1,r=0,n=0;const h=(t,r)=>{n--,u(e);const h=s.id,a=t.reader,o=t.query;if(!a.exceededTransferLimit){if(i=!0,0!==r&&!a.hasFeatures){const t={id:h,addOrUpdate:a,end:0===n,type:"append"};return e.add({message:t,query:o}),void this._onMessage(t)}const t={id:h,addOrUpdate:a,end:0===n,type:"append"};return e.add({message:t,query:o}),void this._onMessage(t)}const c={id:h,addOrUpdate:a,end:i&&0===n,type:"append"};e.add({message:c,query:o}),this._onMessage(c)};let a=0,o=0;for(;!i&&o++<20;){let o;for(let c=0;c<a+1;c++){const a=r++;n++,o=this._fetchDataTilePage(s,a,e).then((t=>t&&h(t,a))).catch((e=>{i=!0,d(e)||(Ht.error(new t("mapview-query-error","Encountered error when fetching tile",{tile:s,error:e})),this._onMessage({id:s.id,addOrUpdate:null,end:i,type:"append"}))}))}await o,u(e),a=Math.min(a+2,6)}}async _fetchDataTilePage(t,s,e){const r=this._queryInfo,n={start:this.pageSize*s,num:this.pageSize,returnExceededLimitFeatures:!0,quantizationParameters:t.getQuantizationParameters()};i(this.maxRecordCountFactor)&&(n.maxRecordCountFactor=this.maxRecordCountFactor);const h=this.createTileQuery(t,n);try{const i=e.signal,n=await this._queue.push({tile:t,query:h,signal:i,depth:s});return u(e),n?r!==this._queryInfo?this._fetchDataTilePage(t,s,e):{reader:n,query:h}:null}catch(t){return f(t),null}}}const Zt=s.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource");function Kt(t,s,e){const i=t.getXHydrated(),r=t.getYHydrated(),n=s.getColumnForX(i),h=Math.floor(s.normalizeCol(n));return`${e}/${Math.floor(s.getRowForY(r))}/${h}`}function Wt(t,s){if(e(t))return null;const i=s.transform,r=t.getQuantizationTransform();if(e(r)){const[s,e]=i.scale,[r,n]=i.translate;return t.transform(-r/s,n/e,1/s,1/-e)}const[n,h]=r.scale,[a,o]=r.translate,[c,u]=i.scale,[l,d]=i.translate;return t.transform((a-l)/c,(-o+d)/u,n/c,h/u)}class ts extends Nt{constructor(t){super(t),this.mode="snapshot",this._loading=!0,this._controller=new AbortController,this._downloadPromise=null,this._didSendEnd=!1,this._queries=new Array,this._invalidated=!1,this._hasAggregates=!1,this._random=new y(1e3),this._featureCount=t.featureCount,this._store=t.store,this._markedIdsBufId=this._store.storage.createBitset()}destroy(){super.destroy(),this._controller.abort()}get loading(){return this._loading}get _signal(){return this._controller.signal}update(t,s){super.update(t,s),this._hasAggregates=t.targets.aggregate}async resend(t=!1){if(await this._downloadPromise,this._invalidated||t)return this._invalidated=!1,this._subscriptions.forEach((t=>t.clear())),this._downloadPromise=this._download(this._featureCount),void await this._downloadPromise;const s=this._queries.map((({query:t,reader:s})=>this._sendPatchQuery(t,s)));await Promise.all(s),this._subscriptions.forEach((t=>{t.requests.done.forEach((t=>this._onMessage(t.message)))}))}async refresh(){await this.resend(!0)}async _sendPatchQuery(t,s){const e=i(t.outFields)?t.outFields:[],r=this._queryInfo.outFields,n=r.filter((t=>-1===e.indexOf(t)));if(!n.length)return;const h=t.clone(),a=this._signal;h.returnGeometry=!1,h.returnCentroid=!1,h.outFields=n,t.outFields=r;const o=await this._queue.push({query:h,depth:0,signal:a});u({signal:a}),s.joinAttributes(o)}async _fetchDataTile(t){this._downloadPromise||(this._downloadPromise=this._download(this._featureCount));const s=this._store.search(t),e=this._subscriptions.get(t.key.id),i=s.length-1;for(let r=0;r<i;r++){const i=Wt(s[r],t),n={type:"append",id:t.id,addOrUpdate:i,end:!1,status:Dt.empty()};e.add({query:null,message:n}),this._hasAggregates||await g(1),this._onMessage(n)}const r=Wt(i>=0?s[i]:null,t),n={type:"append",id:t.id,addOrUpdate:r,end:this._didSendEnd,status:Dt.empty()};e.add({query:null,message:n}),this._onMessage(n)}async _download(t){try{await this.whenInitialized();const s=this._store.storage.getBitset(this._markedIdsBufId),e=new Set;s.clear();const i=Math.ceil(t/this.pageSize),r=Array.from({length:i},((t,s)=>s)).sort((()=>this._random.getInt()-this._random.getInt())).map((t=>this._downloadPage(t,s,e)));await Promise.all(r),this._store.sweepFeatures(s,this._store.storage),this._store.sweepFeatureSets(e)}catch(t){Zt.error("mapview-snapshot-source","Encountered and error when downloading feature snapshot",t)}this._sendEnd(),this._loading=!1}async _downloadPage(t,s,e){const r=this.pageSize,n={start:t*r,num:r,cacheHint:!0};i(this.maxRecordCountFactor)&&(n.maxRecordCountFactor=this.maxRecordCountFactor);const h=this.createQuery(n),a=this._signal,o=await this._queue.push({query:h,depth:t,signal:a});u({signal:a}),this._queries.push({query:h,reader:o}),this._store.insert(o),e.add(o.instance);const c=o.getCursor();for(;c.next();)s.set(c.getDisplayId());this._send(o)}_send(t){if(!this._subscriptions.size)return;let s=null;const r=new Map,n=new Set,h=new Map;this._subscriptions.forEach((t=>{var e;const i=t.tile;r.set(i.key.id,null),s=i.tileInfoView,n.add(i.level);const{row:a,col:o}=i.key,c=`${i.level}/${a}/${o}`,u=null!=(e=h.get(c))?e:[];u.push(t),h.set(c,u)}));for(const i of n){const n=s.getLODInfoAt(i),a=t.getCursor();for(;a.next();){const t=Kt(a,n,i),s=a.getIndex();if(h.has(t))for(const i of h.get(t)){const t=i.tile.id;let n=r.get(t);e(n)&&(n=[],r.set(t,n)),n.push(s)}}}r.forEach(((s,e)=>{if(i(s)){const i=this._subscriptions.get(e),r={type:"append",id:e,addOrUpdate:Wt(G.from(t,s),i.tile),end:!1,status:Dt.empty()};i.add({query:null,message:r}),this._onMessage(r)}}))}_sendEnd(){this._subscriptions.forEach((t=>{const s={type:"append",id:t.tile.id,addOrUpdate:null,end:!0,status:Dt.empty()};t.add({query:null,message:s}),this._onMessage(s)})),this._didSendEnd=!0}}function ss(t,s,e,i){i%2&&(i+=1);let r=0,n=0,h=-90,a=90,o=-180,c=180;for(let t=0;t<i/2;t++){for(let s=0;s<5;s++){const i=(o+c)/2,n=e>i?1:0;r|=n<<29-(s+5*t),o=(1-n)*o+n*i,c=(1-n)*i+n*c}for(let e=0;e<5;e++){const i=(h+a)/2,r=s>i?1:0;n|=r<<29-(e+5*t),h=(1-r)*h+r*i,a=(1-r)*i+r*a}}t.geohashX=r,t.geohashY=n}function es(t,s,e,i,r){r%2&&(r+=1);let n=0,h=0,a=-90,o=90,c=-180,u=180;for(let t=0;t<r/2;t++){for(let s=0;s<5;s++){const e=(c+u)/2,r=i>e?1:0;n|=r<<29-(s+5*t),c=(1-r)*c+r*e,u=(1-r)*e+r*u}for(let s=0;s<5;s++){const i=(a+o)/2,r=e>i?1:0;h|=r<<29-(s+5*t),a=(1-r)*a+r*i,o=(1-r)*i+r*o}}t[2*s]=n,t[2*s+1]=h}class is{constructor(t=[],s=8096){this._nodes=0,this._root=new rs(0,0,0),this._statisticFields=t,this._pool=s?new ct(8096):null}_acquire(t,s,e){this._nodes++;let r=null;return i(this._pool)&&(r=this._pool.dequeue()),i(r)?r.realloc(t,s,e):new rs(t,s,e)}_release(t){this._nodes--,i(this._pool)&&this._pool.enqueue(t)}get count(){return this._root.count}get size(){return this._nodes}get poolSize(){return m(this._pool,0,(t=>t.size))}get depth(){let t=0;return this._forEachNode((s=>t=Math.max(t,s.depth))),t}dropLevels(t){this._forEachNode((s=>{if(s.depth>=t)for(let t=0;t<s.children.length;t++){const e=s.children[t];s.children[t]=null,e&&this._release(e)}}))}clear(){this.dropLevels(0)}insert(t,s,e=0){const i=$.fromOptimizedFeatures([t],"esriGeometryPoint").getCursor();i.next();const r=i.readGeometry();if(!r)return;const[n,h]=r.coords;this.insertCursor(i,t.displayId,n,h,t.geohashX,t.geohashY,s,e)}insertCursor(t,s,e,i,r,n,h,a=0){let o=this._root,c=0,u=0,l=0;for(;null!==o;){if(o.depth>=a&&(o.count+=1,o.xTotal+=e,o.yTotal+=i,o.xGeohashTotal+=r,o.yGeohashTotal+=n,o.displayId=s,this._updateStatisticsCursor(t,o,1)),c>=h)return void o.add(s);const d=Math.ceil((c+1)/2),p=Math.floor((c+1)/2),f=1-c%2,y=30-(3*d+2*p),g=30-(2*d+3*p),m=(r&7*f+3*(1-f)<<y)>>y,w=(n&3*f+7*(1-f)<<g)>>g,b=m+w*(8*f+4*(1-f));u=u<<3*f+2*(1-f)|m,l=l<<2*f+3*(1-f)|w,null==o.children[b]&&(o.children[b]=this._acquire(u,l,c+1)),c+=1,o=o.children[b]}}remove(t,s){const e=$.fromOptimizedFeatures([t],"esriGeometryPoint").getCursor();e.next();const i=e.readGeometry();if(!i)return;const[r,n]=i.coords;this.removeCursor(e,r,n,t.geohashX,t.geohashY,s)}removeCursor(t,s,e,i,r,n){let h=this._root,a=0;for(;null!==h;){if(h.count-=1,h.xTotal-=s,h.yTotal-=e,h.xGeohashTotal-=i,h.yGeohashTotal-=r,this._updateStatisticsCursor(t,h,-1),a>=n)return void h.remove(t.getDisplayId());const o=Math.ceil((a+1)/2),c=Math.floor((a+1)/2),u=1-a%2,l=30-(3*o+2*c),d=30-(2*o+3*c),p=((i&7*u+3*(1-u)<<l)>>l)+((r&3*u+7*(1-u)<<d)>>d)*(8*u+4*(1-u)),f=h.children[p];1===f.count&&(this._release(f),h.children[p]=null),a+=1,h=f}}find(t,s,e){return this._root.find(t,s,e,0,0,0)}findSingleOccupancyNode(t,s,e,i,r){let n=this._root;for(;null!==n;){const h=n.depth,a=n.xNode,o=n.yNode,c=1-h%2,u=n.xGeohashTotal/n.count,l=n.yGeohashTotal/n.count;if(1===n.count&&t<u&&u<=e&&s<l&&l<=i)return n;if(h>=r){n=n.next;continue}const d=Math.ceil((h+1)/2),p=Math.floor((h+1)/2),f=30-(3*d+2*p),y=30-(2*d+3*p),g=~((1<<f)-1),m=~((1<<y)-1),w=(s&m)>>y,b=(e&g)>>f,v=(i&m)>>y,M=a<<3*c+2*(1-c),j=o<<2*c+3*(1-c),x=M+8*c+4*(1-c),_=j+4*c+8*(1-c),q=Math.max(M,(t&g)>>f),I=Math.max(j,w),A=Math.min(x,b),S=Math.min(_,v);let F=null,k=null;for(let t=I;t<=S;t++)for(let s=q;s<=A;s++){const e=n.children[s-M+(t-j)*(8*c+4*(1-c))];e&&(F||(F=e,F.next=n.next),k&&(k.next=e),k=e,e.next=n.next)}n=F||n.next}return null}getRegionDisplayIds(t,s,e,i,r){let n=this._root;const h=[];for(;null!==n;){const a=n.depth,o=n.xNode,c=n.yNode;if(a>=r){const r=n.xGeohashTotal/n.count,a=n.yGeohashTotal/n.count;t<=r&&r<=e&&s<=a&&a<=i&&n.displayIds.forEach((t=>h.push(t))),n=n.next;continue}const u=Math.ceil((a+1)/2),l=Math.floor((a+1)/2),d=1-a%2,p=30-(3*u+2*l),f=30-(2*u+3*l),y=~((1<<p)-1),g=~((1<<f)-1),m=(s&g)>>f,w=(e&y)>>p,b=(i&g)>>f,v=o<<3*d+2*(1-d),M=c<<2*d+3*(1-d),j=v+8*d+4*(1-d),x=M+4*d+8*(1-d),_=Math.max(v,(t&y)>>p),q=Math.max(M,m),I=Math.min(j,w),A=Math.min(x,b);let S=null,F=null;for(let t=q;t<=A;t++)for(let s=_;s<=I;s++){const e=n.children[s-v+(t-M)*(8*d+4*(1-d))];e&&(S||(S=e,S.next=n.next),F&&(F.next=e),F=e,e.next=n.next)}n=S||n.next}return h}getRegionStatistics(t,s,e,i,r){let n=this._root,h=0,a=0,o=0;const c={};let u=0;for(;null!==n;){const l=n.depth,d=n.xNode,p=n.yNode;if(l>=r){const r=n.xGeohashTotal/n.count,l=n.yGeohashTotal/n.count;t<r&&r<=e&&s<l&&l<=i&&(h+=n.count,a+=n.xTotal,o+=n.yTotal,1===n.count&&(u=n.displayId),this._aggregateStatistics(c,n.statistics)),n=n.next;continue}const f=Math.ceil((l+1)/2),y=Math.floor((l+1)/2),g=1-l%2,m=30-(3*f+2*y),w=30-(2*f+3*y),b=~((1<<m)-1),v=~((1<<w)-1),M=(s&v)>>w,j=(e&b)>>m,x=(i&v)>>w,_=d<<3*g+2*(1-g),q=p<<2*g+3*(1-g),I=_+8*g+4*(1-g),A=q+4*g+8*(1-g),S=Math.max(_,(t&b)>>m),F=Math.max(q,M),k=Math.min(I,j),C=Math.min(A,x);let R=null,P=null;for(let r=F;r<=C;r++)for(let l=S;l<=k;l++){const d=n.children[l-_+(r-q)*(8*g+4*(1-g))];if(d){if(r!==F&&r!==C&&l!==S&&l!==k){const r=d.xGeohashTotal/d.count,n=d.yGeohashTotal/d.count;t<r&&r<=e&&s<n&&n<=i&&(h+=d.count,a+=d.xTotal,o+=d.yTotal,1===d.count&&(u=d.displayId),this._aggregateStatistics(c,d.statistics));continue}R||(R=d,R.next=n.next),P&&(P.next=d),P=d,d.next=n.next}}n=R||n.next}return{count:h,attributes:this._normalizeStatistics(c,h),xTotal:a,yTotal:o,referenceId:u}}_forEachNode(t){let s=this._root;for(;null!==s;){const e=this._linkChildren(s)||s.next;t(s),s=e}}_linkChildren(t){let s=null,e=null;for(let i=0;i<=t.children.length;i++){const r=t.children[i];r&&(s||(s=r,s.next=t.next),e&&(e.next=r),e=r,r.next=t.next)}return s}_updateStatisticsCursor(t,s,e){for(const i of this._statisticFields){const r=i.name,n=i.inField?t.readAttribute(i.inField):t.getComputedNumericAtIndex(i.inFieldIndex);switch(i.statisticType){case"norm":{s.statistics[r]||(s.statistics[r]={});const h=t.readAttribute(i.inNormalizationField),a=s.statistics[r].onStatisticField||0,o=s.statistics[r].onStatisticNormalizationField||0;null==n||isNaN(n)||null==h||0===h||isNaN(h)||(s.statistics[r].onStatisticField=a+e*n,s.statistics[r].onStatisticNormalizationField=o+e*h);break}case"sum":case"avg":{s.statistics[r]||(s.statistics[r]={value:0,nanCount:0});const t=s.statistics[r].value,i=s.statistics[r].nanCount;null==n||isNaN(n)?s.statistics[r].nanCount=i+e:s.statistics[r].value=t+e*n;break}case"avg_angle":{s.statistics[r]||(s.statistics[r]={x:0,y:0,nanCount:0});const t=s.statistics[r].x,i=s.statistics[r].y,h=s.statistics[r].nanCount,a=Math.PI/180;null==n||isNaN(n)?s.statistics[r].nanCount=h+e:(s.statistics[r].x=t+e*Math.cos(n*a),s.statistics[r].y=i+e*Math.sin(n*a));break}case"mode":s.statistics[r]||(s.statistics[r]={}),s.statistics[r][n]=(s.statistics[r][n]||0)+e}}}_aggregateStatistics(t,s){for(const e of this._statisticFields){const i=e.name;switch(e.statisticType){case"sum":case"avg":case"avg_angle":case"mode":case"norm":t[i]||(t[i]={});for(const e in s[i])t[i][e]=(t[i][e]||0)+s[i][e]}}}_normalizeStatistics(t,s){const e={};for(const i of this._statisticFields){const r=i.name;switch(i.statisticType){case"norm":{const i=t[r];if(s&&null==i.onStatisticNormalizationField)break;if(s&&i.onStatisticNormalizationField){e[r]=i.onStatisticField/i.onStatisticNormalizationField;break}e[r]=0;break}case"sum":{if(!s)break;const{value:i,nanCount:n}=t[r];if(!(s-n))break;e[r]=i;break}case"avg":{if(!s)break;const{value:i,nanCount:n}=t[r];if(!(s-n))break;e[r]=i/(s-n);break}case"avg_angle":{if(!s)break;const{x:i,y:n,nanCount:h}=t[r];if(!(s-h))break;const a=180/Math.PI,o=Math.atan2(n/(s-h),i/(s-h))*a;e[r]=o;break}case"mode":{const s=t[r];let i=0,n=null;for(const t in s){const e=s[t];e>i&&(i=e,n=t)}e[r]="null"===n?null:n;break}}}return e}}class rs{constructor(t,s,e){this.count=0,this.xTotal=0,this.yTotal=0,this.statistics={},this.displayId=0,this.displayIds=new Set,this.next=null,this.depth=0,this.xNode=0,this.yNode=0,this.xGeohashTotal=0,this.yGeohashTotal=0,this.children=new Array(32);for(let t=0;t<this.children.length;t++)this.children[t]=null;this.xNode=t,this.yNode=s,this.depth=e}realloc(t,s,e){for(let t=0;t<this.children.length;t++)this.children[t]=null;return this.xNode=t,this.yNode=s,this.depth=e,this.next=null,this.xGeohashTotal=0,this.yGeohashTotal=0,this.xTotal=0,this.yTotal=0,this.count=0,this.statistics={},this.displayIds.clear(),this}add(t){this.displayIds.add(t)}remove(t){this.displayIds.delete(t)}getLngLatBounds(){const t=this.depth,s=Math.ceil(t/2),e=Math.floor(t/2);return function(t,s){let e=-90,i=90,r=-180,n=180;for(let h=0;h<s;h++){const s=Math.ceil((h+1)/2),a=Math.floor((h+1)/2),o=1-h%2,c=30-(3*s+2*a),u=30-(2*s+3*a),l=2*o+3*(1-o),d=(7*o+3*(1-o)<<c&t.geohashX)>>c,p=(3*o+7*(1-o)<<u&t.geohashY)>>u;for(let t=3*o+2*(1-o)-1;t>=0;t--){const s=(r+n)/2,e=d&1<<t?1:0;r=(1-e)*r+e*s,n=(1-e)*s+e*n}for(let t=l-1;t>=0;t--){const s=(e+i)/2,r=p&1<<t?1:0;e=(1-r)*e+r*s,i=(1-r)*s+r*i}}return[r,e,n,i]}({geohashX:this.xNode<<30-(3*s+2*e),geohashY:this.yNode<<30-(2*s+3*e)},this.depth)}find(t,s,e,i,r,n){if(i>=e)return this;const h=1-i%2,a=3*h+2*(1-h),o=2*h+3*(1-h),c=30-r-a,u=30-n-o,l=this.children[((t&7*h+3*(1-h)<<c)>>c)+((s&3*h+7*(1-h)<<u)>>u)*(8*h+4*(1-h))];return null==l?null:l.find(t,s,e,i+1,r+a,n+o)}}class ns extends tt{constructor(t,s,e,i,r){super(new W([],[s,e]),i,null,t),this.geohashBoundsInfo=r}get count(){return this.attributes.cluster_count}static create(t,s,e,i,r,n,h,a){const o=new ns(s,e,i,n,h);return o.displayId=t.createDisplayId(!0),o.referenceId=a,o.tileLevel=r,o}update(t,s,e,i,r,n){return this.geometry.coords[0]=t,this.geometry.coords[1]=s,this.tileLevel=e,this.attributes=i,this.geohashBoundsInfo=r,this.referenceId=null,this.referenceId=n,this}toJSON(){return{objectId:this.objectId,referenceId:1===this.attributes.cluster_count?this.referenceId:null,attributes:{...this.attributes,clusterId:this.objectId},geometry:{x:this.geometry.coords[0],y:this.geometry.coords[1]}}}}function hs(t){return 57.29577951308232*t}class as extends L{constructor(t,s,e){super(t,e),this.events=new h,this._geohashLevel=0,this._tileLevel=0,this._aggregateValueRanges={},this._aggregateValueRangesChanged=!1,this._geohashBuf=[],this._clusters=new Map,this._tiles=new Map,this.geometryInfo=t.geometryInfo,this._spatialReference=s,this._projectionSupportCheck=gt(s,w.WGS84),this._bitsets.geohash=e.getBitset(e.createBitset()),this._bitsets.inserted=e.getBitset(e.createBitset())}async updateSchema(t,s){const i=this._schema;try{await super.updateSchema(t,s),await this._projectionSupportCheck}catch(t){}const n=nt(i,s);s&&(!e(n)||t.source||t.storage.filters)?((ht(n,"params.fields")||!this._tree||t.source)&&(this._tree=new is(this._statisticFields),this._rebuildTree(),r("esri-2d-update-debug")&&console.debug("Aggregate mesh needs update due to tree changing")),r("esri-2d-update-debug")&&console.debug("Applying Update - ClusterStore:",n),t.targets[s.name]=!0,t.mesh=!1,this._aggregateValueRanges={}):i&&(t.mesh=!0)}clear(){this._rebuildTree()}sweepFeatures(t,s){this._bitsets.inserted.forEachSet((e=>{if(!t.has(e)){const t=s.lookupByDisplayIdUnsafe(e);this._remove(t)}}))}sweepClusters(t,s,e){this._clusters.forEach(((i,r)=>{i&&i.tileLevel!==e&&(t.releaseDisplayId(i.displayId),s.unsetAttributeData(i.displayId),this._clusters.delete(r))}))}onTileData(t,s,i,r,n=!0){if(!this._schema||e(s.addOrUpdate))return s;const h=this._getTransforms(t,this._spatialReference);{const t=s.addOrUpdate.getCursor();for(;t.next();)this._update(t,r)}if(s.status.mesh||!n)return s;const a=new Array;this._getClustersForTile(a,t,this._schema.params.clusterRadius,i,h),s.addOrUpdate=$.fromOptimizedFeatures(a,"esriGeometryPoint"),s.addOrUpdate.attachStorage(i),s.end=!0;{const e=s.addOrUpdate.getCursor();for(;e.next();){const s=e.getDisplayId();this._bitsets.computed.unset(s),this.setComputedAttributes(i,e,s,t.scale)}}return this._aggregateValueRangesChanged&&s.end&&(this.events.emit("valueRangesChanged",{valueRanges:this._aggregateValueRanges}),this._aggregateValueRangesChanged=!1),s}onTileUpdate({added:t,removed:s}){if(t.length){const s=t[0].level;this._tileLevel=s,this._setGeohashLevel(s)}if(!this._schema)return;const e=this._schema.params.clusterRadius;s.forEach((t=>{this._tiles.delete(t.key.id),this._markTileClustersForDeletion(t,e)}))}getAggregate(t){let s=null;return this._clusters.forEach((e=>{e&&e.displayId===t&&(s=e.toJSON())})),s}getAggregates(){const t=[];return this._clusters.forEach((s=>{s&&s.tileLevel===this._tileLevel&&t.push(s.toJSON())})),t}getDisplayId(t){const s=this._clusters.get(t);return s?s.displayId:null}getFeatureDisplayIdsForAggregate(t){const s=this._clusters.get(t);if(!s)return[];const e=s.geohashBoundsInfo;return this._tree.getRegionDisplayIds(e.xLL,e.yLL,e.xTR,e.yTR,e.level)}getDisplayIdForReferenceId(t){let s;return this._clusters.forEach((e=>{e&&e.referenceId===t&&(s=e.displayId)})),s}getAggregateValueRanges(){return this._aggregateValueRanges}forEach(t){this._clusters.forEach(((s,e)=>{s&&t(s,e)}))}size(){let t=0;return this.forEach((()=>t++)),t}_rebuildTree(){this._bitsets.computed.clear(),this._bitsets.inserted.clear(),this._tree&&this._tree.clear()}_remove(t){const s=t.getDisplayId(),e=t.getXHydrated(),i=t.getYHydrated(),r=this._geohashBuf[2*s],n=this._geohashBuf[2*s+1];this._bitsets.inserted.has(s)&&(this._bitsets.inserted.unset(s),this._tree.removeCursor(t,e,i,r,n,this._geohashLevel))}_update(t,s){const e=t.getDisplayId(),i=this._bitsets.inserted,r=s.isVisible(e);if(r===i.has(e))return;if(!r)return void this._remove(t);const n=t.getXHydrated(),h=t.getYHydrated();this._setGeohash(e,n,h)&&(this._tree.insertCursor(t,e,n,h,this._geohashBuf[2*e],this._geohashBuf[2*e+1],this._geohashLevel),i.set(e))}_setGeohash(t,s,e){if(this._bitsets.geohash.has(t))return!0;const i=this._geohashBuf;if(this._spatialReference.isWebMercator){const r=hs(s/M.radius),n=r-360*Math.floor((r+180)/360);es(i,t,hs(Math.PI/2-2*Math.atan(Math.exp(-e/M.radius))),n,12)}else{const r=mt({x:s,y:e},this._spatialReference,w.WGS84);if(!r)return!1;es(i,t,r.y,r.x,12)}return this._bitsets.geohash.set(t),!0}_getClustersForTile(t,s,r,n,h,a=!0){const o=this._schema.params.clusterPixelBuffer,c=2*r,u=this._getGeohashLevel(s.key.level),l=Math.ceil(2**s.key.level*wt/c),d=Math.ceil(o/c)+0,p=Math.ceil(wt/c),{row:f,col:y}=s.key,g=f*wt,m=Math.floor(y*wt/c)-d,w=Math.floor(g/c)-d,v=m+p+2*d,M=w+p+2*d,j=s.tileInfoView.getLODInfoAt(s.key.level);for(let r=m;r<=v;r++)for(let o=w;o<=M;o++){let c=r;j.wrap&&(c=r<0?r+l:r%l);const d=j.wrap&&r<0,p=j.wrap&&r%l!==r,f=this._lookupCluster(n,j,s.key.level,c,o,u);if(i(f)){const s=b(h,(t=>d?t.left:p?t.right:t.tile));if(a&&e(s))continue;if(!f.count)continue;if(i(s)&&a){const e=f.geometry.clone();let r=f.attributes;e.coords[0]=U(s,e.coords[0]),e.coords[1]=E(s,e.coords[1]),1===f.count&&i(f.referenceId)&&(r={...f.attributes,referenceId:f.referenceId});const n=new K(e,r);n.displayId=f.displayId,t.push(n)}}}}_getGeohashLevel(t){return Math.min(Math.ceil(t/2+2),12)}_setGeohashLevel(t){const s=this._getGeohashLevel(t),e=1*(Math.floor(s/1)+1)-1;if(this._geohashLevel!==e)return this._geohashLevel=e,this._rebuildTree(),void this._bitsets.geohash.clear()}_getTransforms(t,s){const e={originPosition:"upperLeft",scale:[t.resolution,t.resolution],translate:[t.bounds[0],t.bounds[3]]},i=v(s);if(!i)return{tile:e,left:null,right:null};const[r,n]=i.valid;return{tile:e,left:{...e,translate:[n,t.bounds[3]]},right:{...e,translate:[r-n+t.bounds[0],t.bounds[3]]}}}_getClusterId(t,s,e){return(15&t)<<28|(16383&s)<<14|16383&e}_markForDeletion(t,s,e){const i=this._getClusterId(t,s,e);this._clusters.delete(i)}_getClusterBounds(t,s,e){const i=this._schema.params.clusterRadius,r=2*i;let n=e%2?s*r:s*r-i;const h=e*r;let a=n+r;const o=2**t.level*wt;t.wrap&&n<0&&(n=0),t.wrap&&a>o&&(a=o);const c=h/wt,u=a/wt,l=(h-r)/wt;return[t.getXForColumn(n/wt),t.getYForRow(c),t.getXForColumn(u),t.getYForRow(l)]}_lookupCluster(t,s,e,r,n,h){const a=this._getClusterId(e,r,n),o=this._clusters.get(a),[c,u,l,d]=this._getClusterBounds(s,r,n),p={x:c,y:u},f={x:l,y:d};let y=0,g=0,m=0,b=0;if(this._spatialReference.isWebMercator){{const t=hs(p.x/M.radius);y=t-360*Math.floor((t+180)/360),g=hs(Math.PI/2-2*Math.atan(Math.exp(-p.y/M.radius)))}{const t=hs(f.x/M.radius);m=t-360*Math.floor((t+180)/360),b=hs(Math.PI/2-2*Math.atan(Math.exp(-f.y/M.radius)))}}else{const t=mt(p,this._spatialReference,w.WGS84),s=mt(f,this._spatialReference,w.WGS84);if(!t||!s)return null;y=t.x,g=t.y,m=s.x,b=s.y}const v={geohashX:0,geohashY:0},j={geohashX:0,geohashY:0};ss(v,g,y,h),ss(j,b,m,h);const x=v.geohashX,_=v.geohashY,q=j.geohashX,I=j.geohashY,A={xLL:x,yLL:_,xTR:q,yTR:I,level:h},S=this._tree.getRegionStatistics(x,_,q,I,h),{count:F,xTotal:k,yTotal:C,referenceId:R}=S,P=F?k/F:0,T=F?C/F:0;if(0===F)return this._clusters.set(a,null),null;const U={cluster_count:F,...S.attributes},E=i(o)?o.update(P,T,e,U,A,R):ns.create(t,a,P,T,e,U,A,R);return 0===F&&(E.geometry.coords[0]=(c+l)/2,E.geometry.coords[1]=(u+d)/2),this._clusters.set(a,E),this._updateAggregateValueRangeForCluster(E,E.tileLevel),E}_updateAggregateValueRangeForCluster(t,s){const e=this._aggregateValueRanges[s]||{minValue:1/0,maxValue:0},i=e.minValue,r=e.maxValue;e.minValue=Math.min(i,t.count),e.maxValue=Math.max(r,t.count),this._aggregateValueRanges[s]=e,i===e.minValue&&r===e.maxValue||(this._aggregateValueRangesChanged=!0)}_markTileClustersForDeletion(t,s){const e=2*s,i=Math.ceil(wt/e),{row:r,col:n}=t.key,h=r*wt,a=Math.floor(n*wt/e),o=Math.floor(h/e);for(let s=a;s<a+i;s++)for(let e=o;e<o+i;e++)this._markForDeletion(t.key.level,s,e)}}function os(t){if(!d(t)&&!function(t){return"worker:port-closed"===t.name}(t))throw t}function cs(t){return"feature"===t.type&&"snapshot"===t.mode}let us=class extends A{constructor(){super(...arguments),this._storage=new H,this._markedIdsBufId=this._storage.createBitset(),this._lastCleanup=performance.now(),this._cleanupNeeded=!1,this._invalidated=!1,this._tileToResolver=new Map,this._didEdit=!1,this.tileStore=null,this.config=null,this.processor=null,this.remoteClient=null,this.service=null}initialize(){this._initAttributeStore(),this._initStores(),this._initQueryEngine(),this._initSource(),this._updateQueue=new ut({concurrency:"geoevent"===this._source.type?1:4,process:(t,s)=>this._onTileMessage(t,{signal:s})}),this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this)),this.watch("updating",(t=>!t&&this.onIdle()))]),this._checkUpdating=setInterval((()=>this.notifyChange("updating")),300)}async startup(){this._initAttributeStore(),this.tileStore.tiles.forEach((t=>this._source.subscribe(t)))}_initSource(){this._source=function(t,s,e,i,r,n){const h=function(t,s,e,i,r,n){switch(t.type){case"snapshot":return{type:"feature",origin:"snapshot",featureCount:l(t.featureCount,0),serviceInfo:t,onMessage:i,outSR:s,tileInfoView:e,canAcceptRequest:r,store:n};case"stream":return{type:"geoevent",serviceInfo:t,onMessage:i,outSR:s,canAcceptRequest:r};case"memory":case"on-demand":return{type:"feature",serviceInfo:t,onMessage:i,outSR:s,origin:function(t){return Array.isArray(t)?"local":"path"in t&&N(t.path)?"hosted":"unknown"}(t.source),tileInfoView:e,canAcceptRequest:r}}}(t,s,e,i,r,n);switch(h.type){case"feature":switch(h.origin){case"hosted":case"local":return new Jt(h);case"snapshot":return new ts(h);case"unknown":return new Xt(h)}case"geoevent":return new $t(h)}}(this.service,this.spatialReference,this.tileStore.tileScheme,((t,s)=>(this._invalidated=!0,this._patchTile(t,s))),(()=>this._updateQueue.length<50),this.featureStore),this._proxyEvents()}_proxyEvents(){if("geoevent"===this._source.type){const t=this._source.events;this.handles.add([t.on("connectionStatus",(t=>this.remoteClient.invoke("setProperty",{propertyName:"connectionStatus",value:t}).catch(os))),t.on("errorString",(t=>this.remoteClient.invoke("setProperty",{propertyName:"errorString",value:t}).catch(os))),t.on("feature",(t=>this.remoteClient.invoke("emitEvent",{name:"data-received",event:{attributes:t.attributes,centroid:t.centroid,geometry:t.geometry}}).catch(os))),t.on("updateRate",(t=>this.remoteClient.invoke("emitEvent",{name:"update-rate",event:{...t}}).catch(os)))])}}_initAttributeStore(){this.attributeStore?this.attributeStore.invalidateResources():this.attributeStore=new J({type:"remote",initialize:(t,s)=>q(this.remoteClient.invoke("tileRenderer.featuresView.attributeView.initialize",t,{signal:s}).catch(os)),update:(t,s)=>q(this.remoteClient.invoke("tileRenderer.featuresView.attributeView.requestUpdate",t,{signal:s}).catch(os)),render:t=>q(this.remoteClient.invoke("tileRenderer.featuresView.requestRender",void 0,{signal:t}).catch(os))},this.config)}_initStores(){const t={geometryInfo:{geometryType:this.service.geometryType,hasM:!1,hasZ:!1},spatialReference:this.spatialReference,fieldsIndex:this.fieldsIndex,fields:this.service.fields};this.featureStore=new z(t,this._storage,"snapshot"===this.service.type?"snapshot":"on-demand"),this.aggregateStore=new as(t,this.spatialReference,this._storage),this.handles.add(this.aggregateStore.events.on("valueRangesChanged",(t=>{this.remoteClient.invoke("emitEvent",{name:"valueRangesChanged",event:{valueRanges:t.valueRanges}}).catch(os)})))}_initQueryEngine(){var t;const s=this;null==(t=this.queryEngine)||t.destroy(),this.queryEngine=new O({definitionExpression:this.config.definitionExpression,fields:this.service.fields,geometryType:this.service.geometryType,objectIdField:this.service.objectIdField,hasM:!1,hasZ:!1,spatialReference:this.spatialReference.toJSON(),cacheSpatialQueries:!0,featureStore:this.featureStore,aggregateAdapter:{getFeatureObjectIds:t=>s.aggregateStore.getFeatureDisplayIdsForAggregate(t).map((t=>s.getObjectId(t)))},timeInfo:this.service.timeInfo})}destroy(){this._updateQueue.destroy(),this._source.destroy(),this.queryEngine.destroy(),this.attributeStore&&this.attributeStore.destroy(),clearInterval(this._checkUpdating)}get fieldsIndex(){return new D(this.service.fields)}get hasAggregates(){return!!this.config.schema.targets.aggregate}get spatialReference(){return this.tileStore.tileScheme.spatialReference}get updating(){return this.isUpdating()}isUpdating(){return this._source.updating||!!this._updateQueue.length}enableEvent(t){this._source.enableEvent(t.name,t.value)}pause(){this._updateQueue.pause(),this._updateQueue.clear()}async update(t,s){this._set("config",s),this._schema=s.schema,this._initQueryEngine(),await Promise.all([this._source.update(t,s.schema.source),this.featureStore.updateSchema(t,s.schema.targets.feature),this.attributeStore.update(t,s),this.attributeStore.updateFilters(t,this)]),await this.aggregateStore.updateSchema(t,s.schema.targets.aggregate),r("esri-2d-update-debug")&&t.describe()}async applyUpdate(t){t.mesh&&this.clearTiles(),this._updateQueue.resume(),await this._source.applyUpdate(t),this.notifyChange("updating"),await I(this,"updating",!0),this.hasAggregates&&(await g(10),await I(this,"updating",!0))}async onEdits({edits:t}){r("esri-2d-update-debug")&&console.debug("Applying Edit:",t),this._didEdit=!0;try{const s=t.removed.map((t=>t.objectId&&-1!==t.objectId?t.objectId:this._lookupObjectIdByGlobalId(t.globalId))),e=t.addOrModified.map((({objectId:t})=>t));this.featureStore.invalidate(),await this._source.edit(e,s),this.clearTiles(),this.notifyChange("updating"),this.aggregateStore.clear(),await this._source.resend(),await I(this,"updating",!0)}catch(t){}}async refresh(){this.featureStore.invalidate(),this.clearTiles(),this._source.refresh(),this._cleanupNeeded=!0,this.notifyChange("updating"),await I(this,"updating",!0)}clearTiles(){for(const t of this.tileStore.tiles)this.processor.onTileClear(t)}onTileUpdate(t){this.aggregateStore.onTileUpdate(t);for(const s of t.added)this._source.subscribe(s),this._level=s.level;for(const s of t.removed)this._source.unsubscribe(s),this._cleanupNeeded=!0,this._tileToResolver.has(s.id)&&(this._tileToResolver.get(s.id).resolve(),this._tileToResolver.delete(s.id));this.notifyChange("updating")}onIdle(){this._invalidated&&((this.hasAggregates||"heatmap"===this.processor.type)&&this._repushCurrentLevelTiles(),this._invalidated=!1),this._markAndSweep()}async querySummaryStatistics({query:t,params:s}){return this.queryEngine.executeQueryForSummaryStatistics(t,s)}async queryUniqueValues({query:t,params:s}){return this.queryEngine.executeQueryForUniqueValues(t,s)}async queryClassBreaks({query:t,params:s}){return this.queryEngine.executeQueryForClassBreaks(t,s)}queryExtent(t){return this.queryEngine.executeQueryForExtent(t)}queryFeatures(t){return this.queryEngine.executeQuery(t)}queryFeatureCount(t){return this.queryEngine.executeQueryForCount(t)}queryLatestObservations(t){return this.queryEngine.executeQueryForLatestObservations(t)}queryObjectIds(t){return this.queryEngine.executeQueryForIds(t)}async queryStatistics(){return this.featureStore.storeStatistics}getObjectId(t){return this.featureStore.lookupObjectId(t,this._storage)}getDisplayId(t){if(this._schema.targets.aggregate){const s=this.aggregateStore.getDisplayId(t);if(e(s)){const s=this.featureStore.lookupDisplayId(t);return this.aggregateStore.getDisplayIdForReferenceId(s)}return s}return this.featureStore.lookupDisplayId(t)}getFeature(t){const s=this.featureStore.lookupFeatureByDisplayId(t,this._storage);if(e(s))return null;const i=s.readHydratedGeometry(),r=F(i,s.geometryType,s.hasZ,s.hasM);return{attributes:s.readAttributes(),geometry:r}}getAggregate(t){return this.aggregateStore.getAggregate(t)}getAggregates(){return this.aggregateStore.getAggregates()}async setHighlight(t){const s=t.map((t=>this.getDisplayId(t)));return this.attributeStore.setHighlight(t,s)}_lookupObjectIdByGlobalId(t){const s=this.service.globalIdField;if(e(s))throw new Error("Expected globalIdField to be defined");let i=null;if(this.featureStore.forEach((e=>{t===e.readAttribute(s)&&(i=e.getObjectId())})),e(i))throw new Error(`Expected to find a feature with globalId ${t}`);return i}_repushCurrentLevelTiles(){const t=this.tileStore.tiles.filter((t=>t.level===this._level));for(const s of t)this._patchTile({type:"append",id:s.key.id,addOrUpdate:$.fromOptimizedFeatures([],this.service.geometryType),remove:[],end:!0,status:Dt.empty()})}_maybeForceCleanup(){performance.now()-this._lastCleanup>5e3&&this._markAndSweep()}_patchTile(t,s){const e=this._updateQueue.push(t,s).then((()=>{this.notifyChange("updating")})).catch((()=>{this.notifyChange("updating")}));return this.notifyChange("updating"),e}async _onTileMessage(t,s){u(s);const i=this.tileStore.get(t.id);if(!i)return;if(t.clear)return this.processor.onTileClear(i);const r=t.status;this._cleanupNeeded=!0;const n=[];for(const s of t.remove){const t=this.featureStore.lookupDisplayId(s);t&&n.push(t)}t.remove=n;try{if(e(t.addOrUpdate))return void this.processor.onTileMessage(i,{...t,addOrUpdate:null},this.hasAggregates,s).catch(f);if(t.addOrUpdate.setArcadeSpatialReference(this.spatialReference),this.featureStore.hasInstance(t.addOrUpdate.instance)&&r.targets.feature||(r.targets.feature=!0,this.featureStore.onTileData(i,t)),r.storage.data&&r.storage.filters||(r.storage.data=!0,r.storage.filters=!0,this.attributeStore.onTileData(i,t),"geoevent"===this._source.type||this._didEdit?(await this.attributeStore.sendUpdates(),u(s)):this.attributeStore.sendUpdates()),this.hasAggregates&&!r.targets.aggregate){r.targets.aggregate=!0;const s=cs(this._source)&&this._source.loading,e=!cs(this._source)||s||t.end;if(this.aggregateStore.onTileData(i,t,this._storage,this.attributeStore,e),!e)return;r.mesh||(this.attributeStore.onTileData(i,t),await this.attributeStore.sendUpdates(),this.processor.onTileClear(i))}r.mesh||(r.mesh=!0,await this.processor.onTileMessage(i,t,this.hasAggregates,s),u(s)),this._maybeForceCleanup()}catch(t){f(t)}}_mark(t,s,e){const i=(4294901760&this._storage.getInstanceId(t))>>>16;t&&(s.add(i),e.set(t))}_markAndSweep(){if(this._lastCleanup=performance.now(),"feature"===this._source.type&&"snapshot"===this._source.mode||"geoevent"!==this._source.type&&!this._cleanupNeeded)return;this._cleanupNeeded=!1;const t=this._storage.getBitset(this._markedIdsBufId),s=new Set;t.clear();for(const e of this.tileStore.tiles)for(const i of this._source.readers(e.id)){const e=i.getCursor();for(;e.next();){let i=e.getDisplayId();if(!i){const t=e.getObjectId();i=this.featureStore.lookupDisplayId(t)}this._mark(i,s,t)}}"symbol"===this.processor.type&&this.processor.forEachBufferId((e=>{this._mark(e,s,t)})),this._updateQueue.forEach((e=>{for(const i of e.remove){const e=this.featureStore.lookupDisplayId(i);this._mark(e,s,t)}})),this.config.schema.targets.aggregate&&(this.aggregateStore.sweepFeatures(t,this.featureStore),this.aggregateStore.sweepClusters(this._storage,this.attributeStore,this._level)),this.featureStore.sweepFeatures(t,this._storage,this.attributeStore),this.featureStore.sweepFeatureSets(s)}};j([x({constructOnly:!0})],us.prototype,"tileStore",void 0),j([x()],us.prototype,"config",void 0),j([x({readOnly:!0})],us.prototype,"fieldsIndex",null),j([x()],us.prototype,"processor",void 0),j([x({constructOnly:!0})],us.prototype,"remoteClient",void 0),j([x({constructOnly:!0})],us.prototype,"service",void 0),j([x()],us.prototype,"spatialReference",null),j([x()],us.prototype,"updating",null),us=j([_("esri.views.2d.layers.features.controllers.FeatureController2D")],us);const ls=us,ds=new Set;function ps(){return ds}let fs=class extends A{constructor(){super(...arguments),this.controller=null,this.processor=null,this.remoteClient=null,this.tileStore=null,this.service=null,this.viewState=null}initialize(){this.handles.add(this.watch("updating",(t=>{this.remoteClient.invoke("setUpdating",t).catch((()=>{}))})))}destroy(){var t,s,e;null==(t=this.controller)||t.destroy(),null==(s=this.processor)||s.destroy(),null==(e=this.tileStore)||e.destroy(),this.controller=this.processor=this.tileStore=this.remoteClient=null}get updating(){return!this.controller||this.controller.updating}async startup({service:t,config:s,tileInfo:e,tiles:i}){if(this.service=t,!this.tileStore){const t=new dt(S.fromJSON(e));this.tileStore=new pt(t)}this.tileStore.clear(),await this._createProcessorAndController(s),await this.update({config:s},!0),this.tileStore.updateTiles(i)}async updateTiles(t){this.tileStore.updateTiles(t)}async update({config:t},s=!1){const e=Dt.empty();return s||this.controller.pause(),await Promise.all([this.processor.update(e,t),this.controller.update(e,t)]),e.toJSON()}async applyUpdate(t){return this.controller.applyUpdate(Dt.create(t))}async _createProcessorAndController(t){await Promise.all([this._handleControllerConfig(t),this._handleProcessorConfig(t)]),this.controller.processor=this.processor}async _handleControllerConfig(t){const s=await this._createController(this.service,t);return await s.startup(),s}async _handleProcessorConfig(t){return this._createProcessor(this.service,t)}async _createController(t,s){this.controller&&this.controller.destroy();const{tileStore:e,remoteClient:i}=this,r=new ls({service:t,config:s,tileStore:e,remoteClient:i});return this.controller=r,r}async _createProcessor(t,s){const e=s.schema.processors[0].type,i=(await function(t){return"heatmap"===t?import("./p-e0641b2c.js"):import("./p-f2b55f98.js")}(e)).default,{remoteClient:r,tileStore:n}=this,h=new i({service:t,config:s,tileStore:n,remoteClient:r});return this.processor&&this.processor.destroy(),this.processor=h,h}};j([x()],fs.prototype,"controller",void 0),j([x()],fs.prototype,"processor",void 0),j([x()],fs.prototype,"updating",null),j([x()],fs.prototype,"viewState",void 0),fs=j([_("esri.views.2d.layers.features.Pipeline")],fs);const ys=fs;export default ys;export{ps as getInstances}