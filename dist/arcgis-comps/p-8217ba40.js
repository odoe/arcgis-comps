import{u as t,m as s,i,T as r,c as e,h,l as n,a as u,p as c,b as o,x as f,y as a,o as w,d as l,g as p,j as v,V as m,q as y,A as g,L as A,B as d}from"./p-1aa417b4.js";import{e as F}from"./p-ef33ca3e.js";class U{constructor(t,s){this.layout=t,this.buffer="number"==typeof s?new ArrayBuffer(s*t.stride):s;for(const s of t.fieldNames){const i=t.fields.get(s);this[s]=new i.constructor(this.buffer,i.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,s){const i=this[t];return i&&i.elementCount===s.ElementCount&&i.elementType===s.ElementType?i:null}slice(t,s){return new U(this.layout,this.buffer.slice(t*this.stride,s*this.stride))}copyFrom(t,s,i,r){const e=this.stride;if(e%4==0){const h=new Uint32Array(t.buffer,s*e,r*e/4);new Uint32Array(this.buffer,i*e,r*e/4).set(h)}else{const h=new Uint8Array(t.buffer,s*e,r*e);new Uint8Array(this.buffer,i*e,r*e).set(h)}}}class b{constructor(){this.stride=0,this.fields=new Map,this.fieldNames=[]}vec2f(s,i){return this.appendField(s,t,i),this}vec2f64(t,i){return this.appendField(t,s,i),this}vec3f(t,s){return this.appendField(t,i,s),this}vec3f64(t,s){return this.appendField(t,r,s),this}vec4f(t,s){return this.appendField(t,e,s),this}vec4f64(t,s){return this.appendField(t,h,s),this}mat3f(t,s){return this.appendField(t,n,s),this}mat3f64(t,s){return this.appendField(t,u,s),this}mat4f(t,s){return this.appendField(t,c,s),this}mat4f64(t,s){return this.appendField(t,o,s),this}vec4u8(t,s){return this.appendField(t,f,s),this}f32(t,s){return this.appendField(t,a,s),this}f64(t,s){return this.appendField(t,w,s),this}u8(t,s){return this.appendField(t,l,s),this}u16(t,s){return this.appendField(t,p,s),this}i8(t,s){return this.appendField(t,v,s),this}vec2i8(t,s){return this.appendField(t,m,s),this}vec2i16(t,s){return this.appendField(t,y,s),this}vec2u8(t,s){return this.appendField(t,g,s),this}vec4u16(t,s){return this.appendField(t,A,s),this}u32(t,s){return this.appendField(t,d,s),this}appendField(t,s,i){const r=s.ElementCount*F(s.ElementType);this.fields.set(t,{size:r,constructor:s,offset:this.stride,optional:i}),this.stride+=r,this.fieldNames.push(t)}alignTo(t){return this.stride=Math.floor((this.stride+t-1)/t)*t,this}hasField(t){return this.fieldNames.indexOf(t)>=0}createBuffer(t){return new U(this,t)}createView(t){return new U(this,t)}clone(){const t=new b;return t.stride=this.stride,t.fields=new Map,this.fields.forEach(((s,i)=>t.fields.set(i,s))),t.fieldNames=this.fieldNames.slice(),t.BufferType=this.BufferType,t}}function M(){return new b}export{M as A}