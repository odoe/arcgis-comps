import{W as t,al as r}from"./p-c8bc3433.js";import{h as e}from"./p-e9338c35.js";import{_ as n}from"./p-43c6911a.js";import"./p-84bf99cb.js";import"./p-2794293b.js";import"./p-01158f1c.js";import"./p-b13a6689.js";import"./p-595bf8a5.js";import"./p-fa930cf8.js";class o{async createIndex(r,n){const o=new Array;if(!r.vertexAttributes||!r.vertexAttributes.position)return new e;const a=this.createMeshData(r),s=t(n)?await n.invoke("createIndexThread",a,{transferList:o}):this.createIndexThread(a).result;return this.createPooledRBush().fromJSON(s)}createIndexThread(t){const r=new Float64Array(t.position),e=this.createPooledRBush();return t.components?this.createIndexComponentsThread(e,r,t.components.map((t=>new Uint32Array(t)))):this.createIndexAllThread(e,r)}createIndexAllThread(t,r){const e=new Array(r.length/9);let n=0;for(let t=0;t<r.length;t+=9)e[n++]=a(r,t+0,t+3,t+6);return t.load(e),{result:t.toJSON()}}createIndexComponentsThread(t,r,e){let n=0;for(const t of e)n+=t.length/3;const o=new Array(n);let s=0;for(const t of e)for(let e=0;e<t.length;e+=3)o[s++]=a(r,3*t[e+0],3*t[e+1],3*t[e+2]);return t.load(o),{result:t.toJSON()}}createMeshData(t){const r=(t.transform?n({position:t.vertexAttributes.position,normal:null,tangent:null},t.transform,t.spatialReference).position:t.vertexAttributes.position).buffer;return!t.components||t.components.some((t=>!t.faces))?{position:r}:{position:r,components:t.components.map((t=>t.faces))}}createPooledRBush(){return new e(9,r("esri-csp-restrictions")?t=>t:[".minX",".minY",".maxX",".maxY"])}}function a(t,r,e,n){return{minX:Math.min(t[r+0],t[e+0],t[n+0]),maxX:Math.max(t[r+0],t[e+0],t[n+0]),minY:Math.min(t[r+1],t[e+1],t[n+1]),maxY:Math.max(t[r+1],t[e+1],t[n+1]),p0:[t[r+0],t[r+1],t[r+2]],p1:[t[e+0],t[e+1],t[e+2]],p2:[t[n+0],t[n+1],t[n+2]]}}export default o;export{o as ElevationSamplerWorker}