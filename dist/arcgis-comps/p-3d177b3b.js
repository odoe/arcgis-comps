import{e as t,d as i,i as s,p as o,bm as e}from"./p-9ae46e68.js";import{M as r,a9 as n}from"./p-566b0715.js";import{u as a}from"./p-81e5b36e.js";import{j as h}from"./p-523f37cd.js";import{g as p}from"./p-fe4caffe.js";import{h as c}from"./p-1f10277d.js";import{e as f}from"./p-2b250922.js";const l=Math.PI/180;function u(t){return t*l}const d=a(),m=[0,0],M=new f(0,0,0,0);let g=class extends o{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=false,this.imageMaxWidth=2048,this.imageMaxHeight=2048,this.imageRotationSupported=false,this.imageNormalizationSupported=false,this.update=e((async(t,i)=>{if(!t.stationary||this.destroyed)return null;const s=t.state,o=n(s.spatialReference),e=this.hidpi?t.pixelRatio:1,r=this.imageNormalizationSupported&&s.worldScreenWidth&&s.worldScreenWidth<s.size[0];r?(m[0]=s.worldScreenWidth,m[1]=s.size[1]):this.imageRotationSupported?(m[0]=s.size[0],m[1]=s.size[1]):function(t,i){const s=u(i.rotation),o=Math.abs(Math.cos(s)),e=Math.abs(Math.sin(s)),[r,n]=i.size;t[0]=Math.round(n*e+r*o),t[1]=Math.round(n*o+r*e)}(m,s);const a=Math.floor(m[0]*e)>this.imageMaxWidth||Math.floor(m[1]*e)>this.imageMaxHeight,h=!this.imageNormalizationSupported&&o&&(s.extent.xmin<o.valid[0]||s.extent.xmax>o.valid[1]),p=this.imageRotationSupported?s.rotation:0;if(a||h){let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);h&&(t=Math.min(s.worldScreenWidth,t)),this._imagePromise=this._tiledExport(s,t,p,e,i)}else this._imagePromise=this._singleExport(s,m,r?s.paddedViewState.center:s.center,s.resolution,p,e,i);return this._imagePromise.then((async t=>{if(this._imagePromise=null,!this.destroyed){this.bitmaps=null!=t?t:[];for(const i of this.container.children)t.includes(i)||i.fadeOut().then((()=>{i.remove()}));for(const i of t)this.container.addChild(i),i.fadeIn()}})).catch((t=>{throw this._imagePromise=null,t}))}),5e3)}destroy(){this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}updateExports(t){for(const i of this.container.children){if(!i.visible||!i.stage)return;t(i),i.invalidateTexture(),i.requestRender()}}async _export(t,i,s,o,e,r){const n=await this.fetchSource(t,Math.floor(i*e),Math.floor(s*e),{rotation:o,pixelRatio:e,signal:r}),a=new p(n,"additive");return a.x=t.xmin,a.y=t.ymax,a.resolution=t.width/i,a.rotation=o,a.pixelRatio=e,a}async _singleExport(t,i,s,o,e,n,a){!function(t,i,s,o){const[e,r]=i,[n,a]=o,h=.5*s;t[0]=e-h*n,t[1]=r-h*a,t[2]=e+h*n,t[3]=r+h*a}(d,s,o,i);const h=new r(d[0],d[1],d[2],d[3],t.spatialReference);return[await this._export(h,i[0],i[1],e,n,a)]}_tiledExport(t,i,s,o,e){const n=h.create({size:i,spatialReference:t.spatialReference,scales:[t.scale]}),a=new c(n),p=a.getTileCoverage(t);if(!p)return null;const f=[];return p.forEach(((n,h,p,c)=>{M.set(n,h,p,c),a.getTileBounds(d,M);const l=new r(d[0],d[1],d[2],d[3],t.spatialReference);f.push(this._export(l,i,i,s,o,e))})),Promise.all(f)}};t([i()],g.prototype,"_imagePromise",void 0),t([i()],g.prototype,"bitmaps",void 0),t([i()],g.prototype,"container",void 0),t([i()],g.prototype,"fetchSource",void 0),t([i()],g.prototype,"hidpi",void 0),t([i()],g.prototype,"imageMaxWidth",void 0),t([i()],g.prototype,"imageMaxHeight",void 0),t([i()],g.prototype,"imageRotationSupported",void 0),t([i()],g.prototype,"imageNormalizationSupported",void 0),t([i()],g.prototype,"requestUpdate",void 0),t([i()],g.prototype,"updating",null),g=t([s("esri.views.2d.layers.support.ExportStrategy")],g);const v=g;export{v as S}