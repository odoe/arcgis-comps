import{b as t,bO as e,fL as s,f2 as i,dR as r,a,T as n,eB as o,fN as l,r as p,eI as u,eX as c,E as h,c6 as d,eU as f,eW as y,ha as m}from"./p-5420851c.js";import{m as g}from"./p-e11b9b52.js";import{f as j,g as b}from"./p-6df976c7.js";import{V as w}from"./p-21acbbae.js";import{T as I,L as F,O as T}from"./p-5e9a6603.js";import{i as R,n as S,u as E}from"./p-3bb1fb67.js";import{y as _,d as v,c as O,u as D,h as x}from"./p-35f1020d.js";import"./p-53bb6ab4.js";import"./p-ff251557.js";import"./p-c3fd4463.js";import"./p-50ff864e.js";import"./p-c0f8009d.js";import"./p-06d309e6.js";import"./p-8bf8e457.js";import"./p-c3449e4f.js";import"./p-0a5ba773.js";import"./p-03389806.js";const Q={hasAttachments:!1,capabilities:"query, editing, create, delete, update",useStandardizedQueries:!0,supportsCoordinatesQuantization:!0,supportsReturningQueryGeometry:!0,advancedQueryCapabilities:{supportsQueryAttachments:!1,supportsStatistics:!0,supportsPercentileStatistics:!0,supportsReturningGeometryCentroid:!0,supportsQueryWithDistance:!0,supportsDistinct:!0,supportsReturningQueryExtent:!0,supportsReturningGeometryProperties:!1,supportsHavingClause:!0,supportsOrderBy:!0,supportsPagination:!0,supportsQueryWithResultType:!1,supportsSqlExpression:!0,supportsDisjointSpatialRel:!0}};export default class{constructor(){this._queryEngine=null,this._snapshotFeatures=async t=>{const e=await this._fetch(t);return this._createFeatures(e)}}destroy(){var t;null==(t=this._queryEngine)||t.destroy(),this._queryEngine=this._fieldsIndex=this._createDefaultAttributes=null}async load(r,a={}){this.loadOptions={url:r.url,customParameters:r.customParameters};const n=[];await this._checkProjection(r.spatialReference);let o=null;r.url&&(o=await this._fetch(null==a?void 0:a.signal));const p=I(o,{geometryType:r.geometryType}),u=r.fields||p.fields||[],c=null!=r.hasZ?r.hasZ:p.hasZ,h=p.geometryType,d=r.objectIdField||p.objectIdFieldName||"__OBJECTID",f=r.spatialReference||l;let y=r.timeInfo;u===p.fields&&p.unknownFields.length>0&&n.push({name:"geojson-layer:unknown-field-types",message:"Some fields types couldn't be inferred from the features and were dropped",details:{unknownFields:p.unknownFields}});let m=u.find((t=>t.name===d));m?("esriFieldTypeString"!==m.type&&(m.type="esriFieldTypeOID"),m.editable=!1,m.nullable=!1):(m={alias:d,name:d,type:"string"===p.objectIdFieldType?"esriFieldTypeString":"esriFieldTypeOID",editable:!1,nullable:!1},u.unshift(m));const j={};for(const i of u){if(null==i.name&&(i.name=i.alias),null==i.alias&&(i.alias=i.name),!i.name)throw new t("geojson-layer:invalid-field-name","field name is missing",{field:i});if(!e.jsonValues.includes(i.type))throw new t("geojson-layer:invalid-field-type",`invalid type for field "${i.name}"`,{field:i});if(i.name!==m.name){const t=s(i);void 0!==t&&(j[i.name]=t)}}if(this._fieldsIndex=new i(u),y){if(y.startTimeField){const t=this._fieldsIndex.get(y.startTimeField);t?(y.startTimeField=t.name,t.type="esriFieldTypeDate"):y.startTimeField=null}if(y.endTimeField){const t=this._fieldsIndex.get(y.endTimeField);t?(y.endTimeField=t.name,t.type="esriFieldTypeDate"):y.endTimeField=null}if(y.trackIdField){const t=this._fieldsIndex.get(y.trackIdField);t?y.trackIdField=t.name:(y.trackIdField=null,n.push({name:"geojson-layer:invalid-timeInfo-trackIdField",message:"trackIdField is missing",details:{timeInfo:y}}))}y.startTimeField||y.endTimeField||(n.push({name:"geojson-layer:invalid-timeInfo",message:"startTimeField and endTimeField are missing",details:{timeInfo:y}}),y=null)}const b=h?E(h):null,F={warnings:n,featureErrors:[],layerDefinition:{...Q,drawingInfo:b,templates:R(j),extent:null,geometryType:h,objectIdField:d,fields:u,hasZ:!!c,timeInfo:y}};this._queryEngine=new w({fields:u,geometryType:h,hasM:!1,hasZ:c,objectIdField:d,spatialReference:f,timeInfo:y,featureStore:new g({geometryType:h,hasM:!1,hasZ:c}),cacheSpatialQueries:!0}),this._createDefaultAttributes=S(j,d);const T=await this._createFeatures(o);this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,T);const _=this._normalizeFeatures(T,F.warnings,F.featureErrors);if(this._queryEngine.featureStore.addMany(_),F.layerDefinition.extent=this._queryEngine.fullExtent,F.layerDefinition.timeInfo){const{start:t,end:e}=this._queryEngine.timeExtent;F.layerDefinition.timeInfo.timeExtent=[t,e]}return F}async applyEdits(t){const{spatialReference:e,geometryType:s}=this._queryEngine;return await Promise.all([_(e,s),j(t.adds,e),j(t.updates,e)]),await this._waitSnapshotComplete(),this._applyEdits(t)}async queryFeatures(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(t,e.signal)}async queryFeatureCount(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(t,e.signal)}async queryObjectIds(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(t,e.signal)}async queryExtent(t={},e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(t,e.signal)}async querySnapping(t,e={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(t,e.signal)}async refresh(e){var s;return this.loadOptions.customParameters=e,null==(s=this._snapshotTask)||s.abort(),this._snapshotTask=r(this._snapshotFeatures),this._snapshotTask.promise.then((t=>{this._queryEngine.featureStore.clear(),this._objectIdGenerator=this._createObjectIdGenerator(this._queryEngine,t);const e=this._normalizeFeatures(t);e&&this._queryEngine.featureStore.addMany(e)}),(e=>{this._queryEngine.featureStore.clear(),a(e)||n.getLogger("esri.layers.GeoJSONLayer").error(new t("geojson-layer:refresh","An error occurred during refresh",{error:e}))})),await this._waitSnapshotComplete(),{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent}}async _createFeatures(t){const{geometryType:e,hasZ:s,objectIdField:i}=this._queryEngine,r=F(t,{geometryType:e,hasZ:s,objectIdField:i});if(!o(this._queryEngine.spatialReference,l))for(const t of r)p(t.geometry)&&(t.geometry=u(b(c(t.geometry,this._queryEngine.geometryType,this._queryEngine.hasZ,!1),l,this._queryEngine.spatialReference)));return r}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _fetch(t){const{url:e,customParameters:s}=this.loadOptions,i=(await h(e,{responseType:"json",query:{...s},signal:t})).data;return await T(i),i}_normalizeFeatures(t,e,s){const{objectIdField:i}=this._queryEngine,r=[];for(const a of t){const t=this._createDefaultAttributes(),n=v(this._fieldsIndex,t,a.attributes,!0,e);n?null==s||s.push(n):(this._assignObjectId(t,a.attributes,!0),a.attributes=t,a.objectId=t[i],r.push(a))}return r}_applyEdits(t){const{adds:e,updates:s,deletes:i}=t,r={addResults:[],deleteResults:[],updateResults:[],uidToObjectId:{}};if(e&&e.length&&this._applyAddEdits(r,e),s&&s.length&&this._applyUpdateEdits(r,s),i&&i.length){for(const t of i)r.deleteResults.push(O(t));this._queryEngine.featureStore.removeManyById(i)}return{extent:this._queryEngine.fullExtent,timeExtent:this._queryEngine.timeExtent,featureEditResults:r}}_applyAddEdits(t,e){const{addResults:s}=t,{geometryType:i,hasM:r,hasZ:a,objectIdField:n,spatialReference:o,featureStore:l}=this._queryEngine,u=[];for(const r of e){if(r.geometry&&i!==d(r.geometry)){s.push(D("Incorrect geometry type."));continue}const e=this._createDefaultAttributes(),a=v(this._fieldsIndex,e,r.attributes);a?s.push(a):(this._assignObjectId(e,r.attributes),r.attributes=e,null!=r.uid&&(t.uidToObjectId[r.uid]=r.attributes[n]),p(r.geometry)&&(r.geometry=b(x(r.geometry,o),r.geometry.spatialReference,o)),u.push(r),s.push(O(r.attributes[n])))}l.addMany(f([],u,i,a,r,n))}_applyUpdateEdits({updateResults:t},e){const{geometryType:s,hasM:i,hasZ:r,objectIdField:a,spatialReference:n,featureStore:o}=this._queryEngine;for(const l of e){const{attributes:e,geometry:u}=l,c=e&&e[a];if(null==c){t.push(D(`Identifier field ${a} missing`));continue}if(!o.has(c)){t.push(D(`Feature with object id ${c} missing`));continue}const h=y(o.getFeature(c),s,r,i);if(p(u)){if(s!==d(u)){t.push(D("Incorrect geometry type."));continue}h.geometry=b(x(u,n),u.spatialReference,n)}if(e){const s=v(this._fieldsIndex,h.attributes,e);if(s){t.push(s);continue}}o.add(m(h,s,r,i,a)),t.push(O(c))}}_createObjectIdGenerator(t,e){const s=t.fieldsIndex.get(t.objectIdField);if("esriFieldTypeString"===s.type)return()=>s.name+"-"+Date.now().toString(16);let i=Number.NEGATIVE_INFINITY;for(const t of e)t.objectId&&(i=Math.max(i,t.objectId));return i=Math.max(0,i)+1,()=>i++}_assignObjectId(t,e,s=!1){const i=this._queryEngine.objectIdField;t[i]=s&&i in e?e[i]:this._objectIdGenerator()}async _checkProjection(e){try{await j(l,e)}catch{throw new t("geojson-layer","Projection not supported")}}}