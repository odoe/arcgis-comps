import{e as r,d as e,ac as a,aL as s,bq as t,aa as i,aj as n,i as l,a6 as o,ep as u,W as c,bp as p,ad as d,N as y,af as f,d_ as v,H as B,ai as m}from"./p-7b6f6c18.js";import{a as P,u as g,d as A,b,p as h,o as S}from"./p-5f9ac9e7.js";import"./p-227a5838.js";import"./p-d23e08f2.js";function j(r){return r.features.map((e=>{const a=d.fromJSON(r.spatialReference),s=n.fromJSON(e);return y(s.geometry).spatialReference=a,s}))}function k(r){return u(r.features.map((e=>(c(e.geometry)&&(e.geometry.spatialReference=r.spatialReference),p(e.geometry)))))}let w=class extends o{constructor(r){super(r),this.facilities=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.serviceAreaPolylines=null,this.serviceAreaPolygons=null}readFacilities(r){return k(r)}readPointBarriers(r,e){return k(e.barriers)}readPolylineBarriers(r){return k(r)}readPolygonBarriers(r){return k(r)}readIncidents(r,e){return j(e.saPolylines)}readServiceAreaPolygons(r,e){return j(e.saPolygons)}};r([e({type:[a]})],w.prototype,"facilities",void 0),r([s("facilities")],w.prototype,"readFacilities",null),r([e({type:[P]})],w.prototype,"messages",void 0),r([e({type:[a]})],w.prototype,"pointBarriers",void 0),r([s("pointBarriers",["barriers"])],w.prototype,"readPointBarriers",null),r([e({type:[t]})],w.prototype,"polylineBarriers",void 0),r([s("polylineBarriers")],w.prototype,"readPolylineBarriers",null),r([e({type:[i]})],w.prototype,"polygonBarriers",void 0),r([s("polygonBarriers")],w.prototype,"readPolygonBarriers",null),r([e({type:[n]})],w.prototype,"serviceAreaPolylines",void 0),r([s("serviceAreaPolylines",["saPolylines"])],w.prototype,"readIncidents",null),r([e({type:[n]})],w.prototype,"serviceAreaPolygons",void 0),r([s("serviceAreaPolygons",["saPolygons"])],w.prototype,"readServiceAreaPolygons",null),w=r([l("esri.rest.support.ServiceAreaSolveResult")],w);const x=w,N=S({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,defaultBreaks:!0,facilities:!0,outSpatialReference:{name:"outSR",getter:r=>r.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},returnPointBarriers:{name:"returnBarriers"},travelMode:!0});let R=class extends m{constructor(r){super(r),this.url=null}solve(r,e){return async function(r,e,a){const s=[],t=[],i={},n={},l=f(r),{path:o}=l;e.facilities&&e.facilities.features&&g(e.facilities.features,t,"facilities.features",i),e.pointBarriers&&e.pointBarriers.features&&g(e.pointBarriers.features,t,"pointBarriers.features",i),e.polylineBarriers&&e.polylineBarriers.features&&g(e.polylineBarriers.features,t,"polylineBarriers.features",i),e.polygonBarriers&&e.polygonBarriers.features&&g(e.polygonBarriers.features,t,"polygonBarriers.features",i);const u=await v(t);for(const r in i){const e=i[r];s.push(r),n[r]=u.slice(e[0],e[1])}if(A(n,s)){let r=null;try{r=await b(o,e.apiKey,a)}catch{}r&&!r.hasZ&&h(n,s)}for(const r in n)n[r].forEach(((a,s)=>{e.get(r)[s].geometry=a}));const c={...a,query:{...l.query,...N.toQueryParams(e),f:"json"}},{data:p}=await B(`${o}/solveServiceArea`,c);return x.fromJSON(p)}(this.url,r,e)}};r([e()],R.prototype,"url",void 0),R=r([l("esri.tasks.ServiceAreaTask")],R);const q=R;export default q;