import{O as t,e,i as r}from"./p-9ae46e68.js";import{f as s,u as a,d as i,b as o,p,o as n}from"./p-38c85cb2.js";import{v as m}from"./p-8031c809.js";import{e as c}from"./p-41655335.js";import{l as u}from"./p-a7080451.js";import"./p-84bf99cb.js";import"./p-fe01b82b.js";import"./p-566b0715.js";import"./p-98a14d68.js";import"./p-8e03c038.js";import"./p-32462343.js";import"./p-ec378dda.js";const l=n({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,directionsTimeAttribute:{name:"directionsTimeAttributeName"},impedanceAttribute:{name:"impedanceAttributeName"},outSpatialReference:{name:"outSR",getter:t=>t.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},stops:!0,travelMode:!0});let f=class extends u{constructor(t){super(t)}solve(e,r){return async function(e,r,n){const u=[],f=[],b={},j={},d=c(e),{path:A}=d;r.stops&&r.stops.features&&a(r.stops.features,f,"stops.features",b),r.pointBarriers&&r.pointBarriers.features&&a(r.pointBarriers.features,f,"pointBarriers.features",b),r.polylineBarriers&&r.polylineBarriers.features&&a(r.polylineBarriers.features,f,"polylineBarriers.features",b),r.polygonBarriers&&r.polygonBarriers.features&&a(r.polygonBarriers.features,f,"polygonBarriers.features",b);const y=await m(f);for(const t in b){const e=b[t];u.push(t),j[t]=y.slice(e[0],e[1])}if(i(j,u)){let t=null;try{t=await o(A,r.apiKey,n)}catch{}t&&!t.hasZ&&p(j,u)}for(const t in j)j[t].forEach(((e,s)=>{r.get(t)[s].geometry=e}));const B={...n,query:{...d.query,...l.toQueryParams(r),f:"json"}},v=A.endsWith("/solve")?A:`${A}/solve`,N=await t(v,B);return s(N)}(this.url,e,r)}};f=e([r("esri.tasks.RouteTask")],f);const b=f;export default b;