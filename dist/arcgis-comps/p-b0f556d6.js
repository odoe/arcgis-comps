import{v as t,e,d as s,i as r,E as i,aI as n}from"./p-9ae46e68.js";import{z as o}from"./p-566b0715.js";import{b as a}from"./p-8e6daf54.js";function d(t){return t&&"group"===t.type}function l(t,e,s){let r,i;if(t)for(let n=0,o=t.length;n<o;n++){if(r=t.getItemAt(n),r[e]===s)return r;if(d(r)&&(i=l(r.layers,e,s),i))return i}}const h=t.getLogger("esri.support.LayersMixin"),u=t=>{let d=class extends t{constructor(...t){super(...t),this.layers=new i;const e=t=>{t.parent=this,this.layerAdded(t),"elevation"!==t.type&&"base-elevation"!==t.type||h.error(`Layer 'title:${t.title}, id:${t.id}' of type '${t.type}' is not supported as an operational layer and will therefore be ignored.`)},s=t=>{t.parent=null,this.layerRemoved(t)};this.layers.on("before-add",(t=>(t=>{t.parent&&"remove"in t.parent&&t.parent.remove(t)})(t.item))),this.layers.on("after-add",(t=>e(t.item))),this.layers.on("after-remove",(t=>s(t.item)))}destroy(){const t=this.layers.removeAll();for(const e of t)this.layerRemoved(e),e.destroy();this.layers.destroy()}set layers(t){this._set("layers",o(t,this._get("layers")))}add(t,e){const s=this.layers;if(e=s.getNextIndex(e),t instanceof a){const r=t;r.parent===this?this.reorder(r,e):s.add(r,e)}else n(t)?t.then((t=>{this.destroyed||this.add(t,e)})):h.error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(t,e){const s=this.layers;e=s.getNextIndex(e),t.slice().forEach((t=>{t.parent!==this?(s.add(t,e),e+=1):this.reorder(t,e)}))}findLayerById(t){return l(this.layers,"id",t)}findLayerByUid(t){return l(this.layers,"uid",t)}remove(t){return this.layers.remove(t)}removeMany(t){return this.layers.removeMany(t)}removeAll(){return this.layers.removeAll()}reorder(t,e){return this.layers.reorder(t,e)}layerAdded(t){}layerRemoved(t){}};return e([s()],d.prototype,"layers",null),d=e([r("esri.support.LayersMixin")],d),d},f="esri.support.TablesMixin",p=t.getLogger(f);function y(t){return t&&"group"===t.type}function c(t,e,s){if(t)for(let r=0,i=t.length;r<i;r++){const i=t.getItemAt(r);if(i[e]===s)return i;if(y(i)){const t=c(i.tables,e,s);if(t)return t}}}const b=t=>{let n=class extends t{constructor(...t){super(...t),this.tables=new i,this.tables.on("after-add",(t=>{const e=t.item;e.parent&&e.parent!==this&&"tables"in e.parent&&e.parent.tables.remove(e),e.parent=this,"feature"!==e.type&&p.error(`Layer 'title:${e.title}, id:${e.id}' of type '${e.type}' is not supported as a table and will therefore be ignored.`)})),this.tables.on("after-remove",(t=>{t.item.parent=null}))}destroy(){const t=this.tables.removeAll();for(const e of t)e.destroy();this.tables.destroy()}set tables(t){this._set("tables",o(t,this._get("tables")))}findTableById(t){return c(this.tables,"id",t)}findTableByUid(t){return c(this.tables,"uid",t)}};return e([s()],n.prototype,"tables",null),n=e([r(f)],n),n};export{b as c,u as p}