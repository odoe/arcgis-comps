import{e,d as n,i as r,a6 as t,aR as s,aL as i,aO as o,ac as f,a8 as l}from"./p-7b6f6c18.js";let a=class extends t{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};e([n()],a.prototype,"affectsPixelSize",null),e([n({json:{write:!0}})],a.prototype,"spatialReference",void 0),a=e([r("esri.layers.support.rasterTransforms.BaseRasterTransform")],a);const c=a;let u=class extends c{constructor(){super(...arguments),this.type="identity"}};e([s({IdentityXform:"identity"})],u.prototype,"type",void 0),u=e([r("esri.layers.support.rasterTransforms.IdentityTransform")],u);const y=u;function d(e,n,r){const{x:t,y:s}=n;if(r<2)return{x:e[0]+t*e[2]+s*e[4],y:e[1]+t*e[3]+s*e[5]};if(2===r){const n=t*t,r=s*s,i=t*s;return{x:e[0]+t*e[2]+s*e[4]+n*e[6]+i*e[8]+r*e[10],y:e[1]+t*e[3]+s*e[5]+n*e[7]+i*e[9]+r*e[11]}}const i=t*t,o=s*s,f=t*s,l=i*t,a=i*s,c=t*o,u=s*o;return{x:e[0]+t*e[2]+s*e[4]+i*e[6]+f*e[8]+o*e[10]+l*e[12]+a*e[14]+c*e[16]+u*e[18],y:e[1]+t*e[3]+s*e[5]+i*e[7]+f*e[9]+o*e[11]+l*e[13]+a*e[15]+c*e[17]+u*e[19]}}function m(e,n,r){const{xmin:t,ymin:s,xmax:i,ymax:o,spatialReference:f}=n;let a=[];if(r<2)a.push({x:t,y:o}),a.push({x:i,y:o}),a.push({x:t,y:s}),a.push({x:i,y:s});else{let e=10;for(let n=0;n<e;n++)a.push({x:t,y:s+(o-s)*n/(e-1)}),a.push({x:i,y:s+(o-s)*n/(e-1)});e=8;for(let n=1;n<=e;n++)a.push({x:t+(i-t)*n/e,y:s}),a.push({x:t+(i-t)*n/e,y:o})}a=a.map((n=>d(e,n,r)));const c=a.map((e=>e.x)),u=a.map((e=>e.y));return new l({xmin:Math.min.apply(null,c),xmax:Math.max.apply(null,c),ymin:Math.min.apply(null,u),ymax:Math.max.apply(null,u),spatialReference:f})}let x=class extends c{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,n){const{coeffX:r,coeffY:t}=n;if(null==r||!r.length||null==t||!t.length||r.length!==t.length)return null;const s=[];for(let e=0;e<r.length;e++)s.push(r[e]),s.push(t[e]);return s}writeForwardCoefficients(e,n,r){const t=[],s=[];for(let n=0;n<(null==e?void 0:e.length);n++)n%2==0?t.push(e[n]):s.push(e[n]);n.coeffX=t,n.coeffY=s}get inverseCoefficients(){let e=this._get("inverseCoefficients");const n=this._get("forwardCoefficients");return!e&&n&&this.polynomialOrder<2&&(e=function(e){const[n,r,t,s,i,o]=e,f=t*o-i*s,l=i*s-t*o;return[(i*r-n*o)/f,(t*r-n*s)/l,o/f,s/l,-i/f,-t/l]}(n)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,n){const{inverseCoeffX:r,inverseCoeffY:t}=n;if(null==r||!r.length||null==t||!t.length||r.length!==t.length)return null;const s=[];for(let e=0;e<r.length;e++)s.push(r[e]),s.push(t[e]);return s}writeInverseCoefficients(e,n,r){const t=[],s=[];for(let n=0;n<(null==e?void 0:e.length);n++)n%2==0?t.push(e[n]):s.push(e[n]);n.inverseCoeffX=t,n.inverseCoeffY=s}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const n=d(this.forwardCoefficients,e,this.polynomialOrder);return new f({x:n.x,y:n.y,spatialReference:e.spatialReference})}return m(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const n=d(this.inverseCoefficients,e,this.polynomialOrder);return new f({x:n.x,y:n.y,spatialReference:e.spatialReference})}return m(this.inverseCoefficients,e,this.polynomialOrder)}};e([n({json:{write:!0}})],x.prototype,"polynomialOrder",void 0),e([n()],x.prototype,"forwardCoefficients",void 0),e([i("forwardCoefficients",["coeffX","coeffY"])],x.prototype,"readForwardCoefficients",null),e([o("forwardCoefficients")],x.prototype,"writeForwardCoefficients",null),e([n({json:{write:!0}})],x.prototype,"inverseCoefficients",null),e([i("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],x.prototype,"readInverseCoefficients",null),e([o("inverseCoefficients")],x.prototype,"writeInverseCoefficients",null),e([n()],x.prototype,"affectsPixelSize",null),e([s({PolynomialXform:"polynomial"})],x.prototype,"type",void 0),x=e([r("esri.layers.support.rasterTransforms.PolynomialTransform")],x);const v=x,p={PolynomialXform:v,IdentityXform:y},C=Object.keys(p);function w(e){return!e||C.includes(null==e?void 0:e.type)}function h(e){if(!(null==e?void 0:e.type))return null;const n=p[null==e?void 0:e.type];if(n){const r=new n;return r.read(e),r}return null}export{c as a,w as e,h as l,v as m}