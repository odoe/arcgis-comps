import{t,ba as s}from"./p-9ae46e68.js";import{k as e}from"./p-566b0715.js";import{y as i}from"./p-8e03c038.js";import{m as r,n}from"./p-4003c7ae.js";import{t as o}from"./p-3d1b25b6.js";import{t as h}from"./p-3048cc18.js";import"./p-84bf99cb.js";import"./p-fe01b82b.js";import"./p-32462343.js";import"./p-b2d0e2de.js";import"./p-db87794e.js";import"./p-c7a0a732.js";class a{constructor(t,s,e){this.uid=t,this.geometry=s,this.attributes=e,this.visible=!0,this.objectId=null,this.centroid=null}}class l{constructor(){this.exceededTransferLimit=!1,this.features=[],this.fields=[],this.hasM=!1,this.hasZ=!1,this.geometryType=null,this.objectIdFieldName=null,this.globalIdFieldName=null,this.geometryProperties=null,this.geohashFieldName=null,this.spatialReference=null,this.transform=null}}function c(t,s){return s}function u(t,s,e,i){switch(e){case 0:return m(t,s+i,0);case 1:return"lowerLeft"===t.originPosition?m(t,s+i,1):function({translate:t,scale:s},e,i){return t[i]-e*s[i]}(t,s+i,1)}}function p(t,s,e,i){return 2===e?m(t,s,2):u(t,s,e,i)}function y(t,s,e,i){return 2===e?m(t,s,3):u(t,s,e,i)}function f(t,s,e,i){return 3===e?m(t,s,3):p(t,s,e,i)}function m({translate:t,scale:s},e,i){return t[i]+e*s[i]}class d{constructor(t){this.options=t,this.geometryTypes=["point","multipoint","polyline","polygon"],this.previousCoordinate=[0,0],this.transform=null,this.applyTransform=c,this.lengths=[],this.currentLengthIndex=0,this.toAddInCurrentPath=0,this.vertexDimension=0,this.coordinateBuffer=null,this.coordinateBufferPtr=0,this.AttributesConstructor=function(){}}createFeatureResult(){return new l}finishFeatureResult(s){if(this.options.applyTransform&&(s.transform=null),this.AttributesConstructor=function(){},this.coordinateBuffer=null,this.lengths.length=0,!s.hasZ)return;const e=o(s.geometryType,this.options.sourceSpatialReference,s.spatialReference);if(!t(e))for(const t of s.features)e(t.geometry)}createSpatialReference(){return new e}addField(t,s){t.fields.push(i.fromJSON(s));const e=t.fields.map((t=>t.name));this.AttributesConstructor=function(){for(const t of e)this[t]=null}}addFeature(t,s){const e=this.options.maxStringAttributeLength?this.options.maxStringAttributeLength:0;if(e>0)for(const t in s.attributes){const i=s.attributes[t];"string"==typeof i&&i.length>e&&(s.attributes[t]="")}t.features.push(s)}addQueryGeometry(t,s){const{queryGeometry:e,queryGeometryType:i}=s,o=r(e.clone(),e,!1,!1,this.transform),h=n(o,i,!1,!1);let a=null;switch(i){case"esriGeometryPoint":a="point";break;case"esriGeometryPolygon":a="polygon";break;case"esriGeometryPolyline":a="polyline";break;case"esriGeometryMultipoint":a="multipoint"}h.type=a,t.queryGeometryType=i,t.queryGeometry=h}prepareFeatures(t){switch(this.transform=t.transform,this.options.applyTransform&&t.transform&&(this.applyTransform=this.deriveApplyTransform(t)),this.vertexDimension=2,t.hasZ&&this.vertexDimension++,t.hasM&&this.vertexDimension++,t.geometryType){case"point":this.addCoordinate=(t,s,e)=>this.addCoordinatePoint(t,s,e),this.createGeometry=t=>this.createPointGeometry(t);break;case"polygon":this.addCoordinate=(t,s,e)=>this.addCoordinatePolygon(t,s,e),this.createGeometry=t=>this.createPolygonGeometry(t);break;case"polyline":this.addCoordinate=(t,s,e)=>this.addCoordinatePolyline(t,s,e),this.createGeometry=t=>this.createPolylineGeometry(t);break;case"multipoint":this.addCoordinate=(t,s,e)=>this.addCoordinateMultipoint(t,s,e),this.createGeometry=t=>this.createMultipointGeometry(t)}}createFeature(){return this.lengths.length=0,this.currentLengthIndex=0,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0,new a(s(),null,new this.AttributesConstructor)}allocateCoordinates(){const t=this.lengths.reduce(((t,s)=>t+s),0);this.coordinateBuffer=new Float64Array(t*this.vertexDimension),this.coordinateBufferPtr=0}addLength(t,s,e){0===this.lengths.length&&(this.toAddInCurrentPath=s),this.lengths.push(s)}createPointGeometry(t){const s={type:"point",x:0,y:0,spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM};return s.hasZ&&(s.z=0),s.hasM&&(s.m=0),s}addCoordinatePoint(t,s,e){switch(s=this.applyTransform(this.transform,s,e,0),e){case 0:t.x=s;break;case 1:t.y=s;break;case 2:t.hasZ?t.z=s:t.m=s;break;case 3:t.m=s}}transformPathLikeValue(t,s){let e=0;return s<=1&&(e=this.previousCoordinate[s],this.previousCoordinate[s]+=t),this.applyTransform(this.transform,t,s,e)}addCoordinatePolyline(t,s,e){this.dehydratedAddPointsCoordinate(t.paths,s,e)}addCoordinatePolygon(t,s,e){this.dehydratedAddPointsCoordinate(t.rings,s,e)}addCoordinateMultipoint(t,s,e){0===e&&t.points.push([]);const i=this.transformPathLikeValue(s,e);t.points[t.points.length-1].push(i)}createPolygonGeometry(t){return{type:"polygon",rings:[[]],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}createPolylineGeometry(t){return{type:"polyline",paths:[[]],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}createMultipointGeometry(t){return{type:"multipoint",points:[],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}dehydratedAddPointsCoordinate(t,s,e){0===e&&0==this.toAddInCurrentPath--&&(t.push([]),this.toAddInCurrentPath=this.lengths[++this.currentLengthIndex]-1,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0);const i=this.transformPathLikeValue(s,e);0===e&&t[t.length-1].push(new Float64Array(this.coordinateBuffer.buffer,this.coordinateBufferPtr*Float64Array.BYTES_PER_ELEMENT,this.vertexDimension)),this.coordinateBuffer[this.coordinateBufferPtr++]=i}deriveApplyTransform(t){const{hasZ:s,hasM:e}=t;return s&&e?f:s?p:e?y:u}}class b{_parseFeatureQuery(t){const s=h(t.buffer,new d(t.options)),e={...s,spatialReference:s.spatialReference.toJSON(),fields:s.fields?s.fields.map((t=>t.toJSON())):void 0};return Promise.resolve(e)}}function w(){return new b}export default w;