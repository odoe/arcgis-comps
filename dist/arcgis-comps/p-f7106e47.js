import{A as t,af as s,K as i,p as e,h as n,a0 as r,aj as o,b as h,e as c,d as a,i as l,bw as u}from"./p-e58503d5.js";import{N as f,z as d,a as p,n as m}from"./p-1a7268a2.js";import{a as w}from"./p-7731c620.js";import{u as y,c as g}from"./p-fb38a9d0.js";import{u as v,w as x,k as _,e as b,s as M,l as j}from"./p-ea916a39.js";import{e as B,g as A,u as D}from"./p-b79fcce3.js";import{v as F,c as C,y as T,f as P,s as z,l as I}from"./p-c048b814.js";import{u as U}from"./p-eec31d91.js";import{f as L,g as S}from"./p-e49308c6.js";import{O as G,j as R,N as O}from"./p-0edb3309.js";import{P as V}from"./p-47e1bd73.js";import{B as k,k as E,U as q,K as H,q as K,j as N,I as X,E as Y,C as Q,r as Z,t as J}from"./p-e3500fdc.js";import{f as W,h as $,a as tt}from"./p-19bc1e3d.js";import"./p-0bb84768.js";import{f as st,i as it,o as et}from"./p-db566ae7.js";import{a as nt,o as rt,E as ot,l as ht,b as ct}from"./p-c232e25f.js";import{h as at,p as lt,u as ut,y as ft,_ as dt,z as pt,d as mt,c as wt,g as yt}from"./p-c5443b47.js";import{d as gt,u as vt,P as xt}from"./p-cd36fe2a.js";import{X as _t,$ as bt,f as Mt,i as jt,U as Bt}from"./p-5032dfbd.js";import{A as At}from"./p-c0f84cd3.js";import{i as Dt}from"./p-75cd09f2.js";import{a as Ft,U as Ct}from"./p-c1cd5521.js";import{O as Tt,U as Pt}from"./p-4019eec3.js";import{t as zt}from"./p-182bb5be.js";import{l as It}from"./p-8acbca5b.js";import{t as Ut}from"./p-7a68337e.js";import{o as Lt}from"./p-db4d63dc.js";import{r as St,i as Gt,M as Rt,f as Ot,h as Vt}from"./p-b9aa4901.js";import{C as kt}from"./p-6484267b.js";import{t as Et}from"./p-56ed1c7a.js";import{t as qt}from"./p-c2152437.js";import{a as Ht}from"./p-1c2ff3a7.js";class Kt{constructor(){this._dirties=[{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1},{vertexFrom:-1,vertexCount:-1,indexFrom:-1,indexCount:-1,allDirty:!1}]}hasDirty(){return this._dirties.some((t=>-1!==t.indexCount||t.allDirty))}markAllClean(){for(const t of this._dirties)t.indexFrom=-1,t.indexCount=-1,t.vertexFrom=-1,t.vertexCount=-1,t.allDirty=!1}markAllDirty(){for(const t of this._dirties)t.allDirty=!0}forEach(t){for(let s=0;s<this._dirties.length;++s){const{indexCount:i,indexFrom:e,vertexCount:n,vertexFrom:r,allDirty:o}=this._dirties[s],h={};let c,a=!1;(o||-1!==r&&n>0)&&(h.geometry={count:n,from:r,allDirty:o},a=!0),(o||-1!==e&&i>0)&&(c={count:i,from:e,allDirty:o},a=!0),a&&t({indices:c,vertices:h},s)}}markDirtyIndices(t,s,i){const e=this._dirties[t],n=s,r=i;if(!e.allDirty)if(-1!==e.indexCount){const t=Math.min(e.indexFrom,n),s=Math.max(e.indexFrom+e.indexCount,n+r)-t;e.indexFrom=t,e.indexCount=s}else e.indexFrom=n,e.indexCount=r}markDirtyVertices(t,s,i,e){const n=this._dirties[t],r=i,o=e;if(!n.allDirty)if(-1!==n.vertexCount){const t=Math.min(n.vertexFrom,r),s=Math.max(n.vertexFrom+n.vertexCount,r+o)-t;n.vertexFrom=t,n.vertexCount=s}else n.vertexFrom=r,n.vertexCount=o}}class Nt{constructor(t){this._largestRange=null,this._parent=t,this._updateLargestRange()}get largestRange(){return this._largestRange}rangeCreated(t){(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}rangeResized(t,s){t===this._largestRange?t.count<s&&this._updateLargestRange():(!this._largestRange||t.count>this._largestRange.count)&&(this._largestRange=t)}findBestRange(t){let s=this._parent._freeHead,i=null;for(;null!==s;)s.count>=t&&(!i||s.count-t<i.count-t)&&(i=s),s=s.next;return i}findAdjacentRanges(t,s){let i=!0,e=!1,n=null,r=this._parent._freeHead;for(;i&&!e;){const o=null!==r?r.from:this._parent._size;t>=(null!==n?n.from+n.count:0)&&t+s<=o?(i=!1,e=!0):null!==r?(n=r,r=r.next):i=!1}return[n,r]}_updateLargestRange(){let t=null,s=this._parent._freeHead;for(;null!==s;)(!t||s.count>t.count)&&(t=s),s=s.next;this._largestRange=t}}class Xt{constructor(t,s){this._allocated=0,this._size=t,this._freeHead=t>0?{from:0,count:t,prev:null,next:null}:null,this._bookKeeper=s||new Nt(this),this._freeHead&&this._bookKeeper.rangeCreated(this._freeHead)}allocate(t){const s=this._bookKeeper.findBestRange(t);if(null===s)return-1;const i=s.from,e=s.count;if(s.from+=t,s.count-=t,this._bookKeeper.rangeResized(s,i,e),this._allocated+=t,0===s.count){const t=null!==s.prev?this._freeHead:s.next;Xt._removeRange(s),this._freeHead=t}return i}free(t,s){const[i,e]=this._bookKeeper.findAdjacentRanges(t,s),n={from:t,count:s,prev:i,next:e};if(null!==i&&(i.next=n),null!==e&&(e.prev=n),this._bookKeeper.rangeCreated(n),this._allocated-=s,null!==e&&n.from+n.count===e.from){const t=n.from,s=n.count;Xt._fuse(n,e),Xt._removeRange(e),this._bookKeeper.rangeResized(n,t,s),this._bookKeeper.rangeResized(e,void 0,0)}if(null!==i&&i.from+i.count===n.from){const t=i.from,s=i.count;Xt._fuse(i,n),Xt._removeRange(n),this._bookKeeper.rangeResized(i,t,s),this._bookKeeper.rangeResized(n,void 0,0)}this._freeHead=null!==n.prev?this._freeHead:n}get fragmentation(){const t=this._size-this._allocated;return 0===t?0:1-this._bookKeeper.largestRange.count/t}static _removeRange(t){null!==t.prev?null!==t.next?(t.prev.next=t.next,t.next.prev=t.prev):t.prev.next=null:null!==t.next&&(t.next.prev=null)}static _fuse(t,s){t.count+=s.count,t.next=s.next,s.from+=s.count,s.count=0,null!==s.next&&(s.next.prev=t)}}const Yt=["FILL","LINE","MARKER","TEXT","LABEL"];class Qt{constructor(t,s,i,e){this._strides=t,this._displayList=s,this._freeListsAndStorage={},this._dirtyMap=null,this._dirtyMap=i;for(const s in t){this._freeListsAndStorage[s]={vtxFreeList:e?new Xt(e):null,idxFreeList:e?new Xt(e):null,vertexBuffers:{},indexBuffer:e?new Uint32Array(e):null};for(const i in t[s])this._freeListsAndStorage[s].vertexBuffers[i]={data:e?k(e,t[s][i]):null,stride:t[s][i]}}}static fromTileData(t,s){const i=function(t){const s=t.getStrides(),i={};for(let t=0;t<s.length;t++)i[Yt[t]]=s[t];return i}(t),e=[0,0,0,0,0],n=[0,0,0,0,0],r=t.tileDisplayData.displayObjects;for(const t of r)for(const s of t.displayRecords)e[s.geometryType]=Math.max(e[s.geometryType],s.vertexFrom+s.vertexCount),n[s.geometryType]=Math.max(n[s.geometryType],s.indexFrom+s.indexCount);const o=new Qt(i,t.tileDisplayData.displayList,s,null);for(let s=0;s<t.tileBufferData.geometries.length;++s){const i=e[s],r=n[s],h=t.tileBufferData.geometries[s],c=o._storageFor(Yt[s]),a=t.tileBufferData.geometries[s].indexBuffer;let l;c.indexBuffer=a,c.idxFreeList=new Xt(a.length),c.idxFreeList.allocate(r);for(const i in h.vertexBuffer){const e=t.tileBufferData.geometries[s].vertexBuffer[i];c.vertexBuffers[i].data=e.data,c.vertexBuffers[i].stride=e.stride;const n=q(e.stride),r=e.data.length*n/e.stride;l||(l=r)}c.vtxFreeList=new Xt(l),c.vtxFreeList.allocate(i)}return o}delete(t){const s=Yt[t.geometryType];this._freeVertices(s,t.vertexFrom,t.vertexCount),this._freeIndices(s,t.indexFrom,t.indexCount),this._displayList.removeFromList(t),t.vertexFrom=void 0,t.indexFrom=void 0}setMeshData(t,s,i,e,n){const r=Yt[t.geometryType];let o,h;t.meshData=null,void 0===t.vertexFrom?(h=s.vertexCount,o=this._allocateVertices(r,h)):s.vertexCount>t.vertexCount?(this._freeVertices(r,t.vertexFrom,t.vertexCount),h=s.vertexCount,o=this._allocateVertices(r,h)):s.vertexCount===t.vertexCount?(o=t.vertexFrom,h=t.vertexCount):(this._freeVertices(r,t.vertexFrom+s.vertexCount,t.vertexCount-s.vertexCount),o=t.vertexFrom,h=s.vertexCount);let c,a,l,u=!0;if(void 0===t.indexFrom?(c=n,l=s.indexCount,a=this._allocateIndices(r,l)):s.indexCount>t.indexCount?(c=this._displayList.removeFromList(t),this._freeIndices(r,t.indexFrom,t.indexCount),l=s.indexCount,a=this._allocateIndices(r,l)):s.indexCount===t.indexCount?(u=!1,a=t.indexFrom,l=t.indexCount):(c=this._displayList.removeFromList(t),this._freeIndices(r,t.indexFrom+s.indexCount,t.indexCount-s.indexCount),a=t.indexFrom,l=s.indexCount),-1!==o&&-1!==a){const n=this._storageFor(r);if(E(o,a,n.vertexBuffers,n.indexBuffer,s,i,e),t.vertexFrom=o,t.indexFrom=a,t.vertexCount=s.vertexCount,t.indexCount=s.indexCount,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const s in i)this._dirtyMap.markDirtyVertices(t.geometryType,s,t.vertexFrom,t.vertexCount)}return u&&this._displayList.addToList(t,c),!0}return-1!==o&&this._freeVertices(r,o,h),-1!==a&&this._freeIndices(r,a,l),t.setMeshDataFromBuffers(s,i,e),t.vertexFrom=void 0,t.vertexCount=0,t.indexFrom=void 0,t.indexCount=0,!1}tryAddMeshData(t,s){const i=s.vertexBuffer,e=s.indexBuffer,n=Yt[t.geometryType],r=this._allocateVertices(n,t.vertexCount);if(-1===r)return this._freeVertices(n,r,t.vertexCount),!1;const o=this._allocateIndices(n,t.indexCount);if(-1===o)return this._freeVertices(n,r,t.vertexCount),this._freeIndices(n,o,t.indexCount),!1;const h=this._storageFor(n);if(E(r,o,h.vertexBuffers,h.indexBuffer,t,i,e),t.vertexFrom=r,t.indexFrom=o,this._dirtyMap){this._dirtyMap.markDirtyIndices(t.geometryType,t.indexFrom,t.indexCount);for(const s in i)this._dirtyMap.markDirtyVertices(t.geometryType,s,r,t.vertexCount)}return this._displayList.addToList(t),!0}_allocateVertices(t,s){const i=this._storageFor(t),e=i.vtxFreeList.allocate(s);return-1===e||i.vtxFreeList.fragmentation>.5?-1:e}_freeVertices(t,s,i){this._storageFor(t).vtxFreeList.free(s,i)}_freeIndices(t,s,i){this._storageFor(t).idxFreeList.free(s,i)}_allocateIndices(t,s){const i=this._storageFor(t),e=i.idxFreeList.allocate(s);return-1===e||i.idxFreeList.fragmentation>.5?-1:e}_storageFor(t){return this._freeListsAndStorage[t]}_stridesFor(t,s){return this._strides[t][s]}}class Zt{constructor(t){this.geometryMap=H((()=>({indexBuffer:$.createIndex(t,35044),vao:null})),((s,i)=>({vertexBuffer:$.createVertex(t,K[i])})))}dispose(){for(let t=0;t<5;t++){const s=this.geometryMap[t];if(s){s.data.vao&&s.data.vao.dispose(!1),s.data.indexBuffer&&s.data.indexBuffer.dispose();for(const t in s.buffers)s.buffers[t]&&s.buffers[t].data.vertexBuffer.dispose()}}}get(t){const s=this.geometryMap[t];return{draw(t,i,e,n,r){if(!s.data.vao){const n={};for(const t in s.buffers)n[t]=s.buffers[t].data.vertexBuffer;s.data.vao=new W(t,e,i,n,s.data.indexBuffer)}t.bindVAO(s.data.vao),t.drawElements(4,r,5125,Uint32Array.BYTES_PER_ELEMENT*n),t.bindVAO(null)}}}has(t){return null!=this.geometryMap[t]}upload(t,s){s.forEach(((s,i)=>{this._upload(s,i,t)}))}_upload(t,s,i){if(t.indices&&(t.indices.allDirty?this._uploadIndices(i,s):null!=t.indices.from&&null!=t.indices.count&&this._uploadIndices(i,s,t.indices.from,t.indices.count)),t.vertices){const e=t.vertices;for(const t in e){const n=e[t];n.allDirty?this._uploadVertices(i,s,t):null!=n.from&&null!=n.count&&this._uploadVertices(i,s,t,n.from,n.count)}}}_uploadVertices(t,s,i,e,n){const r=this.geometryMap[s];if(!r)return;const o=t.geometries[s].vertexBuffer[i];if(!o)return;const h=o.stride,c=o.data.buffer;r.buffers[i]&&c.byteLength>0&&(null!=e&&null!=n?r.buffers[i].data.vertexBuffer.setSubData(c,e*h,e*h,(e+n)*h):r.buffers[i].data.vertexBuffer.setData(c))}_uploadIndices(t,s,i,e){const n=this.geometryMap[s];if(!n)return;const r=t.geometries[s].indexBuffer.buffer;n.data.indexBuffer&&r.byteLength>0&&(null!=i&&null!=e?n.data.indexBuffer.setSubData(r,4*i,4*i,4*(i+e)):n.data.indexBuffer.setData(r))}}class Jt extends st{constructor(){super(...arguments),this._data=null,this._displayList=null,this._lastCommitTime=0,this._hasData=!1,this._invalidated=!1,this._wglBuffers=null,this._dirtyMap=new Kt}destroy(){super.destroy(),this.clear()}get hasData(){return!!this._hasData}get displayObjects(){var t;return null!=(t=this._displayObjects)?t:[]}getGeometry(t){return this._wglBuffers&&this._wglBuffers.has(t)?this._wglBuffers.get(t):null}getDisplayList(){return this._displayList}patch(t){if(!0===t.clear)return this.clear(),void(this._hasData=!1);const s=t.addOrUpdate,i=t.remove;!this._data&&s&&s.tileDisplayData.displayObjects.length?(s.tileDisplayData.computeDisplayList(),this._dirtyMap=new Kt,this._dispRecStore=Qt.fromTileData(s,this._dirtyMap),this._data=s,this._dirtyMap.markAllDirty(),this._hasData=!0,t.end&&this.ready()):this._data&&(s&&s.tileDisplayData.displayObjects.length||i.length)?this._doPatchData(t):t.end&&this.ready(),t.end&&!this._data&&this.clear(),this.requestRender(),this.emit("change")}commit(t){t.time&&t.time===this._lastCommitTime||(this._lastCommitTime=t.time,this.visible&&this._data&&(this._wglBuffers||(this._wglBuffers=new Zt(t.context)),(this._dirtyMap.hasDirty()||this._invalidated)&&(this._invalidated=!1,this._wglBuffers.upload(this._data.tileBufferData,this._dirtyMap),this._displayList=this._data.tileDisplayData.displayList.clone(),this._displayObjects=this._data.tileDisplayData.displayObjects.slice(),this._dirtyMap.markAllClean())))}clear(){this._data=null,this._displayList=null,this._dispRecStore=null,this._wglBuffers&&(this._wglBuffers.dispose(),this._wglBuffers=null)}_doPatchData(t){this._invalidated=!0,this._patchData(t)||(this._dirtyMap.markAllDirty(),this._data.reshuffle(),this._dispRecStore=Qt.fromTileData(this._data,this._dirtyMap)),this.requestRender()}_patchData(t){let s=!0;const i=t.addOrUpdate&&t.addOrUpdate.tileDisplayData&&t.addOrUpdate.tileDisplayData.displayObjects||[],e=(t.remove||[]).slice();for(const t of i)null!=t.insertAfter&&e.push(t.id);for(const t of e){const s=this._data.tileDisplayData.displayObjectRegistry.get(t);if(s){this._data.tileDisplayData.displayList.removeFromList(s.displayRecords);for(const t of s.displayRecords)this._dispRecStore.delete(t);this._data.tileDisplayData.displayObjectRegistry.delete(t);const i=this._data.tileDisplayData.displayObjects.indexOf(s);this._data.tileDisplayData.displayObjects.splice(i,1)}}for(const e of i){let i,n=this._data.tileDisplayData.displayObjectRegistry.get(e.id);if(n){const t=n.displayRecords;n.set(e),n.displayRecords=t;const s=n.displayRecords.length;for(let t=0;t<s;++t){const s=n.displayRecords[t],i=e.displayRecords[t];(t>=e.displayRecords.length||s.geometryType!==i.geometryType||s.symbolLevel!==i.symbolLevel||s.zOrder!==i.zOrder||s.materialKey!==i.materialKey)&&(this._dispRecStore.delete(n.displayRecords[t]),t<e.displayRecords.length&&(n.displayRecords[t]=void 0))}n.displayRecords.length=e.displayRecords.length}else{let t;n=e.copy(),n.displayRecords=[],this._data.tileDisplayData.displayObjectRegistry.set(e.id,n);const s=this._data.tileDisplayData.displayObjects;if(null!=n.insertAfter)if(i={},n.insertAfter>=0){const i=this._data.tileDisplayData.displayObjectRegistry.get(n.insertAfter);i?(t=s.indexOf(i)+1,t<s.length?s.splice(t,0,n):(s.push(n),t=s.length)):(s.push(n),t=s.length)}else s.unshift(n),t=0;else s.push(n),t=s.length;if(i){const n=e.displayRecords.length>0?1:0;let r=0;for(let e=t-1;e>=0&&r<n;--e)for(let t=s[e].displayRecords.length-1;t>=0&&r<n;--t){const n=s[e].displayRecords[t],o=this._data.tileDisplayData.displayList.getDPInfoType();i[o]||(i[o]=n,++r)}}}const r=e.displayRecords.length;for(let o=0;o<r;++o){const r=e.displayRecords[o];let h=n.displayRecords[o];h?(h.meshData=r.meshData,h.materialKey=r.materialKey):(h=r.copy(),h.vertexFrom=void 0,h.indexFrom=void 0,n.displayRecords[o]=h);const c=r.geometryType,a=this._data.tileDisplayData.displayList.getDPInfoType(),l=t.addOrUpdate.tileBufferData.geometries[c],u=l.vertexBuffer,f=l.indexBuffer;let d;i&&(d=i[a]?this._data.tileDisplayData.displayList.splitAfter(i[a]):-1),s=this._dispRecStore.setMeshData(h,r,u,f,d)&&s,i&&null!=h.indexFrom&&null!=h.indexFrom&&(i[a]=h)}}return s}}class Wt{constructor(){this._byGeometryType=null}get satisfied(){return!this._byGeometryType}reset(){this._byGeometryType=null}verticesFor(t){return this._byGeometryType?this._byGeometryType[t].vertices:0}indicesFor(t){return this._byGeometryType?this._byGeometryType[t].indices:0}needMore(t,s,i){if(!s&&!i)return;this._byGeometryType||(this._byGeometryType=[{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0},{vertices:0,indices:0}]);const e=this._byGeometryType[t];e.vertices+=s,e.indices+=i}}class $t{constructor(){this.geometries=[{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}},{indexBuffer:void 0,vertexBuffer:{}}]}clone(){const t=new $t;for(let s=0;s<this.geometries.length;s++){const i=this.geometries[s],e=t.geometries[s];e.indexBuffer=i.indexBuffer.slice(),e.vertexBuffer={};for(const t in i.vertexBuffer){const{data:s,stride:n}=i.vertexBuffer[t];e.vertexBuffer[t]={data:s.slice(),stride:n}}}return t}static deserialize(t){const s=new $t;for(let i=0;i<5;++i){s.geometries[i].indexBuffer=new Uint32Array(t.geometries[i].indexBuffer),s.geometries[i].vertexBuffer={};for(const e in t.geometries[i].vertexBuffer)s.geometries[i].vertexBuffer[e]={data:N(t.geometries[i].vertexBuffer[e].data,t.geometries[i].vertexBuffer[e].stride),stride:t.geometries[i].vertexBuffer[e].stride}}return s}serialize(){const t={geometries:[{indexBuffer:this.geometries[0].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[1].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[2].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[3].indexBuffer.buffer,vertexBuffer:{}},{indexBuffer:this.geometries[4].indexBuffer.buffer,vertexBuffer:{}}]};for(let s=0;s<5;++s)for(const i in this.geometries[s].vertexBuffer)t.geometries[s].vertexBuffer[i]={data:this.geometries[s].vertexBuffer[i].data.buffer,stride:this.geometries[s].vertexBuffer[i].stride};return t}getBuffers(){const t=[];for(let s=0;s<5;++s){t.push(this.geometries[s].indexBuffer.buffer);for(const i in this.geometries[s].vertexBuffer)t.push(this.geometries[s].vertexBuffer[i].data.buffer)}return t}}function ts(t,s,i,...e){s<t.length?t.splice(s,i,...e):t.push(...e)}const ss=new Map;ss.set(X.MAP,[Y.FILL,Y.LINE,Y.MARKER,Y.TEXT]),ss.set(X.LABEL,[Y.LABEL]),ss.set(X.LABEL_ALPHA,[Y.LABEL]);class is{constructor(){this.symbolLevels=[]}replay(t,s,i){for(const e of this.symbolLevels)for(const n of e.zLevels){const e=n.geometryDPInfo.unified;if(e)for(const n of e){const e=t.painter.getGeometryBrush(n.geometryType),r=s.getGeometry(n.geometryType),o={geometryType:n.geometryType,materialKey:n.materialKey,indexFrom:n.indexFrom,indexCount:n.indexCount,draw:(t,s,i)=>{r.draw(t,s,i,n.indexFrom,n.indexCount)}};e.prepareState(t,s),e.drawGeometry(t,s,o,i)}}}get empty(){return!this.symbolLevels||0===this.symbolLevels.length}clear(){this.symbolLevels.length=0}addToList(t,s){if(Array.isArray(t))for(const i of t)this._addToList(i,s);else this._addToList(t,s)}removeFromList(t){Array.isArray(t)||(t=[t]);let s=null;for(const i of t)s=this._removeFromList(i);return s}clone(){const t=new is;for(const s of this.symbolLevels)t.symbolLevels.push(s.clone());return t}splitAfter(t){const s=this._getDisplayList(t.symbolLevel,t.zOrder),i=s.length,e=t.indexFrom+t.indexCount;for(let n=0;n<i;++n){const i=s[n];if(i.geometryType===t.geometryType&&e>i.indexFrom&&e<=i.indexFrom+i.indexCount){if(e<i.indexFrom+i.indexCount){const t=new es;t.geometryType=i.geometryType,t.materialKey=i.materialKey,t.indexFrom=e,t.indexCount=i.indexFrom+i.indexCount-e,s.splice(n+1,0,t),i.indexCount=e-i.indexFrom}return n}}}_addToList(t,s){const i=this._getDisplayList(t.symbolLevel,t.zOrder),e=null!=s?s:i.length-1,n=e>=0&&e<i.length?i[e]:null;if(null!==n&&n.materialKey===t.materialKey&&n.indexFrom+n.indexCount===t.indexFrom&&n.geometryType===t.geometryType)n.indexCount+=t.indexCount;else{const s=new es;s.indexFrom=t.indexFrom,s.indexCount=t.indexCount,s.materialKey=t.materialKey,s.geometryType=t.geometryType,ts(i,e+1,0,s)}}_removeFromList(t){const s=this._getDisplayList(t.symbolLevel,t.zOrder),i=s.length;let e;for(let n=0;n<i;++n){const i=s[n];if(t.indexFrom+t.indexCount>i.indexFrom&&t.indexFrom<i.indexFrom+i.indexCount&&i.geometryType===t.geometryType){e=n;break}}if(void 0!==e){const i=s[e];if(t.indexFrom===i.indexFrom)return i.indexCount-=t.indexCount,i.indexFrom+=t.indexCount,0===i.indexCount&&ts(s,e,1),e-1;if(t.indexFrom+t.indexCount===i.indexFrom+i.indexCount)return i.indexCount-=t.indexCount,0===i.indexCount?(ts(s,e,1),e-1):e;{const n=i.indexFrom,r=t.indexFrom-i.indexFrom,o=t.indexCount,h=i.indexFrom+i.indexCount-(t.indexFrom+t.indexCount);i.indexCount=r;const c=new es;return c.geometryType=i.geometryType,c.materialKey=i.materialKey,c.indexFrom=n+r+o,c.indexCount=h,ts(s,e+1,0,c),e}}return null}_getDisplayList(t,s){let i;const e=this.symbolLevels.length;for(let s=0;s<e;s++)if(this.symbolLevels[s].symbolLevel===t){i=this.symbolLevels[s];break}let n;i||(i=new os,i.symbolLevel=t,this.symbolLevels.push(i));const r=i.zLevels.length;for(let t=0;t<r;t++)if(i.zLevels[t].zLevel===s){n=i.zLevels[t];break}return n||(n=new rs,n.geometryDPInfo=new ns,n.zLevel=s,i.zLevels.push(n)),n.geometryDPInfo.unified||(n.geometryDPInfo.unified=[]),n.geometryDPInfo.unified}getDPInfoType(){return"unified"}}class es{constructor(){this.materialKey=null,this.indexFrom=0,this.indexCount=0}clone(){const t=new es;return t.geometryType=this.geometryType,t.materialKey=this.materialKey,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t}}class ns{constructor(){this.fill=null,this.line=null,this.marker=null,this.text=null,this.label=null,this.unified=null}clone(){const t=new ns;return t.fill=this.fill&&this.fill.map((t=>t.clone())),t.line=this.line&&this.line.map((t=>t.clone())),t.marker=this.marker&&this.marker.map((t=>t.clone())),t.text=this.text&&this.text.map((t=>t.clone())),t.label=this.label&&this.label.map((t=>t.clone())),t.unified=this.unified&&this.unified.map((t=>t.clone())),t}}class rs{constructor(){this.geometryDPInfo=new ns}clone(){const t=new rs;return t.zLevel=this.zLevel,t.geometryDPInfo=this.geometryDPInfo.clone(),t}}class os{constructor(){this.zLevels=[]}clone(){const t=new os;t.symbolLevel=this.symbolLevel;for(const s of this.zLevels)t.zLevels.push(s.clone());return t}}class hs{constructor(){this.vertexData=new Map,this.vertexCount=0,this.indexData=[]}clear(){this.vertexData.clear(),this.vertexCount=0,this.indexData=[]}update(t,s,i){for(const s in t)this.vertexData.set(s,t[s]);for(const s in this.vertexData)null===t[s]&&this.vertexData.delete(s);this.vertexCount=s,this.indexData=i}}class cs{constructor(t,s,i,e=0,n=0){this.id=t,this.geometryType=s,this.materialKey=i,this.minZoom=e,this.maxZoom=n,this.meshData=null,this.symbolLevel=0,this.zOrder=0,this.vertexFrom=0,this.vertexCount=0,this.indexFrom=0,this.indexCount=0}get sortKey(){return void 0===this._sortKey&&this._computeSortKey(),this._sortKey}clone(){return this.copy()}copy(){const t=new cs(this.id,this.geometryType,this.materialKey);return t.vertexFrom=this.vertexFrom,t.vertexCount=this.vertexCount,t.indexFrom=this.indexFrom,t.indexCount=this.indexCount,t.zOrder=this.zOrder,t.symbolLevel=this.symbolLevel,t.meshData=this.meshData,t.minZoom=this.minZoom,t.maxZoom=this.maxZoom,t}setMeshDataFromBuffers(t,s,i){const e=new hs;for(const i in s){const n=s[i].stride,r=s[i].data,o=[],h=q(n);for(let s=0;s<n*t.vertexCount/h;++s)o[s]=r[s+n*t.vertexFrom/h];e.vertexData.set(i,o)}e.indexData.length=0;for(let s=0;s<t.indexCount;++s)e.indexData[s]=i[s+t.indexFrom]-t.vertexFrom;e.vertexCount=t.vertexCount,this.meshData=e}readMeshDataFromBuffers(t,s){this.meshData?this.meshData.clear():this.meshData=new hs;for(const s in t){const i=t[s].stride,e=t[s].data,n=[],r=q(i);for(let t=0;t<i*this.vertexCount/r;++t)n[t]=e[t+i*this.vertexFrom/r];this.meshData.vertexData.set(s,n)}this.meshData.indexData.length=0;for(let t=0;t<this.indexCount;++t)this.meshData.indexData[t]=s[t+this.indexFrom]-this.vertexFrom;this.meshData.vertexCount=this.vertexCount}writeMeshDataToBuffers(t,s,i,e){for(const i in s){const e=s[i].stride,n=this.meshData.vertexData.get(i),r=s[i].data,o=q(e);for(let s=0;s<e*this.meshData.vertexCount/o;++s)r[s+e*t/o]=n[s]}for(let s=0;s<this.meshData.indexData.length;++s)e[s+i]=this.meshData.indexData[s]+t;this.vertexFrom=t,this.vertexCount=this.meshData.vertexCount,this.indexFrom=i,this.indexCount=this.meshData.indexData.length}static writeAllMeshDataToBuffers(t,s,i){let e=0,n=0;for(const r of t)r.writeMeshDataToBuffers(e,s,n,i),e+=r.vertexCount,n+=r.indexCount}_computeSortKey(){this._sortKey=(31&this.symbolLevel)<<12|(127&this.zOrder)<<4|7&this.geometryType}serialize(t){return t.push(this.geometryType),t.push(this.materialKey),t.push(this.vertexFrom),t.push(this.vertexCount),t.push(this.indexFrom),t.push(this.indexCount),t.push(this.minZoom),t.push(this.maxZoom),t}static deserialize(t,s){const i=t.readInt32(),e=t.readInt32(),n=new cs(s.id,i,e);return n.vertexFrom=t.readInt32(),n.vertexCount=t.readInt32(),n.indexFrom=t.readInt32(),n.indexCount=t.readInt32(),n.minZoom=t.readInt32(),n.maxZoom=t.readInt32(),n}}function as(t,s){if(null!==s){t.push(s.length);for(const i of s)i.serialize(t);return t}t.push(0)}class ls{constructor(t){this.insertAfter=null,this.id=t,this.displayRecords=[]}copy(){const t=new ls(this.id);return t.set(this),t}clone(){const t=new ls(this.id);return t.displayRecords=this.displayRecords.map((t=>t.clone())),t.insertAfter=this.insertAfter,t}set(t){this.id=t.id,this.displayRecords=t.displayRecords,this.insertAfter=t.insertAfter}serialize(t){return t.push(this.id),as(t,this.displayRecords),t}static deserialize(t){const s=t.readInt32(),i=new ls(s);return i.displayRecords=function(t,s,i){const e=t.readInt32(),n=new Array(e);for(let e=0;e<n.length;e++)n[e]=s.deserialize(t,i);return n}(t,cs,{id:s}),i}}class us{constructor(){}get displayObjectRegistry(){if(!this._displayObjectRegistry){this._displayObjectRegistry=new Map;for(const t of this.displayObjects)this._displayObjectRegistry.set(t.id,t)}return this._displayObjectRegistry}get displayList(){return this._displayList}computeDisplayList(){this._displayList=new is;for(const t of this.displayObjects)for(const s of t.displayRecords)this._displayList.addToList(s)}clone(){const t=new us;return this.displayObjects&&(t.displayObjects=this.displayObjects.map((t=>t.clone()))),t}serialize(t){return as(t,this.displayObjects),t}_deserializeObjects(t){const s=t.readInt32(),i=new Array(s),e=new Map;for(let s=0;s<i.length;++s){const n=ls.deserialize(t);i[s]=n,e.set(n.id,n)}this.displayObjects=i,this._displayList=null,this._displayObjectRegistry=e}static deserialize(t){const s=new us;return s._deserializeObjects(t),s}}class fs{constructor(t,s){this.data=t,this.stride=s}static decode(t){const s=N(t.data,t.stride);return new fs(s,t.stride)}static fromVertexVector(t){const s=N(t.data.buffer(),t.stride);return new fs(s,t.stride)}}class ds{constructor(t,s,i){this.geometryType=t,this.indexBuffer=new Uint32Array(s),this.namedBuffers=i}static decode(t){const s=t.geometryType,i=t.indexBuffer,e={};for(const s in t.namedBuffers)e[s]=fs.decode(t.namedBuffers[s]);return new ds(s,i,e)}static fromVertexData(t,s){const i=t.indices,e=N(t.vertices,t.stride),n={geometry:new fs(e,t.stride)};return new ds(s,i,n)}static fromVertexVectors(t){const s=t.geometryType,i=t.indexVector.buffer(),e={};for(const s in t.namedVectors)e[s]=fs.fromVertexVector(t.namedVectors[s]);return new ds(s,i,e)}}class ps{constructor(t,s){this.data=t,this.stride=s}get vertexCount(){const t=this.data.length/(this.stride/4);return t!==(0|t)&&console.debug("Corrupted stride"),t}transfer(t,s){const i=this.data.buffer();t.vertexCount=this.vertexCount,t.data=i,t.stride=this.stride,s.push(i)}}class ms{constructor(t,s,i=!1){this.geometryType=t,this.indexVector=new nt(Uint32Array,6*s),this.namedVectors={};const e=Q(t,i);for(const t in e){const i=e[t];let n;switch(i%4){case 0:case 2:n=new nt(Uint32Array,i*s);break;case 1:case 3:n=new nt(Uint8Array,i*s)}this.namedVectors[t]=new ps(n,i)}}get(t){return this.namedVectors[t].data}getVector(t){return this.namedVectors[t]}transfer(t,s){const i=this.indexVector.buffer(),e={};s.push(i);for(const t in this.namedVectors){const i=this.namedVectors[t];e[t]={},i.transfer(e[t],s)}t.geometryType=this.geometryType,t.indexBuffer=i,t.namedBuffers=e,this.destroy()}intoBuffers(){const t=ds.fromVertexVectors(this);return this.destroy(),t}destroy(){this.indexVector=null,this.namedVectors=null}}const ws=new Wt,ys=new Wt;function gs(t,s){const i={};for(const e in t){const n={data:k(s,t[e]),stride:t[e]};i[e]=n}return i}class vs{constructor(){this.tileDisplayData=null,this.tileBufferData=null}reshuffle(){ws.reset();const t=function(t){const s=[[],[],[],[],[]],i=t;for(const t of i)for(const i of t.displayRecords)s[i.geometryType].push(i);return s}(this.tileDisplayData.displayObjects);for(const s of t)for(const t of s)t&&ws.needMore(t.geometryType,t.meshData?t.meshData.vertexCount:t.vertexCount,t.meshData?t.meshData.indexData.length:t.indexCount);const s=t.length,i=new $t;for(let t=0;t<s;++t){i.geometries[t].indexBuffer=new Uint32Array(Math.round(1.5*ws.indicesFor(t)));const s=[];for(const i in this.tileBufferData.geometries[t].vertexBuffer)s.push(this.tileBufferData.geometries[t].vertexBuffer[i].stride);const e=vs._computeVertexAlignment(s),n=Math.round(1.5*ws.verticesFor(t)),r=vs._align(n,e);for(const s in this.tileBufferData.geometries[t].vertexBuffer){const e=this.tileBufferData.geometries[t].vertexBuffer[s].stride;i.geometries[t].vertexBuffer[s]={stride:e,data:k(r,e)}}}ys.reset(),this.tileDisplayData.displayList.clear();for(let e=0;e<s;++e){const s=t[e];for(const t of s){if(t.meshData)t.writeMeshDataToBuffers(ys.verticesFor(e),i.geometries[e].vertexBuffer,ys.indicesFor(e),i.geometries[e].indexBuffer),t.meshData=null;else{const s=this.tileBufferData.geometries[e].vertexBuffer,n=this.tileBufferData.geometries[e].indexBuffer,r=i.geometries[e].vertexBuffer,o=i.geometries[e].indexBuffer,h=ys.verticesFor(e),c=ys.indicesFor(e);E(h,c,r,o,t,s,n),t.vertexFrom=h,t.indexFrom=c}ys.needMore(e,t.vertexCount,t.indexCount)}}for(const t of this.tileDisplayData.displayObjects)this.tileDisplayData.displayList.addToList(t.displayRecords);this.tileBufferData=i}getStrides(){const t=[];for(let s=0;s<this.tileBufferData.geometries.length;++s){const i=this.tileBufferData.geometries[s];t[s]={};for(const e in i.vertexBuffer)t[s][e]=i.vertexBuffer[e].stride}return t}clone(){const t=new vs;return t.tileBufferData=this.tileBufferData.clone(),t.tileDisplayData=this.tileDisplayData.clone(),t}_guessSize(){const{displayObjects:t}=this.tileDisplayData,s=Math.min(t.length,4);let i=0;for(let e=0;e<s;e++)i=Math.max(i,t[e].displayRecords.length);return 2*(12*t.length+t.length*i*40)}serialize(){const t=this.tileBufferData.serialize(),s=this.tileBufferData.getBuffers(),i=this.tileDisplayData.serialize(new nt(Int32Array,this._guessSize())).buffer();return s.push(i),{result:{displayData:i,bufferData:t},transferList:s}}static fromVertexData(s,i){const e={},n=new Map;for(const t of i)n.set(t.id,t);return Z((i=>{const r=s.data[i];if(t(r)){const t=it.from(r.records).getCursor();for(;t.next();){const s=t.id,e=t.materialKey,r=t.indexFrom,o=t.indexCount,h=t.vertexFrom,c=t.vertexCount,a=n.get(s),l=new cs(s,i,e);l.indexFrom=r,l.indexCount=o,l.vertexFrom=h,l.vertexCount=c,a.displayRecords.push(l)}e[i]=ds.fromVertexData(r,i)}else e[i]=new ms(i,0).intoBuffers()})),vs.fromMeshData({displayObjects:i,vertexBuffersMap:e})}static fromMeshData(t){const s=new vs,i=new us,e=new $t;i.displayObjects=t.displayObjects;for(const s in t.vertexBuffersMap){const i=t.vertexBuffersMap[s];e.geometries[s].indexBuffer=i.indexBuffer,e.geometries[s].vertexBuffer=i.namedBuffers}return s.tileDisplayData=i,s.tileBufferData=e,s}static bind(t,s){const i=new vs;return i.tileDisplayData=t,i.tileBufferData=s,i}static create(t,s){const i=new vs;i.tileDisplayData=new us,i.tileDisplayData.displayObjects=t;const e=[0,0,0,0,0],n=[0,0,0,0,0],r=[[],[],[],[],[]];for(const s of t)for(const t of s.displayRecords)r[t.geometryType].push(t),e[t.geometryType]+=t.meshData.vertexCount,n[t.geometryType]+=t.meshData.indexData.length;const o=new $t,h=function(t){return[t.fill||{},t.line||{},t.icon||{},t.text||{},t.label||{}]}(s);for(let t=0;t<5;t++){const s=new Uint32Array(n[t]),i=gs(h[t],e[t]);cs.writeAllMeshDataToBuffers(r[t],i,s),o.geometries[t]={indexBuffer:s,vertexBuffer:i}}return i.tileBufferData=o,i}static _align(t,s){const i=t%s;return 0===i?t:t+(s-i)}static _computeVertexAlignment(t){let s=!1,i=!1;for(const e of t)e%4==2?s=!0:e%4!=0&&(i=!0);return i?4:s?2:1}}class xs extends gt{constructor(t,s){super(t,s,null)}static from(t){const s=At.createInstance(),i=[],e=t.filter((t=>!!t.geometry));for(const t of e){const s=F(t.geometry);_t(i,[t],s,!1,!1,"uid")}return new xs(s,i)}get geometryType(){const t=this._current;return t?t.geometryType:null}get insertAfter(){return this._current.insertAfter}readGraphic(){return this._current}getCursor(){return this.copy()}copy(){const t=new xs(this.instance,this._features);return this.copyInto(t),t}}const _s=new zt,bs=new zt,Ms="esriGeometryPolyline";function js(t){t.coords.length=0,t.lengths.length=0}class Bs{constructor(){this.bounds=v(),this.graphic=null}static acquire(t=null,s,i,e,n){let r;return 0===Bs._pool.length?r=new Bs:(r=Bs._pool.pop(),this._set.delete(r)),r.acquire(t,s,i,e,n),r}static release(t){t&&!this._set.has(t)&&(t.release(),this._pool.push(t),this._set.add(t))}static getCentroidQuantized(t,i){if(C(t.geometry)){const e=t.symbol;if(s(e))return null;if(at(e.type)||lt(e.type)){const s=B(t.geometry);return Tt(i,{},{x:s[0],y:s[1]},!1,!1)}}return null}acquire(t=null,s,i,e,n){t&&this.set(t,s,i,e,n)}release(){this.graphic=null,this.symbolResource=null,this.geometry=null}get symbol(){return this.symbolResource.symbol}set(t,s,i,e,n){this.graphic=t,this.geometry=i,this.symbolResource=s,this.bounds=e,n&&(this.size=n)}getGeometryQuantized(t,s,i,e){const n=this.geometry;if(C(n)){const s=n.rings;if(1===s.length&&2===s[0].length)return Pt(t,{paths:[[s[0][0],s[0][1]]]})}else{if(T(n))return js(_s),js(bs),bt(_s,n),Mt(bs,_s,n.hasZ,n.hasM,Ms,t.scale[0]),jt(_s,bs,n.hasZ,n.hasM,Ms,t),Bt(_s,n.hasZ,n.hasM);if(P(n)){const r=.5*e*Math.max(Math.abs(this.size[0])+this.size[2]-this.size[0],Math.abs(this.size[1])+this.size[3]-this.size[1]),[o,h]=Ft(i),c=h-o,a=n.points.filter((t=>{if(t[0]+r>h||t[0]-r<o){const i=[...t];return t[0]+r>h?i[0]-=c:i[0]+=c,x(s,t,r)||x(s,i,r)}return x(s,t,r)}));return 0===a.length?{points:a}:Pt(t,{points:a})}}return Pt(t,this.geometry)}}Bs._pool=[],Bs._set=new Set;const As={minX:0,minY:0,maxX:0,maxY:0},Ds=v();function Fs(t,s,i,e,n){return As.minX=s,As.minY=i,As.maxX=e,As.maxY=n,t.search(As)}function Cs(t){return{minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]}}class Ts{constructor(t,s,i,e,n,r,o){this._graphics=e,this._onAdd=n,this._onRemove=r,this._hashToCIM=o,this._index=Dt(9,Cs),this._itemByGraphic=new Map,this._inflatedSizeHelper=new f,this._tileInfoView=t,this._uidFieldName=i;const h=t.getClosestInfoForScale(s);h&&(this._resolution=this._tileInfoView.getTileResolution(h.level))}setResourceManager(t){this._cimResourceManager=t,this._hittestDrawHelper=new d(t)}hitTest(t,s,i,e,n){t=Ct(t,this._tileInfoView.spatialReference);const r=.5*e*window.devicePixelRatio*i;Ds[0]=t-r,Ds[1]=s-r,Ds[2]=t+r,Ds[3]=s+r;const o=.5*e*(i+ut),h=Fs(this._index,t-o,s-o,t+o,s+o);if(!h||0===h.length)return[];const c=[],a=v(),l=v();for(const t of h){const{geometry:s,symbolResource:i}=t;this._getSymbolBounds(a,i,s,l,n),l[3]=l[2]=l[1]=l[0]=0,_(a,Ds)&&t.graphic.visible&&c.push(t)}if(0===c.length)return[];const u=this._hittestDrawHelper,f=[];for(const t of c){const{geometry:s,symbolResource:i}=t,{hash:r,textInfo:o}=i,h=this._hashToCIM.get(r);h&&u.hitTest(Ds,h.symbol,s,o,n,e)&&f.push(t)}return f.sort(Ps),f.map((t=>t.graphic))}getGraphicsData(t,s,i){const e=this._searchForItems(s);if(0===e.length||0===i.length)return[];e.sort(((t,s)=>t.zorder-s.zorder)),e[0].insertAfter=-1;for(let t=1;t<e.length;t++)e[t].insertAfter=e[t-1].graphic.uid;e.sort(((t,s)=>t.graphic.uid-s.graphic.uid)),i.sort(((t,s)=>t.uid-s.uid));let n,r=0,o=0;const h=s.resolution,c=[],a={originPosition:"upperLeft",scale:[h,h],translate:[s.bounds[0],s.bounds[3]]};for(const l of i){for(o=-2;r<e.length;)if(n=e[r],r++,l.uid===n.graphic.uid){o=n.insertAfter;break}if(!n.geometry||-2===o)continue;const i=n.getGeometryQuantized(a,s.bounds,this._tileInfoView.spatialReference,h),u={...n.graphic.attributes};u[this._uidFieldName]=l.uid,null==n.groupId&&(n.groupId=t.createTemplateGroup(n.symbol,null)),c.push({centroid:Bs.getCentroidQuantized(n,a),geometry:i,attributes:u,symbol:n.symbol,groupId:n.groupId,insertAfter:o,zorder:n.zorder})}return c.sort(((t,s)=>t.zorder-s.zorder)),c}queryTileData(t,s){if(0===this._graphics.length)return[];const{bounds:i,resolution:e}=s,n=this._searchForItems(s),r=[];return 0===n.length||this._createTileGraphics(r,t,n,{originPosition:"upperLeft",scale:[e,e],translate:[i[0],i[3]]},s),r}has(t){return this._itemByGraphic.has(t)}getBounds(t){const s=this._itemByGraphic.get(t);return s?s.bounds:null}getAllBounds(){return Array.from(this._itemByGraphic.values()).filter((t=>t.graphic.visible)).map((t=>t.bounds))}addOrModify(i,e,n){if(!i||s(e))return;this.has(i)&&this.remove(i),this._onAdd(i);const r=[0,0,0,0],o=this._getSymbolBounds(null,e,n,r,0),h=Bs.acquire(i,e,n,t(o)?o:null,r);return this._itemByGraphic.set(i,h),n&&this._index.insert(h),h.bounds}remove(t){if(!this._itemByGraphic.has(t))return;this._onRemove(t);const s=this._itemByGraphic.get(t);this._index.remove(s),this._itemByGraphic.delete(t)}updateZ(){const t=this._graphics.items;let s,i;for(let e=0;e<t.length;e++)i=t[e],s=this._itemByGraphic.get(i),s&&(s.zorder=e)}update(s,i,e){const n=this._itemByGraphic.get(s);n.groupId=null;const r=b(n.bounds);this._index.remove(n);const o=this._getSymbolBounds(n.bounds,i,e,n.size,0);return t(o)&&n.set(s,i,e,o,n.size),e&&this._index.insert(n),{oldBounds:r,newBounds:n.bounds}}updateLevel(s){if(this._resolution===s)return;this._resolution=s,this._index.clear();const i=this._itemByGraphic,e=[];for(const[s,n]of i){const s=this._getSymbolBounds(n.bounds,n.symbolResource,n.geometry,n.size,0);n.geometry&&t(s)&&(n.bounds=s,e.push(n))}this._index.load(e)}clear(){this._itemByGraphic.clear(),this._index.clear()}_createTileGraphics(t,s,i,e,n){const r=this._uidFieldName,o=this._tileInfoView.spatialReference,{bounds:h,resolution:c}=n;let a,l,u,f;i.sort(((t,s)=>t.zorder-s.zorder));for(let n=0;n<i.length;n++){u=i[n],a=u.graphic,l=u.getGeometryQuantized(e,h,o,c),f=0===n?-1:i[n-1].graphic.uid;const d={...u.graphic.attributes};d[r]=a.uid,null==u.groupId&&(u.groupId=s.createTemplateGroup(u.symbol,null)),t.push({centroid:Bs.getCentroidQuantized(u,e),geometry:l,attributes:d,symbol:u.symbol,groupId:u.groupId,insertAfter:f,zorder:u.zorder})}}_searchForItems(t){const s=this._tileInfoView.spatialReference,i=t.bounds;if(s.isWrappable){const[e,n]=Ft(s),r=Math.abs(i[2]-n)<1e-5,o=Math.abs(i[0]-e)<1e-5;if((!r||!o)&&(r||o)){const s=t.resolution;let o;o=v(r?[e,i[1],e+s*ut,i[3]]:[n-s*ut,i[1],n,i[3]]);const h=Fs(this._index,i[0],i[1],i[2],i[3]),c=Fs(this._index,o[0],o[1],o[2],o[3]);return[...new Set([...h,...c])]}}return Fs(this._index,i[0],i[1],i[2],i[3])}_getSymbolBounds(t,s,i,e,n){if(!s||!s.symbol)return null;if(t||(t=v()),A(t,i),!e||0===e[0]&&0===e[1]&&0===e[2]&&0===e[3]){const{hash:t,textInfo:i}=s,r=this._hashToCIM.get(t);if(!r)return null;e||(e=[0,0,0,0]);const o=this._inflatedSizeHelper.getSymbolInflateSize(e,r.symbol,this._cimResourceManager,n,i);e[0]=window.devicePixelRatio*y(o[0]),e[1]=window.devicePixelRatio*y(o[1]),e[2]=window.devicePixelRatio*y(o[2]),e[3]=window.devicePixelRatio*y(o[3])}const r=this._resolution,o=f.SafeSize(e);return t[0]-=o*r,t[1]-=o*r,t[2]+=o*r,t[3]+=o*r,t}}const Ps=(t,s)=>{const i=ft(t.graphic),e=ft(s.graphic);return i===e?s.zorder-t.zorder:i-e},zs=i("esri-2d-graphic-debug");function Is(t,s,i){if(i.has(t))return i.get(t);const e={tile:s,addedOrModified:[],removed:[]};return i.set(t,e),e}let Us=class extends(Ut(w(e))){constructor(t){super(t),this._storage=new vt,this._displayIds=new Map,this._controller=new AbortController,this._tiles=new Map,this._graphicStoreUpdate=!1,this._graphicsSet=new Set,this._matcher=Promise.resolve(null),this._tileUpdateSet=new Set,this._tilesToUpdate=new Map,this._graphicIdToAbortController=new Map,this._attached=!1,this._highlightIds=new Map,this._updatingGraphicsTimer=null,this._hashToExpandedSymbol=new Map,this._hashToExpandedSymbolPromise=new Map,this._hashToCIMSymbolPromise=new Map,this._hashToCIM=new Map,this._processing=!1,this._needsProcessing=!1,this._pendingUpdate={added:new Set,updated:new Set,removed:new Set},this.lastUpdateId=-1,this.updateRequested=!1,this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}_createMatcher(t,s,i){if(t){const e=dt({indexCount:0,fields:{}},"feature",t);this._matcher=rt(e,s,null,i)}}_createDisplayId(t){return this._displayIds.has(t)||this._displayIds.set(t,this._storage.createDisplayId()),this._displayIds.get(t)}initialize(){this._attributeStore=new xt({type:"local",initialize:t=>Promise.resolve(this.container.attributeView.initialize(t)),update:t=>this.container.attributeView.requestUpdate(t),render:()=>this.container.requestRender()},Lt()),this.container.hasHighlight=()=>!!this._highlightIds.size;const t=new ot(this.container.getMaterialItems.bind(this.container),this.view.featuresTilingScheme.tileInfo);this._graphicStore=new Ts(this.view.featuresTilingScheme,this.view.state.scale,this.uid,this.graphics,(t=>{this._createDisplayId(t.uid),this._setFilterState(t.uid,t.visible)}),(t=>{const s=this._displayIds.get(t.uid);this._displayIds.delete(t.uid),this._storage.releaseDisplayId(s)}),this._hashToCIM),this._meshFactory=new ht(null,this.uid,t),this._templateStore=t,this.handles.add([this.watch("renderer",(s=>{this._createMatcher(s,t,this.container.stage.resourceManager);for(const t of this.graphics)this._pendingUpdate.updated.add(t);this.requestUpdate()})),this.view.graphicsTileStore.on("update",(t=>this._onTileUpdate(t))),this.container.on("attach",(()=>{zs&&this.container.enableRenderingBounds((()=>this._graphicStore.getAllBounds())),this.graphics.items.length>0&&this._graphicsChangeHandler({target:this.graphics,added:this.graphics.items,removed:[],moved:[]}),this.handles.add(this.graphics.on("change",(t=>this._graphicsChangeHandler(t))),"graphics");const s=this.container.stage.resourceManager;this._createMatcher(this.renderer,t,s),this._graphicStore.setResourceManager(s),this._attached=!0,this.notifyChange("updating")}))]),this._onTileUpdate({added:this.view.graphicsTileStore.tiles,removed:[]})}destroy(){this._updatingGraphicsTimer&&(clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=null,this.notifyChange("updating")),this._controller.abort(),this.container.destroy(),this._set("graphics",null),this._graphicStore.clear(),this._attributeStore=null,this._hashToExpandedSymbol.clear(),this.view=null,this.renderer=null,this._hashToCIM.clear(),this._hashToCIMSymbolPromise.clear(),this._hashToExpandedSymbolPromise.clear()}get updating(){return!this._attached||null!==this._updatingGraphicsTimer||this._tileUpdateSet.size>0||this._tilesToUpdate.size>0}hitTest(t,s){if(!this.view||!this.view.position)return Promise.resolve(null);const i=this.view.toMap(g(t,s));return this.searchFeatures(i).then((t=>t&&t.length?t[0]:null))}async searchFeatures(t,s=2){const{resolution:i,rotation:e}=this.view.state;return this._graphicStore.hitTest(t.x,t.y,s,i,e)}update(t){n(this._controller.signal);const s=t.state,{resolution:i}=s;if(this._graphicStore.updateLevel(i),this._graphicStoreUpdate=!0,this.updateRequested=!1,this._pendingUpdate.updated.size>0){if(!this._processing)return void this._updateGraphics();this._needsProcessing=!0}}viewChange(){this.requestUpdate()}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback())}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}graphicUpdateHandler(t){const{graphic:s,property:i,newValue:e}=t;switch(i){case"attributes":break;case"geometry":case"symbol":this._pendingUpdate.updated.add(s),this.requestUpdate();break;case"visible":this._setFilterState(s.uid,e),this._attributeStore.sendUpdates()}}addHighlight(t){for(const s of t)if(this._highlightIds.has(s)){const t=this._highlightIds.get(s);this._highlightIds.set(s,t+1)}else this._highlightIds.set(s,1);this._updateHighlight()}removeHighlight(t){for(const s of t)if(this._highlightIds.has(s)){const t=this._highlightIds.get(s)-1;0===t?this._highlightIds.delete(s):this._highlightIds.set(s,t)}this._updateHighlight()}_updateHighlight(){const t=Array.from(this._highlightIds.keys()),s=t.map((t=>this._displayIds.get(t)));this._attributeStore.setHighlight(t,s)}_getIntersectingTiles(s){const i=this._graphicStore.getBounds(s);if(!i||0===M(i)||0===j(i))return[];const e=yt(i,this.view.spatialReference);return t(e)?[...new Set([...this.view.graphicsTileStore.boundsIntersections(e[0]),...this.view.graphicsTileStore.boundsIntersections(e[1])])]:this.view.graphicsTileStore.boundsIntersections(i)}async _updateTile(t){n(this._controller.signal);const s=t.tile,i=this._getGraphicsData(this._templateStore,s,t.addedOrModified),e=await this._processGraphics(s,i);return n(this._controller.signal),this._patchTile(s.key,{type:"update",addOrUpdate:e,remove:t.removed,end:!0,clear:!1,sort:!1}),e}_patchTile(t,s){if(!this._tiles.has(t))return;const i=this._tiles.get(t);this.container.onTileData(i,s),this.container.requestRender()}_graphicsChangeHandler(t){const s=this._pendingUpdate;for(const i of t.added)s.added.add(i);for(const i of t.moved)s.updated.add(i);for(const i of t.removed)this._pendingUpdate.added.has(i)?s.added.delete(i):s.removed.add(i);this._processing?this._needsProcessing=!0:this._updateGraphics()}_getGraphicsToUpdate(){const t={added:[],removed:[],updated:[]};if(!this.graphics)return t;const s=this._pendingUpdate;for(const i of this.graphics.items)s.added.has(i)?t.added.push(i):s.updated.has(i)&&t.updated.push(i);for(const i of s.removed)this._graphicStore.has(i)&&t.removed.push(i);return s.added.clear(),s.removed.clear(),s.updated.clear(),t}async _updateGraphics(){this._processing=!0;const{added:t,removed:s,updated:i}=this._getGraphicsToUpdate(),e=this._tilesToUpdate;let n;try{if(!this._graphicStoreUpdate){const t=this.view.state,{resolution:s}=t;this._graphicStore.updateLevel(s)}const r=[],o=new Array(t.length+s.length);for(let t=0;t<i.length;t++){const s=i[t],h=this._getIntersectingTiles(s);for(const t of h)n=t.id,Is(n,t,e).removed.push(this._displayIds.get(s.uid));r.push(this._updateGraphic(s,null)),o[t]=s}const h=i.length;for(let s=0;s<t.length;s++){const i=t[s];o[h+s]=i,this._graphicsSet.add(i),r.push(this._addGraphic(i))}for(const t of s){this._abortProcessingGraphic(t.uid);const s=this._getIntersectingTiles(t);for(const i of s)n=i.id,Is(n,i,e).removed.push(this._displayIds.get(t.uid));this._graphicsSet.delete(t),this._graphicStore.remove(t)}let c;this._flipUpdatingGraphics(),await Promise.all(r);for(let t=0;t<o.length;t++){c=o[t];const s=this._getIntersectingTiles(c);for(const t of s)n=t.id,Is(n,t,e).addedOrModified.push(c)}this._graphicStore.updateZ();const a=[];for(const[t,s]of e)a.push(this._updateTile(s));await Promise.all(a)}catch(t){}for(const t of s)try{const s=await this._getSymbolForGraphic(t,{});if(s){const t=s.hash();this._hashToExpandedSymbol.delete(t)}}catch(t){}e.clear(),this.notifyChange("updating"),this._processing=!1,this._needsProcessing&&(this._needsProcessing=!1,this._updateGraphics())}_getArcadeInfo(t){const i=(t.attributes?Object.keys(t.attributes):[]).map((s=>({name:s,alias:s,type:"string"==typeof t.attributes[s]?"esriFieldTypeString":"esriFieldTypeDouble"})));return s(t.geometry)?null:{geometryType:F(t.geometry),spatialReference:r.fromJSON(t.geometry.spatialReference),fields:i}}_getSymbolForGraphic(s,i){return n(this._controller.signal),t(s.symbol)?Promise.resolve(s.symbol):t(this.renderer)?this.renderer.getSymbolAsync(s,{scale:this.view.scale,abortOptions:i}):Promise.resolve(this._getNullSymbol(s))}_getCIMSymbol(s,i,e){let n=this._hashToCIM.get(i);if(n)return Promise.resolve(n);const r=p(s);if(t(r)){if("CIMSymbolReference"===r.type)return n=r,this._hashToCIM.set(i,n),Promise.resolve(n);let t=this._hashToCIMSymbolPromise.get(i);return t||(t=r.fetchCIMSymbol(e).then((t=>(this._hashToCIM.set(i,t.data),this._hashToCIMSymbolPromise.delete(i),t))).catch((t=>(this._hashToCIMSymbolPromise.delete(i),o(t),null))),this._hashToCIMSymbolPromise.set(i,t),t)}return Promise.resolve(null)}_expandCIMSymbol(t,s,i,e){const n=this._hashToExpandedSymbol.get(i);if(n)return Promise.resolve(n);let r=this._hashToExpandedSymbolPromise.get(i);if(r)return r;const o=this.container.stage,h=this._getArcadeInfo(s),c=pt(t);return r=It(c,h,o.resourceManager,e),this._hashToExpandedSymbolPromise.set(i,r),r.then((t=>(this._hashToExpandedSymbol.set(i,t),this._hashToExpandedSymbolPromise.delete(i),t))),r}async _getSymbolResources(t,i){return n(this._controller.signal),this.container.stage?this._getSymbolForGraphic(t,i).then((e=>{const n=e.hash();return this._getCIMSymbol(e,n,i).then((e=>s(e)?null:this._expandCIMSymbol(e,t,n,i).then((t=>{const s=t.layers.filter((t=>"text"===t.type&&"string"==typeof t.text));if(s&&s.length>0){const i=new Array(s.length);for(let t=0;t<s.length;t++){const e=s[t],n=[],[r]=m(e.text);for(let t=0;t<r.length;t++)n.push(r.charCodeAt(t));i[t]={symbol:e,id:t,glyphIds:n}}const e=new Map;return this.container.getMaterialItems(i).then((i=>{for(let t=0;t<s.length;t++){const n=s[t];e.set(n.cim,{text:n.text,mosaicItem:i[t].mosaicItem})}return{symbol:t,textInfo:e,hash:n}}))}return{symbol:t,hash:n}}))))})).catch((t=>(o(t),null))):null}async _projectAndNormalizeGeometry(t,i){if(n(this._controller.signal),s(t.geometry)||"mesh"===t.geometry.type)return null;let e=t.geometry;if(C(e))e.rings=e.rings;else if(T(e))e.paths=e.paths;else if(z(e)){const s=await this._getSymbolForGraphic(t,i);n(this._controller.signal),e=at(s.type)||lt(s.type)?e.center:mt(e)}await L(e.spatialReference,this.view.spatialReference);const r=U(e),o=S(r,e.spatialReference,this.view.spatialReference);return D(o),o}_onTileUpdate(t){const s=u(this.view.spatialReference);if(t.added&&t.added.length>0)for(const i of t.added)this._addNewTile(i,s);if(t.removed&&t.removed.length>0)for(const s of t.removed)this._removeTile(s.key)}async _addGraphic(t){this._abortProcessingGraphic(t.uid),n(this._controller.signal);const s=new AbortController;this._graphicIdToAbortController.set(t.uid,s);const i={signal:s.signal};try{await this._addOrUpdateGraphic(t,i),n(this._controller.signal),this._graphicIdToAbortController.delete(t.uid)}catch(s){if(this._graphicIdToAbortController.delete(t.uid),!h(s))throw s}}_updateGraphic(t,s){n(this._controller.signal);const i=this._projectAndNormalizeGeometry(t,s),e=this._getSymbolResources(t,s);return Promise.all([i,e]).then((([s,i])=>{n(this._controller.signal),this._graphicStore.addOrModify(t,i,s)}))}_addOrUpdateGraphic(t,s){n(this._controller.signal);const i=this._projectAndNormalizeGeometry(t,s),e=this._getSymbolResources(t,s);return Promise.all([i,e]).then((([s,i])=>{n(this._controller.signal),this._graphicsSet.has(t)&&this._graphicStore.addOrModify(t,i,s)}))}_addTile(t){const s=this.view.featuresTilingScheme.getTileBounds(v(),t),i=new Jt(t,s[0],s[3]);return this._tiles.set(t,i),this.container.addChild(i),i}async _addNewTile(t,s){const i=this._addTile(t.key),e=this._graphicStore.queryTileData(this._templateStore,t);if(0===e.length)return;if(s){const i=Math.round((s.valid[1]-s.valid[0])/t.resolution);for(const t of e)t.geometry&&(I(t.geometry)||P(t.geometry))&&this._wrapPoints(t,i)}const n=t.key;this._tileUpdateSet.add(t.key),this.notifyChange("updating");try{const s={type:"update",clear:!1,addOrUpdate:await this._processGraphics(t,e),remove:[],end:!0,sort:!1};i.patch(s),this._tileUpdateSet.delete(n),this.notifyChange("updating")}catch(t){if(this._tileUpdateSet.delete(n),this.notifyChange("updating"),!h(t))throw t}}_removeTile(t){if(!this._tiles.has(t))return;const s=this._tiles.get(t);this.container.removeChild(s),s.destroy(),this._tiles.delete(t)}_setFilterState(t,s){const i=this._displayIds.get(t),e=this._attributeStore.getHighlightFlag(t);this._attributeStore.setData(i,0,0,e|(s?V:0))}_getGraphicsData(t,s,i){const e=u(this.view.spatialReference),n=this._graphicStore.getGraphicsData(t,s,i);if(e){const t=Math.round((e.valid[1]-e.valid[0])/s.resolution);for(const s of n)s.geometry&&(I(s.geometry)||P(s.geometry))&&this._wrapPoints(s,t)}return n}_wrapPoints(t,s){const i=t.geometry;P(i)?this._wrapMultipoint(i,s):this._wrapPoint(t,s)}_wrapMultipoint(t,s){const i=t.points,e=[];let n=0,r=0;for(const[t,o]of i){if(e.push([t+n,o]),n=0,s===wt){const i=5*ut;t+r<i?(e.push([s,0]),n=-s):t+r>wt-i&&(e.push([-s,0]),n=s)}else t+r<-ut?(e.push([s,0]),n=-s):t+r>wt+ut&&(e.push([-s,0]),n=s);r+=t}t.points=e}_wrapPoint(t,s){const i=t.geometry;if(s===wt){const e=5*ut;i.x<e?t.geometry={points:[[i.x,i.y],[s,0]]}:i.x>wt-e&&(t.geometry={points:[[i.x,i.y],[-s,0]]})}else i.x<-ut?t.geometry={points:[[i.x,i.y],[s,0]]}:i.x>wt+ut&&(t.geometry={points:[[i.x,i.y],[-s,0]]})}_processGraphics(t,s,i){if(!s||!s.length||!this._meshFactory)return null;const e=xs.from(s),n=this._meshFactory;return this._matcher.then((s=>n.analyzeGraphics(e,this.container.stage.resourceManager,s,null,null,i).then((()=>(this._attributeStore.sendUpdates(),this._processAnalyzedGraphics(t,e))))))}_processAnalyzedGraphics(t,s){const i=this._meshFactory,e=s.getSize(),n=s.getCursor(),r=new ct(t.key.id,{features:e,records:e,metrics:0},!1,!1,!1),o=[];for(;n.next();){const s=n.readGraphic();s.insertAfter=-1===s.insertAfter?-1:this._displayIds.get(s.insertAfter),s.displayId=this._displayIds.get(s.attributes[this.uid]);const e=new ls(s.displayId);e.insertAfter=s.insertAfter,o.push(e),i.writeGraphic(r,n,t.level)}const h=r.serialize(t.tileInfoView.tileInfo.isWrappable);return 1!==h.length?new vs:vs.fromVertexData(h[0].message,o)}_abortProcessingGraphic(t){this._graphicIdToAbortController.has(t)&&this._graphicIdToAbortController.get(t).abort()}_getNullSymbol(t){const s=t.geometry;return T(s)?G:C(s)||z(s)?R:O}_flipUpdatingGraphics(){this._updatingGraphicsTimer&&clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=setTimeout((()=>{this._updatingGraphicsTimer=null,this.notifyChange("updating")}),160),this.notifyChange("updating")}};c([a({constructOnly:!0})],Us.prototype,"requestUpdateCallback",void 0),c([a()],Us.prototype,"container",void 0),c([a({constructOnly:!0})],Us.prototype,"graphics",void 0),c([a()],Us.prototype,"updating",null),c([a()],Us.prototype,"view",void 0),c([a()],Us.prototype,"updateRequested",void 0),Us=c([l("esri.views.2d.layers.support.GraphicsView2D")],Us);const Ls=Us,Ss=Math.PI/180;class Gs extends Ht{constructor(t){super(),this._dvsMat3=kt(),this._localOrigin={x:0,y:0},this._getBounds=t}destroy(){this._vao&&(this._vao.dispose(!0),this._vao=null,this._vertexBuffer=null,this._indexBuffer=null),this._program&&(this._program.dispose(),this._program=null)}doRender(t){const{context:s}=t,i=this._getBounds();if(i.length<1)return;this._createShaderProgram(s),this._updateMatricesAndLocalOrigin(t),this._updateBufferData(s,i),s.setBlendingEnabled(!0),s.setDepthTestEnabled(!1),s.setStencilWriteMask(0),s.setStencilTestEnabled(!1),s.setBlendFunction(1,771),s.setColorMask(!0,!0,!0,!0);const e=this._program;s.bindVAO(this._vao),s.useProgram(e),e.setUniformMatrix3fv("u_dvsMat3",this._dvsMat3),s.gl.lineWidth(1),s.drawElements(1,8*i.length,5125,0),s.bindVAO()}_createTransforms(){return{dvs:kt()}}_createShaderProgram(t){this._program||(this._program=new tt(t,"precision highp float;\n        uniform mat3 u_dvsMat3;\n\n        attribute vec2 a_position;\n\n        void main() {\n          mediump vec3 pos = u_dvsMat3 * vec3(a_position, 1.0);\n          gl_Position = vec4(pos.xy, 0.0, 1.0);\n        }","precision mediump float;\n      void main() {\n        gl_FragColor = vec4(0.75, 0.0, 0.0, 0.75);\n      }",Rs().attributes))}_updateMatricesAndLocalOrigin(t){const{state:s}=t,{displayMat3:i,size:e,resolution:n,pixelRatio:r,rotation:o,viewpoint:h}=s,c=Ss*o,{x:a,y:l}=h.targetGeometry,u=Ct(a,s.spatialReference);this._localOrigin.x=u,this._localOrigin.y=l;const f=r*e[0],d=r*e[1],p=n*f,m=n*d,w=St(this._dvsMat3);Gt(w,w,i),Rt(w,w,Et(f/2,d/2)),Ot(w,w,qt(e[0]/p,-d/m,1)),Vt(w,w,-c)}_updateBufferData(t,s){const{x:i,y:e}=this._localOrigin,n=new Float32Array(8*s.length),r=new Uint32Array(8*s.length);let o=0,h=0;for(const t of s)n[2*o+0]=t[0]-i,n[2*o+1]=t[1]-e,n[2*o+2]=t[0]-i,n[2*o+3]=t[3]-e,n[2*o+4]=t[2]-i,n[2*o+5]=t[3]-e,n[2*o+6]=t[2]-i,n[2*o+7]=t[1]-e,r[h+0]=o+0,r[h+1]=o+3,r[h+2]=o+3,r[h+3]=o+2,r[h+4]=o+2,r[h+5]=o+1,r[h+6]=o+1,r[h+7]=o+0,o+=4,h+=8;if(this._vertexBuffer?this._vertexBuffer.setData(n.buffer):this._vertexBuffer=$.createVertex(t,35048,n.buffer),this._indexBuffer?this._indexBuffer.setData(r):this._indexBuffer=$.createIndex(t,35048,r),!this._vao){const s=Rs();this._vao=new W(t,s.attributes,s.bufferLayouts,{geometry:this._vertexBuffer},this._indexBuffer)}}}const Rs=()=>J("bounds",{geometry:[{location:0,name:"a_position",count:2,type:5126}]});class Os extends et{constructor(t){super(t),this.hasHighlight=()=>!0}destroy(){super.destroy(),this._boundsRenderer&&(this._boundsRenderer.destroy(),this._boundsRenderer=null)}enableRenderingBounds(t){this._boundsRenderer=new Gs(t),this.requestRender()}get hasLabels(){return!1}onTileData(t,s){t.patch(s),this.contains(t)||this.addChild(t),this.requestRender()}onTileError(t){t.clear(),this.contains(t)||this.addChild(t)}_renderChildren(t,s){for(const i of this.children)i.isReady&&i.hasData&&(i.commit(t),t.context.setStencilFunction(514,i.stencilRef,255),i._displayList.replay(t,i,s))}}export{Ls as r,Os as t}