import{e as t,d as s,i as e,aE as i,r,u as h,ai as n,A as a,a as o,V as l,p as u,af as c,F as d,G as p,a0 as m,dk as f,aW as g}from"./p-e58503d5.js";import{t as v,v as w,g as y,f as L,l as b,_,e as M,a as S,b as x}from"./p-b9873014.js";import{e as C}from"./p-e06536a7.js";import{B as A,f as j}from"./p-ea916a39.js";import{l as z,g as P,x as V,p as O}from"./p-ab86fcff.js";import{E as D,B as R,c as G,a8 as E,z as q,q as I,o as F,u as W,d as U,r as k,a as T,_ as $,g as B,v as H,M as N}from"./p-2f398ed1.js";import{i as J,p as X}from"./p-5d962998.js";import{D as K,K as Q,J as Y,O as Z,E as tt,p as st,d as et,a as it,R as rt}from"./p-01e5a461.js";import{j as ht,r as nt,c as at}from"./p-ccdb8e80.js";import{e as ot}from"./p-2c84c65f.js";import{n as lt}from"./p-d3105731.js";import{c as ut,m as ct}from"./p-c96ccdbf.js";import{r as dt,n as pt}from"./p-4d38e149.js";import{n as mt,t as ft,a as gt,J as vt,h as wt,e as yt,b as Lt,c as bt,d as _t,o as Mt,k as St,X as xt,a7 as Ct,f as At,aa as jt,av as zt,ar as Pt,ad as Vt,a0 as Ot}from"./p-eb48bb01.js";import{aH as Dt,aW as Rt,aS as Gt,i as Et}from"./p-340cd100.js";import{g as qt,c as It,b as Ft,l as Wt,f as Ut,r as kt,e as Tt}from"./p-bdf9e611.js";import{I as $t,w as Bt,c as Ht,t as Nt,$ as Jt,m as Xt,b as Kt}from"./p-c93d2280.js";import{x as Qt}from"./p-97ec6ae5.js";import{r as Yt,d as Zt}from"./p-e6fe5d89.js";import{n as ts}from"./p-746a9d8f.js";import{geodesicArea as ss}from"./p-2f16d655.js";import{v as es}from"./p-b79fcce3.js";import{R as is}from"./p-df35b79d.js";import{_ as rs,b as hs,g as ns}from"./p-6ded4c02.js";let as=class extends r.EventedAccessor{constructor(t={}){super(t),this._handles=new h,this._version=0,this._internalGeometryChange=!1,this._extent=A()}destroy(){this._handles=n(this._handles)}set areaMeasurement(t){this._set("areaMeasurement",t),a(t)&&a(this.view)&&this._initialize(t,this.view)}set view(t){this._set("view",t),a(t)&&a(this.areaMeasurement)&&this._initialize(this.areaMeasurement,t)}get initialized(){return a(this.areaMeasurement)&&a(this.view)}get version(){return this._version}get isValidPolygon(){return this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].isClosed()}get extent(){if(this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].vertices.length>0){const t=A(this._extent);return this.forEachVertex((s=>{j(t,s.pos)})),t}return null}get spatialReference(){return this.initialized?this.editGeometry.coordinateHelper.spatialReference:null}_initialize(t,s){this._handles.removeAll(),this._handles.add(o(t,"geometry",(()=>this._updateEditGeometryFromModelGeometry(t,s)),!0)),this._makeDirty(!0)}_makeDirty(t=!1){this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),this.notifyChange("extent"),t&&this.notifyChange("numVertices")}_updateEditGeometryFromModelGeometry(t,s){this._version++,this._internalGeometryChange||(this._handles.remove("EditGeometry"),this._editGeometryOperations=a(t.geometry)?z.fromGeometry(t.geometry,s.state.viewingMode):new z(new P("polygon",V(!0,!1,s.spatialReference),s.state.viewingMode)),this._makeDirty(!0),this.emit("change"),this._handles.add(this.editGeometry.on("change",(s=>{this._makeDirty(null!=s.addedVertices||null!=s.removedVertices),this._internalGeometryChange=!0,t.geometry=this.numVertices>0?this.editGeometry.geometry:null,this._internalGeometryChange=!1})),"EditGeometry"))}get editGeometry(){return this._editGeometryOperations.data}get vertices(){const t=[];return this.forEachVertex((s=>{t.push(s)})),t}get numVertices(){return this.initialized&&this.editGeometry.components.length>0?this.editGeometry.components[0].vertices.length:0}get lastPoint(){if(this.initialized&&this.editGeometry.components.length>0){const t=this.editGeometry.components[0].getLastVertex();if(a(t))return this.editGeometry.coordinateHelper.vectorToPoint(t.pos)}return null}getVertex(t){if(!this.initialized||0===this.editGeometry.components.length||0===this.editGeometry.components[0].vertices.length)return null;const s=this.editGeometry.components[0].vertices[0];let e=s;do{if(e.index===t)return e;e=e.rightEdge.rightVertex}while(e!==s&&null!=e);return null}getVertexPositionAsPoint(t){return this.editGeometry.coordinateHelper.vectorToPoint(t.pos)}getVertexPositionAsPointFromIndex(t){return this.editGeometry.coordinateHelper.vectorToPoint(this.getVertex(t).pos)}forEachVertex(t){this.initialized&&this.editGeometry.components.length>0&&this.editGeometry.components[0].iterateVertices(t)}forEachVertexPosition(t){const s=this.editGeometry.coordinateHelper;this.forEachVertex(((e,i)=>{s.vectorToPoint(e.pos,os),t(os,i)}))}clear(){a(this.areaMeasurement)&&(this.areaMeasurement.geometry=null)}add(t){if(!this.initialized)return null;if(0===this.editGeometry.components.length){const t=l(this.view);this.editGeometry.components.push(new O(t.spatialReference,t.state.viewingMode))}const s=this._editGeometryOperations.appendVertex(this.editGeometry.coordinateHelper.pointToVector(t));return this.emit("change"),s}close(){if(!this.initialized||0===this.editGeometry.components.length)return null;const t=this._editGeometryOperations.closeComponent(this.editGeometry.components[0]);return this.emit("change"),t}ensureContains(t,s=""){let e=!1;if(this.editGeometry.components.forEach((s=>{s.iterateVertices((s=>{s===t&&(e=!0)}))})),!e)throw new Error(`vertex doesnt exist ${s}`);return e}setVertexPosition(t,s){if(!this.initialized)return null;const e=this._editGeometryOperations.setVertexPosition(t,this.editGeometry.coordinateHelper.pointToVector(s));return this.emit("change"),e}equals(t){if(this.numVertices!==t.numVertices)return!1;let s=!0;return this.forEachVertexPosition(((e,i)=>{const r=t.getVertexPositionAsPointFromIndex(i);e.equals(r)||(s=!1)})),!!s}};t([s({value:null})],as.prototype,"areaMeasurement",null),t([s({value:null})],as.prototype,"view",null),t([s()],as.prototype,"isValidPolygon",null),t([s()],as.prototype,"extent",null),t([s()],as.prototype,"spatialReference",null),t([s()],as.prototype,"numVertices",null),as=t([e("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurement3DPathHelper")],as);const os=new i;let ls=class extends u{constructor(){super(...arguments),this.measurementData=null,this.unitNormalizer=new v,this.path=new as,this.lastDraggedVertex=null,this.mode=0}destroy(){this.measurementData=null,this.path=n(this.path)}get validMeasurement(){return this.path.isValidPolygon}};function us(t){const s=new mt;return s.extensions.add("GL_OES_standard_derivatives"),s.attributes.add("position","vec3"),s.attributes.add("uv0","vec2"),s.vertex.uniforms.add("proj","mat4").add("view","mat4"),s.varyings.add("vUV","vec2"),t.multipassTerrainEnabled&&s.varyings.add("depth","float"),s.vertex.code.add(ft`
    void main(void) {
      vUV = uv0;
      ${t.multipassTerrainEnabled?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),t.multipassTerrainEnabled&&(s.fragment.include(gt),s.include(vt,t)),s.fragment.uniforms.add("size","vec2").add("color1","vec4").add("color2","vec4"),s.fragment.include(wt),s.fragment.code.add(ft`
    void main() {
      ${t.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      gl_FragColor = mix(color2, color1, t);
      ${t.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    }
  `),s}t([s()],ls.prototype,"measurementData",void 0),t([s()],ls.prototype,"validMeasurement",null),t([s()],ls.prototype,"unitNormalizer",void 0),t([s()],ls.prototype,"path",void 0),t([s()],ls.prototype,"lastDraggedVertex",void 0),t([s()],ls.prototype,"cursorPoint",void 0),t([s()],ls.prototype,"mode",void 0),ls=t([e("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementView3DData")],ls);const cs=Object.freeze({__proto__:null,build:us});class ds extends bt{initializeProgram(t){const s=ds.shader.get(),e=this.configuration,i=s.build({OITEnabled:0===e.transparencyPassType,multipassTerrainEnabled:e.multipassTerrainEnabled,cullAboveGround:e.cullAboveGround});return new _t(t.rctx,i,Mt)}bindPass(t,s){St(this.program,s.camera.projectionMatrix),this.program.setUniform2fv("size",t.size),this.program.setUniform4fv("color1",t.color1),this.program.setUniform4fv("color2",t.color2),s.multipassTerrainEnabled&&(this.program.setUniform2fv("cameraNearFar",s.camera.nearFar),this.program.setUniform2fv("inverseViewport",s.inverseViewport),xt(this.program,s))}bindDraw(t){Ct(this.program,t)}setPipelineState(t){const s=this.configuration,e=3===t,i=2===t;return qt({blending:s.transparent?e?ms:It(t):null,depthTest:{func:Ft(t)},depthWrite:e?s.writeDepth&&Wt:Ut(t),colorWrite:kt,polygonOffset:e||i?s.polygonOffset&&ps:{factor:-1,units:-25}})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}ds.shader=new At(cs,(()=>import("./p-797fa8cc.js")));const ps={factor:0,units:-25},ms=Tt(770,1,771,771);class fs extends Lt{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}t([yt()],fs.prototype,"transparent",void 0),t([yt()],fs.prototype,"writeDepth",void 0),t([yt()],fs.prototype,"polygonOffset",void 0),t([yt({count:4})],fs.prototype,"transparencyPassType",void 0),t([yt()],fs.prototype,"multipassTerrainEnabled",void 0),t([yt()],fs.prototype,"cullAboveGround",void 0);class gs extends jt{constructor(t){super(t,ws),this.techniqueConfig=new fs}dispose(){}getPassParameters(){return this.parameters}getTechniqueConfig(t,s){return this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.polygonOffset=this.parameters.polygonOffset,this.techniqueConfig.transparencyPassType=s?s.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!s&&s.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!s&&s.cullAboveGround,this.techniqueConfig}intersect(t,s,e,i,r,h,n){return zt(t,s,i,r,h,void 0,n)}requiresSlot(t){let s=2;return this.parameters.transparent&&(s=this.parameters.writeDepth?4:7),t===s||20===t}createGLMaterial(t){return 0===t.output||7===t.output?new vs(t):null}createBufferWriter(){return new Dt(Rt)}}class vs extends Pt{updateParameters(t){return this.ensureTechnique(ds,t)}beginSlot(t){return this.updateParameters(t)}bind(t,s){s.bindPass(this._material.getPassParameters(),t)}}const ws={size:[1,1],color1:[.75,.75,.75,1],color2:[.5,.5,.5,1],transparent:!1,writeDepth:!0,polygonOffset:!1,...Vt};class ys extends ut{constructor(t){super(t),this._checkerBoardMaterial=null,this._renderOccluded=4,this._geometry=null,this._size=[1,1],this._color1=dt(1,.5,0,.5),this._color2=dt(1,1,1,.5),this.applyProps(t)}get renderOccluded(){return this._renderOccluded}set renderOccluded(t){t!==this._renderOccluded&&(this._renderOccluded=t,this.updateMaterial())}get geometry(){return this._geometry}set geometry(t){this._geometry=t,this.geometryChanged()}get size(){return this._size}set size(t){this._size=t,this.updateMaterial()}get color1(){return this._color1}set color1(t){D(t,this._color1)||(R(this._color1,t),this.updateMaterial())}get color2(){return this._color2}set color2(t){D(t,this._color2)||(R(this._color2,t),this.updateMaterial())}updateMaterial(){a(this._checkerBoardMaterial)&&this._checkerBoardMaterial.setParameters({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded})}createExternalResources(){this._checkerBoardMaterial=new gs({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:4})}destroyExternalResources(){this._checkerBoardMaterial=null}forEachExternalMaterial(t){a(this._checkerBoardMaterial)&&t(this._checkerBoardMaterial)}createGeometries(t){if(c(this._geometry)||c(this._checkerBoardMaterial))return;const s=Ls;ht(s,this.transform);const e=this._geometry,i=[],r=lt();e.position.forEach((t=>{G(r,t,s),i.push(r[0],r[1],r[2])}));const h=[];e.uv.forEach((t=>{h.push(t[0],t[1])}));const n=new Ot([["position",{size:3,data:i,exclusive:!0}],["uv0",{size:2,data:h,exclusive:!0}]],[["position",e.triangleIndices],["uv0",e.triangleIndices]]);t.addGeometry(n,this._checkerBoardMaterial)}geometryChanged(){this.recreateGeometry()}}const Ls=lt();let bs=class extends u{constructor(t){super(t),this._handles=new h,this._params={..._s},this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._pathLengthLabel=null,this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._cursorSegment=null,this._origin=lt(),this._originTransform=ot(),this._cursorPositionRenderSpace=lt(),this.messages=null,this.viewData=Ms,this.areaLabel=null,this.perimeterLengthLabel=null,this.loadingMessages=!0}get visible(){return this.analysisView.visible}get testData(){return{labels:{area:this._areaLabel,pathLength:this._pathLengthLabel,cursorSegmentLength:this._cursorSegmentLengthLabel,perimeterLength:this._perimeterLengthLabel}}}initialize(){const t=this.view,s=this._params;this._path=new ct({view:t,attached:!0,width:s.pathLineWidth,color:s.pathLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPath=new ct({view:t,attached:!0,width:s.pathLineWidth,color:s.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._perimeter=new ct({view:t,attached:!0,width:s.perimeterLineWidth,color:s.perimeterLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPerimeter=new ct({view:t,attached:!0,width:s.perimeterLineWidth,color:s.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._projectionLines=new ct({view:t,attached:!0,width:s.projectionLineWidth,color:s.projectionLineColor,stipplePattern:Gt(s.projectionLineStippleSize),stippleIntegerRepeats:!1,polygonOffset:!0,renderOccluded:4}),this._measurementArea=new ys({view:t,attached:!0,color1:s.areaColor1,color2:s.areaColor2}),this._areaLabel=new w({view:this.view,attached:!0,fontSize:16}),this._pathLengthLabel=new w({view:t,attached:!0,fontSize:12}),this._cursorSegmentLengthLabel=new w({view:t,attached:!0,fontSize:12}),this._perimeterLengthLabel=new w({view:t,attached:!0,fontSize:12});const e=this.analysisView.analysisViewData;this._handles.add([J((()=>[e.mode,this.visible,this.analysisView.unit,e.measurementData,e.cursorPoint]),(()=>this._update()),X),J((()=>{var s;return null==(s=t.state)?void 0:s.camera}),(()=>this._updateLabels()),X),d((async()=>this._updateMessageBundle()))]),this._updateMessageBundle()}destroy(){this._measurementArea=n(this._measurementArea),this._path=n(this._path),this._intersectedPath=n(this._intersectedPath),this._perimeter=n(this._perimeter),this._intersectedPerimeter=n(this._intersectedPerimeter),this._areaLabel=n(this._areaLabel),this._pathLengthLabel=n(this._pathLengthLabel),this._cursorSegmentLengthLabel=n(this._cursorSegmentLengthLabel),this._perimeterLengthLabel=n(this._perimeterLengthLabel),this._handles=n(this._handles),this.set("view",null)}_update(){if(this.destroyed)return;const t=this.analysisView.analysisViewData.measurementData;c(t)||(this._updateViewData(t,this.analysisView.analysisViewData.path,this.analysisView.analysisViewData.cursorPoint),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels())}_updateViewData(t,s,e){const i=s.isValidPolygon,r="geodesic"===t.actualMeasurementMode,h=r?t.geodesicArea:t.area;let n=1;if(h){const s=this._toPreferredAreaUnit(h,this.analysisView.unit);n=E(Math.sqrt(s.value)/Math.sqrt(300)),n*=Math.sqrt(K(1,s.unit,"square-meters")),n/=t.unitNormalizer.normalizeDistance(1)}this._set("viewData",{validMeasurement:i,path:s,pathVersion:s.version,cursorPoint:e,measurementData:t,mode:t.actualMeasurementMode,positionsGeographic:t.positionsGeographic,positionsRenderCoords:t.positionsRenderCoords,positionsProjected:t.positionsProjectedWorldCoords,positionsFittedRenderCoords:t.positionsFittedRenderCoords,intersectingSegments:r?t.geodesicIntersectingSegments:t.intersectingSegments,triangleIndices:r?t.geodesicTriangleIndices:t.triangleIndices,fittingMode:t.fittingMode,areaCentroid:r?t.geodesicAreaCentroidRenderCoords:t.areaCentroidRenderCoords,pathLengthLabelSegmentIndex:i?0:s.numVertices-2,perimeterLengthLabelSegmentIndex:0,checkerSize:n})}_updateOrigin(){y(this.viewData.positionsRenderCoords,this._origin),nt(this._originTransform),at(this._originTransform,this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform}_createSegments(t){const s=this.viewData,e=s.path,i=this.view.renderCoordsHelper.spatialReference,r=s.mode,h=[],n=[],a=[],o=s.validMeasurement?e.numVertices:e.numVertices-1;for(let l=0;l<o;++l){const o=s[t][l],u=s[t][(l+1)%e.numVertices];let c=null;switch(r){case"euclidean":c=new _(o,u);break;case"geodesic":c=new L(o,u,i)}s.intersectingSegments.has(l)?a.push(c):n.push(c),h.push(c)}return{all:h,nonIntersecting:n,intersecting:a}}_updatePathSegments(){const t=this.visible,s=this.viewData,e=this._createSegments("positionsRenderCoords"),i=s.path,r=!i.isValidPolygon,h=s.cursorPoint,n=this.view.renderCoordsHelper,o=n.spatialReference,l=s.mode;if(this._cursorSegment=null,i.numVertices>0&&r&&a(h)&&n.toRenderCoords(h,this._cursorPositionRenderSpace)){const t=s.positionsRenderCoords[i.numVertices-1],r=this._cursorPositionRenderSpace;let h=null;switch(l){case"euclidean":h=new _(t,r);break;case"geodesic":h=new L(t,r,o)}e.nonIntersecting.push(h),this._cursorSegment=h}this._path.setGeometryFromSegments(e.nonIntersecting,this._origin),this._path.visible=t,this._intersectedPath.setGeometryFromSegments(e.intersecting,this._origin),this._intersectedPath.visible=t,this._pathSegments=e.all}_updatePerimeterSegments(){const t=this.visible&&"euclidean"===this.viewData.mode,s=this._createSegments("positionsFittedRenderCoords");this._perimeter.setGeometryFromSegments(s.nonIntersecting,this._origin),this._perimeter.visible=t,this._intersectedPerimeter.setGeometryFromSegments(s.intersecting,this._origin),this._intersectedPerimeter.visible=t,this._perimeterSegments=s.all}_updateArea(){const t=this.viewData;switch(t.mode){case"euclidean":this._updateAreaEuclidean(t);break;case"geodesic":this._updateAreaGeodesic()}}_updateAreaEuclidean(t){const s=this.visible;t.validMeasurement&&0===t.intersectingSegments.size&&t.triangleIndices?(this._measurementArea.geometry={uv:t.positionsProjected,position:t.positionsFittedRenderCoords,triangleIndices:t.triangleIndices},this._measurementArea.size=[t.checkerSize,t.checkerSize],this._measurementArea.visible=s):this._measurementArea.visible=!1}_updateAreaGeodesic(){this._measurementArea.visible=!1}_updateProjectionLines(){const t=this.viewData,s=this.visible,e=t.path;if(e.numVertices>0&&t.validMeasurement&&"euclidean"===t.mode){const i=[];for(let s=0;s<e.numVertices;++s){const e=lt();G(e,t.positionsRenderCoords[s],this._origin);const r=lt();G(r,t.positionsFittedRenderCoords[s],this._origin),i.push([e,r])}this._projectionLines.geometry=i,this._projectionLines.visible=s}else this._projectionLines.geometry=null,this._projectionLines.visible=!1}_updateLabels(){if(this.destroyed)return;const t=this.viewData,s=t.path;if(!s)return;const e=t.measurementData,i=t.mode,r=!s.isValidPolygon,h=this.visible,n=this._formatAreaLabel(this.messages,"geodesic"===i?e.geodesicArea:e.area,this.analysisView.unit);a(n)?(this._areaLabel.geometry={type:"point",point:t.areaCentroid},this._areaLabel.text=n,this._areaLabel.visible=t.validMeasurement&&0===t.intersectingSegments.size&&h):this._areaLabel.visible=!1,this._set("areaLabel",l(n));const o=this._formatLengthLabel(this.messages,"geodesic"===i?e.geodesicPathLength:e.pathLength,this.analysisView.unit);if(a(o)&&t.pathLengthLabelSegmentIndex>=0&&t.pathLengthLabelSegmentIndex<this._pathSegments.length){const e=this._pathSegments[t.pathLengthLabelSegmentIndex],i=a(this._cursorSegment)?this._cursorSegment:Ss;this._pathLengthLabel.distance=this._params.labelDistance,this._pathLengthLabel.geometry={type:"corner",left:e,right:i},this._pathLengthLabel.text=o,this._pathLengthLabel.visible=r&&s.numVertices>0&&h}else this._pathLengthLabel.visible=!1;const u="geodesic"===i?t.measurementData.geodesicCursorSegmentLength:t.measurementData.cursorSegmentLength;if(a(u)){const t=this._formatLengthLabel(this.messages,u,this.analysisView.unit);this._cursorSegmentLengthLabel.distance=this._params.labelDistance,this._cursorSegmentLengthLabel.geometry=a(this._cursorSegment)?{type:"segment",segment:this._cursorSegment,sampleLocation:"end"}:null,this._cursorSegmentLengthLabel.anchor="bottom",this._cursorSegmentLengthLabel.text=l(t),this._cursorSegmentLengthLabel.visible=r&&0!==u.value&&h}else this._cursorSegmentLengthLabel.visible=!1;this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel)&&(this._cursorSegmentLengthLabel.visible=!1),this._pathLengthLabel.overlaps(this._areaLabel)&&(this._pathLengthLabel.visible=!1);const c="geodesic"===t.mode,d=c?e.geodesicPathLength:e.perimeterLength,p=l(null!=d?this._formatLengthLabel(this.messages,d,this.analysisView.unit):null);if(this._set("perimeterLengthLabel",l(p)),t.validMeasurement&&0===t.intersectingSegments.size){this._perimeterLengthLabel.distance=this._params.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=p,this._perimeterLengthLabel.visible=!0;let s=!0;for(let e=0;e<t.path.numVertices;++e){const i=(t.perimeterLengthLabelSegmentIndex+e)%t.path.numVertices;if(s=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:c?this._pathSegments[i]:this._perimeterSegments[i],sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;s=!1}this._perimeterLengthLabel.visible=s&&h}else this._perimeterLengthLabel.visible=!1}_toPreferredAreaUnit(t,s){return t.toUnit(this._preferredAreaUnit(t,s))}_preferredAreaUnit(t,s){switch(s){case"metric":return Y(t.value,t.unit);case"imperial":return Q(t.value,t.unit);default:return s}}_preferredLengthUnit(t,s){const e=this._deriveLengthUnitFromAreaUnit(s);switch(e){case"metric":return tt(t.value,t.unit);case"imperial":return Z(t.value,t.unit);default:return e}}_deriveLengthUnitFromAreaUnit(t){switch(t){case"metric":case"ares":case"hectares":return"metric";case"imperial":case"acres":return"imperial";case"square-inches":return"inches";case"square-feet":return"feet";case"square-yards":return"yards";case"square-miles":return"miles";case"square-us-feet":return"us-feet";case"square-millimeters":return"millimeters";case"square-centimeters":return"centimeters";case"square-decimeters":return"decimeters";case"square-meters":return"meters";case"square-kilometers":return"kilometers"}throw new Error("unhandled area unit")}_formatAreaLabel(t,s,e){return t&&s&&b(t,s,this._preferredAreaUnit(s,e))}_formatLengthLabel(t,s,e){return t&&s&&b(t,s,this._preferredLengthUnit(s,e))}_updateMessageBundle(){this.loadingMessages=!0,p("esri/core/t9n/Units").then((t=>{this.messages=t,this.view&&this._update()})).finally((()=>{this.loadingMessages=!1}))}};t([s()],bs.prototype,"view",void 0),t([s()],bs.prototype,"messages",void 0),t([s()],bs.prototype,"analysis",void 0),t([s()],bs.prototype,"viewData",void 0),t([s()],bs.prototype,"analysisView",void 0),t([s({readOnly:!0})],bs.prototype,"areaLabel",void 0),t([s({readOnly:!0})],bs.prototype,"perimeterLengthLabel",void 0),t([s()],bs.prototype,"loadingMessages",void 0),t([s()],bs.prototype,"visible",null),bs=t([e("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementVisualization")],bs);const _s={laserLineGlowColor:[1,.5,0],laserLineGlowWidth:8,laserLineGlowFalloff:8,laserLineInnerColor:[1,1,1],laserLineInnerWidth:1,laserLineGlobalAlpha:.75,laserLineEnabled:!0,handleColor:[1,.5,0],handleOpacity:.5,handleRadius:5,handleRadiusHovered:10,handleRadiusMouse:10,handleRadiusTouch:25,pathLineColor:[1,.5,0,1],pathLineWidth:3,intersectingLineColor:[1,.2,0,1],perimeterLineColor:[1,.5,0,1],perimeterLineWidth:2,projectionLineColor:[1,.5,0,1],projectionLineWidth:2,projectionLineStippleSize:5,areaColor1:[1,.5,0,.5],areaColor2:[1,1,1,.5],fillColor:[1,.5,0,.5],lineSubdivisions:64,labelDistance:25},Ms={validMeasurement:!1,path:null,pathVersion:-1,cursorPoint:null,measurementData:null,mode:null,positionsGeographic:null,positionsRenderCoords:null,positionsProjected:null,positionsFittedRenderCoords:null,intersectingSegments:null,triangleIndices:null,fittingMode:null,areaCentroid:null,pathLengthLabelSegmentIndex:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null},Ss=new _(lt(),lt());function xs(t,s,e){const i={distance:null};return is(i,[t[0],t[1]],[s[0],s[1]],e),i.distance}function Cs(t,s,e){return.5*Math.abs((s[0]-t[0])*(e[1]-t[1])-(s[1]-t[1])*(e[0]-t[0]))}function As(t,s,e,i){const r=Vs;return $t(t,i,js)&&$t(s,i,zs)&&$t(e,i,Ps)?(r.setPoint(0,0,js),r.setPoint(0,1,zs),r.setPoint(0,2,Ps),Math.abs(ss(r,"square-meters"))):0}const js=lt(),zs=lt(),Ps=lt(),Vs=new es({rings:[[js,zs,Ps]],spatialReference:m.WGS84}),Os=lt();class Ds{constructor(t,s){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=lt(),this.areaCentroidRenderCoords=lt(),this.geodesicAreaCentroidRenderCoords=lt(),this._length=0,this._centroidRenderCoords=lt(),this._planeWorldCoords=pt(),this._worldUp=lt(),this._worldTangent=lt(),this._frame=[lt(),lt(),lt()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=lt(),this._tempV=lt(),this._tempVec3=lt(),this._tempSphere={center:lt(),radius:0},this._sceneView=t,this.unitNormalizer=s}update(t,s,e,i,r,h,n){const o=this.unitNormalizer,l=this._sceneView.renderSpatialReference,u=this.unitNormalizer.spatialReference,c=a(s);if(this._pathVersion===t.version&&this._validMeasurement===i&&!n&&this._hasCursorPoint===c&&this._mode===h)return!1;this._pathVersion=t.version,this._validMeasurement=i,this._hasCursorPoint=c,this._resize(t.numVertices);const d=et(e.spatialReference),p=Nt(e.spatialReference,d)&&Jt(e.spatialReference),m=this.positionsGeographic,f=this.positionsWorldCoords,v=this.positionsRenderCoords,w=this.positionsSpherical;t.forEachVertexPosition(((t,s)=>{(function(t,s){s.hasZ||(s.z=g(Et(t,s,"ground"),0))})(e.elevationProvider,t),Bt(t,f[s],u),Bt(t,v[s],l),p&&(Ht(t,m[s]),Bt(t,w[s],d),T(w[s],w[s]))}));const y=this._updatePathLengths(i);if(this.pathLength=this._length>1?new M(o.normalizeDistance(y),"meters"):null,p){const t=this._updateGeodesicPathLengths(i,u);this.geodesicPathLength=this._length>1?new M(t,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(t,s),this._updateMode(t,h),i?(this._updateArea(e,o,l,u,r),p&&this._updateGeodesicArea(e),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(t){for(t<this._length&&(this.positionsWorldCoords.length=t,this.positionsRenderCoords.length=t,this.positionsProjectedWorldCoords.length=t,this.positionsFittedRenderCoords.length=t,this.positionsGeographic.length=t,this.positionsSpherical.length=t,this.positionsStereographic.length=t,this.pathSegmentLengths.length=t,this.geodesicPathSegmentLengths.length=t,this.perimeterSegmentLengths.length=t,this._length=t);this._length<t;)this.positionsWorldCoords.push(lt()),this.positionsRenderCoords.push(lt()),this.positionsProjectedWorldCoords.push(ts()),this.positionsFittedRenderCoords.push(lt()),this.positionsGeographic.push(lt()),this.positionsSpherical.push(lt()),this.positionsStereographic.push(ts()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(t){const s=this.positionsWorldCoords,e=this.pathSegmentLengths;let i=0;for(let r=0;r<this._length;++r){const h=e[r]=I(s[r],s[(r+1)%this._length]);(r<this._length-1||t)&&(i+=h)}return i}_updateGeodesicPathLengths(t,s){const e=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let r=0;for(let h=0;h<this._length;++h){const n=i[h]=xs(e[h],e[(h+1)%this._length],s);(h<this._length-1||t)&&(r+=n)}return r}_updateArea(t,s,e,i,r){const h=t.renderCoordsHelper,n=this.positionsWorldCoords,a=this.positionsRenderCoords,o=this.positionsProjectedWorldCoords,l=this.positionsFittedRenderCoords,u=this._planeWorldCoords,c=this._centroidRenderCoords;S(a,c),h.worldUpAtPosition(c,this._worldUp),h.worldBasisAtPosition(c,0,this._worldTangent),Xt(c,this._worldUp,e,this._worldUp,i),Xt(c,this._worldTangent,e,this._worldTangent,i),n.length>2&&function(t,s){if(t.length<3)throw new Error("need at least 3 points to fit a plane");rs(t[0],t[1],t[2],s)}(n,u),this.fittingMode=this._selectFittingMode(u,n,this._worldUp,r);let d=0;if("horizontal"===this.fittingMode){let t=-1/0;a.forEach(((s,e)=>{const i=h.getAltitude(a[e]);i>t&&(t=i,d=e)}))}const p=n[d];let m=u,f=this._worldTangent;"horizontal"===this.fittingMode?m=this._worldUp:"vertical"===this.fittingMode&&(m=this._tempVec3,f=this._worldUp,hs(u,this._worldUp,m)),k(this._frame[2],m),hs(f,m,this._frame[0]),$(this._frame[1],this._frame[0],this._frame[2]),H(this._frame[1],this._frame[1]);const g=this._tempVec3,v=this._tempU,w=this._tempV;for(let t=0;t<this._length;++t){const s=o[t],r=l[t];G(g,n[t],p),Yt(s,q(this._frame[0],g),q(this._frame[1],g)),U(v,this._frame[0],s[0]),U(w,this._frame[1],s[1]),W(g,v,w),W(g,g,p),Kt(g,i,r,e)}this.perimeterLength=this._length>0?new M(s.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,S(l,this.areaCentroidRenderCoords),Kt(this.areaCentroidRenderCoords,e,this.areaCentroidWorldCoords,i),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new M(s.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(t){const s=t.renderCoordsHelper,e=this.positionsSpherical,i=this.positionsStereographic,r=this._tempVec3,h=function(t,s=null,e=!0){const i=(t,s)=>{if(0===s[0]&&0===s[1]&&0===s[2])return!1;for(let e=0;e<t.length;++e)if(q(s,t[e])<-1e-6)return!1;return!0};if(0===t.length)return!1;if(1===t.length)return s&&k(s,t[0]),!0;F(Os,0,0,0);for(let s=0;s<t.length;++s)W(Os,Os,t[s]);if(T(Os,Os),i(t,Os))return s&&k(s,Os),!0;if(!e)return!1;for(let e=0;e<t.length;++e)for(let r=0;r<t.length;++r)if(e!==r&&($(Os,t[e],t[r]),T(Os,Os),i(t,Os)))return s&&k(s,Os),!0;return!1}(e,r);if(!h)return void(this.geodesicArea=null);const n=this._tempU,a=this._tempV;ns(r,n,a);for(let t=0;t<this._length;++t){const s=q(e[t],n),h=q(e[t],a),o=q(e[t],r);Yt(i[t],s/o,h/o)}U(r,r,st(t.spatialReference).radius),s.toRenderCoords(r,et(t.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=h&&0===this.geodesicIntersectingSegments.size?new M(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const t=this.positionsProjectedWorldCoords,s=this.perimeterSegmentLengths;let e=0;for(let i=0;i<this._length;++i)e+=s[i]=Zt(t[i],t[(i+1)%this._length]);return e}_updateIntersectingSegments(){const t=this.positionsProjectedWorldCoords,s=this.intersectingSegments;s.clear();for(let e=0;e<this._length;++e)for(let i=e+2;i<this._length;++i)(i+1)%this._length!==e&&f(t[e],t[(e+1)%this._length],t[i],t[(i+1)%this._length])&&(s.add(e),s.add(i))}_computeArea(){const t=this.positionsProjectedWorldCoords,s=Rs(t,2),e=this.triangleIndices=new Uint32Array(Qt(s,[],2));let i=0;for(let s=0;s<e.length;s+=3)i+=Cs(t[e[s]],t[e[s+1]],t[e[s+2]]);return i}_updateGeodesicIntersectingSegments(){const t=this.positionsStereographic,s=this.geodesicIntersectingSegments;s.clear();for(let e=0;e<this._length;++e)for(let i=e+2;i<this._length;++i)(i+1)%this._length!==e&&f(t[e],t[(e+1)%this._length],t[i],t[(i+1)%this._length])&&(s.add(e),s.add(i))}_computeGeodesicArea(){const t=this.positionsGeographic,s=Rs(this.positionsStereographic,2),e=this.geodesicTriangleIndices=new Uint32Array(Qt(s,[],2));let i=0;for(let s=0;s<e.length;s+=3)i+=As(t[e[s]],t[e[s+1]],t[e[s+2]],m.WGS84);return i}_selectFittingMode(t,s,e,i){const r=s.map((s=>Math.abs(function(t,s){return q(t,s)+t[3]}(t,s)))).reduce(((t,s)=>Math.max(t,s)),0);!function(t,s){const e=s.center;F(e,0,0,0);for(let s=0;s<t.length;++s)W(e,e,t[s]);U(e,e,1/t.length);let i=0;for(let s=0;s<t.length;++s)i=Math.max(i,B(e,t[s]));s.radius=Math.sqrt(i)}(s,this._tempSphere);const h=r/(2*this._tempSphere.radius);let n="horizontal";return h<i.maxRelativeErrorCoplanar?n="oblique":h<i.maxRelativeErrorAlmostCoplanar&&(n=Math.abs(q(e,t))>Math.cos(N(i.verticalAngleThreshold))?"horizontal":"vertical"),n}_updateCursorSegmentLength(t,s){const e=t.lastPoint;!t.isValidPolygon&&a(e)&&a(s)?(this.geodesicCursorSegmentLength=new M(function(t,s){if(!Ht(t,js)||!Ht(s,zs))return 0;const e={distance:null};return is(e,[js[0],js[1]],[zs[0],zs[1]]),e.distance}(e,s),"meters"),this.cursorSegmentLength=new M(this.unitNormalizer.normalizeDistance(function(t,s,e){return Bt(t,js,e)&&Bt(s,zs,e)?I(js,zs):0}(e,s,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null)}_updateMode(t,s){if(0===s){this.actualMeasurementMode="euclidean";let s=0;null!=this.geodesicPathLength&&(s+=this.geodesicPathLength.value),!t.isValidPolygon&&a(this.geodesicCursorSegmentLength)&&(s+=this.geodesicCursorSegmentLength.value),s>Gs&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=1===s?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=s}}function Rs(t,s){const e=new Float64Array(t.length*s);for(let i=0;i<t.length;++i){const r=t[i];for(let t=0;t<s;++t)e[i*s+t]=r[t]}return e}const Gs=1e5;let Es=class extends u{constructor(t){super(t),this._handles=new h}initialize(){const t=this.view.spatialReference,s=et(t),e=s===it?rt:s,i=!t||Nt(t,e)?e:t,r=new v(i);this._measurementDataManager=new Ds(this.view,r),this._handles.add([this.analysisViewData.path.on("change",(()=>this._update())),this.analysisViewData.watch("cursorPoint",(()=>this._update()),!0),this.analysisViewData.watch("mode",(()=>this._update()),!0)]),this._update()}destroy(){this._handles=n(this._handles)}_update(t=!1){const s=this.analysisViewData;if(this._measurementDataManager.update(s.path,s.cursorPoint,this.view,s.validMeasurement,{maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80},s.mode,t)){const t=this._measurementDataManager.getData();this._set("measurementData",t),s.measurementData=t}}};t([s({constructOnly:!0})],Es.prototype,"view",void 0),t([s({constructOnly:!0})],Es.prototype,"analysis",void 0),t([s({readOnly:!0})],Es.prototype,"measurementData",void 0),t([s({constructOnly:!0})],Es.prototype,"analysisViewData",void 0),Es=t([e("esri.views.3d.analysis.AreaMeasurement.support.AreaMeasurementController")],Es);let qs=class extends(C(u)){constructor(t){super(t),this.type="area-measurement-view-3d",this.analysisViewData=new ls}initialize(){this.analysisViewData.path.view=this.view,this.analysisViewData.path.areaMeasurement=this.analysis,this.analysisVisualization=new bs({view:this.view,analysis:this.analysis,analysisView:this}),this.analysisController=new Es({view:this.view,analysis:this.analysis,analysisViewData:this.analysisViewData})}destroy(){this.analysisController=n(this.analysisController),this.analysisVisualization=n(this.analysisVisualization),this.analysisViewData=n(this.analysisViewData)}get updating(){var t;return!(null==(t=this.analysisVisualization)||!t.loadingMessages)}get result(){const t=this.analysisViewData.measurementData;return a(t)?"euclidean"===t.actualMeasurementMode?{area:t.area,pathLength:t.perimeterLength,mode:"euclidian"}:{area:t.geodesicArea,pathLength:t.pathLength,mode:"geodesic"}:{area:null,mode:null,pathLength:null}}get unit(){return g(this.analysis.unit,this._defaultUnit)}get testData(){return{visualization:this.analysisVisualization,controller:this.analysisController}}};t([s()],qs.prototype,"type",void 0),t([s()],qs.prototype,"analysis",void 0),t([s()],qs.prototype,"updating",null),t([s()],qs.prototype,"analysisVisualization",void 0),t([s()],qs.prototype,"analysisController",void 0),t([s()],qs.prototype,"result",null),t([s()],qs.prototype,"analysisViewData",void 0),t([s()],qs.prototype,"unit",null),t([s(x)],qs.prototype,"_defaultUnit",void 0),qs=t([e("esri.views.3d.analysis.AreaMeasurement.AreaMeasurementView3D")],qs);const Is=Object.freeze({__proto__:null,get AreaMeasurementView3D(){return qs},default:qs});export{Is as A,us as o}