import{bf as t,r as s,aA as i,b3 as h,ax as r,ay as n,t as e,aI as o,b7 as a,bJ as u,ai as c,k as l,a7 as f}from"./p-9ae46e68.js";import{a9 as M,M as m}from"./p-566b0715.js";import{e as p}from"./p-2b250922.js";import{a as d}from"./p-285c6a34.js";import{u as g}from"./p-81e5b36e.js";import{a as v}from"./p-f42060e0.js";class w{constructor(t=(t=>t.values().next().value)){this._peeker=t,this._items=new Set}get length(){return this._items.size}clear(){this._items.clear()}last(){if(0===this._items.size)return;let t;for(t of this._items);return t}peek(){if(0!==this._items.size)return this._peeker(this._items)}push(t){this.contains(t)||this._items.add(t)}contains(t){return this._items.has(t)}pop(){if(0===this.length)return;const s=this.peek();return this._items.delete(t(s)),s}popLast(){if(0===this.length)return;const s=this.last();return this._items.delete(t(s)),s}remove(t){this._items.delete(t)}filter(t){return this._items.forEach((s=>{t(s)||this._items.delete(s)})),this}}class x{constructor(t,s){this.item=t,this.controller=s,this.promise=null}}class b{constructor(t){this._deferreds=new Map,this._controllers=new Map,this._processingItems=new Map,this._isPaused=!1,this._schedule=null,this._task=null,this.concurrency=1,t.concurrency&&(this.concurrency=t.concurrency),this._queue=new w(t.peeker),this.process=t.process;const i=t.scheduler;t.priority&&s(i)&&(this._task=i.registerTask(t.priority,this))}destroy(){this.clear(),this._schedule&&(this._schedule.remove(),this._schedule=null),this._task&&(this._task.remove(),this._task=null)}get length(){return this._processingItems.size+this._queue.length}abort(t){const s=this._controllers.get(t);s&&s.abort()}clear(){this._queue.clear();const t=[];this._controllers.forEach((s=>t.push(s))),this._controllers.clear(),t.forEach((t=>t.abort())),this._processingItems.clear(),this._cancelNext()}forEach(t){this._deferreds.forEach(((s,i)=>t(i)))}get(t){const s=this._deferreds.get(t);return s?s.promise:void 0}isOngoing(t){return this._processingItems.has(t)}has(t){return this._deferreds.has(t)}pause(){this._isPaused||(this._isPaused=!0,this._cancelNext())}push(t,n){const e=this.get(t);if(e)return e;const o=new AbortController;let u=null;n&&(u=i(n,(()=>o.abort())));const c=()=>{l.remove(),s(u)&&u.remove(),this._deferreds.delete(t),this._controllers.delete(t),this._queue.remove(t),this._processingItems.delete(t),this._scheduleNext()},l=h(o.signal,(()=>{const s=this._processingItems.get(t);s&&s.controller.abort(),c(),f.reject(a())})),f=r();return this._deferreds.set(t,f),this._controllers.set(t,o),f.promise.then(c,c),this._queue.push(t),this._scheduleNext(),f.promise}last(){return this._queue.last()}peek(){return this._queue.peek()}popLast(){return this._queue.popLast()}reset(){const t=[];this._processingItems.forEach((s=>t.push(s))),this._processingItems.clear();for(const s of t)this._queue.push(s.item),s.controller.abort();this._scheduleNext()}resume(){this._isPaused&&(this._isPaused=!1,this._scheduleNext())}takeAll(){const t=[];for(;this._queue.length;)t.push(this._queue.pop());return this.clear(),t}get running(){return!this._isPaused&&this._queue.length>0&&this._processingItems.size<this.concurrency}runTask(t){for(;!t.done&&this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop()),t.madeProgress()}_scheduleNext(){this._task||this._isPaused||this._schedule||(this._schedule=n((()=>{this._schedule=null,this._next()})))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(t,s){this._canProcessFulfillment(t)&&(this._scheduleNext(),this._deferreds.get(t.item).resolve(s))}_processError(t,s){this._canProcessFulfillment(t)&&(this._scheduleNext(),this._deferreds.get(t.item).reject(s))}_canProcessFulfillment(t){return!!this._deferreds.get(t.item)&&this._processingItems.get(t.item)===t}_process(t){if(e(t))return;let s;const i=new AbortController,h=new x(t,i);this._processingItems.set(t,h);try{s=this.process(t,i.signal)}catch(t){this._processError(h,t)}o(s)?(h.promise=s,s.then((t=>this._processResult(h,t)),(t=>this._processError(h,t)))):this._processResult(h,s)}get test(){return{update:t=>this.runTask(t)}}}function _(t,s){return[t,s]}function F(t,s,i){return t[0]=s,t[1]=i,t}const C=new p("0/0/0/0");class T{constructor(t,s,i,h,r,n,e,o,a,u,c,l){this.level=t,this.resolution=s,this.scale=i,this.origin=h,this.first=r,this.last=n,this.size=e,this.norm=o,this.worldStart=a,this.worldEnd=u,this.worldSize=c,this.wrap=l}static create(t,i,h=null){const r=M(t.spatialReference),n=_(t.origin.x,t.origin.y),e=_(t.size[0]*i.resolution,t.size[1]*i.resolution),o=_(-1/0,-1/0),a=_(1/0,1/0),u=_(1/0,1/0);s(h)&&(F(o,Math.max(0,Math.floor((h.xmin-n[0])/e[0])),Math.max(0,Math.floor((n[1]-h.ymax)/e[1]))),F(a,Math.max(0,Math.floor((h.xmax-n[0])/e[0])),Math.max(0,Math.floor((n[1]-h.ymin)/e[1]))),F(u,a[0]-o[0]+1,a[1]-o[1]+1));const{cols:c,rows:l}=i;let f,m,p,d;return!h&&c&&l&&(F(o,0,0),F(a,c-1,l-1),F(u,c,l)),t.isWrappable?(f=_(Math.ceil(Math.round((r.valid[1]-r.valid[0])/i.resolution)/t.size[0]),u[1]),m=_(Math.floor((r.origin[0]-n[0])/e[0]),o[1]),p=_(f[0]+m[0]-1,a[1]),d=!0):(m=o,p=a,f=u,d=!1),new T(i.level,i.resolution,i.scale,n,o,a,u,e,m,p,f,d)}normalizeCol(t){if(!this.wrap)return t;const s=this.worldSize[0];return t<0?s-1-Math.abs((t+1)%s):t%s}denormalizeCol(t,s){return this.wrap?this.worldSize[0]*s+t:t}getWorldForColumn(t){return this.wrap?Math.floor(t/this.worldSize[0]):0}getFirstColumnForWorld(t){return t*this.worldSize[0]+this.first[0]}getLastColumnForWorld(t){return t*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(t){return(t-this.origin[0])/this.norm[0]}getXForColumn(t){return this.origin[0]+t*this.norm[0]}getRowForY(t){return(this.origin[1]-t)/this.norm[1]}getYForRow(t){return this.origin[1]-t*this.norm[1]}getTileBounds(t,s,i=!1){C.set(s);const h=i?C.col:this.denormalizeCol(C.col,C.world),r=C.row;return function(t,s,i,h,r){t[0]=s,t[1]=i,t[2]=h,t[3]=r}(t,this.getXForColumn(h),this.getYForRow(r+1),this.getXForColumn(h+1),this.getYForRow(r)),t}getTileCoords(t,s,i=!1){C.set(s);const h=i?C.col:this.denormalizeCol(C.col,C.world);return Array.isArray(t)?F(t,this.getXForColumn(h),this.getYForRow(C.row)):(t.x=this.getXForColumn(h),t.y=this.getYForRow(C.row)),t}}class S{constructor(){this.spans=[]}acquire(t){this.lodInfo=t}release(){this.lodInfo=null,this.spans.length=0}forEach(t,s){const{spans:i,lodInfo:h}=this,{level:r}=h;if(0!==i.length)for(const{row:n,colFrom:e,colTo:o}of i)for(let i=e;i<=o;i++)t.call(s,r,n,h.normalizeCol(i),h.getWorldForColumn(i))}}S.pool=new u(S);class X{constructor(t,s,i){this.row=t,this.colFrom=s,this.colTo=i}}const Y=new p("0/0/0/0");class y{constructor(t,s,i,h,r,n,e,o){this.x=t,this.ymin=s,this.ymax=i,this.invM=h,this.leftAdjust=r,this.rightAdjust=n,this.leftBound=e,this.rightBound=o}static create(t,s){t[1]>s[1]&&([t,s]=[s,t]);const[i,h]=t,[r,n]=s,e=r-i,o=n-h,a=0!==o?e/o:0,u=(Math.ceil(h)-h)*a,c=(Math.floor(h)-h)*a;return new y(i,Math.floor(h),Math.ceil(n),a,e<0?u:c,e<0?c:u,e<0?r:i,e<0?i:r)}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const I=[[0,0],[0,0],[0,0],[0,0]];class L{constructor(t,s=null){this.tileInfo=t,this.fullExtent=s,this.scales=[],this._lodInfos=null,this._infoByScale={},this._infoByLevel={};const i=t.lods.slice();i.sort((function(t,s){return s.scale-t.scale}));const h=this._lodInfos=i.map((i=>T.create(t,i,s)));i.forEach(((t,s)=>{this._infoByLevel[t.level]=h[s],this._infoByScale[t.scale]=h[s],this.scales[s]=t.scale}),this),this._wrap=t.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(t){return this._infoByLevel["number"==typeof t?t:t.level]}getTileBounds(t,s,i=!1){Y.set(s);const h=this._infoByLevel[Y.level];return h?h.getTileBounds(t,Y,i):t}getTileCoords(t,s,i=!1){Y.set(s);const h=this._infoByLevel[Y.level];return h?h.getTileCoords(t,Y,i):t}getTileCoverage(t,s=192,i="closest"){const h="closest"===i?this.getClosestInfoForScale(t.scale):this.getSmallestInfoForScale(t.scale),r=S.pool.acquire(h),n=this._wrap;let e,o,a,u=1/0,c=-1/0;const l=r.spans;I[0][0]=I[0][1]=I[1][1]=I[3][0]=-s,I[1][0]=I[2][0]=t.size[0]+s,I[2][1]=I[3][1]=t.size[1]+s;for(const s of I)t.toMap(s,s),s[0]=h.getColumnForX(s[0]),s[1]=h.getRowForY(s[1]);const f=[];let M=3;for(let t=0;t<4;t++){if(I[t][1]===I[M][1]){M=t;continue}const s=y.create(I[t],I[M]);u=Math.min(s.ymin,u),c=Math.max(s.ymax,c),void 0===f[s.ymin]&&(f[s.ymin]=[]),f[s.ymin].push(s),M=t}if(null==u||null==c||c-u>100)return null;let m=[];for(e=u;e<c;){null!=f[e]&&(m=m.concat(f[e])),o=1/0,a=-1/0;for(let t=m.length-1;t>=0;t--){const s=m[t];o=Math.min(o,s.getLeftCol()),a=Math.max(a,s.getRightCol())}if(o=Math.floor(o),a=Math.floor(a),e>=h.first[1]&&e<=h.last[1])if(n)if(h.size[0]<h.worldSize[0]){const t=Math.floor(a/h.worldSize[0]);for(let s=Math.floor(o/h.worldSize[0]);s<=t;s++)l.push(new X(e,Math.max(h.getFirstColumnForWorld(s),o),Math.min(h.getLastColumnForWorld(s),a)))}else l.push(new X(e,o,a));else o>h.last[0]||a<h.first[0]||(o=Math.max(o,h.first[0]),a=Math.min(a,h.last[0]),l.push(new X(e,o,a)));e+=1;for(let t=m.length-1;t>=0;t--){const s=m[t];s.ymax>=e?s.incrRow():m.splice(t,1)}}return r}getTileParentId(t){Y.set(t);const s=this._lodInfos.indexOf(this._infoByLevel[Y.level])-1;return s<0?null:(this._getTileIdAtLOD(Y,this._lodInfos[s],Y),Y.id)}getTileResolution(t){const s=this._infoByLevel["object"==typeof t?t.level:t];return s?s.resolution:-1}getTileScale(t){const s=this._infoByLevel[t.level];return s?s.scale:-1}intersects(t,s){Y.set(s);const i=this._infoByLevel[Y.level],h=t.lodInfo;if(h.resolution>i.resolution){this._getTileIdAtLOD(Y,h,Y);const s=h.denormalizeCol(Y.col,Y.world);for(const i of t.spans)if(i.row===Y.row&&i.colFrom<=s&&i.colTo>=s)return!0}if(h.resolution<i.resolution){const[s,r,n,e]=t.spans.reduce(((t,s)=>(t[0]=Math.min(t[0],s.row),t[1]=Math.max(t[1],s.row),t[2]=Math.min(t[2],s.colFrom),t[3]=Math.max(t[3],s.colTo),t)),[1/0,-1/0,1/0,-1/0]),o=i.denormalizeCol(Y.col,Y.world),a=h.getColumnForX(i.getXForColumn(o)),u=h.getRowForY(i.getYForRow(Y.row)),c=h.getColumnForX(i.getXForColumn(o+1))-1,l=h.getRowForY(i.getYForRow(Y.row+1))-1;return!(a>e||c<n||u>r||l<s)}const r=h.denormalizeCol(Y.col,Y.world);return t.spans.some((t=>t.row===Y.row&&t.colFrom<=r&&t.colTo>=r))}normalizeBounds(t,s,i){if(t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],this._wrap){const s=M(this.tileInfo.spatialReference),h=-i*(s.valid[1]-s.valid[0]);t[0]+=h,t[2]+=h}return t}getSmallestInfoForScale(t){const s=this.scales;if(this._infoByScale[t])return this._infoByScale[t];if(t>s[0])return this._infoByScale[s[0]];for(let i=1;i<s.length-1;i++)if(t>s[i]+1e-6)return this._infoByScale[s[i-1]];return this._infoByScale[s[s.length-1]]}getClosestInfoForScale(t){const s=this.scales;return this._infoByScale[t]||(t=s.reduce(((s,i)=>Math.abs(i-t)<Math.abs(s-t)?i:s),s[0])),this._infoByScale[t]}scaleToLevel(t){const s=this.scales;if(this._infoByScale[t])return this._infoByScale[t].level;for(let i=s.length-1;i>=0;i--)if(t<s[i])return i===s.length-1?this._infoByScale[s[s.length-1]].level:this._infoByScale[s[i]].level+(s[i]-t)/(s[i]-s[i+1]);return this._infoByScale[s[0]].level}scaleToZoom(t){return this.tileInfo.scaleToZoom(t)}_getTileIdAtLOD(t,s,i){const h=this._infoByLevel[i.level];return t.set(i),s.resolution<h.resolution?null:(s.resolution===h.resolution||(t.level=s.level,t.col=Math.floor(i.col*h.resolution/s.resolution+.01),t.row=Math.floor(i.row*h.resolution/s.resolution+.01)),t)}}function R(t,s){if(!(this instanceof R))return new R(t,s);this._maxEntries=Math.max(4,t||9),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),s&&("function"==typeof s?this.toBBox=s:this._initFormat(s)),this.clear()}function j(t,s,i){if(!i)return s.indexOf(t);for(var h=0;h<s.length;h++)if(i(t,s[h]))return h;return-1}function A(t,s){B(t,0,t.children.length,s,t)}function B(t,s,i,h,r){r||(r=q(null)),r.minX=1/0,r.minY=1/0,r.maxX=-1/0,r.maxY=-1/0;for(var n,e=s;e<i;e++)n=t.children[e],P(r,t.leaf?h(n):n);return r}function P(t,s){return t.minX=Math.min(t.minX,s.minX),t.minY=Math.min(t.minY,s.minY),t.maxX=Math.max(t.maxX,s.maxX),t.maxY=Math.max(t.maxY,s.maxY),t}function k(t,s){return t.minX-s.minX}function O(t,s){return t.minY-s.minY}function z(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function N(t){return t.maxX-t.minX+(t.maxY-t.minY)}function D(t,s){return(Math.max(s.maxX,t.maxX)-Math.min(s.minX,t.minX))*(Math.max(s.maxY,t.maxY)-Math.min(s.minY,t.minY))}function E(t,s){var i=Math.max(t.minX,s.minX),h=Math.max(t.minY,s.minY),r=Math.min(t.maxX,s.maxX),n=Math.min(t.maxY,s.maxY);return Math.max(0,r-i)*Math.max(0,n-h)}function J(t,s){return t.minX<=s.minX&&t.minY<=s.minY&&s.maxX<=t.maxX&&s.maxY<=t.maxY}function W(t,s){return s.minX<=t.maxX&&s.minY<=t.maxY&&s.maxX>=t.minX&&s.maxY>=t.minY}function q(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function Q(t,s,i,h,r){for(var n,e=[s,i];e.length;)(i=e.pop())-(s=e.pop())<=h||(n=s+Math.ceil((i-s)/h/2)*h,d(t,n,s,i,r),e.push(s,n,n,i))}R.prototype={all:function(){return this._all(this.data,[])},search:function(t){var s=this.data,i=[],h=this.toBBox;if(!W(t,s))return i;for(var r,n,e,o,a=[];s;){for(r=0,n=s.children.length;r<n;r++)e=s.children[r],W(t,o=s.leaf?h(e):e)&&(s.leaf?i.push(e):J(t,o)?this._all(e,i):a.push(e));s=a.pop()}return i},collides:function(t){var s=this.data,i=this.toBBox;if(!W(t,s))return!1;for(var h,r,n,e,o=[];s;){for(h=0,r=s.children.length;h<r;h++)if(n=s.children[h],W(t,e=s.leaf?i(n):n)){if(s.leaf||J(t,e))return!0;o.push(n)}s=o.pop()}return!1},load:function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var s=0,i=t.length;s<i;s++)this.insert(t[s]);return this}var h=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===h.height)this._splitRoot(this.data,h);else{if(this.data.height<h.height){var r=this.data;this.data=h,h=r}this._insert(h,this.data.height-h.height-1,!0)}else this.data=h;return this},insert:function(t){return t&&this._insert(t,this.data.height-1),this},clear:function(){return this.data=q([]),this},remove:function(t,s){if(!t)return this;for(var i,h,r,n,e=this.data,o=this.toBBox(t),a=[],u=[];e||a.length;){if(e||(e=a.pop(),h=a[a.length-1],i=u.pop(),n=!0),e.leaf&&-1!==(r=j(t,e.children,s)))return e.children.splice(r,1),a.push(e),this._condense(a),this;n||e.leaf||!J(e,o)?h?(i++,e=h.children[i],n=!1):e=null:(a.push(e),u.push(i),i=0,h=e,e=e.children[0])}return this},toBBox:function(t){return t},compareMinX:k,compareMinY:O,toJSON:function(){return this.data},fromJSON:function(t){return this.data=t,this},_all:function(t,s){for(var i=[];t;)t.leaf?s.push.apply(s,t.children):i.push.apply(i,t.children),t=i.pop();return s},_build:function(t,s,i,h){var r,n=i-s+1,e=this._maxEntries;if(n<=e)return A(r=q(t.slice(s,i+1)),this.toBBox),r;h||(h=Math.ceil(Math.log(n)/Math.log(e)),e=Math.ceil(n/Math.pow(e,h-1))),(r=q([])).leaf=!1,r.height=h;var o,a,u,c,l=Math.ceil(n/e),f=l*Math.ceil(Math.sqrt(e));for(Q(t,s,i,f,this.compareMinX),o=s;o<=i;o+=f)for(Q(t,o,u=Math.min(o+f-1,i),l,this.compareMinY),a=o;a<=u;a+=l)c=Math.min(a+l-1,u),r.children.push(this._build(t,a,c,h-1));return A(r,this.toBBox),r},_chooseSubtree:function(t,s,i,h){for(var r,n,e,o,a,u,c,l;h.push(s),!s.leaf&&h.length-1!==i;){for(c=l=1/0,r=0,n=s.children.length;r<n;r++)a=z(e=s.children[r]),(u=D(t,e)-a)<l?(l=u,c=a<c?a:c,o=e):u===l&&a<c&&(c=a,o=e);s=o||s.children[0]}return s},_insert:function(t,s,i){var h=i?t:(0,this.toBBox)(t),r=[],n=this._chooseSubtree(h,this.data,s,r);for(n.children.push(t),P(n,h);s>=0&&r[s].children.length>this._maxEntries;)this._split(r,s),s--;this._adjustParentBBoxes(h,r,s)},_split:function(t,s){var i=t[s],h=i.children.length,r=this._minEntries;this._chooseSplitAxis(i,r,h);var n=this._chooseSplitIndex(i,r,h),e=q(i.children.splice(n,i.children.length-n));e.height=i.height,e.leaf=i.leaf,A(i,this.toBBox),A(e,this.toBBox),s?t[s-1].children.push(e):this._splitRoot(i,e)},_splitRoot:function(t,s){this.data=q([t,s]),this.data.height=t.height+1,this.data.leaf=!1,A(this.data,this.toBBox)},_chooseSplitIndex:function(t,s,i){var h,r,n,e,o,a,u,c;for(a=u=1/0,h=s;h<=i-s;h++)e=E(r=B(t,0,h,this.toBBox),n=B(t,h,i,this.toBBox)),o=z(r)+z(n),e<a?(a=e,c=h,u=o<u?o:u):e===a&&o<u&&(u=o,c=h);return c},_chooseSplitAxis:function(t,s,i){var h=t.leaf?this.compareMinX:k,r=t.leaf?this.compareMinY:O;this._allDistMargin(t,s,i,h)<this._allDistMargin(t,s,i,r)&&t.children.sort(h)},_allDistMargin:function(t,s,i,h){t.children.sort(h);var r,n,e=this.toBBox,o=B(t,0,s,e),a=B(t,i-s,i,e),u=N(o)+N(a);for(r=s;r<i-s;r++)n=t.children[r],P(o,t.leaf?e(n):n),u+=N(o);for(r=i-s-1;r>=s;r--)n=t.children[r],P(a,t.leaf?e(n):n),u+=N(a);return u},_adjustParentBBoxes:function(t,s,i){for(var h=i;h>=0;h--)P(s[h],t)},_condense:function(t){for(var s,i=t.length-1;i>=0;i--)0===t[i].children.length?i>0?(s=t[i-1].children).splice(s.indexOf(t[i]),1):this.clear():A(t[i],this.toBBox)},_initFormat:function(t){var s=["return a"," - b",";"];this.compareMinX=new Function("a","b",s.join(t[0])),this.compareMinY=new Function("a","b",s.join(t[1])),this.toBBox=new Function("a","return {minX: a"+t[0]+", minY: a"+t[1]+", maxX: a"+t[2]+", maxY: a"+t[3]+"};")}};class V{constructor(t,s){this.key=new p(0,0,0,0),this.bounds=g(),this.objectIds=new Set,this.key.set(s);const i=t.getLODInfoAt(this.key);this.tileInfoView=t,this.tileInfoView.getTileBounds(this.bounds,this.key,!0),this.resolution=i.resolution,this.scale=i.scale,this.level=i.level}get id(){return this.key.id}get extent(){return m.fromBounds(this.bounds,this.tileInfoView.tileInfo.spatialReference)}get transform(){return{originPosition:"upperLeft",scale:[this.resolution,this.resolution],translate:[this.bounds[0],this.bounds[3]]}}createChildTiles(){const t=this.key.getChildKeys(),s=c.acquire();for(let i=0;i<t.length;i++)s[i]=new V(this.tileInfoView,t[i]);return s}getQuantizationParameters(){return v.fromJSON({mode:"view",originPosition:"upperLeft",tolerance:this.resolution,extent:{xmin:this.bounds[0],ymin:this.bounds[1],xmax:this.bounds[2],ymax:this.bounds[3],spatialReference:this.tileInfoView.tileInfo.spatialReference}})}}const Z={added:[],removed:[]},G=new Set,H=new p(0,0,0,0);class K extends l{constructor(t){super(),this._tiles=new Map,this._index=R(9,f("esri-csp-restrictions")?t=>({minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]}):[".bounds[0]",".bounds[1]",".bounds[2]",".bounds[3]"]),this.tiles=[],this.tileScheme=t}destroy(){this.clear()}clear(){this.tiles.length=0,this._tiles.clear(),this._index.clear()}has(t){return this._tiles.has(t)}get(t){return this._tiles.get(t)}boundsIntersections(t){return this._index.search({minX:t[0],minY:t[1],maxX:t[2],maxY:t[3]})}updateTiles(t){const s={added:[],removed:[]};for(const i of t.added)if(!this.has(i)){const t=new V(this.tileScheme,i);this._tiles.set(i,t),this._index.insert(t),s.added.push(t)}for(const i of t.removed)if(this.has(i)){const t=this.get(i);this._tiles.delete(i),this._index.remove(t),s.removed.push(t)}this.tiles.length=0,this._tiles.forEach((t=>this.tiles.push(t))),(s.added.length||s.removed.length)&&this.emit("update",s)}setViewState(t){const s=this.tileScheme.getTileCoverage(t,0);if(!s)return;const{spans:i,lodInfo:h}=s,{level:r}=h;if(i.length>0)for(const{row:t,colFrom:s,colTo:n}of i)for(let i=s;i<=n;i++){const s=H.set(r,t,h.normalizeCol(i),h.getWorldForColumn(i)).id;if(G.add(s),!this.has(s)){const t=new V(this.tileScheme,s);this._tiles.set(s,t),this._index.insert(t),this.tiles.push(t),Z.added.push(t)}}for(let t=this.tiles.length-1;t>=0;t--){const s=this.tiles[t];G.has(s.id)||(this._tiles.delete(s.id),this.tiles.splice(t,1),this._index.remove(s),Z.removed.push(s))}(Z.added.length||Z.removed.length)&&this.emit("update",Z),S.pool.release(s),G.clear(),Z.added.length=0,Z.removed.length=0}}export{b as a,S as b,w as e,L as h,R as i,K as l}