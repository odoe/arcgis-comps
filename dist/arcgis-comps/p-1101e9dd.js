import"./p-b79fcce3.js";import{A as t,aE as n}from"./p-e58503d5.js";import{j as e,R as r,A as s}from"./p-d1a9be2d.js";const i=new Map,l=new class{constructor(t=15e3,n=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,n)}decreaseRefCount(t,n){const e=t+"/"+n,r=this._cachedBlocks;if(r.has(e)){const t=r.get(e);return t.refCount--,t.refCount<=0&&(r.delete(e),t.controller&&t.controller.abort()),t.refCount}return 0}getBlock(t,n){const e=t+"/"+n,r=this._cachedBlocks;if(r.has(e)){const t=r.get(e);return t.ts=Date.now(),t.refCount++,r.delete(e),r.set(e,t),t.block}return null}putBlock(t,n,e,r=null){const s=this._cachedBlocks,i=t+"/"+n;if(s.has(i)){const t=s.get(i);t.ts=Date.now(),t.refCount++}else s.set(i,{block:e,ts:Date.now(),refCount:1,controller:r});this.trim(),this.updateTimer()}deleteBlock(t,n){const e=this._cachedBlocks,r=t+"/"+n;e.has(r)&&e.delete(r)}updateMaxSize(t){this._size=t,this.trim()}empty(){this._cachedBlocks.clear(),this.clearTimer()}getCurrentSize(){return this._cachedBlocks.size}updateTimer(){if(null!=this._timer)return;const t=this._cachedBlocks;this._timer=setInterval((()=>{const n=Array.from(t),e=Date.now();for(let r=0;r<n.length&&n[r][1].ts<=e-this._duration;r++)t.delete(n[r][0]);0===t.size&&this.clearTimer()}),this._interval)}trim(){const t=this._cachedBlocks;if(-1===this._size||this._size>=t.size)return;const n=Array.from(t);for(let e=0;e<n.length-this._size;e++)t.delete(n[e][0])}clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function o(t,n){return null==n?t:`${t}?sliceId=${n}`}function u(t,n){const e={extent:null,rasterInfo:n,cache:new Map};if(i.has(t)){const n=i.get(t);return n.push(e),n.length-1}return i.set(t,[e]),0}function c(t,n){if(i.has(t)){const e=i.get(t);e[n]=null,e.some((t=>null!=t))||i.delete(t)}}function f(t,n,e){if(!i.has(t))return null==n?l.decreaseRefCount(t,e):0;const r=i.get(t);if(null==r[n])return l.decreaseRefCount(t,e);const s=r[n].cache;if(s.has(e)){const t=s.get(e);if(t.refCount--,0===t.refCount){s.delete(e);for(let t=0;t<r.length;t++)r[t]&&r[t].cache.has(e)&&r[t].cache.delete(e);t.controller&&t.controller.abort()}return t.refCount}return 0}function a(t,n,e){if(!i.has(t))return null==n?l.getBlock(t,e):null;const r=i.get(t);if(null==r[n]){for(let t=0;t<r.length;t++)if(r[t]&&r[t].cache.has(e)){const n=r[t].cache.get(e);return n.refCount++,n.block}return l.getBlock(t,e)}const s=r[n].cache;if(s.has(e)){const t=s.get(e);return t.refCount++,t.block}for(let t=0;t<r.length;t++)if(t!==n&&r[t]&&r[t]&&r[t].cache.has(e)){const n=r[t].cache.get(e);return n.refCount++,s.set(e,n),n.block}return null}function h(t,n,e,r,s=null){if(!i.has(t))return void(null==n&&l.putBlock(t,e,r,s));const o=i.get(t);if(null==o[n])return void l.putBlock(t,e,r,s);const u={refCount:1,block:r,isResolved:!1,isRejected:!1,controller:s};r.then((()=>u.isResolved=!0)).catch((()=>u.isRejected=!0)),o[n].cache.set(e,u)}function p(t,n,e){if(!i.has(t))return void(null==n&&l.deleteBlock(t,e));const r=i.get(t);null!=r[n]?r[n].cache.delete(e):l.deleteBlock(t,e)}function M(t,n){if(!i.has(t))return null;const e=i.get(t);return null==e[n]?null:e[n]}function d(i,l,o,u,c,f,a=null){const h=M(i,l),p=h.extent,{cache:d,rasterInfo:m}=h;if(p&&p.xmin===o.xmin&&p.xmax===o.xmax&&p.ymin===o.ymin&&p.ymax===o.ymax)return;const x=o.clone().normalize(),{spatialReference:y,transform:v}=m,R=new Set;for(let i=0;i<x.length;i++){const l=x[i];if(l.xmax-l.xmin<=u||l.ymax-l.ymin<=u)continue;let o=e(l,y,a);t(v)&&(o=v.inverseTransform(o));const h=new n({x:u,y:u,spatialReference:l.spatialReference});if(null==c&&!(c=r(h,y,l,a)))return;const{pyramidLevel:p,pyramidResolution:M,excessiveReading:d}=s(c,m,f||"closest");if(d)return;const{storageInfo:w}=m,{origin:I}=w,g={x:Math.max(0,Math.floor((o.xmin-I.x)/M.x)),y:Math.max(0,Math.floor((I.y-o.ymax)/M.y))},k=Math.ceil((o.xmax-o.xmin)/M.x-.1),$=Math.ceil((o.ymax-o.ymin)/M.y-.1),b=p>0?w.pyramidBlockWidth:w.blockWidth,j=p>0?w.pyramidBlockHeight:w.blockHeight,C=1,D=Math.max(0,Math.floor(g.x/b)-C),A=Math.max(0,Math.floor(g.y/j)-C),B=Math.floor((g.x+k-1)/b)+C,S=Math.floor((g.y+$-1)/j)+C;for(let t=A;t<=S;t++)for(let n=D;n<=B;n++)R.add(`${p}/${t}/${n}`)}d.forEach(((t,n)=>{if(!R.has(n)){const t=d.get(n);(null==t||t.isResolved||t.isRejected)&&d.delete(n)}})),h.extent={xmin:o.xmin,ymin:o.ymin,xmax:o.xmax,ymax:o.ymax}}export{p as d,d as g,f as h,o as i,a as m,u as s,c as u,h as x}