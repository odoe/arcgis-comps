import{af as t,d_ as e,H as r,e as a,i as s,ai as i}from"./p-7b6f6c18.js";import{f as o,u as n,d as u,b as c,p as m,o as p}from"./p-5f9ac9e7.js";import"./p-227a5838.js";import"./p-d23e08f2.js";const l=p({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,directionsTimeAttribute:{name:"directionsTimeAttributeName"},impedanceAttribute:{name:"impedanceAttributeName"},outSpatialReference:{name:"outSR",getter:t=>t.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},stops:!0,travelMode:!0});let f=class extends i{constructor(t){super(t)}solve(a,s){return async function(a,s,i){const p=[],f=[],b={},d={},A=t(a),{path:y}=A;s.stops&&s.stops.features&&n(s.stops.features,f,"stops.features",b),s.pointBarriers&&s.pointBarriers.features&&n(s.pointBarriers.features,f,"pointBarriers.features",b),s.polylineBarriers&&s.polylineBarriers.features&&n(s.polylineBarriers.features,f,"polylineBarriers.features",b),s.polygonBarriers&&s.polygonBarriers.features&&n(s.polygonBarriers.features,f,"polygonBarriers.features",b);const B=await e(f);for(const t in b){const e=b[t];p.push(t),d[t]=B.slice(e[0],e[1])}if(u(d,p)){let t=null;try{t=await c(y,s.apiKey,i)}catch{}t&&!t.hasZ&&m(d,p)}for(const t in d)d[t].forEach(((e,r)=>{s.get(t)[r].geometry=e}));const j={...i,query:{...A.query,...l.toQueryParams(s),f:"json"}},v=y.endsWith("/solve")?y:`${y}/solve`,N=await r(v,j);return o(N)}(this.url,a,s)}};f=a([s("esri.tasks.RouteTask")],f);const b=f;export default b;