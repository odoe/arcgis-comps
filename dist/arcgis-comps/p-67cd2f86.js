import{h as t,br as s,dl as r,A as e,V as i,s as p,cu as o,b as a,c as m}from"./p-e58503d5.js";import{e as c,n}from"./p-5032dfbd.js";import{m as h}from"./p-e06c6cf3.js";import{g as j,f as d}from"./p-e49308c6.js";import{V as u}from"./p-bfea9714.js";import{O as f,L as l}from"./p-48c5edb1.js";import{d as b}from"./p-6ba45bbf.js";import{B as y}from"./p-a0a662b5.js";import{d as w}from"./p-612de336.js";import"./p-53bb6ab4.js";import"./p-c048b814.js";import"./p-b79fcce3.js";import"./p-182bb5be.js";import"./p-db87794e.js";import"./p-f94762ac.js";import"./p-ea916a39.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-58386239.js";import"./p-285c6a34.js";import"./p-f8414adc.js";import"./p-8925cd73.js";import"./p-c93d2280.js";import"./p-01e5a461.js";import"./p-ccdb8e80.js";import"./p-fea9512d.js";import"./p-50ff864e.js";import"./p-b0565d49.js";import"./p-c1cd5521.js";import"./p-9f58a277.js";import"./p-61f47d2b.js";import"./p-06d309e6.js";import"./p-4019eec3.js";import"./p-292d2320.js";import"./p-8bcb4bb3.js";import"./p-e0d9ff4c.js";import"./p-e273719b.js";import"./p-74de0937.js";import"./p-a9a30646.js";import"./p-7a658388.js";import"./p-85a6d41b.js";import"./p-765e6c28.js";import"./p-ca295674.js";import"./p-5d962998.js";import"./p-41f2b2dd.js";import"./p-9a8fa752.js";import"./p-a131049b.js";import"./p-a2324023.js";export default class{constructor(){this._queryEngine=null,this._customParameters=null,this._snapshotFeatures=async i=>{const{objectIdField:p}=this._queryEngine,o=await y(this._getFeatureUrl,this._featureType.typeName,this._getFeatureOutputFormat,{customParameters:this._customParameters,dateFields:this._queryEngine.fieldsIndex.dateFields.map((t=>t.name)),signal:i});await f(o),t(i);const a=l(o,{geometryType:this._queryEngine.geometryType,hasZ:!1,objectIdField:p});if(!s(this._queryEngine.spatialReference,r))for(const t of a)e(t.geometry)&&(t.geometry=c(j(n(t.geometry,this._queryEngine.geometryType,!1,!1),r,this._queryEngine.spatialReference)));let m=1;for(const t of a){const s={};b(this._fieldsIndex,s,t.attributes,!0),t.attributes=s,null==t.attributes[p]&&(t.objectId=t.attributes[p]=m++)}return a}}destroy(){var t;null==(t=this._queryEngine)||t.destroy(),this._queryEngine=null}async load(s,r){const{getFeatureUrl:e,getFeatureOutputFormat:p,spatialReference:o,fields:a,geometryType:m,featureType:c,objectIdField:n,customParameters:j}=s;this._featureType=c,this._customParameters=j,this._getFeatureUrl=e,this._getFeatureOutputFormat=p,this._fieldsIndex=new w(a),await this._checkProjection(o),t(r),this._queryEngine=new u({fields:a,geometryType:m,hasM:!1,hasZ:!1,objectIdField:n,spatialReference:o,timeInfo:null,featureStore:new h({geometryType:m,hasM:!1,hasZ:!1})});const d=await this._snapshotFeatures(i(r.signal));return this._queryEngine.featureStore.addMany(d),{extent:this._queryEngine.fullExtent}}async applyEdits(){throw new p("wfs-source:editing-not-supported","applyEdits() is not supported on WFSLayer")}async queryFeatures(t={},s={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQuery(t,s.signal)}async queryFeatureCount(t={},s={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForCount(t,s.signal)}async queryObjectIds(t={},s={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForIds(t,s.signal)}async queryExtent(t={},s={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForExtent(t,s.signal)}async querySnapping(t,s={}){return await this._waitSnapshotComplete(),this._queryEngine.executeQueryForSnapping(t,s.signal)}async refresh(t){var s;return this._customParameters=t,null==(s=this._snapshotTask)||s.abort(),this._snapshotTask=o(this._snapshotFeatures),this._snapshotTask.promise.then((t=>{this._queryEngine.featureStore.clear(),t&&this._queryEngine.featureStore.addMany(t)}),(t=>{this._queryEngine.featureStore.clear(),a(t)||m.getLogger("esri.layers.WFSLayer").error(new p("wfs-layer:getfeature-error","An error occurred during the GetFeature request",{error:t}))})),await this._waitSnapshotComplete(),{extent:this._queryEngine.fullExtent}}async _waitSnapshotComplete(){if(this._snapshotTask&&!this._snapshotTask.finished){try{await this._snapshotTask.promise}catch{}return this._waitSnapshotComplete()}}async _checkProjection(t){try{await d(r,t)}catch{throw new p("unsupported-projection","Projection not supported",{spatialReference:t})}}}