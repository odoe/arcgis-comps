import{I as t}from"./p-566b0715.js";import{a7 as s,r,t as e,bc as i}from"./p-9ae46e68.js";import{e as h}from"./p-2a252a78.js";import{n}from"./p-4003c7ae.js";import{t as o}from"./p-b2d0e2de.js";class u{constructor(t,s){this._mask=0,this._buf=t,this._mask=s}static fromBuffer(t,s){return new u(t,s)}static create(t,s=4294967295){const r=new Uint32Array(Math.ceil(t/32));return new u(r,s)}_getIndex(t){return Math.floor(t/32)}has(t){const s=this._mask&t;return!!(this._buf[this._getIndex(s)]&1<<s%32)}hasRange(t,s){let r=t,e=s;for(;r%32&&r!==e;){if(this.has(r))return!0;r++}for(;e%32&&r!==e;){if(this.has(r))return!0;e--}if(r===e)return!1;for(let t=r/32;t!==e/32;t++)if(this._buf[t])return!0;return!1}set(t){const s=this._mask&t,r=this._getIndex(s);this._buf[r]|=1<<s%32}setRange(t,s){let r=t,e=s;for(;r%32&&r!==e;)this.set(r++);for(;e%32&&r!==e;)this.set(e--);if(r!==e)for(let t=r/32;t!==e/32;t++)this._buf[t]=4294967295}unset(t){const s=this._mask&t,r=this._getIndex(s);this._buf[r]&=4294967295^1<<s%32}resize(t){const s=this._buf,r=new Uint32Array(Math.ceil(t/32));r.set(s),this._buf=r}or(t){for(let s=0;s<this._buf.length;s++)this._buf[s]|=t._buf[s];return this}and(t){for(let s=0;s<this._buf.length;s++)this._buf[s]&=t._buf[s];return this}xor(t){for(let s=0;s<this._buf.length;s++)this._buf[s]^=t._buf[s];return this}ior(t){for(let s=0;s<this._buf.length;s++)this._buf[s]|=~t._buf[s];return this}iand(t){for(let s=0;s<this._buf.length;s++)this._buf[s]&=~t._buf[s];return this}ixor(t){for(let s=0;s<this._buf.length;s++)this._buf[s]^=~t._buf[s];return this}any(){for(let t=0;t<this._buf.length;t++)if(this._buf[t])return!0;return!1}copy(t){for(let s=0;s<this._buf.length;s++)this._buf[s]=t._buf[s];return this}clone(){return new u(this._buf.slice(),this._mask)}clear(){for(let t=0;t<this._buf.length;t++)this._buf[t]=0}forEachSet(t){for(let s=0;s<this._buf.length;s++){let r=this._buf[s],e=32*s;if(r)for(;r;)1&r&&t(e),r>>>=1,e++}}countSet(){let t=0;return this.forEachSet((()=>{t++})),t}}var a,f;let l=0;const c=null!=(a=s("featurelayer-simplify-thresholds"))?a:[.5,.5,.5,.5],d=c[0],m=c[1],p=c[2],g=c[3],y=null!=(f=s("featurelayer-simplify-payload-size-factors"))?f:[1,2,4],A=y[0],S=y[1],x=y[2];class I{constructor(t){this.type="FeatureSetReader",this.seen=!1,this.instance=0,this._tx=0,this._ty=0,this._sx=1,this._sy=1,this._deleted=null,this._joined=[],this._objectIdToIndex=null,this._level=0,this.instance=t}static createInstance(){return l++,l=l>65535?0:l,l}get isEmpty(){return r(this._deleted)&&this._deleted.countSet()===this.getSize()}set level(t){this._level=t}getAreaSimplificationThreshold(t,s){let r=1;s>4e6?r=x:s>1e6?r=S:s>5e5&&(r=A);let e=0;t>4e3?e=g*r:t>2e3?e=p*r:t>100?e=m:t>15&&(e=d);let i=8;return this._level<4?i=1:this._level<5?i=2:this._level<6&&(i=4),e*i}setArcadeSpatialReference(t){this._arcadeSpatialReference=t}attachStorage(t){this._storage=t}getQuantizationTransform(){throw new Error("Unable to find transform for featureSet")}getStorage(){return this._storage}getComputedNumeric(t){return this.getComputedNumericAtIndex(0)}setComputedNumeric(t,s){return this.setComputedNumericAtIndex(s,0)}getComputedString(t){return this.getComputedStringAtIndex(0)}setComputedString(t,s){return this.setComputedStringAtIndex(0,s)}getComputedNumericAtIndex(t){return this._storage.getComputedNumericAtIndex(this.getDisplayId(),t)}setComputedNumericAtIndex(t,s){this._storage.setComputedNumericAtIndex(this.getDisplayId(),t,s)}getComputedStringAtIndex(t){return this._storage.getComputedStringAtIndex(this.getDisplayId(),t)}setComputedStringAtIndex(t,s){return this._storage.setComputedStringAtIndex(this.getDisplayId(),t,s)}transform(t,s,r,e){const i=this.copy();return i._tx+=t,i._ty+=s,i._sx*=r,i._sy*=e,i}readAttribute(t,s=!1){const r=this._readAttribute(t,s);if(void 0!==r)return r;for(const r of this._joined){r.setIndex(this.getIndex());const e=r._readAttribute(t,s);if(void 0!==e)return e}}readAttributes(){const t=this._readAttributes();for(const s of this._joined){s.setIndex(this.getIndex());const r=s._readAttributes();for(const s of Object.keys(r))t[s]=r[s]}return t}joinAttributes(t){this._joined.push(t)}readArcadeFeature(){return this}geometry(){const s=this.readHydratedGeometry(),r=n(s,this.geometryType,this.hasZ,this.hasM),e=t(r);return e&&(e.spatialReference=this._arcadeSpatialReference),e}field(t){return this.readAttribute(t,!0)}hasField(t){return!0}setField(t,s){}keys(){return[]}castToText(){return""}removeIds(t){if(e(this._objectIdToIndex)){const t=new Map,s=this.getCursor();for(;s.next();)t.set(s.getObjectId(),s.getIndex());this._objectIdToIndex=t}const s=this._objectIdToIndex;for(const r of t)s.has(r)&&this.removeAtIndex(s.get(r))}removeAtIndex(t){e(this._deleted)&&(this._deleted=u.create(this.getSize())),this._deleted.set(t)}readGeometryForDisplay(){return this.readUnquantizedGeometry(!0)}readLegacyGeometryForDisplay(){return this.readLegacyGeometry(!0)}*features(){const t=this.getCursor();for(;t.next();)yield t.readOptimizedFeature()}_getExists(){return e(this._deleted)||!this._deleted.has(this.getIndex())}_computeCentroid(){if("esriGeometryPolygon"!==this.geometryType)return null;const t=this.readUnquantizedGeometry();if(!t||t.hasIndeterminateRingOrder)return null;const s=i(this.getQuantizationTransform(),null);return h(new o,t,this.hasM,this.hasZ,s)}copyInto(t){t.seen=this.seen,t._storage=this._storage,t._arcadeSpatialReference=this._arcadeSpatialReference,t._joined=this._joined,t._tx=this._tx,t._ty=this._ty,t._sx=this._sx,t._sy=this._sy,t._deleted=this._deleted,t._objectIdToIndex=this._objectIdToIndex}}export{I as A,u as t}