import{Q as t,K as s,b as i,T as e,A as n,af as o}from"./p-e58503d5.js";import{u as r}from"./p-480e5606.js";import"./p-19bc1e3d.js";import{o as h}from"./p-0bb84768.js";import{t as c}from"./p-2d0c34e5.js";import{a}from"./p-9d34911e.js";import{O as l}from"./p-1a7268a2.js";import{e as f}from"./p-77b9a0fc.js";import{D as u}from"./p-6484267b.js";import{t as m,e as p}from"./p-4414d64f.js";import{o as w,l as y}from"./p-fbb06b4d.js";class d{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new c(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new c;let i=null,e=-1;for(let n=0;n<this._free.length;++n){const o=this._free[n];t<=o.width&&s<=o.height&&(null===i||o.y<=i.y&&o.x<=i.x)&&(i=o,e=n)}return null===i?new c:(this._free.splice(e,1),i.width<i.height?(i.width>t&&this._free.push(new c(i.x+t,i.y,i.width-t,s)),i.height>s&&this._free.push(new c(i.x,i.y+s,i.width,i.height-s))):(i.width>t&&this._free.push(new c(i.x+t,i.y,i.width-t,i.height)),i.height>s&&this._free.push(new c(i.x,i.y+s,t,i.height-s))),new c(i.x,i.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const i=this._free[s];if(i.y===t.y&&i.height===t.height&&i.x+i.width===t.x)i.width+=t.width;else if(i.x===t.x&&i.width===t.width&&i.y+i.height===t.y)i.height+=t.height;else if(t.y===i.y&&t.height===i.height&&t.x+t.width===i.x)i.x=t.x,i.width+=t.width;else{if(t.x!==i.x||t.width!==i.width||t.y+t.height!==i.y)continue;i.y=t.y,i.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}class g{constructor(t,s,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=i,this._binPack=new d(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const i=[],e=this._glyphSource,n=new Set;for(const t of s){const s=Math.floor(.00390625*t);n.add(s)}const o=[];return n.forEach((s=>{if(s<=256){const i=t+s;if(this._rangePromises.has(i))o.push(this._rangePromises.get(i));else{const n=e.getRange(t,s).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,n),o.push(n)}}})),Promise.all(o).then((()=>{let n=this._glyphIndex[t];n||(n={},this._glyphIndex[t]=n);for(const o of s){const s=n[o];if(s){i[o]={sdf:!0,rect:s.rect,metrics:s.metrics,page:s.page,code:o};continue}const r=e.getGlyph(t,o);if(!r||!r.metrics)continue;const h=r.metrics;let a;if(0===h.width)a=new c(0,0,0,0);else{const t=3,s=h.width+2*t,i=h.height+2*t;let e=s%4?4-s%4:4,n=i%4?4-i%4:4;1===e&&(e=5),1===n&&(n=5),a=this._binPack.allocate(s+e,i+n),a.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new d(this.width-4,this.height-4),a=this._binPack.allocate(s+e,i+n));const o=this._glyphData[this._currentPage],c=r.bitmap;let l,f;if(c)for(let t=0;t<i;t++){l=s*t,f=this.width*(a.y+t+1)+a.x;for(let t=0;t<s;t++)o[f+t+1]=c[l+t]}}n[o]={rect:a,metrics:h,tileIDs:null,page:this._currentPage},i[o]={sdf:!0,rect:a,metrics:h,page:this._currentPage,code:o},this._dirties[this._currentPage]=!0}return i}))}removeGlyphs(t){for(const s in this._glyphIndex){const i=this._glyphIndex[s];if(!i)continue;let e;for(const s in i)if(e=i[s],e.tileIDs.delete(t),0===e.tileIDs.size){const t=this._glyphData[e.page],n=e.rect;let o,r;for(let s=0;s<n.height;s++)for(o=this.width*(n.y+s)+n.x,r=0;r<n.width;r++)t[o+r]=0;delete i[s],this._dirties[e.page]=!0}}}bind(t,s,i,e=0){this._textures[i]||(this._textures[i]=new h(t,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const n=this._textures[i];n.setSamplingMode(s),this._dirties[i]&&n.setData(this._glyphData[i]),t.bindTexture(n,e),this._dirties[i]=!1}dispose(){this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}}class b{constructor(t){if(this._metrics=[],this._bitmaps=[],t)for(;t.next();)switch(t.tag()){case 1:{const s=t.getMessage();for(;s.next();)switch(s.tag()){case 3:{const t=s.getMessage();let i,e,n,o,r,h,c;for(;t.next();)switch(t.tag()){case 1:i=t.getUInt32();break;case 2:e=t.getBytes();break;case 3:n=t.getUInt32();break;case 4:o=t.getUInt32();break;case 5:r=t.getSInt32();break;case 6:h=t.getSInt32();break;case 7:c=t.getUInt32();break;default:t.skip()}t.release(),i&&(this._metrics[i]={width:n,height:o,left:r,top:h,advance:c},this._bitmaps[i]=e);break}default:s.skip()}s.release();break}default:t.skip()}}getMetrics(t){return this._metrics[t]}getBitmap(t){return this._bitmaps[t]}}class M{constructor(){this._ranges=[]}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}class A{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(s,i){const e=this._getFontStack(s);if(e.getRange(i))return Promise.resolve();const n=256*i,o=n+255,r=this._baseURL.replace("{fontstack}",s).replace("{range}",n+"-"+o);return t(r,{responseType:"array-buffer"}).then((t=>{e.addRange(i,new b(new a(new Uint8Array(t.data),new DataView(t.data))))})).catch((()=>{e.addRange(i,new b)}))}getGlyph(t,s){const i=this._getFontStack(t);if(!i)return;const e=Math.floor(s/256);if(e>256)return;const n=i.getRange(e);return n?{metrics:n.getMetrics(s),bitmap:n.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new M),s}}class x{constructor(t,s,i=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(t<=0||s<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,i>0&&(this._maxItemSize=i),this._binPack=new d(t-4,s-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new d(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),s=Math.floor(this._pageHeight),i=new Uint32Array(t*s);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let i,e,n=this._mosaicRects[t];if(n)return n;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(t&&t.startsWith("dasharray-")?([i,e]=this._rasterizeDash(t),s=!0):i=this._sprites.getSpriteInfo(t),!i||!i.width||!i.height||i.width<0||i.height<0)return null;const o=i.width,r=i.height,[h,c,a]=this._allocateImage(o,r);return h.width<=0?null:(this._copy(h,i,c,a,s,e),n={rect:h,width:o,height:r,sdf:i.sdf,simplePattern:!1,pixelRatio:i.pixelRatio,page:c},this._mosaicRects[t]=n,n)}getSpriteItems(t){const s={};for(const i of t)s[i.name]=this.getSpriteItem(i.name,i.repeat);return s}getMosaicItemPosition(t,s){const i=this.getSpriteItem(t,s),e=i&&i.rect;return e?(e.width=i.width,e.height=i.height,{tl:[e.x+2,e.y+2],br:[e.x+2+i.width,e.y+2+i.height],page:i.page}):null}bind(t,s,i=0,e=0){this._textures[i]||(this._textures[i]=new h(t,{pixelFormat:6408,dataType:5121,wrapMode:33071,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));const n=this._textures[i];n.setSamplingMode(s),this._dirties[i]&&n.setData(new Uint8Array(this._mosaicsData[i].buffer)),t.bindTexture(n,e),this._dirties[i]=!1}static _copyBits(t,s,i,e,n,o,r,h,c,a,l){let f=e*s+i,u=h*o+r;if(l){u-=o;for(let r=-1;r<=a;r++,f=((r+a)%a+e)*s+i,u+=o)for(let s=-1;s<=c;s++)n[u+s]=t[f+(s+c)%c]}else for(let i=0;i<a;i++){for(let s=0;s<c;s++)n[u+s]=t[f+s];f+=s,u+=o}}_copy(t,s,i,e,n,o){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const r=new Uint32Array(o?o.buffer:this._sprites.image.buffer),h=this._mosaicsData[i];h&&r||console.error("Source or target images are uninitialized!"),x._copyBits(r,o?s.width:this._sprites.width,s.x,s.y,h,e[0],t.x+2,t.y+2,s.width,s.height,n),this._dirties[i]=!0}_allocateImage(t,s){t+=2,s+=2;const i=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<i){const i=new c(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[t,s]]}let e=t%4?4-t%4:4,n=s%4?4-s%4:4;1===e&&(e=5),1===n&&(n=5);const o=this._binPack.allocate(t+e,s+n);return o.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new d(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[o,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=t.match(/\[(.*?)\]/);if(!s)return null;const i=s[1].split(",").map(Number),e=t.slice(t.lastIndexOf("-")+1),[n,o,r]=l.rasterizeDash(i,e);return[{x:0,y:0,width:o,height:r,sdf:!0,pixelRatio:1},new Uint8Array(n.buffer)]}}function S(t,s,i,e,n,o){t.fillStyle=s,t.fillRect(i,e,n,o)}function v(t,s,i,e,n,o){t.strokeStyle=s,t.strokeRect(i,e,n,o)}function T(t,s){const i=window.COLLISION_XRAY;for(let e=0;e<s.length;++e){const n=!s[e].unique.show;if(i||!n)for(const o of s[e].colliders){if(!o.enabled)continue;const r=!s[e].unique.parts[o.partIndex].show;if(!i&&r)continue;const h=o.xScreen,c=o.yScreen,a=o.dxScreen,l=o.dyScreen;t.globalAlpha=n||r?.2:1,S(t,"green",h-1,c-1,3,3),v(t,"red",h+a,c+l,o.width,o.height),S(t,"blue",h+a-1,c+l-1,3,3),t.globalAlpha=1}}}class k{constructor(t,s,i){this._layer=t,this._styleRepository=s,this.devicePixelRatio=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._layer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(t){this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,t),this._spriteSourcePromise.then((t=>{this._spriteMosaic=new x(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}));const i=new A(this._styleRepository.glyphs);this._glyphMosaic=new g(1024,1024,i),this._broadcastPromise=r("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then((i=>(this._connection=i,Promise.all(this._connection.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,vectorTileLayerMaxBuffers:s("vectortilelayer-max-buffers")},t)))))}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}async setStyle(t,i){await this._broadcastPromise,this._styleRepository=t,this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((t=>{this._spriteMosaic=new x(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}));const e=new A(t.glyphs);return this._glyphMosaic=new g(1024,1024,e),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:i,vectorTileLayerMaxBuffers:s("vectortilelayer-max-buffers")})),this._broadcastPromise}fetchTileData(t,s){return this._getRefKeys(t,s).then((t=>{const i=this._layer.sourceNameToSource,e=[];for(const t in i)e.push(t);return this._getSourcesData(e,t,s)}))}parseTileData(t,s){const i=t&&t.data;if(!i)return Promise.resolve(null);const{sourceName2DataAndRefKey:e,transferList:n}=i;return 0===Object.keys(e).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((i=>i.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:e,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:n}).then((t=>({tileData:t})))))))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}perfReport({key:t,milliseconds:s}){!function(t,s){if(!window.PERFORMANCE_RECORDING_STORAGE)return;const i=window.PERFORMANCE_RECORDING_STORAGE;i.perf=i.perf||{};const e=i.perf;e[t]=e[t]||{start:null,time:0,min:void 0,max:void 0,samples:[],unit:"ms"},e[t].time+=s,e[t].samples.push(s),(null==e[t].min||s<e[t].min)&&(e[t].min=s),(null==e[t].max||s>e[t].max)&&(e[t].max=s)}(t,s)}async _getTilePayload(t,s,e){const n=f.pool.acquire(t.id),o=this._layer.sourceNameToSource[s].getSourceTileUrl(n.level,n.row,n.col);f.pool.release(n);try{return{protobuff:await this.request(o,e),sourceName:s}}catch(t){if(i(t))throw t;return{protobuff:null,sourceName:s}}}request(s,i){return t(s,{responseType:"array-buffer",...i}).then((({data:t})=>t))}_getRefKeys(t,s){const i=this._layer.sourceNameToSource,n=new Array;for(const e in i){const o=i[e].getRefKey(t,s);n.push(o)}return e(n)}_getSourcesData(t,s,i){const n=[];for(let e=0;e<s.length;e++)if(null==s[e].value||null==t[e])n.push(null);else{const o=this._getTilePayload(s[e].value,t[e],i);n.push(o)}return e(n).then((t=>{const i={},e=[];for(let n=0;n<t.length;n++)t[n].value&&t[n].value&&t[n].value.protobuff&&t[n].value.protobuff.byteLength>0&&(i[t[n].value.sourceName]={refKey:s[n].value.id,protobuff:t[n].value.protobuff},e.push(t[n].value.protobuff));return{sourceName2DataAndRefKey:i,transferList:e}}))}}function P(t,s,i,e,n,o){const{iconRotationAlignment:r,textRotationAlignment:h,iconTranslate:c,iconTranslateAnchor:a,textTranslate:l,textTranslateAnchor:f}=e;let u=0;for(const e of t.colliders){const[t,m]=0===e.partIndex?c:l,p=0===e.partIndex?a:f,w=e.minLod<=o&&o<=e.maxLod;u+=w?0:1,e.enabled=w,e.xScreen=e.xTile*n[0]+e.yTile*n[3]+n[6],e.yScreen=e.xTile*n[1]+e.yTile*n[4]+n[7],0===p?(e.xScreen+=i*t-s*m,e.yScreen+=s*t+i*m):(e.xScreen+=t,e.yScreen+=m),1===(0===e.partIndex?r:h)?(e.dxScreen=e.dxPixels,e.dyScreen=e.dyPixels):(e.dxScreen=i*(e.dxPixels+e.width/2)-s*(e.dyPixels+e.height/2)-e.width/2,e.dyScreen=s*(e.dxPixels+e.width/2)+i*(e.dyPixels+e.height/2)-e.height/2)}t.colliders.length>0&&u===t.colliders.length&&(t.unique.show=!1)}class U{constructor(t,s,i,e,n,o){this._symbols=t,this._styleRepository=e,this._zoom=n,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new w(s,i,m),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const s of t)for(const t of s.symbols)this._allNeededMatrices.has(t.tile)||this._allNeededMatrices.set(t.tile,u(t.tile.transforms.tileUnitsToPixels))}work(t){const s=this._gridIndex;function i(t){const i=t.xScreen+t.dxScreen,e=t.yScreen+t.dyScreen,n=i+t.width,o=e+t.height,[r,h,c,a]=s.getCellSpan(i,e,n,o);for(let t=h;t<=a;t++)for(let h=r;h<=c;h++){const r=s.cells[t][h];for(const t of r){const s=t.xScreen+t.dxScreen,r=t.yScreen+t.dyScreen,h=s+t.width,c=r+t.height;if(!(n<s||i>h||o<r||e>c))return!0}}return!1}const e=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const s=this._symbols[this._currentLayerCursor],n=this._getProperties(s.styleLayerUID);for(;this._currentSymbolCursor<s.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-e>t)return!1;const o=s.symbols[this._currentSymbolCursor];if(!o.unique.show)continue;P(o,this._si,this._co,n,this._allNeededMatrices.get(o.tile),this._zoom);const r=o.unique;if(!r.show)continue;const{iconAllowOverlap:h,iconIgnorePlacement:c,textAllowOverlap:a,textIgnorePlacement:l}=n;for(const t of o.colliders){if(!t.enabled)continue;const s=r.parts[t.partIndex];s.show&&!(t.partIndex?a:h)&&i(t)&&(t.hard?r.show=!1:s.show=!1)}if(r.show)for(const t of o.colliders){if(!t.enabled)continue;if(t.partIndex?l:c)continue;if(!r.parts[t.partIndex].show)continue;const s=t.xScreen+t.dxScreen,i=t.yScreen+t.dyScreen,e=s+t.width,n=i+t.height,[o,h,a,f]=this._gridIndex.getCellSpan(s,i,e,n);for(let s=h;s<=f;s++)for(let i=o;i<=a;i++)this._gridIndex.cells[s][i].push(t)}}}return!0}_getProperties(t){const s=this._styleProps.get(t);if(s)return s;const i=this._zoom,e=this._styleRepository.getStyleLayerByUID(t),n=0!==e.getLayoutValue("symbol-placement",i);let o=e.getLayoutValue("icon-rotation-alignment",i);2===o&&(o=n?0:1);let r=e.getLayoutValue("text-rotation-alignment",i);2===r&&(r=n?0:1);const h=e.getPaintValue("icon-translate",i),c=e.getPaintValue("icon-translate-anchor",i),a=e.getPaintValue("text-translate",i),l=e.getPaintValue("text-translate-anchor",i),f={iconAllowOverlap:e.getLayoutValue("icon-allow-overlap",i),iconIgnorePlacement:e.getLayoutValue("icon-ignore-placement",i),textAllowOverlap:e.getLayoutValue("text-allow-overlap",i),textIgnorePlacement:e.getLayoutValue("text-ignore-placement",i),iconRotationAlignment:o,textRotationAlignment:r,iconTranslateAnchor:c,iconTranslate:h,textTranslateAnchor:l,textTranslate:a};return this._styleProps.set(t,f),f}}function D(t,s){if(t.priority-s.priority)return t.priority-s.priority;const i=t.tile.key,e=s.tile.key;return i.world-e.world?i.world-e.world:i.level-e.level?i.level-e.level:i.row-e.row?i.row-e.row:i.col-e.col?i.col-e.col:t.xTile-s.xTile?t.xTile-s.xTile:t.yTile-s.yTile}class _{constructor(t,s,i,e,n,o){this._visibleTiles=t,this._symbolRepository=s,this._createCollisionJob=i,this._assignTileSymbolsOpacity=e,this._symbolLayerSorter=n,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(t,s){this._screenWidth===t&&this._screenHeight===s||this.restart(),this._screenWidth=t,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(t){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(t))return!1;if(this._selectionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(t))return!1;if(this._collisionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(t))return!1;if(this._opacityJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}return this._running=!1,!0}_createSelectionJob(){const t=this._symbolRepository.uniqueSymbols;for(let s=0;s<t.length;s++){const i=t[s];for(let t=0;t<i.uniqueSymbols.length;t++){const s=i.uniqueSymbols[t];for(const t of s.tileSymbols)t.selectedForRendering=!1}}const s=[];let i=0,e=0;const n=this._isLayerVisible,o=this._symbolLayerSorter;return{work:function(o){let r;const h=performance.now();for(;e<t.length;e++,i=0){const c=t[e],a=c.styleLayerUID;if(!n(a)){s[e]||(s[e]={styleLayerUID:a,symbols:[]});continue}s[e]=s[e]||{styleLayerUID:a,symbols:[]};const l=s[e];for(;i<c.uniqueSymbols.length;i++){if(r=c.uniqueSymbols[i],i%100==99&&performance.now()-h>o)return!1;let t=null,s=!1,e=!1;for(const i of r.tileSymbols)if(!e||!s){const n=i.tile;(!t||n.isCoverage||n.neededForCoverage&&!s)&&(t=i,(n.neededForCoverage||n.isCoverage)&&(e=!0),n.isCoverage&&(s=!0))}if(t.selectedForRendering=!0,e){l.symbols.push(t),r.show=!0;for(const t of r.parts)t.show=!0}else r.show=!1}}for(const t of s)t.symbols.sort(D);return!0},get sortedSymbols(){return s.sort(o)}}}_createOpacityJob(){const t=this._assignTileSymbolsOpacity,s=this._visibleTiles;let i=0;function e(s,i){const n=s.symbols;for(const[t,s]of n)I(s,i);t(s,i);for(const t of s.childrenTiles)e(t,i)}return{work(t){const o=performance.now();for(;i<s.length;i++){if(performance.now()-o>t)return!1;const r=s[i];n(r.parentTile)||e(r,performance.now())}return!0}}}}function I(t,s){for(const i of t){const t=i.unique;for(const i of t.parts)i.startOpacity+=(s-i.startTime)/p*(i.targetOpacity>.5?1:-1),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=s,i.targetOpacity=t.show&&i.show?1:0}}class R{constructor(t,s,i){this.tileCoordRange=t,this._visibleTiles=s,this._createUnique=i,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return o(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(t,s){this._uniqueSymbolLayerArray=null;let i=this._tiles.get(t.id);i||(i={symbols:new Map},this._tiles.set(t.id,i));const e=new Map;if(s)for(const t of s)i.symbols.has(t)&&(e.set(t,i.symbols.get(t)),i.symbols.delete(t));else for(const[s,n]of t.layerData)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e);const n=t.symbols,o=new Map;for(const[t,s]of n){let e=s.length;if(e>=32){let n=this.tileCoordRange;do{n/=2,e/=4}while(e>8&&n>64);const r=new w(this.tileCoordRange,this.tileCoordRange,n);o.set(t,{flat:s,index:r}),i.symbols.set(t,{flat:s,index:r});for(const t of s)r.getCell(t.xTile,t.yTile).push(t)}else o.set(t,{flat:s}),i.symbols.set(t,{flat:s})}this._addSymbols(t.key,n)}deleteStyleLayers(t){this._uniqueSymbolLayerArray=null;for(const[s,i]of this._tiles){const e=new Map;for(const s of t)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e),0===i.symbols.size&&this._tiles.delete(s)}}removeTile(t){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(t.id);if(!s)return;const i=new Map;for(const[e,n]of t.symbols)s.symbols.has(e)&&(i.set(e,s.symbols.get(e)),s.symbols.delete(e));this._removeSymbols(i),0===s.symbols.size&&this._tiles.delete(t.id)}_removeSymbols(t){for(const[s,{flat:i}]of t)for(const t of i){const i=t.unique,e=i.tileSymbols,n=e.length-1;for(let s=0;s<n;s++)if(e[s]===t){e[s]=e[n];break}if(e.length=n,0===n){const t=this._uniqueSymbolsReferences.get(s);t.delete(i),0===t.size&&this._uniqueSymbolsReferences.delete(s)}t.unique=null}}_addSymbols(t,s){if(0===s.size)return;const i=this._visibleTiles;for(const e of i)e.parentTile||e.key.world!==t.world||e.key.level===t.level&&!e.key.equals(t)||this._matchSymbols(e,t,s);for(const[t,i]of s)for(const s of i)if(o(s.unique)){const i=this._createUnique();s.unique=i,i.tileSymbols.push(s);let e=this._uniqueSymbolsReferences.get(t);e||(e=new Set,this._uniqueSymbolsReferences.set(t,e)),e.add(i)}}_matchSymbols(t,s,i){if(t.key.level>s.level){const i=t.key.level-s.level;if(t.key.row>>i!==s.row||t.key.col>>i!==s.col)return}if(s.level>t.key.level){const i=s.level-t.key.level;if(s.row>>i!==t.key.row||s.col>>i!==t.key.col)return}if(s.equals(t.key)){for(const e of t.childrenTiles)this._matchSymbols(e,s,i);return}const e=new Map;for(const[o,r]of i){const i=[];for(const e of r){const n=y(this.tileCoordRange,e.xTile,s.level,s.col,t.key.level,t.key.col),o=y(this.tileCoordRange,e.yTile,s.level,s.row,t.key.level,t.key.row);n>=0&&n<this.tileCoordRange&&o>=0&&o<this.tileCoordRange&&i.push({symbol:e,xTransformed:n,yTransformed:o})}const h=[],c=t.key.level<s.level?1:1<<t.key.level-s.level,a=this._tiles.get(t.id).symbols.get(o);if(a){const t=a.flat;for(const s of i){let i,e=!1;const o=s.xTransformed,r=s.yTransformed;i=n(a.index)?a.index.getCell(o,r):t;const l=s.symbol,f=l.hash;for(const t of i)if(f===t.hash&&Math.abs(o-t.xTile)<=c&&Math.abs(r-t.yTile)<=c){const s=t.unique;l.unique=s,s.tileSymbols.push(l),e=!0;break}e||h.push(l)}}h.length>0&&e.set(o,h)}for(const i of t.childrenTiles)this._matchSymbols(i,s,e)}_createUniqueSymbolLayerArray(){const t=this._uniqueSymbolsReferences,s=new Array(t.size);let i,e=0;for(const[n,o]of t){const t=new Array(o.size);i=0;for(const s of o)t[i++]=s;s[e]={styleLayerUID:n,uniqueSymbols:t},e++}return s}}export{U as a,k as h,_ as i,T as o,R as r}