import{af as t,a0 as e,bK as s}from"./p-e58503d5.js";import{N as i,j as r}from"./p-3bcc4805.js";import{m as o,n}from"./p-5032dfbd.js";import{y as a}from"./p-a131049b.js";import{t as h}from"./p-bba8b671.js";import{t as p}from"./p-ca4492df.js";import"./p-53bb6ab4.js";import"./p-3721667d.js";import"./p-f94762ac.js";import"./p-ea916a39.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-4019eec3.js";import"./p-c048b814.js";import"./p-b79fcce3.js";import"./p-182bb5be.js";import"./p-db87794e.js";import"./p-a9a30646.js";import"./p-a2324023.js";import"./p-01e5a461.js";import"./p-9d34911e.js";function c(t,e){return e}function l(t,e,s,i){switch(s){case 0:return y(t,e+i,0);case 1:return"lowerLeft"===t.originPosition?y(t,e+i,1):function({translate:t,scale:e},s,i){return t[i]-s*e[i]}(t,e+i,1)}}function u(t,e,s,i){return 2===s?y(t,e,2):l(t,e,s,i)}function m(t,e,s,i){return 2===s?y(t,e,3):l(t,e,s,i)}function f(t,e,s,i){return 3===s?y(t,e,3):u(t,e,s,i)}function y({translate:t,scale:e},s,i){return t[i]+s*e[i]}class d{constructor(t){this.options=t,this.geometryTypes=["point","multipoint","polyline","polygon"],this.previousCoordinate=[0,0],this.transform=null,this.applyTransform=c,this.lengths=[],this.currentLengthIndex=0,this.toAddInCurrentPath=0,this.vertexDimension=0,this.coordinateBuffer=null,this.coordinateBufferPtr=0,this.AttributesConstructor=function(){}}createFeatureResult(){return new i}finishFeatureResult(e){if(this.options.applyTransform&&(e.transform=null),this.AttributesConstructor=function(){},this.coordinateBuffer=null,this.lengths.length=0,!e.hasZ)return;const s=h(e.geometryType,this.options.sourceSpatialReference,e.spatialReference);if(!t(s))for(const t of e.features)s(t.geometry)}createSpatialReference(){return new e}addField(t,e){t.fields.push(a.fromJSON(e));const s=t.fields.map((t=>t.name));this.AttributesConstructor=function(){for(const t of s)this[t]=null}}addFeature(t,e){const s=this.options.maxStringAttributeLength?this.options.maxStringAttributeLength:0;if(s>0)for(const t in e.attributes){const i=e.attributes[t];"string"==typeof i&&i.length>s&&(e.attributes[t]="")}t.features.push(e)}addQueryGeometry(t,e){const{queryGeometry:s,queryGeometryType:i}=e,r=o(s.clone(),s,!1,!1,this.transform),a=n(r,i,!1,!1);let h=null;switch(i){case"esriGeometryPoint":h="point";break;case"esriGeometryPolygon":h="polygon";break;case"esriGeometryPolyline":h="polyline";break;case"esriGeometryMultipoint":h="multipoint"}a.type=h,t.queryGeometryType=i,t.queryGeometry=a}prepareFeatures(t){switch(this.transform=t.transform,this.options.applyTransform&&t.transform&&(this.applyTransform=this.deriveApplyTransform(t)),this.vertexDimension=2,t.hasZ&&this.vertexDimension++,t.hasM&&this.vertexDimension++,t.geometryType){case"point":this.addCoordinate=(t,e,s)=>this.addCoordinatePoint(t,e,s),this.createGeometry=t=>this.createPointGeometry(t);break;case"polygon":this.addCoordinate=(t,e,s)=>this.addCoordinatePolygon(t,e,s),this.createGeometry=t=>this.createPolygonGeometry(t);break;case"polyline":this.addCoordinate=(t,e,s)=>this.addCoordinatePolyline(t,e,s),this.createGeometry=t=>this.createPolylineGeometry(t);break;case"multipoint":this.addCoordinate=(t,e,s)=>this.addCoordinateMultipoint(t,e,s),this.createGeometry=t=>this.createMultipointGeometry(t)}}createFeature(){return this.lengths.length=0,this.currentLengthIndex=0,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0,new r(s(),null,new this.AttributesConstructor)}allocateCoordinates(){const t=this.lengths.reduce(((t,e)=>t+e),0);this.coordinateBuffer=new Float64Array(t*this.vertexDimension),this.coordinateBufferPtr=0}addLength(t,e,s){0===this.lengths.length&&(this.toAddInCurrentPath=e),this.lengths.push(e)}createPointGeometry(t){const e={type:"point",x:0,y:0,spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM};return e.hasZ&&(e.z=0),e.hasM&&(e.m=0),e}addCoordinatePoint(t,e,s){switch(e=this.applyTransform(this.transform,e,s,0),s){case 0:t.x=e;break;case 1:t.y=e;break;case 2:t.hasZ?t.z=e:t.m=e;break;case 3:t.m=e}}transformPathLikeValue(t,e){let s=0;return e<=1&&(s=this.previousCoordinate[e],this.previousCoordinate[e]+=t),this.applyTransform(this.transform,t,e,s)}addCoordinatePolyline(t,e,s){this.dehydratedAddPointsCoordinate(t.paths,e,s)}addCoordinatePolygon(t,e,s){this.dehydratedAddPointsCoordinate(t.rings,e,s)}addCoordinateMultipoint(t,e,s){0===s&&t.points.push([]);const i=this.transformPathLikeValue(e,s);t.points[t.points.length-1].push(i)}createPolygonGeometry(t){return{type:"polygon",rings:[[]],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}createPolylineGeometry(t){return{type:"polyline",paths:[[]],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}createMultipointGeometry(t){return{type:"multipoint",points:[],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}dehydratedAddPointsCoordinate(t,e,s){0===s&&0==this.toAddInCurrentPath--&&(t.push([]),this.toAddInCurrentPath=this.lengths[++this.currentLengthIndex]-1,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0);const i=this.transformPathLikeValue(e,s);0===s&&t[t.length-1].push(new Float64Array(this.coordinateBuffer.buffer,this.coordinateBufferPtr*Float64Array.BYTES_PER_ELEMENT,this.vertexDimension)),this.coordinateBuffer[this.coordinateBufferPtr++]=i}deriveApplyTransform(t){const{hasZ:e,hasM:s}=t;return e&&s?f:e?u:s?m:l}}class b{_parseFeatureQuery(t){const e=p(t.buffer,new d(t.options)),s={...e,spatialReference:e.spatialReference.toJSON(),fields:e.fields?e.fields.map((t=>t.toJSON())):void 0};return Promise.resolve(s)}}function j(){return new b}export default j;