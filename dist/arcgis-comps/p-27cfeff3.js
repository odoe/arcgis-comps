import{af as t,A as r,Q as s,az as e,aj as i}from"./p-e58503d5.js";import{G as n}from"./p-dae095dd.js";import{B as a}from"./p-efbca0ca.js";import o from"./p-0eb619a6.js";class l{constructor(t,r,s,e){this.parsedUrl=t,this.portalItem=r,this.apiKey=s,this.signal=e,this.rootDocument=null;const i=this.parsedUrl.path.match(/^(.*)\/SceneServer\/layers\/([\d]*)\/?$/i);i&&(this.urlParts={root:i[1],layerId:parseInt(i[2],10)})}async fetch(){var r;if(!this.urlParts)return null;const s=null!=(r=this.portalItem)?r:await this.portalItemFromServiceItemId();if(t(s))return this.loadFromUrl();const e=await this.findAndLoadRelatedPortalItem(s);return t(e)?null:this.loadFeatureLayerFromPortalItem(e)}async fetchPortalItem(){var r;if(!this.urlParts)return null;const s=null!=(r=this.portalItem)?r:await this.portalItemFromServiceItemId();return t(s)?null:this.findAndLoadRelatedPortalItem(s)}async fetchRootDocument(){if(r(this.rootDocument))return this.rootDocument;if(t(this.urlParts))return this.rootDocument={},{};const e={query:{f:"json",token:this.apiKey},responseType:"json",signal:this.signal},i=`${this.urlParts.root}/SceneServer`;try{const t=await s(i,e);this.rootDocument=t.data}catch{this.rootDocument={}}return this.rootDocument}async fetchServiceOwningPortalUrl(){var t;const r=null==(t=e)?void 0:t.findServerInfo(this.parsedUrl.path);if(null!=r&&r.owningSystemUrl)return r.owningSystemUrl;const n=this.parsedUrl.path.replace(/(.*\/rest)\/.*/i,"$1")+"/info";try{const t=(await s(n,{query:{f:"json"},responseType:"json",signal:this.signal})).data.owningSystemUrl;if(t)return t}catch(t){i(t)}return null}async findAndLoadRelatedPortalItem(t){try{return(await t.fetchRelatedItems({relationshipType:"Service2Service",direction:"reverse"},{signal:this.signal})).find((t=>"Feature Service"===t.type))||null}catch(t){return i(t),null}}async loadFeatureLayerFromPortalItem(t){await t.load({signal:this.signal});const r=await this.findMatchingAssociatedSublayerUrl(t.url);return new n({url:r,portalItem:t}).load({signal:this.signal})}async loadFromUrl(){const t=await this.findMatchingAssociatedSublayerUrl(`${this.urlParts.root}/FeatureServer`);return new n({url:t}).load({signal:this.signal})}async findMatchingAssociatedSublayerUrl(t){const r=t.replace(/^(.*FeatureServer)(\/[\d]*\/?)?$/i,"$1"),e={query:{f:"json"},responseType:"json",authMode:"no-prompt",signal:this.signal},i=this.urlParts.layerId,n=this.fetchRootDocument(),a=s(r,e),[o,l]=await Promise.all([a,n]),h=l&&l.layers,c=o.data&&o.data.layers;if(!Array.isArray(c))throw new Error("expected layers array");if(Array.isArray(h)){for(let t=0;t<Math.min(h.length,c.length);t++)if(h[t].id===i)return`${r}/${c[t].id}`}else if(i<c.length)return`${r}/${c[i].id}`;throw new Error("could not find matching associated sublayer")}async portalItemFromServiceItemId(){const t=(await this.fetchRootDocument()).serviceItemId;if(!t)return null;const s=new o({id:t,apiKey:this.apiKey}),e=await this.fetchServiceOwningPortalUrl();r(e)&&(s.portal=new a({url:e}));try{return s.load({signal:this.signal})}catch(t){return i(t),null}}}export{l}