import{a0 as t,Z as n,Q as e,c as o,af as s,A as r,a8 as i,a9 as c,bw as f,s as a,ad as u}from"./p-e58503d5.js";import{m as l,v as p}from"./p-b79fcce3.js";import{c as m,d as y,v as g,a as w}from"./p-c048b814.js";const h={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new l({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:t.WebMercator}),minus180Line:new l({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:t.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new l({paths:[[[180,-180],[180,180]]],spatialReference:t.WGS84}),minus180Line:new l({paths:[[[-180,-180],[-180,180]]],spatialReference:t.WGS84})}};function d(t,n){return Math.ceil((t-n)/(2*n))}function x(t,n){const e=N(t);for(const t of e)for(const e of t)e[0]+=n;return t}function N(t){return m(t)?t.rings:t.paths}function R(t){const n=(null==t?void 0:t.isWebMercator)?102100:4326;return[h[n].minX,h[n].maxX]}async function j(t,o,s,r){const i="string"==typeof t?n(t):t,c=o[0].spatialReference,f={...r,query:{...i.query,f:"json",sr:JSON.stringify(c),target:JSON.stringify({geometryType:g(o[0]),geometries:o}),cutter:JSON.stringify(s)}},a=await e(i.path+"/cut",f),{cutIndexes:u,geometries:l=[]}=a.data;return{cutIndexes:u,geometries:l.map((t=>{const n=y(t);return n.spatialReference=c,n}))}}async function v(t,o,s){const r="string"==typeof t?n(t):t,i=o[0].spatialReference,c=g(o[0]),f={...s,query:{...r.query,f:"json",sr:i.wkid?i.wkid:JSON.stringify(i),geometries:JSON.stringify(J(o))}};return function(t,n,e){const o=w(n);return t.map((t=>{const n=o.fromJSON(t);return n.spatialReference=e,n}))}((await e(r.path+"/simplify",f)).data,c,i)}function J(t){return{geometryType:g(t[0]),geometries:t.map((t=>t.toJSON()))}}const L=o.getLogger("esri.geometry.support.normalizeUtils");function O(t){return"polygon"===t[0].type}function S(t){return"polyline"===t[0].type}function b(t,n,e){if(n){const n=function(t,n){if(!(t instanceof l||t instanceof p)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw L.error(t),new a(t)}const e=N(t),o=[];for(const t of e){const e=[];o.push(e),e.push([t[0][0],t[0][1]]);for(let o=0;o<t.length-1;o++){const s=t[o][0],r=t[o][1],i=t[o+1][0],c=t[o+1][1],f=Math.sqrt((i-s)*(i-s)+(c-r)*(c-r)),a=(c-r)/f,u=(i-s)/f,l=f/n;if(l>1){for(let t=1;t<=l-1;t++){const o=t*n;e.push([u*o+s,a*o+r])}const t=(f+Math.floor(l-1)*n)/2;e.push([u*t+s,a*t+r])}e.push([i,c])}}return function(t){return"polygon"===t.type}(t)?new p({rings:o,spatialReference:t.spatialReference}):new l({paths:o,spatialReference:t.spatialReference})}(t,1e6);t=c(n,!0)}return e&&(t=x(t,e)),t}function X(t,n,e){if(Array.isArray(t)){const o=t[0];if(o>n){const e=d(o,n);t[0]=o+e*(-2*n)}else if(o<e){const n=d(o,e);t[0]=o+n*(-2*e)}}else{const o=t.x;if(o>n){const e=d(o,n);t=t.clone().offset(e*(-2*n),0)}else if(o<e){const n=d(o,e);t=t.clone().offset(n*(-2*e),0)}}return t}function A(t,n){let e=-1;for(let o=0;o<n.cutIndexes.length;o++){const s=n.cutIndexes[o],r=n.geometries[o],i=N(r);for(let t=0;t<i.length;t++){const n=i[t];n.some((e=>{if(e[0]<180)return!0;{let e=0;for(let t=0;t<n.length;t++){const o=n[t][0];e=o>e?o:e}e=Number(e.toFixed(9));const o=-360*d(e,180);for(let e=0;e<n.length;e++){const n=r.getPoint(t,e);r.setPoint(t,e,n.clone().offset(o,0))}return!0}}))}if(s===e){if(O(t))for(const n of N(r))t[s]=t[s].addRing(n);else if(S(t))for(const n of N(r))t[s]=t[s].addPath(n)}else e=s,t[s]=r}return t}async function M(t,n,e){var o;if(!Array.isArray(t))return M([t],n);const c=null!=(o=null==n?void 0:n.url)?o:u.geometryServiceUrl;let a,m,y,g,w,N,R,J,L=0;const O=[],S=[];for(const n of t)if(s(n))S.push(n);else if(a||(a=n.spatialReference,m=f(a),y=a.isWebMercator,N=y?102100:4326,g=h[N].maxX,w=h[N].minX,R=h[N].plus180Line,J=h[N].minus180Line),m)if("mesh"===n.type)S.push(n);else if("point"===n.type)S.push(X(n.clone(),g,w));else if("multipoint"===n.type){const t=n.clone();t.points=t.points.map((t=>X(t,g,w))),S.push(t)}else if("extent"===n.type){const t=n.clone()._normalize(!1,!1,m);S.push(t.rings?new p(t):t)}else if(n.extent){const t=n.extent,e=d(t.xmin,w)*(2*g);let o=0===e?n.clone():x(n.clone(),e);t.offset(e,0),t.intersects(R)&&t.xmax!==g?(L=t.xmax>L?t.xmax:L,o=b(o,y),O.push(o),S.push("cut")):t.intersects(J)&&t.xmin!==w?(L=t.xmax*(2*g)>L?t.xmax*(2*g):L,o=b(o,y,360),O.push(o),S.push("cut")):S.push(o)}else S.push(n.clone());else S.push(n);let q=d(L,g),I=-90;const T=q,z=new l;for(;q>0;){const t=360*q-180;z.addPath([[t,I],[t,-1*I]]),I*=-1,q--}if(O.length>0&&T>0){const n=A(O,await j(c,O,z,e)),o=[],s=[];for(let e=0;e<S.length;e++){const c=S[e];if("cut"!==c)s.push(c);else{const c=n.shift(),f=t[e];r(f)&&"polygon"===f.type&&f.rings&&f.rings.length>1&&c.rings.length>=f.rings.length?(o.push(c),s.push("simplify")):s.push(y?i(c):c)}}if(!o.length)return s;const f=await v(c,o,e),a=[];for(let t=0;t<s.length;t++){const n=s[t];a.push("simplify"!==n?n:y?i(f.shift()):f.shift())}return a}const D=[];for(let t=0;t<S.length;t++){const n=S[t];if("cut"!==n)D.push(n);else{const t=O.shift();D.push(!0===y?i(t):t)}}return Promise.resolve(D)}function q(t,n){const e=f(n);if(e){const[n,o]=e.valid,s=o-n;if(t<n)for(;t<n;)t+=s;if(t>o)for(;t>o;)t-=s}return t}export{q as U,R as a,d as i,h as r,N as s,M as v}