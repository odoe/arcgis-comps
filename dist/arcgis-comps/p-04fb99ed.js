import{r as t,a7 as r}from"./p-9ae46e68.js";import{h as e}from"./p-cb4bfb58.js";import{_ as o}from"./p-4ece03e9.js";import"./p-84bf99cb.js";import"./p-285c6a34.js";import"./p-566b0715.js";import"./p-fe01b82b.js";import"./p-2794293b.js";import"./p-138c2b2c.js";import"./p-01158f1c.js";import"./p-39da60a5.js";import"./p-bae36c84.js";import"./p-e49afbb8.js";import"./p-19c767c2.js";import"./p-d925341f.js";import"./p-76b2eeb3.js";class n{async createIndex(r,o){const n=new Array;if(!r.vertexAttributes||!r.vertexAttributes.position)return new e;const s=this.createMeshData(r),a=t(o)?await o.invoke("createIndexThread",s,{transferList:n}):this.createIndexThread(s).result;return this.createPooledRBush().fromJSON(a)}createIndexThread(t){const r=new Float64Array(t.position),e=this.createPooledRBush();return t.components?this.createIndexComponentsThread(e,r,t.components.map((t=>new Uint32Array(t)))):this.createIndexAllThread(e,r)}createIndexAllThread(t,r){const e=new Array(r.length/9);let o=0;for(let t=0;t<r.length;t+=9)e[o++]=s(r,t+0,t+3,t+6);return t.load(e),{result:t.toJSON()}}createIndexComponentsThread(t,r,e){let o=0;for(const t of e)o+=t.length/3;const n=new Array(o);let a=0;for(const t of e)for(let e=0;e<t.length;e+=3)n[a++]=s(r,3*t[e+0],3*t[e+1],3*t[e+2]);return t.load(n),{result:t.toJSON()}}createMeshData(t){const r=(t.transform?o({position:t.vertexAttributes.position,normal:null,tangent:null},t.transform,t.spatialReference).position:t.vertexAttributes.position).buffer;return!t.components||t.components.some((t=>!t.faces))?{position:r}:{position:r,components:t.components.map((t=>t.faces))}}createPooledRBush(){return new e(9,r("esri-csp-restrictions")?t=>t:[".minX",".minY",".maxX",".maxY"])}}function s(t,r,e,o){return{minX:Math.min(t[r+0],t[e+0],t[o+0]),maxX:Math.max(t[r+0],t[e+0],t[o+0]),minY:Math.min(t[r+1],t[e+1],t[o+1]),maxY:Math.max(t[r+1],t[e+1],t[o+1]),p0:[t[r+0],t[r+1],t[r+2]],p1:[t[e+0],t[e+1],t[e+2]],p2:[t[o+0],t[o+1],t[o+2]]}}export default n;export{n as ElevationSamplerWorker}