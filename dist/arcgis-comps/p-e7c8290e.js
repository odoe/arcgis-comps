import{e as t,d as i,i as s,p as o,I as e,_ as a,bw as n}from"./p-e58503d5.js";import{u as r}from"./p-ea916a39.js";import{j as h}from"./p-db63fa0e.js";import{g as p}from"./p-6d6923ed.js";import{h as c}from"./p-75cd09f2.js";import{e as l}from"./p-77b9a0fc.js";const u=Math.PI/180;function d(t){return t*u}const f=r(),m=[0,0],M=new l(0,0,0,0);let g=class extends o{constructor(t){super(t),this._imagePromise=null,this.bitmaps=[],this.hidpi=false,this.imageMaxWidth=2048,this.imageMaxHeight=2048,this.imageRotationSupported=false,this.imageNormalizationSupported=false,this.update=e((async(t,i)=>{if(!t.stationary||this.destroyed)return null;const s=t.state,o=n(s.spatialReference),e=this.hidpi?t.pixelRatio:1,a=this.imageNormalizationSupported&&s.worldScreenWidth&&s.worldScreenWidth<s.size[0];a?(m[0]=s.worldScreenWidth,m[1]=s.size[1]):this.imageRotationSupported?(m[0]=s.size[0],m[1]=s.size[1]):function(t,i){const s=d(i.rotation),o=Math.abs(Math.cos(s)),e=Math.abs(Math.sin(s)),[a,n]=i.size;t[0]=Math.round(n*e+a*o),t[1]=Math.round(n*o+a*e)}(m,s);const r=Math.floor(m[0]*e)>this.imageMaxWidth||Math.floor(m[1]*e)>this.imageMaxHeight,h=!this.imageNormalizationSupported&&o&&(s.extent.xmin<o.valid[0]||s.extent.xmax>o.valid[1]),p=this.imageRotationSupported?s.rotation:0;if(r||h){let t=Math.min(this.imageMaxWidth,this.imageMaxHeight);h&&(t=Math.min(s.worldScreenWidth,t)),this._imagePromise=this._tiledExport(s,t,p,e,i)}else this._imagePromise=this._singleExport(s,m,a?s.paddedViewState.center:s.center,s.resolution,p,e,i);return this._imagePromise.then((async t=>{if(this._imagePromise=null,!this.destroyed){this.bitmaps=null!=t?t:[];for(const i of this.container.children)t.includes(i)||i.fadeOut().then((()=>{i.remove()}));for(const i of t)this.container.addChild(i),i.fadeIn()}})).catch((t=>{throw this._imagePromise=null,t}))}),5e3)}destroy(){this.bitmaps=[]}get updating(){return!this.destroyed&&null!==this._imagePromise}updateExports(t){for(const i of this.container.children){if(!i.visible||!i.stage)return;t(i),i.invalidateTexture(),i.requestRender()}}async _export(t,i,s,o,e,a){const n=await this.fetchSource(t,Math.floor(i*e),Math.floor(s*e),{rotation:o,pixelRatio:e,signal:a}),r=new p(n,"additive");return r.x=t.xmin,r.y=t.ymax,r.resolution=t.width/i,r.rotation=o,r.pixelRatio=e,r}async _singleExport(t,i,s,o,e,n,r){!function(t,i,s,o){const[e,a]=i,[n,r]=o,h=.5*s;t[0]=e-h*n,t[1]=a-h*r,t[2]=e+h*n,t[3]=a+h*r}(f,s,o,i);const h=new a(f[0],f[1],f[2],f[3],t.spatialReference);return[await this._export(h,i[0],i[1],e,n,r)]}_tiledExport(t,i,s,o,e){const n=h.create({size:i,spatialReference:t.spatialReference,scales:[t.scale]}),r=new c(n),p=r.getTileCoverage(t);if(!p)return null;const l=[];return p.forEach(((n,h,p,c)=>{M.set(n,h,p,c),r.getTileBounds(f,M);const u=new a(f[0],f[1],f[2],f[3],t.spatialReference);l.push(this._export(u,i,i,s,o,e))})),Promise.all(l)}};t([i()],g.prototype,"_imagePromise",void 0),t([i()],g.prototype,"bitmaps",void 0),t([i()],g.prototype,"container",void 0),t([i()],g.prototype,"fetchSource",void 0),t([i()],g.prototype,"hidpi",void 0),t([i()],g.prototype,"imageMaxWidth",void 0),t([i()],g.prototype,"imageMaxHeight",void 0),t([i()],g.prototype,"imageRotationSupported",void 0),t([i()],g.prototype,"imageNormalizationSupported",void 0),t([i()],g.prototype,"requestUpdate",void 0),t([i()],g.prototype,"updating",null),g=t([s("esri.views.2d.layers.support.ExportStrategy")],g);const v=g;export{v as S}