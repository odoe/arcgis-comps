import{af as t,A as s,c as i,K as e,bE as r,b as h,s as n,dc as o,dd as a,c9 as u,V as c}from"./p-e58503d5.js";import{W as l,c as f,t as d,n as p,b as m,m as g}from"./p-5032dfbd.js";import{e as y}from"./p-182bb5be.js";import{A as b,t as x}from"./p-c0f84cd3.js";import{e as w}from"./p-2f398ed1.js";import{m as A}from"./p-889f7a78.js";import{d as I}from"./p-612de336.js";import{N as M,O as S,K as T,c as C,J as F}from"./p-47e1bd73.js";import{Q as _}from"./p-e3500fdc.js";import{n as D,l as z,r as j}from"./p-9b76ac50.js";class v extends b{constructor(t,s,i){super(t),this._featureIndex=-1,this._dateFields=new Set,this._geometryType=i,this._features=s}static fromFeatures(t,s,i){const e=l([],t,s,!1,!1,i);for(let s=0;s<e.length;s++)e[s].displayId=t[s].displayId;return v.fromOptimizedFeatures(e,s)}static fromFeatureSet(t,s){const i=f(t,s);return v.fromOptimizedFeatureSet(i)}static fromOptimizedFeatureSet(t){const{features:s,geometryType:i}=t,e=v.fromOptimizedFeatures(s,i);e._exceededTransferLimit=t.exceededTransferLimit,e._transform=t.transform;for(const s of t.fields)"esriFieldTypeDate"===s.type&&e._dateFields.add(s.name);return e}static fromOptimizedFeatures(t,s,i){const e=b.createInstance(),r=new v(e,t,s);return r._transform=i,r}get _current(){return this._features[this._featureIndex]}get geometryType(){return this._geometryType}get hasFeatures(){return!!this._features.length}get hasNext(){return this._featureIndex+1<this._features.length}get exceededTransferLimit(){return this._exceededTransferLimit}get hasZ(){return!1}get hasM(){return!1}removeIds(t){const s=new Set(t);this._features=this._features.filter((t=>!s.has(t.objectId)))}append(t){for(const s of t)this._features.push(s)}getSize(){return this._features.length}getCursor(){return this.copy()}getQuantizationTransform(){return this._transform}getAttributeHash(){let t="";for(const s in this._current.attributes)t+=this._current.attributes[s];return t}getIndex(){return this._featureIndex}setIndex(t){this._featureIndex=t}getObjectId(){return this._current.objectId}getDisplayId(){return this._current.displayId}setDisplayId(t){this._current.displayId=t}getGroupId(){return this._current.groupId}setGroupId(t){this._current.groupId=t}copy(){const t=new v(this.instance,this._features,this.geometryType);return this.copyInto(t),t}next(){for(;++this._featureIndex<this._features.length&&!this._getExists(););return this._featureIndex<this._features.length}readLegacyFeature(){return d(this._current,this.geometryType,this.hasZ,this.hasM)}readOptimizedFeature(){return this._current}readLegacyPointGeometry(){return this.readGeometry()?{x:this.getX(),y:this.getY()}:null}readLegacyGeometry(){const t=this.readGeometry();return p(t,this.geometryType,this.hasZ,this.hasM)}readLegacyCentroid(){const s=this.readCentroid();return t(s)?null:{x:s.coords[0]*this._sx+this._tx,y:s.coords[1]*this._sy+this._ty}}readGeometryArea(){return y(this._current)?m(this._current.geometry,2):0}readUnquantizedGeometry(){const t=this.readGeometry();if("esriGeometryPoint"===this.geometryType||!t)return t;const s=t.clone();return function({coords:t,lengths:s}){let i=0;for(const e of s){for(let s=1;s<e;s++)t[2*(i+s)]+=t[2*(i+s)-2],t[2*(i+s)+1]+=t[2*(i+s)-1];i+=e}}(s),s}readHydratedGeometry(){const i=this._current.geometry;if(t(i))return null;const e=i.clone();return s(this._transform)&&g(e,e,this.hasZ,this.hasM,this._transform),e}getXHydrated(){if(!y(this._current))return 0;const s=this._current.geometry.coords[0],i=this.getQuantizationTransform();return t(i)?s:s*i.scale[0]+i.translate[0]}getYHydrated(){if(!y(this._current))return 0;const s=this._current.geometry.coords[1],i=this.getQuantizationTransform();return t(i)?s:i.translate[1]-s*i.scale[1]}getX(){return y(this._current)?this._current.geometry.coords[0]*this._sx+this._tx:0}getY(){return y(this._current)?this._current.geometry.coords[1]*this._sy+this._ty:0}readGeometry(){if(!y(this._current))return null;const t=this._current.geometry.clone();if(t.isPoint)return t.coords[0]=t.coords[0]*this._sx+this._tx,t.coords[1]=t.coords[1]*this._sy+this._ty,t;let s=0;for(const i of t.lengths)t.coords[2*s]=t.coords[2*s]*this._sx+this._tx,t.coords[2*s+1]=t.coords[2*s+1]*this._sy+this._ty,s+=i;return t}readCentroid(){if(!y(this._current))return null;if(!this._current.centroid){const t=this._computeCentroid();if(!t)return null;t.coords[0]=(t.coords[0]-this._tx)/this._sx,t.coords[1]=(t.coords[1]-this._ty)/this._sy,this._current.centroid=t}const t=this._current.centroid.clone();return t.coords[0]=t.coords[0]*this._sx+this._tx,t.coords[1]=t.coords[1]*this._sx+this._ty,t}_readAttribute(t,s){const i=this._current.attributes[t];if(void 0!==i)return null!=i&&s&&this._dateFields.has(t)?new Date(i):i;const e=this.readAttributes(),r=t.toLocaleLowerCase().trim();for(const t in e)if(t.toLocaleLowerCase().trim()===r){const i=this._current.attributes[t];return null!=i&&s&&this._dateFields.has(t)?new Date(i):i}}copyInto(t){super.copyInto(t),t._featureIndex=this._featureIndex,t._transform=this._transform,t._dateFields=this._dateFields}_readAttributes(){return this._current.attributes}}const G=i.getLogger("esri.views.layers.2d.features.support.AttributeStore"),N=D(z,G),k=t=>(2147483648&t)>>>31,B=t=>2147483647&t;function O(t){return 1===k(t)}const H={sharedArrayBuffer:e("esri-shared-array-buffer"),atomics:e("esri-atomics")};function E(t,s){return i=>s(t(i))}class L{constructor(t,s,i,e){this.size=0,this.texelSize=4;const{pixelType:r,layout:h,textureOnly:n}=e;this.textureOnly=n||!1,this.pixelType=r,this._ctype=s,this.layout=h,this._resetRange(),this._shared=t,this.size=i,n||(this.data=this._initData(r,i,t,s))}get buffer(){return u(this.data,(t=>t.buffer))}unsetComponentAllTexels(t,s){const i=c(this.data);for(let e=0;e<this.size*this.size;e++)i[e*this.texelSize+t]&=~s;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponentAllTexels(t,s){const i=c(this.data);for(let e=0;e<this.size*this.size;e++)i[e*this.texelSize+t]|=255&s;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponent(t,s,i){const e=c(this.data);for(const r of i)e[r*this.texelSize+t]|=s,this.dirtyStart=Math.min(this.dirtyStart,r),this.dirtyEnd=Math.max(this.dirtyEnd,r)}setComponentTexel(t,s,i){c(this.data)[i*this.texelSize+t]|=s,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i)}unsetComponentTexel(t,s,i){c(this.data)[i*this.texelSize+t]&=~s,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i)}getData(t,s){const i=B(t);return c(this.data)[i*this.texelSize+s]}setData(t,s,i){const e=B(t);0!=(this.layout&1<<s)?(this.data[e*this.texelSize+s]=i,this.dirtyStart=Math.min(this.dirtyStart,e),this.dirtyEnd=Math.max(this.dirtyEnd,e)):G.error("mapview-attributes-store","Tried to set a value for a texel's readonly component")}lock(){5121===this.pixelType&&this._shared&&H.atomics&&"local"!==this._ctype&&Atomics.store(this.data,0,1)}unlock(){5121===this.pixelType&&this._shared&&H.atomics&&"local"!==this._ctype&&Atomics.store(this.data,0,0)}expand(t){if(this.size=t,!this.textureOnly){const s=this._initData(this.pixelType,t,this._shared,this._ctype),i=c(this.data);s.set(i),this.data=s}}toMessage(){const t=this.dirtyStart,s=this.dirtyEnd,i=this.texelSize;if(t>s)return null;this._resetRange();const e=!(this._shared||"local"===this._ctype),r=this.pixelType,h=this.layout,n=c(this.data);return{start:t,end:s,data:e&&n.slice(t*i,(s+1)*i)||null,pixelType:r,layout:h}}_initData(t,s,i,e){const r=i&&"local"!==e?SharedArrayBuffer:ArrayBuffer,h=_(t),n=new h(new r(s*s*4*h.BYTES_PER_ELEMENT));for(let t=0;t<n.length;t+=4)n[t+1]=255;return n}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}}class P{constructor(t,s){this._client=t,this.config=s,this._attributeComputeMap=new Map,this._blocks=new Array,this._filters=new Array(M),this._targetType=0,this._abortController=new AbortController,this._hasScaleExpr=!1,this._size=32,this._idsToHighlight=new Set;const i=s.supportsTextureFloat?5126:5121;N(`Creating AttributeStore ${H.sharedArrayBuffer?"with":"without"} shared memory`),this._blockDescriptors=[{pixelType:5121,layout:1},{pixelType:5121,layout:15,textureOnly:!0},{pixelType:i,layout:15},{pixelType:i,layout:15}],this._blocks=this._blockDescriptors.map((()=>null))}destroy(){this._abortController.abort()}get hasScaleExpr(){return this._hasScaleExpr}get _signal(){return this._abortController.signal}update(i,r){this.config=r;const h=r.schema.processors[0].storage,n=A(this._schema,h);if((i.targets.feature||i.targets.aggregate)&&(i.storage.data=!0),n&&(e("esri-2d-update-debug")&&console.debug("Applying Update - AttributeStore:",n),i.storage.data=!0,this._schema=h,this._attributeComputeMap.clear(),!t(h))){switch(h.target){case"feature":this._targetType=0;break;case"aggregate":this._targetType=1}if("subtype"===h.type)for(const t in h.mapping){const i=h.mapping[t];if(s(i))for(const t of i.mapping)this._bindAttribute(t)}else for(const t of h.mapping)this._bindAttribute(t)}}onTileData(s,i){if(t(i.addOrUpdate))return;const e=i.addOrUpdate.getCursor();for(;e.next();){const t=e.getDisplayId();this.setAttributeData(t,e)}}invalidateResources(){this._createResourcesPromise=null,this._abortController.abort(),this._abortController=new AbortController}async setHighlight(t,s){const i=this._getBlock(0),e=s.map((t=>B(t)));i.lock(),i.unsetComponentAllTexels(0,1),i.setComponent(0,1,e),i.unlock(),this._idsToHighlight.clear();for(const s of t)this._idsToHighlight.add(s);await this.sendUpdates()}async updateFilters(t,s){const{config:i,service:r,spatialReference:h}=s,{filters:n}=i,o=n.map(((t,s)=>this._updateFilter(t,s,r,h)));(await Promise.all(o)).some((t=>t))&&(t.storage.filters=!0,e("esri-2d-update-debug")&&console.debug("Applying Update - AttributeStore:","Filters changed"))}setData(t,s,i,e){const r=B(t);this._ensureSizeForTexel(r),this._getBlock(s).setData(t,i,e)}getData(t,s,i){return this._getBlock(s).getData(t,i)}getHighlightFlag(t){return this._idsToHighlight.has(t)?S:0}unsetAttributeData(t){const s=B(t);this._getBlock(0).setData(s,0,0)}setAttributeData(t,s){const i=B(t);if(this._ensureSizeForTexel(i),this._getBlock(0).setData(i,0,this.getFilterFlags(s)),this._targetType!==k(t))return;const e=this._attributeComputeMap,r=this.config.supportsTextureFloat?1:2;e.size&&e.forEach(((t,e)=>{const h=e*r%4,n=Math.floor(e*r/4),o=this._getBlock(n+T),a=t(s);if(this.config.supportsTextureFloat)o.setData(i,h,a);else if(a===C)o.setData(i,h,255),o.setData(i,h+1,255);else{const t=w(Math.round(a),-32767,32766)+32768,s=(65280&t)>>8;o.setData(i,h,255&t),o.setData(i,h+1,s)}}))}sendUpdates(){if(this._nextUpdate)return this._nextUpdate.promise;if(this._currUpdate)return this._nextUpdate=r(),this._nextUpdate.promise;const t={blocks:this._blocks.map((t=>s(t)?t.toMessage():null))};return this._currUpdate=this._createResources().then((()=>{const s=()=>{if(this._currUpdate=null,this._nextUpdate){const t=this._nextUpdate;this._nextUpdate=null,this.sendUpdates().then((()=>t.resolve()))}},i=this._client.update(t,this._signal).then(s).catch(s);return this._client.render(this._signal),i})).catch((t=>h(t)?(this._createResourcesPromise=null,this._createResources()):(G.error(new n("mapview-attribute-store","Encountered an error during client update",t)),Promise.resolve()))),this._currUpdate}_ensureSizeForTexel(t){for(;t>=this._size*this._size;)if(this._expand())return}_bindAttribute(t){let s;if(null!=t.fieldIndex)t.normalizationField&&G.warn("mapview-arcade","Ignoring normalizationField specified with an arcade expression which is not supported."),s=s=>s.getComputedNumericAtIndex(t.fieldIndex);else{if(!t.field)return;s=t.normalizationField?s=>{const i=s.readAttribute(t.normalizationField);return i?s.readAttribute(t.field)/i:null}:s=>s.readAttribute(t.field)}t.valueRepresentation&&(s=E(s,(s=>j(s,t.valueRepresentation)))),this._attributeComputeMap.set(t.binding,E(s,(t=>null===t||isNaN(t)||t===1/0?C:t)))}_createResources(){if(s(this._createResourcesPromise))return this._createResourcesPromise;this._getBlock(F),N("Initializing AttributeStore");const i={shared:H.sharedArrayBuffer&&!("local"===this._client.type),size:this._size,blocks:o(this._blocks,(t=>({textureOnly:t.textureOnly,buffer:t.buffer,pixelType:t.pixelType})))},e=this._client.initialize(i,this._signal).catch((t=>{h(t)?this._createResourcesPromise=null:G.error(new n("mapview-attribute-store","Encountered an error during client initialization",t))}));return this._createResourcesPromise=e,e.then((()=>t(this._createResourcesPromise)?this._createResources():void 0)),e}_getBlock(t){const i=this._blocks[t];if(s(i))return i;N(`Initializing AttributeBlock at index ${t}`);const e=new L(H.sharedArrayBuffer,this._client.type,this._size,this._blockDescriptors[t]);return this._blocks[t]=e,this._createResourcesPromise=null,e}_expand(){if(this._size<this.config.maxTextureSize){const t=this._size<<=1;return N("Expanding block size to",t,this._blocks),a(this._blocks,(s=>s.expand(t))),this._createResourcesPromise=null,this._size=t,0}return G.error(new n("mapview-limitations","Maximum number of onscreen features exceeded.")),-1}async _updateFilter(i,e,r,h){const n=this._filters[e],o=s(n)&&n.hash;if(!n&&!i)return!1;if(o===JSON.stringify(i))return!1;if(t(i)){if(!n)return!1;const t=1<<e+1,s=this._getBlock(0);return this._filters[e]=null,s.setComponentAllTexels(0,t),this.sendUpdates(),!0}const a=await this._getFilter(e,r);return await a.update(i,h),!0}async _getFilter(t,i){const e=this._filters[t];if(s(e))return e;const{default:r}=await import("./p-c326b042.js"),h=new r({geometryType:i.geometryType,hasM:!1,hasZ:!1,timeInfo:i.timeInfo,fieldsIndex:new I(i.fields)});return this._filters[t]=h,h}isVisible(t){return!!(2&this._getBlock(0).getData(t,0))}getFilterFlags(s){let i=0;const e=(t=>1===k(t)?254:255)(s.getDisplayId());for(let r=0;r<this._filters.length;r++){const h=this._filters[r];i|=(e&1<<r&&!t(h)&&!h.check(s)?0:1)<<r}let r=0;if(this._idsToHighlight.size){const t=s.getObjectId();r=this.getHighlightFlag(t)}return i<<1|r}}class R{constructor(){this._freeIds=[],this._idCounter=1}createId(t=!1){return function(t,s){return((s?2147483648:0)|t)>>>0}(this._getFreeId(),t)}releaseId(t){this._freeIds.push(t)}_getFreeId(){return this._freeIds.length?this._freeIds.pop():this._idCounter++}}function U(t,s,i){if(!(t.length>s))for(;t.length<=s;)t.push(i)}const X=2147483647;class Y{constructor(){this._numerics=[],this._strings=[],this._idGenerator=new R,this._allocatedSize=256,this._bitsets=[],this._instanceIds=[],this._bounds=[]}createBitset(){const t=this._bitsets.length;return this._bitsets.push(x.create(this._allocatedSize,X)),t+1}getBitset(t){return this._bitsets[t-1]}_expand(){this._allocatedSize<<=1;for(const t of this._bitsets)t.resize(this._allocatedSize)}_ensureNumeric(t,s){this._numerics[t]||(this._numerics[t]=[]),U(this._numerics[t],s,0)}_ensureInstanceId(t){U(this._instanceIds,t,0)}_ensureString(t,s){this._strings[t]||(this._strings[t]=[]),U(this._strings[t],s,null)}createDisplayId(t=!1){const s=this._idGenerator.createId();return s>this._allocatedSize&&this._expand(),((t,s)=>((s?2147483648:0)|t)>>>0)(s,t)}releaseDisplayId(t){for(const s of this._bitsets)s.unset(t);return this._idGenerator.releaseId(t&X)}getComputedNumeric(t,s){return this.getComputedNumericAtIndex(t&X,0)}setComputedNumeric(t,s,i){return this.setComputedNumericAtIndex(t&X,i,0)}getComputedString(t,s){return this.getComputedStringAtIndex(t&X,0)}setComputedString(t,s,i){return this.setComputedStringAtIndex(t&X,0,i)}getComputedNumericAtIndex(t,s){const i=t&X;return this._ensureNumeric(s,i),this._numerics[s][i]}setComputedNumericAtIndex(t,s,i){const e=t&X;this._ensureNumeric(s,e),this._numerics[s][e]=i}getInstanceId(t){const s=t&X;return this._ensureInstanceId(s),this._instanceIds[s]}setInstanceId(t,s){const i=t&X;this._ensureInstanceId(i),this._instanceIds[i]=s}getComputedStringAtIndex(t,s){const i=t&X;return this._ensureString(s,i),this._strings[s][i]}setComputedStringAtIndex(t,s,i){const e=t&X;this._ensureString(s,e),this._strings[s][e]=i}getXMin(t){return this._bounds[4*(t&X)]}getYMin(t){return this._bounds[4*(t&X)+1]}getXMax(t){return this._bounds[4*(t&X)+2]}getYMax(t){return this._bounds[4*(t&X)+3]}setBounds(t,s){const i=s.readHydratedGeometry();if(!i||!i.coords.length)return!1;let e=1/0,r=1/0,h=-1/0,n=-1/0;i.forEachVertex(((t,s)=>{e=Math.min(e,t),r=Math.min(r,s),h=Math.max(h,t),n=Math.max(n,s)}));const o=t&X;return U(this._bounds,4*o+4,0),this._bounds[4*o]=e,this._bounds[4*o+1]=r,this._bounds[4*o+2]=h,this._bounds[4*o+3]=n,!0}}export{O as B,P,B as R,v as d,Y as u}