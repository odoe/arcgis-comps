import{bl as t,aZ as s,aw as e,A as i,b as n}from"./p-e58503d5.js";import{t as o,n as r,f as c,h,a,r as l,P as f,b as u}from"./p-9790d1b4.js";import{t as d,C as p}from"./p-2d0c34e5.js";import{o as w}from"./p-4414d64f.js";import{t as m,r as b,a as M,n as y,e as g,b as x}from"./p-f94ceb31.js";import{a as k}from"./p-9d34911e.js";import{t as I,d as _,f as T,a as v}from"./p-7356a318.js";import{x as A}from"./p-97ec6ae5.js";import"./p-53bb6ab4.js";import"./p-47e1bd73.js";import"./p-a617738c.js";import"./p-e273719b.js";import"./p-74de0937.js";import"./p-2f398ed1.js";import"./p-d3105731.js";import"./p-81049b2d.js";import"./p-9658240e.js";function L(t){return 746===t||747===t||!(t<4352)&&(t>=12704&&t<=12735||t>=12544&&t<=12591||t>=65072&&t<=65103&&!(t>=65097&&t<=65103)||t>=63744&&t<=64255||t>=13056&&t<=13311||t>=11904&&t<=12031||t>=12736&&t<=12783||t>=12288&&t<=12351&&!(t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||t>=13312&&t<=19903||t>=19968&&t<=40959||t>=12800&&t<=13055||t>=12592&&t<=12687||t>=43360&&t<=43391||t>=55216&&t<=55295||t>=4352&&t<=4607||t>=44032&&t<=55215||t>=12352&&t<=12447||t>=12272&&t<=12287||t>=12688&&t<=12703||t>=12032&&t<=12255||t>=12784&&t<=12799||t>=12448&&t<=12543&&12540!==t||t>=65280&&t<=65519&&!(65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||t>=65104&&t<=65135&&!(t>=65112&&t<=65118||t>=65123&&t<=65126)||t>=5120&&t<=5759||t>=6320&&t<=6399||t>=65040&&t<=65055||t>=19904&&t<=19967||t>=40960&&t<=42127||t>=42128&&t<=42191)}function N(t){return!(t<11904)&&(t>=12704&&t<=12735||t>=12544&&t<=12591||t>=65072&&t<=65103||t>=63744&&t<=64255||t>=13056&&t<=13311||t>=11904&&t<=12031||t>=12736&&t<=12783||t>=12288&&t<=12351||t>=13312&&t<=19903||t>=19968&&t<=40959||t>=12800&&t<=13055||t>=65280&&t<=65519||t>=12352&&t<=12447||t>=12272&&t<=12287||t>=12032&&t<=12255||t>=12784&&t<=12799||t>=12448&&t<=12543||t>=65040&&t<=65055||t>=42128&&t<=42191||t>=40960&&t<=42127)}function P(t){switch(t){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function j(t){switch(t){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}const S=24;class D{constructor(t,s,e,i,n,o,r){this._glyphItems=t,this._maxWidth=s,this._lineHeight=e,this._letterSpacing=i,this._hAnchor=n,this._vAnchor=o,this._justify=r}getShaping(t,s,e){const i=this._letterSpacing,n=this._lineHeight,o=this._justify,r=this._maxWidth,c=[];let h=0,a=0;const l=t.length;for(let s=0;s<l;s++){const n=t.charCodeAt(s),o=e&&L(n);let r;for(const t of this._glyphItems)if(r=t[n],r)break;c.push({codePoint:n,x:h,y:a,vertical:o,glyphMosaicItem:r}),r&&(h+=r.metrics.advance+i)}let f=h;r>0&&(f=h/Math.max(1,Math.ceil(h/r)));const u=t.indexOf("â€‹")>=0,d=[];for(let t=0;t<l-1;t++){const s=c[t].codePoint,e=N(s);if(P(s)||e){let i=0;if(10===s)i-=1e4;else if(e&&u)i+=150;else{40!==s&&65288!==s||(i+=50);const e=c[t+1].codePoint;41!==e&&65289!==e||(i+=50)}d.push(this._buildBreak(t+1,c[t].x,f,d,i,!1))}}const p=this._optimalBreaks(this._buildBreak(l,h,f,d,0,!0));let w=0;const m=s?-n:n;let b=0;for(let t=0;t<p.length;t++){const s=p[t];let e=b;for(;e<s&&j(c[e].codePoint);)c[e].glyphMosaicItem=null,++e;let i=s-1;for(;i>e&&j(c[i].codePoint);)c[i].glyphMosaicItem=null,--i;if(e<=i){const t=c[e].x;for(let s=e;s<=i;s++)c[s].x-=t,c[s].y=a;let s=c[i].x;c[i].glyphMosaicItem&&(s+=c[i].glyphMosaicItem.metrics.advance),w=Math.max(s,w),o&&this._applyJustification(c,e,i)}b=s,a+=m}if(c.length>0){const t=p.length-1,e=(o-this._hAnchor)*w;let i=(-this._vAnchor*(t+1)+.5)*n;s&&t&&(i+=t*n);for(const t of c)t.x+=e,t.y+=i}return c.filter((t=>t.glyphMosaicItem))}static getTextBox(t,s){if(!t.length)return null;let e=1/0,i=1/0,n=0,o=0;for(const r of t){const t=r.x,c=r.y-17,h=t+r.glyphMosaicItem.metrics.advance,a=c+s;e=Math.min(e,t),n=Math.max(n,h),i=Math.min(i,c),o=Math.max(o,a)}return{x:e,y:i,width:n-e,height:o-i}}static getBox(t){if(!t.length)return null;let s=1/0,e=1/0,i=0,n=0;for(const o of t){const{height:t,left:r,top:c,width:h}=o.glyphMosaicItem.metrics,a=o.x,l=o.y-(t-Math.abs(c)),f=a+h+r,u=l+t;s=Math.min(s,a),i=Math.max(i,f),e=Math.min(e,l),n=Math.max(n,u)}return{x:s,y:e,width:i-s,height:n-e}}static addDecoration(t,s){const e=t.length;if(0===e)return;let i=t[0].x+t[0].glyphMosaicItem.metrics.left,n=t[0].y;for(let o=1;o<e;o++){const e=t[o];if(e.y!==n){const r=t[o-1].x+t[o-1].glyphMosaicItem.metrics.left+t[o-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:i,y:n+s-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new d(4,0,4,8),metrics:{width:r-i,height:8,left:0,top:0,advance:0},page:0,code:0}}),n=e.y,i=e.x+e.glyphMosaicItem.metrics.left}}const o=t[e-1].x+t[e-1].glyphMosaicItem.metrics.left+t[e-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:i,y:n+s-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new d(4,0,4,8),metrics:{width:o-i,height:8,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(t,s,e,i){const n=(t-s)*(t-s);return i?t<s?n/2:2*n:n+Math.abs(e)*e}_buildBreak(t,s,e,i,n,o){let r=null,c=this._breakScore(s,e,n,o);for(const t of i){const i=this._breakScore(s-t.x,e,n,o)+t.score;i<=c&&(r=t,c=i)}return{index:t,x:s,score:c,previousBreak:r}}_optimalBreaks(t){return t?this._optimalBreaks(t.previousBreak).concat(t.index):[]}_applyJustification(t,s,e){const i=t[e],n=(i.x+(i.vertical?S:i.glyphMosaicItem?i.glyphMosaicItem.metrics.advance:0))*this._justify;for(let i=s;i<=e;i++)t[i].x-=n}}const F=.5;class B{constructor(t,s,e=0,i=-1,n=F){this.x=t,this.y=s,this.angle=e,this.segment=i,this.minzoom=n}}class C{constructor(t,s,e,i,n,o=F,c=r){this.anchor=t,this.labelAngle=s,this.glyphAngle=e,this.page=i,this.alternateVerticalGlyph=n,this.minzoom=o,this.maxzoom=c}}class U{constructor(t,s,e,i,n,o,r,c,h,a,l,f){this.tl=t,this.tr=s,this.bl=e,this.br=i,this.mosaicRect=n,this.labelAngle=o,this.minAngle=r,this.maxAngle=c,this.anchor=h,this.minzoom=a,this.maxzoom=l,this.page=f}}class R{constructor(t){this.shapes=t}}class O{getIconPlacement(t,s,e){const i=new m(t.x,t.y),n=0===e.rotationAlignment,r=e.keepUpright;let h=e.rotate*c;n&&(h+=t.angle);const a=new R([]);return e.allowOverlap&&e.ignorePlacement||!w||(a.iconColliders=[]),this._addIconPlacement(a,i,s,e,h),n&&r&&this._addIconPlacement(a,i,s,e,h+o),a}_addIconPlacement(t,s,e,i,n){const o=e.pixelRatio,c=e.width/o,h=e.height/o,a=i.offset;let l=a[0],f=a[1];switch(i.anchor){case 0:l-=c/2,f-=h/2;break;case 1:f-=h/2;break;case 2:l-=c,f-=h/2;break;case 3:l-=c/2;break;case 4:l-=c/2,f-=h;break;case 5:break;case 7:f-=h;break;case 6:l-=c;break;case 8:l-=c,f-=h}const u=e.rect,d=2/o,p=l-d,b=f-d,M=p+u.width/o,y=b+u.height/o,g=new m(p,b),x=new m(M,y),k=new m(p,y),I=new m(M,b);if(0!==n){const t=Math.cos(n),s=Math.sin(n);g.rotate(t,s),x.rotate(t,s),k.rotate(t,s),I.rotate(t,s)}const _=new U(g,I,k,x,u,n,0,256,s,F,r,0);if(t.shapes.push(_),(!i.allowOverlap||!i.ignorePlacement)&&w){const e=i.size,o=i.padding;t.iconColliders.push({xTile:s.x,yTile:s.y,dxPixels:l*e-o,dyPixels:f*e-o,hard:!i.optional,partIndex:0,width:c*e+2*o,height:h*e+2*o,angle:n,minLod:F,maxLod:r})}}getTextPlacement(t,s,e,i){const n=new m(t.x,t.y),h=i.rotate*c,a=0===i.rotationAlignment,l=i.keepUpright,f=i.padding;let u=F;const d=a?t.angle:0,p=t.segment>=0&&a,w=i.allowOverlap&&i.ignorePlacement?null:[],b=[],M=!p;let y=Number.POSITIVE_INFINITY,g=Number.NEGATIVE_INFINITY,x=y,k=g;const I=(p||a)&&l,_=i.size/S;let T=!1;for(const t of s)if(t.vertical){T=!0;break}let v,A=0,L=0;if(!p&&T){const t=D.getTextBox(s,i.lineHeight*S);switch(i.anchor){case 1:A=t.height/2,L=-t.width/2;break;case 2:A=-t.height/2,L=t.width/2;break;case 3:A=t.height/2,L=t.width/2;break;case 4:A=-t.height/2,L=-t.width/2;break;case 5:A=t.height;break;case 7:L=-t.width;break;case 6:L=t.width;break;case 8:A=-t.height}}A+=i.offset[0]*S,L+=i.offset[1]*S;for(const c of s){const s=c.glyphMosaicItem;if(!s||s.rect.isEmpty)continue;const N=s.rect,P=s.metrics,j=s.page;if(w&&M){if(void 0!==v&&v!==c.y){let s,e,n,o;T?(s=-k+A,e=y+L,n=k-x,o=g-y):(s=y+A,e=x+L,n=g-y,o=k-x),w.push({xTile:t.x,yTile:t.y,dxPixels:s*_-f,dyPixels:e*_-f,hard:!i.optional,partIndex:1,width:n*_+2*f,height:o*_+2*f,angle:h,minLod:F,maxLod:r}),y=Number.POSITIVE_INFINITY,g=Number.NEGATIVE_INFINITY,x=y,k=g}v=c.y}const S=[];if(p){const i=(c.x+P.left-4+.5*s.metrics.width)*_*8;if(u=this._placeGlyph(t,u,i,e,t.segment,1,c.vertical,j,S),l&&(u=this._placeGlyph(t,u,i,e,t.segment,-1,c.vertical,j,S)),u>=2)break}else S.push(new C(n,d,d,j,!1)),a&&l&&S.push(new C(n,d+o,d+o,j,!1));const D=c.x+P.left,B=c.y-17-P.top,R=D+P.width,O=B+P.height;let z,V,G,q,E,W,K,Y;!p&&T?c.vertical?(z=new m(-((B+O)/2+P.width/2)-4+A,(D+R)/2-P.height/2-4+L),V=new m(z.x+N.width,z.y+N.height),G=new m(z.x,V.y),q=new m(V.x,z.y)):(z=new m(4-B+A,D-4+L),V=new m(z.x-N.height,z.y+N.width),G=new m(V.x,z.y),q=new m(z.x,V.y)):(z=new m(D-4+A,B-4+L),V=new m(z.x+N.width,z.y+N.height),G=new m(z.x,V.y),q=new m(V.x,z.y));for(const s of S){let e,n,o,r;s.alternateVerticalGlyph?(E||(E=new m((D+R)/2+A-P.height/2-4,(B+O)/2+L+P.width/2+4),W=new m(E.x+N.height,E.y-N.width),K=new m(W.x,E.y),Y=new m(E.x,W.y)),e=E,n=K,o=Y,r=W):(e=z,n=G,o=q,r=V);const a=B,l=O,u=s.glyphAngle+h;if(0!==u){const t=Math.cos(u),s=Math.sin(u);e=e.clone(),n=n.clone(),o=o.clone(),r=r.clone(),e.rotate(t,s),r.rotate(t,s),n.rotate(t,s),o.rotate(t,s)}let d=0,v=256;p&&T?c.vertical?s.alternateVerticalGlyph?(d=32,v=96):(d=224,v=32):(d=224,v=96):(d=192,v=64),b.push(new U(e,o,n,r,N,s.labelAngle,d,v,s.anchor,s.minzoom,s.maxzoom,s.page)),!w||I&&!this._legible(s.labelAngle)||(M?(D<y&&(y=D),a<x&&(x=a),R>g&&(g=R),l>k&&(k=l)):s.minzoom<2&&w.push({xTile:t.x,yTile:t.y,dxPixels:(D+A)*_-f,dyPixels:(a+A)*_-f,hard:!i.optional,partIndex:1,width:(R-D)*_+2*f,height:(l-a)*_+2*f,angle:u,minLod:s.minzoom,maxLod:s.maxzoom}))}}if(u>=2)return null;if(w&&M){let s,e,n,o;T?(s=-k+A,e=y+L,n=k-x,o=g-y):(s=y+A,e=x+L,n=g-y,o=k-x),w.push({xTile:t.x,yTile:t.y,dxPixels:s*_-f,dyPixels:e*_-f,hard:!i.optional,partIndex:1,width:n*_+2*f,height:o*_+2*f,angle:h,minLod:F,maxLod:r})}const N=new R(b);return w&&w.length>0&&(N.textColliders=w),N}_legible(t){const s=h(t);return s<65||s>=193}_placeGlyph(t,s,e,i,n,c,h,f,u){let d=c;const p=d<0?a(t.angle+o,l):t.angle;let w=0;e<0&&(d*=-1,e*=-1,w=o),d>0&&++n;let b=new m(t.x,t.y),M=i[n],y=r;if(i.length<=n)return y;for(;;){const t=M.x-b.x,o=M.y-b.y,r=Math.sqrt(t*t+o*o),c=Math.max(e/r,s),m=a(Math.atan2(o/r,t/r)+w,l);if(u.push(new C(b,p,m,f,!1,c,y)),h&&u.push(new C(b,p,m,f,!0,c,y)),c<=s)return c;b=M.clone();do{if(i.length<=(n+=d)||n<0)return c;M=i[n]}while(b.isEqual(M));let g=M.x-b.x,x=M.y-b.y;const k=Math.sqrt(g*g+x*x);g*=r/k,x*=r/k,b.x-=g,b.y-=x,y=c}}}class z{constructor(t,s){this.values={};const e=s.keys,i=s.values;for(;t.next();)switch(t.tag()){case 1:this.id=t.getUInt64();break;case 2:{const s=t.getMessage(),n=this.values;for(;!s.empty();){const t=s.getUInt32(),o=s.getUInt32();n[e[t]]=i[o]}s.release();break}case 3:this.type=t.getUInt32();break;case 4:this._pbfGeometry=t.getMessage();break;default:t.skip()}}getGeometry(t){if(void 0!==this._geometry)return this._geometry;if(!this._pbfGeometry)return null;const s=this._pbfGeometry;let e,i;this._pbfGeometry=null,t?t.reset(this.type):e=[];let n,o=1,r=0,c=0,h=0;for(;!s.empty();){if(0===r){const t=s.getUInt32();o=7&t,r=t>>3}switch(r--,o){case 1:c+=s.getSInt32(),h+=s.getSInt32(),t?t.moveTo(c,h):(i&&e.push(i),i=[],i.push(new m(c,h)));break;case 2:c+=s.getSInt32(),h+=s.getSInt32(),t?t.lineTo(c,h):i.push(new m(c,h));break;case 7:t?t.close():i&&!i[0].equals(c,h)&&i.push(i[0].clone());break;default:throw s.release(),new Error("Invalid path operation")}}return t?n=t.result():(i&&e.push(i),n=e),s.release(),this._geometry=n,n}}class V extends I{constructor(){super(12)}add(t,s,e){const i=this.array;i.push(t),i.push(s),i.push(e)}}class G{constructor(t){for(this.extent=4096,this.keys=[],this.values=[],this._pbfLayer=t.clone();t.next();)switch(t.tag()){case 1:this.name=t.getString();break;case 3:this.keys.push(t.getString());break;case 4:this.values.push(t.processMessage(G._parseValue));break;case 5:this.extent=t.getUInt32();break;default:t.skip()}}getData(){return this._pbfLayer}static _parseValue(t){for(;t.next();)switch(t.tag()){case 1:return t.getString();case 2:return t.getFloat();case 3:return t.getDouble();case 4:return t.getInt64();case 5:return t.getUInt64();case 6:return t.getSInt64();case 7:return t.getBool();default:t.skip()}return null}}class q extends I{constructor(t){super(t)}add(t,s,e,i,n,o,r,c,h,a,l,f){const u=this.array;let d=I.i1616to32(t,s);u.push(d);const p=31;d=I.i8888to32(Math.round(p*e),Math.round(p*i),Math.round(p*n),Math.round(p*o)),u.push(d),d=I.i8888to32(Math.round(p*r),Math.round(p*c),Math.round(p*h),Math.round(p*a)),u.push(d),d=I.i1616to32(l,0),u.push(d),f&&u.push(...f)}}class E extends I{constructor(t){super(t)}add(t,s,e){const i=this.array;i.push(I.i1616to32(t,s)),e&&i.push(...e)}}class W extends I{constructor(t){super(t)}add(t,s,e,i,n,o,r){const c=this.array,h=this.index;let a=I.i1616to32(t,s);return c.push(a),a=I.i8888to32(Math.round(15*e),Math.round(15*i),n,o),c.push(a),r&&c.push(...r),h}}class K extends I{constructor(t){super(t)}add(t,s,e,i,n,o,r,c,a,l,f,u){const d=this.array;let p=I.i1616to32(t,s);d.push(p),p=I.i1616to32(Math.round(8*e),Math.round(8*i)),d.push(p),p=I.i8888to32(n/4,o/4,c,a),d.push(p),p=I.i8888to32(0,h(r),10*l,Math.min(10*f,255)),d.push(p),u&&d.push(...u)}}class Y extends I{constructor(t){super(t)}add(t,s,e,i,n){const o=this.array,r=I.i1616to32(2*t+e,2*s+i);o.push(r),n&&o.push(...n)}}class Z{constructor(t,s,e){this.layerExtent=4096,this._features=[],this.layer=t,this.zoom=s,this._spriteInfo=e,this._filter=t.getFeatureFilter()}pushFeature(t){this._filter&&!this._filter.filter(t,this.zoom)||this._features.push(t)}hasFeatures(){return this._features.length>0}getResources(t,s,e){}}class H extends Z{constructor(t,s,e,i,n){super(t,s,e),this.type=4,this._circleVertexBuffer=i,this._circleIndexBuffer=n}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(t){const s=this._circleVertexBuffer,e=this._circleIndexBuffer;this._circleIndexStart=3*e.index,this._circleIndexCount=0;const i=this.layer,n=this.zoom;t&&t.setExtent(this.layerExtent);for(const o of this._features){const r=o.getGeometry(t);if(!r)continue;const c=i.circleMaterial.encodeAttributes(o,n,i);for(const t of r)if(t)for(const i of t){const t=s.index;s.add(i.x,i.y,0,0,c),s.add(i.x,i.y,0,1,c),s.add(i.x,i.y,1,0,c),s.add(i.x,i.y,1,1,c),e.add(t+0,t+1,t+2),e.add(t+1,t+2,t+3),this._circleIndexCount+=6}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this._circleVertexBuffer.array.length,t+=this._circleIndexBuffer.array.length;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._circleIndexStart,s[i++]=this._circleIndexCount,s[i++]=this._circleVertexBuffer.array.length;for(let t=0;t<this._circleVertexBuffer.array.length;t++)e[i++]=this._circleVertexBuffer.array[t];s[i++]=this._circleIndexBuffer.array.length;for(let t=0;t<this._circleIndexBuffer.array.length;t++)s[i++]=this._circleIndexBuffer.array[t];return s.buffer}}class J extends Z{constructor(t,s,e,i,n,o,r){super(t,s,e),this.type=1,this._patternMap=new Map,this._fillVertexBuffer=i,this._fillIndexBuffer=n,this._outlineVertexBuffer=o,this._outlineIndexBuffer=r}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(t,s,e){const i=this.zoom,n=this.layer.getPaintProperty("fill-pattern");if(n)if(n.isDataDriven)for(const t of this._features)s(n.getValue(i,t),!0);else s(n.getValue(i),!0)}processFeatures(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const s=this.layer,e=this.zoom,{fillMaterial:i,outlineMaterial:n,hasDataDrivenFill:o,hasDataDrivenOutline:r}=s;t&&t.setExtent(this.layerExtent);const c=s.getPaintProperty("fill-pattern"),h=null==c?void 0:c.isDataDriven;let a=!c&&s.getPaintValue("fill-antialias",e);if(s.outlineUsesFillColor){if(a&&!s.hasDataDrivenOpacity){const t=s.getPaintValue("fill-opacity",e),i=s.getPaintValue("fill-opacity",e+1);t<1&&i<1&&(a=!1)}if(a&&!s.hasDataDrivenColor){const t=s.getPaintValue("fill-color",e),i=s.getPaintValue("fill-color",e+1);t[3]<1&&i[3]<1&&(a=!1)}}const l=this._features,f=null==t?void 0:t.validateTessellation;if(h){const o=[];for(const h of l){const l=c.getValue(e,h),u=this._spriteInfo[l];if(!u||!u.rect)continue;const d=i.encodeAttributes(h,e,s,u),p=a&&r?n.encodeAttributes(h,e,s):[],w=h.getGeometry(t);o.push({ddFillAttributes:d,ddOutlineAttributes:p,page:u.page,geometry:w}),o.sort(((t,s)=>t.page-s.page));for(const{ddFillAttributes:t,ddOutlineAttributes:e,page:i,geometry:n}of o)this._processFeature(n,a,s.outlineUsesFillColor,t,e,f,i)}}else for(const c of l){const h=o?i.encodeAttributes(c,e,s):null,l=a&&r?n.encodeAttributes(c,e,s):null,u=c.getGeometry(t);this._processFeature(u,a,s.outlineUsesFillColor,h,l,f)}}serialize(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._fillIndexStart,s[i++]=this._fillIndexCount,s[i++]=this._outlineIndexStart,s[i++]=this._outlineIndexCount;const n=this._patternMap,o=n.size;if(s[i++]=o,o>0)for(const[t,[e,o]]of n)s[i++]=t,s[i++]=e,s[i++]=o;s[i++]=this._fillVertexBuffer.array.length;for(let t=0;t<this._fillVertexBuffer.array.length;t++)e[i++]=this._fillVertexBuffer.array[t];s[i++]=this._fillIndexBuffer.array.length;for(let t=0;t<this._fillIndexBuffer.array.length;t++)s[i++]=this._fillIndexBuffer.array[t];s[i++]=this._outlineVertexBuffer.array.length;for(let t=0;t<this._outlineVertexBuffer.array.length;t++)e[i++]=this._outlineVertexBuffer.array[t];s[i++]=this._outlineIndexBuffer.array.length;for(let t=0;t<this._outlineIndexBuffer.array.length;t++)s[i++]=this._outlineIndexBuffer.array[t];return s.buffer}_processFeature(t,s,e,i,n,o,r){if(!t)return;const c=t.length;if(s&&(!e||!n||0===n.length))for(let s=0;s<c;s++)this._processOutline(t[s],n);let h;for(let s=0;s<c;s++){const e=J._area(t[s]);e>32?(void 0!==h&&this._processFill(t,h,i,o,r),h=[s]):e<-32&&void 0!==h&&h.push(s)}void 0!==h&&this._processFill(t,h,i,o,r)}_processOutline(t,s){const e=this._outlineVertexBuffer,i=this._outlineIndexBuffer,n=i.index;let o,r,c;const h=new m(0,0),a=new m(0,0),l=new m(0,0);let f=-1,u=-1,d=-1,p=-1,w=-1,b=!1,M=t.length;if(M<2)return;const y=t[0];let g=t[M-1];for(;M&&g.isEqual(y);)--M,g=t[M-1];if(!(M-0<2)){for(let n=0;n<M;++n){0===n?(o=t[M-1],r=t[0],c=t[1],h.assignSub(r,o),h.normalize(),h.rightPerpendicular()):(o=r,r=c,c=n!==M-1?t[n+1]:t[0],h.assign(a));const m=this._isClipEdge(o,r);-1===p&&(b=m),a.assignSub(c,r),a.normalize(),a.rightPerpendicular();const y=h.x*a.y-h.y*a.x;l.assignAdd(h,a),l.normalize();const g=-l.x*-h.x+-l.y*-h.y;let x=Math.abs(0!==g?1/g:1);x>8&&(x=8),y>=0?(d=e.add(r.x,r.y,h.x,h.y,0,1,s),-1===p&&(p=d),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d),u=e.add(r.x,r.y,x*-l.x,x*-l.y,0,-1,s),-1===w&&(w=u),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d),f=u,u=d,d=e.add(r.x,r.y,l.x,l.y,0,1,s),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d),u=e.add(r.x,r.y,a.x,a.y,0,1,s),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d)):(d=e.add(r.x,r.y,x*l.x,x*l.y,0,1,s),-1===p&&(p=d),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d),u=e.add(r.x,r.y,-h.x,-h.y,0,-1,s),-1===w&&(w=u),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d),f=u,u=d,d=e.add(r.x,r.y,-l.x,-l.y,0,-1,s),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d),f=e.add(r.x,r.y,-a.x,-a.y,0,-1,s),f>=0&&u>=0&&d>=0&&!m&&i.add(f,u,d))}f>=0&&u>=0&&p>=0&&!b&&i.add(f,u,p),f>=0&&p>=0&&w>=0&&!b&&i.add(f,w,p),this._outlineIndexCount+=3*(i.index-n)}}_processFill(s,e,i,n,o){let r;e.length>1&&(r=[]);let c=0;for(const t of e)0!==c&&r.push(c),c+=s[t].length;const h=2*c,a=t.acquire();for(const t of e){const e=s[t],i=e.length;for(let t=0;t<i;++t)a.push(e[t].x,e[t].y)}const l=A(a,r,2);if(A.deviation(a,r,2,l)>0){const t=e.map((t=>s[t].length)),{buffer:n,vertexCount:r}=b(a,t);if(r>0){const t=this._fillVertexBuffer.index;for(let t=0;t<r;t++)this._fillVertexBuffer.add(n[2*t],n[2*t+1],i);for(let s=0;s<r;s+=3){const e=t+s;this._fillIndexBuffer.add(e,e+1,e+2)}if(void 0!==o){const t=this._patternMap,s=t.get(o);s?s[1]+=r:t.set(o,[this._fillIndexStart+this._fillIndexCount,r])}this._fillIndexCount+=r}}else{const t=l.length;if(t>0){const s=this._fillVertexBuffer.index;let e=0;for(;e<h;)this._fillVertexBuffer.add(a[e++],a[e++],i);let n=0;for(;n<t;)this._fillIndexBuffer.add(s+l[n++],s+l[n++],s+l[n++]);if(void 0!==o){const s=this._patternMap,e=s.get(o);e?e[1]+=t:s.set(o,[this._fillIndexStart+this._fillIndexCount,t])}this._fillIndexCount+=t}}t.release(a)}_isClipEdge(t,s){return t.x===s.x?t.x<=-64||t.x>=4160:t.y===s.y&&(t.y<=-64||t.y>=4160)}static _area(t){let s=0;const e=t.length-1;for(let i=0;i<e;i++)s+=(t[i].x-t[i+1].x)*(t[i].y+t[i+1].y);return s+=(t[e].x-t[0].x)*(t[e].y+t[0].y),.5*s}}class Q extends Z{constructor(t,s,e,i,n){super(t,s,e),this.type=2,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=i,this.tessellationProperties._lineIndexBuffer=n,this._lineTessellator=new M(X(this.tessellationProperties),$(this.tessellationProperties),t.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(t,s,e){const i=this.layer,n=this.zoom,o=i.hasDataDrivenLine,r=i.getPaintProperty("line-pattern"),c=i.getPaintProperty("line-dasharray"),h=i.getLayoutProperty("line-cap");if(!r&&!c)return;const a=(null==h?void 0:h.getValue(n))||0,l=null==h?void 0:h.isDataDriven;if(o){const t=null==r?void 0:r.isDataDriven,e=null==c?void 0:c.isDataDriven;if(!t&&!e)return;for(const e of this._features)s(t?r.getValue(n,e):this._getDashArrayKey(e,n,i,c,l,h,a))}else if(r)s(r.getValue(n));else if(c){const t=c.getValue(n);s(i.getDashKey(t,a))}}processFeatures(t){var s,e,i,n,o,r;this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const c=this.layer,h=this.zoom,a=this._features,l=this._tessellationOptions,{hasDataDrivenLine:f,lineMaterial:u}=c;t&&t.setExtent(this.layerExtent);const d=c.getPaintProperty("line-pattern"),p=c.getPaintProperty("line-dasharray"),w=null==d?void 0:d.isDataDriven,m=null==p?void 0:p.isDataDriven;let b;b=c.getLayoutProperty("line-cap");const M=null!=(s=b)&&s.isDataDriven?b:null,y=M?null:c.getLayoutValue("line-cap",h),g=y||0,x=!!M;b=c.getLayoutProperty("line-join");const k=null!=(e=b)&&e.isDataDriven?b:null,I=k?null:c.getLayoutValue("line-join",h);b=c.getLayoutProperty("line-miter-limit");const _=null!=(i=b)&&i.isDataDriven?b:null,T=_?null:c.getLayoutValue("line-miter-limit",h);b=c.getLayoutProperty("line-round-limit");const v=null!=(n=b)&&n.isDataDriven?b:null,A=v?null:c.getLayoutValue("line-round-limit",h);b=c.getPaintProperty("line-width");const L=null!=(o=b)&&o.isDataDriven?b:null,N=L?null:c.getPaintValue("line-width",h);b=c.getPaintProperty("line-offset");const P=null!=(r=b)&&r.isDataDriven?b:null,j=P?null:c.getPaintValue("line-offset",h);if(w||m){const s=[];for(const e of a){const i=w?d.getValue(h,e):this._getDashArrayKey(e,h,c,p,x,M,g),n=this._spriteInfo[i];if(!n||!n.rect)continue;const o=u.encodeAttributes(e,h,c,n),r=e.getGeometry(t);s.push({ddAttributes:o,page:n.page,cap:M?M.getValue(h,e):y,join:k?k.getValue(h,e):I,miterLimit:_?_.getValue(h,e):T,roundLimit:v?v.getValue(h,e):A,halfWidth:.5*(L?L.getValue(h,e):N),offset:P?P.getValue(h,e):j,geometry:r})}s.sort(((t,s)=>t.page-s.page)),l.textured=!0;for(const{ddAttributes:t,page:e,cap:i,join:n,miterLimit:o,roundLimit:r,halfWidth:c,offset:h,geometry:a}of s)l.capType=i,l.joinType=n,l.miterLimit=o,l.roundLimit=r,l.halfWidth=c,l.offset=h,this._processFeature(a,t,e)}else{l.textured=!(!d&&!p),l.capType=y,l.joinType=I,l.miterLimit=T,l.roundLimit=A,l.halfWidth=.5*N,l.offset=j;for(const s of a){const e=f?u.encodeAttributes(s,h,c):null;M&&(l.capType=M.getValue(h,s)),k&&(l.joinType=k.getValue(h,s)),_&&(l.miterLimit=_.getValue(h,s)),v&&(l.roundLimit=v.getValue(h,s)),L&&(l.halfWidth=.5*L.getValue(h,s)),P&&(l.offset=P.getValue(h,s));const i=s.getGeometry(t);this._processFeature(i,e)}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this.tessellationProperties._lineVertexBuffer.array.length,t+=this.tessellationProperties._lineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const s=new Uint32Array(t),e=new Int32Array(s.buffer);let i=0;s[i++]=this.type,s[i++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[i++]=this.layerUIDs[t];s[i++]=this._lineIndexStart,s[i++]=this._lineIndexCount;const n=this._patternMap,o=n.size;if(s[i++]=o,o>0)for(const[t,[e,o]]of n)s[i++]=t,s[i++]=e,s[i++]=o;s[i++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineVertexBuffer.array.length;t++)e[i++]=this.tessellationProperties._lineVertexBuffer.array[t];s[i++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineIndexBuffer.array.length;t++)s[i++]=this.tessellationProperties._lineIndexBuffer.array[t];return s.buffer}_processFeature(t,s,e){if(!t)return;const i=t.length;for(let n=0;n<i;n++)this._processGeometry(t[n],s,e)}_processGeometry(t,s,e){if(t.length<2)return;let i,n,o=t[0],r=1;for(;r<t.length;)i=t[r].x-o.x,n=t[r].y-o.y,i*i+n*n<1e-6?t.splice(r,1):(o=t[r],++r);if(t.length<2)return;const c=this.tessellationProperties._lineIndexBuffer,h=3*c.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=65535,this.tessellationProperties._ddValues=s,this._lineTessellator.tessellate(t,this._tessellationOptions);const a=3*c.index-h;if(void 0!==e){const t=this._patternMap,s=t.get(e);s?s[1]+=a:t.set(e,[h+this._lineIndexCount,a])}this._lineIndexCount+=a}_getDashArrayKey(t,s,e,i,n,o,r){const c=n?o.getValue(s,t):r,h=i.getValue(s,t);return e.getDashKey(h,c)}}const X=t=>(s,e,i,n,o,r,c,h,a,l,f)=>(t._lineVertexBuffer.add(s,e,c,h,i,n,o,r,a,l,f,t._ddValues),t._lineVertexBuffer.index-1),$=t=>(s,e,i)=>{t._lineIndexBuffer.add(s,e,i)};function tt(t,s){return t.iconMosaicItem&&s.iconMosaicItem?t.iconMosaicItem.page===s.iconMosaicItem.page?0:t.iconMosaicItem.page-s.iconMosaicItem.page:t.iconMosaicItem&&!s.iconMosaicItem?1:!t.iconMosaicItem&&s.iconMosaicItem?-1:0}class st extends Z{constructor(t,s,e,i,n,o,r,c){super(t,s,c.getSpriteItems()),this.type=3,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._iconVertexBuffer=e,this._iconIndexBuffer=i,this._textVertexBuffer=n,this._textIndexBuffer=o,this._placementEngine=r,this._workerTileHandler=c}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(t,e,i){const n=this.layer,o=this.zoom;t&&t.setExtent(this.layerExtent);const r=n.getLayoutProperty("icon-image"),c=n.getLayoutProperty("text-field");let h=n.getLayoutProperty("text-transform"),a=n.getLayoutProperty("text-font");const l=[];let f,u,d,p;r&&!r.isDataDriven&&(f=r.getValue(o)),c&&!c.isDataDriven&&(u=c.getValue(o)),h&&h.isDataDriven||(d=n.getLayoutValue("text-transform",o),h=null),a&&a.isDataDriven||(p=n.getLayoutValue("text-font",o),a=null);for(const w of this._features){const m=w.getGeometry(t);if(!m||0===m.length)continue;let b,M;r&&(b=r.isDataDriven?r.getValue(o,w):this._replaceKeys(f,w.values),b&&e(b));let y=!1;if(c&&(M=c.isDataDriven?c.getValue(o,w):this._replaceKeys(u,w.values),M)){switch(M=M.replace(/\\n/g,"\n"),h&&(d=h.getValue(o,w)),d){case 2:M=M.toLowerCase();break;case 1:M=M.toUpperCase()}if(st._bidiEngine.hasBidiChar(M)){let t;t="rtl"===st._bidiEngine.checkContextual(M)?"IDNNN":"ICNNN",M=st._bidiEngine.bidiTransform(M,t,"VLYSN"),y=!0}const t=M.length;if(t>0){a&&(p=a.getValue(o,w));for(const s of p){let e=i[s];e||(e=i[s]=new Set);for(let s=0;s<t;s++){const t=M.charCodeAt(s);e.add(t)}}}}if(!b&&!M)continue;const g=n.getLayoutValue("symbol-sort-key",o,w),x={feature:w,sprite:b,label:M,rtl:y,geometry:m,hash:(M?s(M):0)^(b?s(b):0),priority:g,textFont:p};l.push(x)}this._symbolFeatures=l}processFeatures(t){t&&t.setExtent(this.layerExtent);const s=this.layer,e=this.zoom,i=s.getLayoutValue("symbol-placement",e),n=0!==i,o=8*s.getLayoutValue("symbol-spacing",e),r=s.getLayoutProperty("icon-image"),h=s.getLayoutProperty("text-field"),a=r?new _(s,e,n):null,l=h?new T(s,e,n):null,f=this._workerTileHandler;let u;r&&(u=f.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const d=[];let p=1;l&&l.size&&(p=l.size/S);const w=l?l.maxAngle*c:0,m=l?8*l.size:0;for(const t of this._symbolFeatures){let s,r;a&&u&&t.sprite&&(s=u[t.sprite],s&&s.sdf&&(this._isIconSDF=!0)),s&&a.update(e,t.feature);let c=0;const h=t.label;if(h){l.update(e,t.feature);const s=n?l.keepUpright:l.writingMode&&l.writingMode.indexOf(1)>=0;let i=.5;switch(l.anchor){case 5:case 1:case 7:i=0;break;case 6:case 2:case 8:i=1}let o=.5;switch(l.anchor){case 5:case 3:case 6:o=0;break;case 7:case 4:case 8:o=1}let a=.5;switch(l.justify){case 0:a=i;break;case 1:a=0;break;case 3:a=1}const u=l.letterSpacing*S,d=n?0:l.maxWidth*S,w=l.lineHeight*S,m=t.textFont.map((t=>f.getGlyphItems(t)));if(r=new D(m,d,w,u,i,o,a).getShaping(h,t.rtl,s),r&&r.length>0){let t=1e30,s=-1e30;for(const e of r)t=Math.min(t,e.x),s=Math.max(s,e.x);c=(s-t+48)*p*8}}for(let e of t.geometry){const h=[];if(1===i){if(r&&r.length>0&&l&&l.size){const t=8*l.size*(2+Math.min(2,4*Math.abs(l.offset[1])));e=st._smoothVertices(e,t)}st._pushAnchors(h,e,o,c)}else 2===i?st._pushCenterAnchor(h,e):3===t.feature.type?st._pushCentroid(h,e):h.push(new B(e[0].x,e[0].y));for(const i of h){if(i.x<0||i.x>4096||i.y<0||i.y>4096)continue;if(n&&c>0&&0===l.rotationAlignment&&!st._honorsTextMaxAngle(e,i,c,w,m))continue;const o={shaping:r,line:e,iconMosaicItem:s,anchor:i,symbolFeature:t,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};d.push(o),this._processFeature(o,a,l)}}}d.sort(tt),this._addPlacedGlyphs(),this._symbolInstances=d}serialize(){let t=11;t+=this.layerUIDs.length,t+=3*this.markerPageMap.size,t+=3*this.glyphsPageMap.size,t+=st.symbolsSerializationLength(this._symbolInstances),t+=this._iconVertexBuffer.array.length,t+=this._iconIndexBuffer.array.length,t+=this._textVertexBuffer.array.length,t+=this._textIndexBuffer.array.length;const s=new Uint32Array(t),e=new Int32Array(s.buffer),i=new Float32Array(s.buffer);let n=0;s[n++]=this.type,s[n++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[n++]=this.layerUIDs[t];s[n++]=this._isIconSDF?1:0,s[n++]=this.markerPageMap.size;for(const[t,[e,i]]of this.markerPageMap)s[n++]=t,s[n++]=e,s[n++]=i;s[n++]=this.glyphsPageMap.size;for(const[t,[e,i]]of this.glyphsPageMap)s[n++]=t,s[n++]=e,s[n++]=i;s[n++]=this._iconVertexBuffer.index/4,s[n++]=this._textVertexBuffer.index/4,n=st.serializeSymbols(s,e,i,n,this._symbolInstances),s[n++]=this._iconVertexBuffer.array.length;for(let t=0;t<this._iconVertexBuffer.array.length;t++)e[n++]=this._iconVertexBuffer.array[t];s[n++]=this._iconIndexBuffer.array.length;for(let t=0;t<this._iconIndexBuffer.array.length;t++)s[n++]=this._iconIndexBuffer.array[t];s[n++]=this._textVertexBuffer.array.length;for(let t=0;t<this._textVertexBuffer.array.length;t++)e[n++]=this._textVertexBuffer.array[t];s[n++]=this._textIndexBuffer.array.length;for(let t=0;t<this._textIndexBuffer.array.length;t++)s[n++]=this._textIndexBuffer.array[t];return s.buffer}static symbolsSerializationLength(t){let s=0;s+=1;for(const e of t||[]){s+=4,s+=1;for(const t of e.textColliders)s+=10;for(const t of e.iconColliders)s+=10;s+=1,s+=2*e.textVertexRanges.length,s+=1,s+=2*e.iconVertexRanges.length}return s}static serializeSymbols(t,s,e,i,n){s[i++]=(n=n||[]).length;for(const t of n){s[i++]=t.anchor.x,s[i++]=t.anchor.y,s[i++]=t.symbolFeature.hash,s[i++]=t.symbolFeature.priority,s[i++]=t.textColliders.length+t.iconColliders.length;for(const n of t.textColliders)s[i++]=n.xTile,s[i++]=n.yTile,s[i++]=n.dxPixels,s[i++]=n.dyPixels,s[i++]=n.hard?1:0,s[i++]=n.partIndex,e[i++]=n.minLod,e[i++]=n.maxLod,s[i++]=n.width,s[i++]=n.height;for(const n of t.iconColliders)s[i++]=n.xTile,s[i++]=n.yTile,s[i++]=n.dxPixels,s[i++]=n.dyPixels,s[i++]=n.hard?1:0,s[i++]=n.partIndex,e[i++]=n.minLod,e[i++]=n.maxLod,s[i++]=n.width,s[i++]=n.height;s[i++]=t.textVertexRanges.length;for(const[e,n]of t.textVertexRanges)s[i++]=e,s[i++]=n;s[i++]=t.iconVertexRanges.length;for(const[e,n]of t.iconVertexRanges)s[i++]=e,s[i++]=n}return i}_replaceKeys(t,s){return t.replace(/{([^{}]+)}/g,(function(t,e){return e in s?s[e]:""}))}_processFeature(t,s,e){const{line:i,iconMosaicItem:n,shaping:o,anchor:r}=t,c=this.zoom,h=this.layer,a=!!n;let l=!0;a&&(l=s.optional||!n);const u=o&&o.length>0;let d,p,w=!0;if(u&&(w=e.optional),a&&(d=this._placementEngine.getIconPlacement(r,n,s)),(d||l)&&(u&&(p=this._placementEngine.getTextPlacement(r,o,i,e)),p||w)){if(d&&p||(w||l?w||p?l||d||(p=null):d=null:(d=null,p=null)),p){const s=h.hasDataDrivenText?h.textMaterial.encodeAttributes(t.symbolFeature.feature,c,h):null;if(this._storePlacedGlyphs(t,p.shapes,c,e.rotationAlignment,s),p.textColliders){t.textColliders=p.textColliders;for(const t of p.textColliders){t.minLod=Math.max(c+f(t.minLod),0),t.maxLod=Math.min(c+f(t.maxLod),25);const s=t.angle;if(s){const e=Math.cos(s),i=Math.sin(s),n=t.dxPixels*e-t.dyPixels*i,o=t.dxPixels*i+t.dyPixels*e,r=(t.dxPixels+t.width)*e-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*e,h=t.dxPixels*e-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*e,l=(t.dxPixels+t.width)*e-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*e,u=Math.min(n,r,h,l),d=Math.max(n,r,h,l),p=Math.min(o,c,a,f),w=Math.max(o,c,a,f);t.dxPixels=u,t.dyPixels=p,t.width=d-u,t.height=w-p}}}}if(d){const e=h.hasDataDrivenIcon?h.iconMaterial.encodeAttributes(t.symbolFeature.feature,c,h):null;if(this._addPlacedIcons(t,d.shapes,c,n.page,1===s.rotationAlignment,e),d.iconColliders){t.iconColliders=d.iconColliders;for(const t of d.iconColliders){t.minLod=Math.max(c+f(t.minLod),0),t.maxLod=Math.min(c+f(t.maxLod),25);const s=t.angle;if(s){const e=Math.cos(s),i=Math.sin(s),n=t.dxPixels*e-t.dyPixels*i,o=t.dxPixels*i+t.dyPixels*e,r=(t.dxPixels+t.width)*e-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*e,h=t.dxPixels*e-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*e,l=(t.dxPixels+t.width)*e-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*e,u=Math.min(n,r,h,l),d=Math.max(n,r,h,l),p=Math.min(o,c,a,f),w=Math.max(o,c,a,f);t.dxPixels=u,t.dyPixels=p,t.width=d-u,t.height=w-p}}}}}}_addPlacedIcons(t,s,e,i,n,o){const r=Math.max(e-1,0),c=this._iconVertexBuffer,h=this._iconIndexBuffer,a=this._markerMap;for(const l of s){const s=n?0:Math.max(e+f(l.minzoom),r),u=n?25:Math.min(e+f(l.maxzoom),25);if(u<=s)continue;const d=l.tl,p=l.tr,w=l.bl,m=l.br,b=l.mosaicRect,M=l.labelAngle,y=l.minAngle,g=l.maxAngle,x=l.anchor,k=c.index,I=b.x,_=b.y,T=I+b.width,v=_+b.height,A=c.index;c.add(x.x,x.y,d.x,d.y,I,_,M,y,g,s,u,o),c.add(x.x,x.y,p.x,p.y,T,_,M,y,g,s,u,o),c.add(x.x,x.y,w.x,w.y,I,v,M,y,g,s,u,o),c.add(x.x,x.y,m.x,m.y,T,v,M,y,g,s,u,o),t.iconVertexRanges.length>0&&t.iconVertexRanges[0][0]+t.iconVertexRanges[0][1]===A?t.iconVertexRanges[0][1]+=4:t.iconVertexRanges.push([A,4]),h.add(k+0,k+1,k+2),h.add(k+1,k+2,k+3),a.has(i)?a.get(i)[1]+=6:a.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const t=this._textVertexBuffer,s=this._textIndexBuffer,e=this._glyphMap;for(const[i,n]of this._glyphBufferDataStorage)for(const o of n){const n=t.index,r=o.symbolInstance,c=o.ddAttributes,h=t.index;t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tl[0],o.tl[1],o.xmin,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.tr[0],o.tr[1],o.xmax,o.ymin,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.bl[0],o.bl[1],o.xmin,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),t.add(o.glyphAnchor[0],o.glyphAnchor[1],o.br[0],o.br[1],o.xmax,o.ymax,o.labelAngle,o.minAngle,o.maxAngle,o.minLod,o.maxLod,c),r.textVertexRanges.length>0&&r.textVertexRanges[0][0]+r.textVertexRanges[0][1]===h?r.textVertexRanges[0][1]+=4:r.textVertexRanges.push([h,4]),s.add(n+0,n+1,n+2),s.add(n+1,n+2,n+3),e.has(i)?e.get(i)[1]+=6:e.set(i,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(t,s,e,i,n){const o=Math.max(e-1,0),r=1===i;let c,h,a,l,u,d,p,w,m,b,M;for(const i of s)c=r?0:Math.max(e+f(i.minzoom),o),h=r?25:Math.min(e+f(i.maxzoom),25),h<=c||(a=i.tl,l=i.tr,u=i.bl,d=i.br,p=i.labelAngle,w=i.minAngle,m=i.maxAngle,b=i.anchor,M=i.mosaicRect,this._glyphBufferDataStorage.has(i.page)||this._glyphBufferDataStorage.set(i.page,[]),this._glyphBufferDataStorage.get(i.page).push({glyphAnchor:[b.x,b.y],tl:[a.x,a.y],tr:[l.x,l.y],bl:[u.x,u.y],br:[d.x,d.y],xmin:M.x,ymin:M.y,xmax:M.x+M.width,ymax:M.y+M.height,labelAngle:p,minAngle:w,maxAngle:m,minLod:c,maxLod:h,placementLod:o,symbolInstance:t,ddAttributes:n}))}static _pushAnchors(t,s,e,i){e+=i;let n=0;const o=s.length-1;for(let t=0;t<o;t++)n+=m.distance(s[t],s[t+1]);let r=i||e;if(r*=.5,n<=r)return;const c=r/n;let h=0,a=-(e=n/Math.max(Math.round(n/e),1))/2;const l=s.length-1;for(let i=0;i<l;i++){const n=s[i],o=s[i+1],r=o.x-n.x,l=o.y-n.y,f=Math.sqrt(r*r+l*l);let d;for(;a+e<h+f;){a+=e;const s=(a-h)/f,p=u(n.x,o.x,s),w=u(n.y,o.y,s);void 0===d&&(d=Math.atan2(l,r)),t.push(new B(p,w,d,i,c))}h+=f}}static _pushCenterAnchor(t,s){let e=0;const i=s.length-1;for(let t=0;t<i;t++)e+=m.distance(s[t],s[t+1]);const n=e/2;let o=0;const r=s.length-1;for(let e=0;e<r;e++){const i=s[e],r=s[e+1],c=r.x-i.x,h=r.y-i.y,a=Math.sqrt(c*c+h*h);if(n<o+a){const s=(n-o)/a,l=u(i.x,r.x,s),f=u(i.y,r.y,s),d=Math.atan2(h,c);return void t.push(new B(l,f,d,e,0))}o+=a}}static _deviation(t,s,e){return Math.atan2((s.x-t.x)*(e.y-s.y)-(s.y-t.y)*(e.x-s.x),(s.x-t.x)*(e.x-s.x)+(s.y-t.y)*(e.y-s.y))}static _honorsTextMaxAngle(t,s,e,i,n){let o=0;const r=e/2;let c=new m(s.x,s.y),h=s.segment+1;for(;o>-r;){if(--h,h<0)return!1;o-=m.distance(t[h],c),c=t[h]}o+=m.distance(t[h],t[h+1]);const a=[];let l=0;const f=t.length;for(;o<r;){const s=t[h];let e,r=h;do{if(++r,r===f)return!1;e=t[r]}while(e.isEqual(s));let c,u=r;do{if(++u,u===f)return!1;c=t[u]}while(c.isEqual(e));const d=this._deviation(s,e,c);for(a.push({deviation:d,distToAnchor:o}),l+=d;o-a[0].distToAnchor>n;)l-=a.shift().deviation;if(Math.abs(l)>i)return!1;o+=m.distance(e,c),h=r}return!0}static _smoothVertices(t,s){if(s<=0)return t;let e=t.length;if(e<3)return t;const i=[];let n=0,o=0;i.push(0);for(let s=1;s<e;s++){const e=m.distance(t[s],t[s-1]);e>0&&(n+=e,i.push(n),o++,o!==s&&(t[o]=t[s]))}if(e=o+1,e<3)return t;s=Math.min(s,.2*n);const r=t[0].x,c=t[0].y,h=t[e-1].x,a=t[e-1].y,l=m.sub(t[0],t[1]);l.normalize(),t[0].x+=s*l.x,t[0].y+=s*l.y,l.assignSub(t[e-1],t[e-2]),l.normalize(),t[e-1].x+=s*l.x,t[e-1].y+=s*l.y,i[0]-=s,i[e-1]+=s;const f=[];f.push(new m(r,c));const u=1e-6,d=.5*s;for(let n=1;n<e-1;n++){let o=0,r=0,c=0;for(let e=n-1;e>=0;e--){const h=d+i[e+1]-i[n];if(h<0)break;const a=i[e+1]-i[e],l=i[n]-i[e]<d?1:h/a;if(l<u)break;const f=l*l,p=l*h-.5*f*a,w=l*a/s,m=t[e+1],b=t[e].x-m.x,M=t[e].y-m.y;o+=w/p*(m.x*l*h+.5*f*(h*b-a*m.x)-f*l*a*b/3),r+=w/p*(m.y*l*h+.5*f*(h*M-a*m.y)-f*l*a*M/3),c+=w}for(let h=n+1;h<e;h++){const e=d-i[h-1]+i[n];if(e<0)break;const a=i[h]-i[h-1],l=i[h]-i[n]<d?1:e/a;if(l<u)break;const f=l*l,p=l*e-.5*f*a,w=l*a/s,m=t[h-1],b=t[h].x-m.x,M=t[h].y-m.y;o+=w/p*(m.x*l*e+.5*f*(e*b-a*m.x)-f*l*a*b/3),r+=w/p*(m.y*l*e+.5*f*(e*M-a*m.y)-f*l*a*M/3),c+=w}f.push(new m(o/c,r/c))}return f.push(new m(h,a)),t[0].x=r,t[0].y=c,t[e-1].x=h,t[e-1].y=a,f}static _pushCentroid(t,s){const e=4096,i=4096,n=s.length-1;let o=0,r=0,c=0,h=s[0].x,a=s[0].y;h>e&&(h=e),h<0&&(h=0),a>i&&(a=i),a<0&&(a=0);for(let t=1;t<n;t++){let n=s[t].x,l=s[t].y,f=s[t+1].x,u=s[t+1].y;n>e&&(n=e),n<0&&(n=0),l>i&&(l=i),l<0&&(l=0),f>e&&(f=e),f<0&&(f=0),u>i&&(u=i),u<0&&(u=0);const d=(n-h)*(u-a)-(f-h)*(l-a);o+=d*(h+n+f),r+=d*(a+l+u),c+=d}o/=3*c,r/=3*c,isNaN(o)||isNaN(r)||t.push(new B(o,r))}}var et;st._bidiEngine=new p,function(t){t[t.INITIALIZED=0]="INITIALIZED",t[t.NO_DATA=1]="NO_DATA",t[t.READY=2]="READY",t[t.MODIFIED=3]="MODIFIED",t[t.INVALID=4]="INVALID"}(et||(et={}));class it{constructor(t,s,e,i,n){if(this._pbfTiles={},this._tileClippers={},this._client=e,this._tile=s,n){this._styleLayerUIDs=new Set;for(const t of n)this._styleLayerUIDs.add(t)}this._styleRepository=i,this._layers=this._styleRepository.layers;const[o,r,c]=s.tileKey.split("/").map(parseFloat);this._level=o;const h=8+Math.max(5*(this._level-14),0);for(const s of Object.keys(t)){const e=t[s];if(this._pbfTiles[s]=new k(new Uint8Array(e.protobuff),new DataView(e.protobuff)),e.refKey){const[t]=e.refKey.split("/").map(parseFloat),i=o-t;if(i>0){const t=(1<<i)-1;this._tileClippers[s]=new y(i,r&t,c&t,8,h)}}this._tileClippers[s]||(this._tileClippers[s]=new g)}}_canParseStyleLayer(t){return!this._styleLayerUIDs||this._styleLayerUIDs.has(t)}async parse(t){const s=x(),e=this._initialize(t),{returnedBuckets:i}=e;this._processLayers(e),this._linkReferences(e),this._filterFeatures(e);const n=[],o=new Set,r=(t,s)=>{o.has(t)||(n.push({name:t,repeat:s}),o.add(t))},c={};for(const t of i)t.getResources(t.tileClipper,r,c);if(this._tile.status===et.INVALID)return Promise.resolve([]);const h=this._fetchResources(n,c,t);return Promise.all([...h,s]).then((()=>this._processFeatures(e.returnedBuckets)))}_initialize(t){return{signal:t&&t.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(t){const{sourceNameToTileData:s,layers:e,zoom:i,sourceNameToTileClipper:n,sourceNameToUniqueSourceLayerBuckets:o,sourceNameToUniqueSourceLayers:r,returnedBuckets:c,layerIdToBucket:h,referencerUIDToReferencedId:a}=t;for(let t=e.length-1;t>=0;t--){const l=e[t];if(!this._canParseStyleLayer(l.uid)||l.minzoom&&i<Math.floor(l.minzoom)||l.maxzoom&&i>=l.maxzoom||0===l.type)continue;if(!s[l.source]||!n[l.source])continue;const f=n[l.source],u=l.sourceLayer,d=s[l.source][u];if(d){let t=r[l.source];if(t||(t=r[l.source]=new Set),t.add(l.sourceLayer),l.refLayerId)a.set(l.uid,l.refLayerId);else{const t=this._createBucket(l);if(t){t.layerUIDs=[l.uid],t.layerExtent=d.extent,t.tileClipper=f;let s=o[l.source];s||(s=o[l.source]={});let e=s[u];e||(e=s[u]=[]),e.push(t),c.push(t),h[l.id]=t}}}}}_linkReferences(t){const{layerIdToBucket:s,referencerUIDToReferencedId:e}=t;e.forEach(((t,e)=>{s[t=t]&&s[t].layerUIDs.push(e)}))}_filterFeatures(t){const{signal:s,sourceNameToTileData:i,sourceNameToUniqueSourceLayerBuckets:n,sourceNameToUniqueSourceLayers:o}=t,r=10*this._level,c=10*(this._level+1),h=[],a=[];for(const t of Object.keys(o))o[t].forEach((s=>{h.push(s),a.push(t)}));for(let t=0;t<h.length;t++){const o=a[t],l=h[t];if(!i[o]||!n[o])continue;const f=i[o][l],u=n[o][l];if(!u||0===u.length)continue;if(e(s))return;const d=f.getData();for(;d.nextTag(2);){const t=d.getMessage(),s=new z(t,f);t.release();const e=s.values;if(e){const t=e._minzoom;if(t&&t>=c)continue;const s=e._maxzoom;if(s&&s<=r)continue}for(const t of u)t.pushFeature(s)}}}_fetchResources(t,s,e){const i=[],n=this._tile.getWorkerTileHandler();let o,r;t.length>0&&(o=n.fetchSprites(t,this._client,e),i.push(o));for(const t in s){const o=s[t];o.size>0&&(r=n.fetchGlyphs(this._tile.tileKey,t,o,this._client,e),i.push(r))}return i}_processFeatures(t){const s=t.filter((t=>t.hasFeatures()||this._canParseStyleLayer(t.layer.uid)));for(const t of s)t.processFeatures(t.tileClipper);return s}_parseTileData(t){const s={};for(const e of Object.keys(t)){const i=t[e],n={};for(;i.next();)switch(i.tag()){case 3:{const t=i.getMessage(),s=new G(t);t.release(),n[s.name]=s;break}default:i.skip()}s[e]=n}return s}_createBucket(t){switch(t.type){case 0:return null;case 1:return this._createFillBucket(t);case 2:return this._createLineBucket(t);case 4:return this._createCircleBucket(t);case 3:return this._createSymbolBucket(t)}}_createFillBucket(t){return new J(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new E(t.fillMaterial.getStride()),new V,new W(t.outlineMaterial.getStride()),new V)}_createLineBucket(t){return new Q(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new q(t.lineMaterial.getStride()),new V)}_createCircleBucket(t){return new H(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new Y(t.circleMaterial.getStride()),new V)}_createSymbolBucket(t){const s=this._tile;return new st(t,this._level,new K(t.iconMaterial.getStride()),new V,new K(t.textMaterial.getStride()),new V,s.placementEngine,s.getWorkerTileHandler())}}class nt{constructor(t,s,e,i){this.status=et.INITIALIZED,this.placementEngine=new O,this.tileKey=t,this.refKeys=s,this._workerTileHandler=e,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=et.INITIALIZED,this._workerTileHandler=null}async parse(t,s,e){const o=e&&e.signal;if(i(o)){const t=()=>{o.removeEventListener("abort",t),this.status=et.INVALID};o.addEventListener("abort",t)}let r;try{r=await this._parse(t,e)}catch(t){if(n(t))throw t;return{result:[],transferList:[]}}this.status=et.READY;const c=[];for(const t of r){const s=t.serialize();c.push(s)}return{result:c,transferList:c.length<=s&&c}}setObsolete(){this.status=et.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}async _parse(t,s){const e=t.sourceName2DataAndRefKey;return 0===Object.keys(e).length?[]:(this.status=et.MODIFIED,new it(e,this,s.client,this._styleRepository,t.styleLayerUIDs).parse(s))}}export default class{constructor(){this._spriteInfo={},this._glyphInfo={}}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){var t;return null==(t=this._styleRepository)?void 0:t.layers}async createTileAndParse(t,s){const{key:e}=t,i={};for(const s of Object.keys(t.sourceName2DataAndRefKey))i[s]=t.sourceName2DataAndRefKey[s].refKey;const o=new nt(e,i,this,this._styleRepository);try{return await o.parse(t,this._vectorTileLayerMaxBuffers,s)}catch(t){if(o.setObsolete(),o.release(),!n(t))throw t;return null}}updateStyle(t){if(!t||0===t.length||!this._styleRepository)return;const s=this._styleRepository;for(const e of t){const t=e.data;switch(e.type){case 0:s.setPaintProperties(t.layer,t.paint);break;case 1:s.setLayoutProperties(t.layer,t.layout);break;case 3:s.deleteStyleLayer(t.layer);break;case 2:s.setStyleLayer(t.layer,t.index)}}}setStyle(t){this._styleRepository=new v(t.style),this._spriteInfo={},this._glyphInfo={},this._vectorTileLayerMaxBuffers=t.vectorTileLayerMaxBuffers}fetchSprites(t,s,e){const i=[],n=this._spriteInfo;for(const s of t)void 0===n[s.name]&&i.push(s);return 0===i.length?Promise.resolve():s.invoke("getSprites",i,{signal:e&&e.signal}).then((t=>{for(const s in t)n[s]=t[s]}))}getSpriteItems(){return this._spriteInfo}fetchGlyphs(t,s,e,i,n){const o=[];let r=this._glyphInfo[s];return r?e.forEach((t=>{r[t]||o.push(t)})):(r=this._glyphInfo[s]=[],e.forEach((t=>o.push(t)))),0===o.length?Promise.resolve():i.invoke("getGlyphs",{tileID:t,font:s,codePoints:o},n).then((t=>{for(let s=0;s<t.length;s++)t[s]&&(r[s]=t[s])}))}getGlyphItems(t){return this._glyphInfo[t]}}