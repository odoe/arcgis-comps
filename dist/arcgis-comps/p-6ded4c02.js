import{e as t,d as n,u as r,y as i,a as s,_ as o,z as h,o as c,c as u,l as e,s as a}from"./p-2f398ed1.js";import{n as f}from"./p-d3105731.js";function M(t){return Math.sqrt(Math.max(t[0]*t[0]+t[4]*t[4]+t[8]*t[8],t[1]*t[1]+t[5]*t[5]+t[9]*t[9],t[2]*t[2]+t[6]*t[6]+t[10]*t[10]))}function m(t,n){const r=Math.sqrt(n[0]*n[0]+n[4]*n[4]+n[8]*n[8]),i=Math.sqrt(n[1]*n[1]+n[5]*n[5]+n[9]*n[9]),s=Math.sqrt(n[2]*n[2]+n[6]*n[6]+n[10]*n[10]);return c(t,r,i,s),t}function d(t,n,r){r=r||t;const i=h(t,n);c(r,t[0]-i*n[0],t[1]-i*n[1],t[2]-i*n[2]),s(r,r)}function l(t,n,r){Math.abs(t[0])>Math.abs(t[1])?c(n,0,1,0):c(n,1,0,0),o(r,t,n),s(n,n),o(n,r,t),s(r,r)}function p(t,n){return(t%n+n)%n}function w(t,n,r,i,s,o){const h=t+(n-t)*s;return h+(r+(i-r)*s-h)*o}function z(t,s,o,c=f()){const u=a(t),e=a(s),M=h(t,s)/(u*e);if(M<.9999999999999999){const i=Math.acos(M),h=((1-o)*u+o*e)/Math.sin(i),a=h/u*Math.sin((1-o)*i),f=h/e*Math.sin(o*i);return n(A,t,a),n(B,s,f),r(c,A,B)}return i(c,t,s,o)}function j(t,o,c,e=f(),M=f()){const m=a(t),d=a(o),l=h(t,o)/(m*d);if(l<.9999999999999999){const i=Math.acos(l),s=Math.sin(i),h=Math.sin(c*i),u=Math.sin((1-c)*i),a=(1-c)*m+c*d;{const i=a/s,c=i/d*h;n(A,t,i/m*u),n(B,o,c),r(e,A,B)}{const e=1/m*(-Math.cos((1-c)*i)*i*a+u*(-m+d));n(A,t,e);const f=1/d*(Math.cos(c*i)*i*a+h*(-m+d));n(B,o,f),r(M,A,B),n(M,M,1/s)}return M}return i(e,t,o,c),u(M,o,t),s(M,M),M}function _(t,n,r){t=s(A,t),n=s(B,n);const i=e(h(t,n));if(r){const s=o(v,t,n);if(h(s,r)<0)return-i}return i}function g(t){const n=t.length;return function(r){if(r<=t[0][0])return t[0][1];if(r>=t[n-1][0])return t[n-1][1];let i=1;for(;r>t[i][0];)i++;const s=t[i][0],o=(s-r)/(s-t[i-1][0]);return o*t[i-1][1]+(1-o)*t[i][1]}}class x{constructor(t,n){this.min=t,this.max=n,this.range=n-t}ndiff(t,n=0){return Math.ceil((t-n)/this.range)*this.range+n}_normalize(t,n,r,i=0,s=!1){return(r-=i)<t?r+=this.ndiff(t-r):r>n&&(r-=this.ndiff(r-n)),s&&r===n&&(r=t),r+i}normalize(t,n=0,r=!1){return this._normalize(this.min,this.max,t,n,r)}clamp(n,r=0){return t(n-r,this.min,this.max)+r}monotonic(t,n,r){return t<n?n:n+this.ndiff(t-n,r)}minimalMonotonic(t,n,r){return this._normalize(t,t+this.range,n,r)}center(t,n,r){return n=this.monotonic(t,n,r),this.normalize((t+n)/2,r)}diff(t,n,r){return this.monotonic(t,n,r)-t}shortestSignedDiff(t,n){t=this.normalize(t);const r=(n=this.normalize(n))-t,i=n<t?this.minimalMonotonic(t,n)-t:n-this.minimalMonotonic(n,t);return Math.abs(r)<Math.abs(i)?r:i}contains(t,n,r){return n=this.minimalMonotonic(t,n),(r=this.minimalMonotonic(t,r))>t&&r<n}}function y(t,n,r,i){u(D,n,t),u(F,r,t),o(i,D,F),s(i,i),i[3]=-h(t,i)}const D=f(),F=f();function S(t){for(const n in t){const r=t[n];r instanceof Function&&(t[n]=r.bind(t))}return t}const b=S(new x(0,2*Math.PI)),k=S(new x(-Math.PI,Math.PI)),q=S(new x(0,360)),v=f(),A=f(),B=f();export{b as F,g as I,x as P,k as S,q as U,y as _,d as b,M as d,l as g,j,p,z as q,_ as w,w as x,m as z}