import{e as r,d as e,i as t,r as i,O as s}from"./p-9ae46e68.js";import{c as a,a as n,u as o,d as l,b as u,p as c,o as p}from"./p-38c85cb2.js";import{v as d}from"./p-8031c809.js";import{e as m}from"./p-41655335.js";import{E as f,o as y,b2 as B,v as b,h as v,k as j}from"./p-566b0715.js";import{a as h}from"./p-fe01b82b.js";import g from"./p-98a14d68.js";import{l as A}from"./p-a7080451.js";import"./p-84bf99cb.js";import"./p-ec378dda.js";import"./p-8e03c038.js";import"./p-32462343.js";function P(r){return r.features.map((e=>{const t=j.fromJSON(r.spatialReference),s=v.fromJSON(e);return i(s.geometry)&&(s.geometry.spatialReference=t),s}))}function R(r){return g.fromJSON(r).features.map((r=>r.geometry))}let F=class extends h{constructor(r){super(r),this.directions=null,this.facilities=null,this.incidents=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.routes=null}readFacilities(r){return R(r)}readIncidents(r){return R(r)}readPointBarriers(r,e){return R(e.barriers)}readPolylineBarriers(r){return R(r)}readPolygonBarriers(r){return R(r)}readRoutes(r){return P(r)}};r([e({type:[a]})],F.prototype,"directions",void 0),r([e({type:[f]})],F.prototype,"facilities",void 0),r([y("facilities")],F.prototype,"readFacilities",null),r([e({type:[f]})],F.prototype,"incidents",void 0),r([y("incidents")],F.prototype,"readIncidents",null),r([e({type:[n]})],F.prototype,"messages",void 0),r([e({type:[f]})],F.prototype,"pointBarriers",void 0),r([y("pointBarriers",["barriers"])],F.prototype,"readPointBarriers",null),r([e({type:[B]})],F.prototype,"polylineBarriers",void 0),r([y("polylineBarriers")],F.prototype,"readPolylineBarriers",null),r([e({type:[b]})],F.prototype,"polygonBarriers",void 0),r([y("polygonBarriers")],F.prototype,"readPolygonBarriers",null),r([e({type:[v]})],F.prototype,"routes",void 0),r([y("routes")],F.prototype,"readRoutes",null),F=r([t("esri.rest.support.ClosestFacilitySolveResult")],F);const C=F,N=p({accumulateAttributes:{name:"accumulateAttributeNames"},attributeParameterValues:!0,directionsTimeAttribute:{name:"directionsTimeAttributeName"},impedanceAttribute:{name:"impedanceAttributeName"},facilities:!0,incidents:!0,outSpatialReference:{name:"outSR",getter:r=>r.outSpatialReference.wkid},pointBarriers:{name:"barriers"},polylineBarriers:!0,polygonBarriers:!0,restrictionAttributes:{name:"restrictionAttributeNames"},returnPointBarriers:{name:"returnBarriers"},returnRoutes:{name:"returnCFRoutes"},travelMode:!0});let w=class extends A{constructor(r){super(r),this.url=null}solve(r,e){return async function(r,e,t){const i=[],a=[],n={},p={},f=m(r),{path:y}=f;e.incidents&&e.incidents.features&&o(e.incidents.features,a,"incidents.features",n),e.facilities&&e.facilities.features&&o(e.facilities.features,a,"facilities.features",n),e.pointBarriers&&e.pointBarriers.features&&o(e.pointBarriers.features,a,"pointBarriers.features",n),e.polylineBarriers&&e.polylineBarriers.features&&o(e.polylineBarriers.features,a,"polylineBarriers.features",n),e.polygonBarriers&&e.polygonBarriers.features&&o(e.polygonBarriers.features,a,"polygonBarriers.features",n);const B=await d(a);for(const r in n){const e=n[r];i.push(r),p[r]=B.slice(e[0],e[1])}if(l(p,i)){let r=null;try{r=await u(y,e.apiKey,t)}catch{}r&&!r.hasZ&&c(p,i)}for(const r in p)p[r].forEach(((t,i)=>{e.get(r)[i].geometry=t}));const b={...t,query:{...f.query,...N.toQueryParams(e),f:"json"}},{data:v}=await s(`${y}/solveClosestFacility`,b);return C.fromJSON(v)}(this.url,r,e)}};r([e()],w.prototype,"url",void 0),w=r([t("esri.tasks.ClosestFacilityTask")],w);const x=w;export default x;