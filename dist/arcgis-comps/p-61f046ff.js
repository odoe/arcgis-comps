import{e,d as r,i as n,a1 as t,a2 as s,a3 as i,aE as o,_ as f}from"./p-e58503d5.js";import{r as l}from"./p-a9a30646.js";import"./p-b79fcce3.js";let a=class extends t{get affectsPixelSize(){return!1}forwardTransform(e){return e}inverseTransform(e){return e}};e([r()],a.prototype,"affectsPixelSize",null),e([r({json:{write:!0}})],a.prototype,"spatialReference",void 0),a=e([n("esri.layers.support.rasterTransforms.BaseRasterTransform")],a);const c=a;let u=class extends c{constructor(){super(...arguments),this.type="identity"}};e([l({IdentityXform:"identity"})],u.prototype,"type",void 0),u=e([n("esri.layers.support.rasterTransforms.IdentityTransform")],u);const d=u;function y(e,r,n){const{x:t,y:s}=r;if(n<2)return{x:e[0]+t*e[2]+s*e[4],y:e[1]+t*e[3]+s*e[5]};if(2===n){const r=t*t,n=s*s,i=t*s;return{x:e[0]+t*e[2]+s*e[4]+r*e[6]+i*e[8]+n*e[10],y:e[1]+t*e[3]+s*e[5]+r*e[7]+i*e[9]+n*e[11]}}const i=t*t,o=s*s,f=t*s,l=i*t,a=i*s,c=t*o,u=s*o;return{x:e[0]+t*e[2]+s*e[4]+i*e[6]+f*e[8]+o*e[10]+l*e[12]+a*e[14]+c*e[16]+u*e[18],y:e[1]+t*e[3]+s*e[5]+i*e[7]+f*e[9]+o*e[11]+l*e[13]+a*e[15]+c*e[17]+u*e[19]}}function m(e,r,n){const{xmin:t,ymin:s,xmax:i,ymax:o,spatialReference:l}=r;let a=[];if(n<2)a.push({x:t,y:o}),a.push({x:i,y:o}),a.push({x:t,y:s}),a.push({x:i,y:s});else{let e=10;for(let r=0;r<e;r++)a.push({x:t,y:s+(o-s)*r/(e-1)}),a.push({x:i,y:s+(o-s)*r/(e-1)});e=8;for(let r=1;r<=e;r++)a.push({x:t+(i-t)*r/e,y:s}),a.push({x:t+(i-t)*r/e,y:o})}a=a.map((r=>y(e,r,n)));const c=a.map((e=>e.x)),u=a.map((e=>e.y));return new f({xmin:Math.min.apply(null,c),xmax:Math.max.apply(null,c),ymin:Math.min.apply(null,u),ymax:Math.max.apply(null,u),spatialReference:l})}let x=class extends c{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(e,r){const{coeffX:n,coeffY:t}=r;if(null==n||!n.length||null==t||!t.length||n.length!==t.length)return null;const s=[];for(let e=0;e<n.length;e++)s.push(n[e]),s.push(t[e]);return s}writeForwardCoefficients(e,r,n){const t=[],s=[];for(let r=0;r<(null==e?void 0:e.length);r++)r%2==0?t.push(e[r]):s.push(e[r]);r.coeffX=t,r.coeffY=s}get inverseCoefficients(){let e=this._get("inverseCoefficients");const r=this._get("forwardCoefficients");return!e&&r&&this.polynomialOrder<2&&(e=function(e){const[r,n,t,s,i,o]=e,f=t*o-i*s,l=i*s-t*o;return[(i*n-r*o)/f,(t*n-r*s)/l,o/f,s/l,-i/f,-t/l]}(r)),e}set inverseCoefficients(e){this._set("inverseCoefficients",e)}readInverseCoefficients(e,r){const{inverseCoeffX:n,inverseCoeffY:t}=r;if(null==n||!n.length||null==t||!t.length||n.length!==t.length)return null;const s=[];for(let e=0;e<n.length;e++)s.push(n[e]),s.push(t[e]);return s}writeInverseCoefficients(e,r,n){const t=[],s=[];for(let r=0;r<(null==e?void 0:e.length);r++)r%2==0?t.push(e[r]):s.push(e[r]);r.inverseCoeffX=t,r.inverseCoeffY=s}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(e){if("point"===e.type){const r=y(this.forwardCoefficients,e,this.polynomialOrder);return new o({x:r.x,y:r.y,spatialReference:e.spatialReference})}return m(this.forwardCoefficients,e,this.polynomialOrder)}inverseTransform(e){if("point"===e.type){const r=y(this.inverseCoefficients,e,this.polynomialOrder);return new o({x:r.x,y:r.y,spatialReference:e.spatialReference})}return m(this.inverseCoefficients,e,this.polynomialOrder)}};e([r({json:{write:!0}})],x.prototype,"polynomialOrder",void 0),e([r()],x.prototype,"forwardCoefficients",void 0),e([s("forwardCoefficients",["coeffX","coeffY"])],x.prototype,"readForwardCoefficients",null),e([i("forwardCoefficients")],x.prototype,"writeForwardCoefficients",null),e([r({json:{write:!0}})],x.prototype,"inverseCoefficients",null),e([s("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],x.prototype,"readInverseCoefficients",null),e([i("inverseCoefficients")],x.prototype,"writeInverseCoefficients",null),e([r()],x.prototype,"affectsPixelSize",null),e([l({PolynomialXform:"polynomial"})],x.prototype,"type",void 0),x=e([n("esri.layers.support.rasterTransforms.PolynomialTransform")],x);const p=x,v={PolynomialXform:p,IdentityXform:d},C=Object.keys(v);function w(e){return!e||C.includes(null==e?void 0:e.type)}function h(e){if(!(null==e?void 0:e.type))return null;const r=v[null==e?void 0:e.type];if(r){const n=new r;return n.read(e),n}return null}export{c as a,w as e,h as l,p as m}