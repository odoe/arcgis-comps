import{E as t}from"./p-566b0715.js";import{r as n}from"./p-9ae46e68.js";import{j as e,R as r,A as i}from"./p-40c5644b.js";const s=new Map,l=new class{constructor(t=15e3,n=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=t,this._interval=Math.min(t,n)}decreaseRefCount(t,n){const e=t+"/"+n,r=this._cachedBlocks;if(r.has(e)){const t=r.get(e);return t.refCount--,t.refCount<=0&&(r.delete(e),t.controller&&t.controller.abort()),t.refCount}return 0}getBlock(t,n){const e=t+"/"+n,r=this._cachedBlocks;if(r.has(e)){const t=r.get(e);return t.ts=Date.now(),t.refCount++,r.delete(e),r.set(e,t),t.block}return null}putBlock(t,n,e,r=null){const i=this._cachedBlocks,s=t+"/"+n;if(i.has(s)){const t=i.get(s);t.ts=Date.now(),t.refCount++}else i.set(s,{block:e,ts:Date.now(),refCount:1,controller:r});this.trim(),this.updateTimer()}deleteBlock(t,n){const e=this._cachedBlocks,r=t+"/"+n;e.has(r)&&e.delete(r)}updateMaxSize(t){this._size=t,this.trim()}empty(){this._cachedBlocks.clear(),this.clearTimer()}getCurrentSize(){return this._cachedBlocks.size}updateTimer(){if(null!=this._timer)return;const t=this._cachedBlocks;this._timer=setInterval((()=>{const n=Array.from(t),e=Date.now();for(let r=0;r<n.length&&n[r][1].ts<=e-this._duration;r++)t.delete(n[r][0]);0===t.size&&this.clearTimer()}),this._interval)}trim(){const t=this._cachedBlocks;if(-1===this._size||this._size>=t.size)return;const n=Array.from(t);for(let e=0;e<n.length-this._size;e++)t.delete(n[e][0])}clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function o(t,n){return null==n?t:`${t}?sliceId=${n}`}function u(t,n){const e={extent:null,rasterInfo:n,cache:new Map};if(s.has(t)){const n=s.get(t);return n.push(e),n.length-1}return s.set(t,[e]),0}function c(t,n){if(s.has(t)){const e=s.get(t);e[n]=null,e.some((t=>null!=t))||s.delete(t)}}function f(t,n,e){if(!s.has(t))return null==n?l.decreaseRefCount(t,e):0;const r=s.get(t);if(null==r[n])return l.decreaseRefCount(t,e);const i=r[n].cache;if(i.has(e)){const t=i.get(e);if(t.refCount--,0===t.refCount){i.delete(e);for(let t=0;t<r.length;t++)r[t]&&r[t].cache.has(e)&&r[t].cache.delete(e);t.controller&&t.controller.abort()}return t.refCount}return 0}function a(t,n,e){if(!s.has(t))return null==n?l.getBlock(t,e):null;const r=s.get(t);if(null==r[n]){for(let t=0;t<r.length;t++)if(r[t]&&r[t].cache.has(e)){const n=r[t].cache.get(e);return n.refCount++,n.block}return l.getBlock(t,e)}const i=r[n].cache;if(i.has(e)){const t=i.get(e);return t.refCount++,t.block}for(let t=0;t<r.length;t++)if(t!==n&&r[t]&&r[t]&&r[t].cache.has(e)){const n=r[t].cache.get(e);return n.refCount++,i.set(e,n),n.block}return null}function h(t,n,e,r,i=null){if(!s.has(t))return void(null==n&&l.putBlock(t,e,r,i));const o=s.get(t);if(null==o[n])return void l.putBlock(t,e,r,i);const u={refCount:1,block:r,isResolved:!1,isRejected:!1,controller:i};r.then((()=>u.isResolved=!0)).catch((()=>u.isRejected=!0)),o[n].cache.set(e,u)}function p(t,n,e){if(!s.has(t))return void(null==n&&l.deleteBlock(t,e));const r=s.get(t);null!=r[n]?r[n].cache.delete(e):l.deleteBlock(t,e)}function m(t,n){if(!s.has(t))return null;const e=s.get(t);return null==e[n]?null:e[n]}function M(s,l,o,u,c,f,a=null){const h=m(s,l),p=h.extent,{cache:M,rasterInfo:d}=h;if(p&&p.xmin===o.xmin&&p.xmax===o.xmax&&p.ymin===o.ymin&&p.ymax===o.ymax)return;const x=o.clone().normalize(),{spatialReference:y,transform:v}=d,R=new Set;for(let s=0;s<x.length;s++){const l=x[s];if(l.xmax-l.xmin<=u||l.ymax-l.ymin<=u)continue;let o=e(l,y,a);n(v)&&(o=v.inverseTransform(o));const h=new t({x:u,y:u,spatialReference:l.spatialReference});if(null==c&&!(c=r(h,y,l,a)))return;const{pyramidLevel:p,pyramidResolution:m,excessiveReading:M}=i(c,d,f||"closest");if(M)return;const{storageInfo:w}=d,{origin:I}=w,g={x:Math.max(0,Math.floor((o.xmin-I.x)/m.x)),y:Math.max(0,Math.floor((I.y-o.ymax)/m.y))},k=Math.ceil((o.xmax-o.xmin)/m.x-.1),$=Math.ceil((o.ymax-o.ymin)/m.y-.1),b=p>0?w.pyramidBlockWidth:w.blockWidth,j=p>0?w.pyramidBlockHeight:w.blockHeight,C=1,D=Math.max(0,Math.floor(g.x/b)-C),B=Math.max(0,Math.floor(g.y/j)-C),S=Math.floor((g.x+k-1)/b)+C,z=Math.floor((g.y+$-1)/j)+C;for(let t=B;t<=z;t++)for(let n=D;n<=S;n++)R.add(`${p}/${t}/${n}`)}M.forEach(((t,n)=>{if(!R.has(n)){const t=M.get(n);(null==t||t.isResolved||t.isRejected)&&M.delete(n)}})),h.extent={xmin:o.xmin,ymin:o.ymin,xmax:o.xmax,ymax:o.ymax}}export{p as d,M as g,f as h,o as i,a as m,u as s,c as u,h as x}