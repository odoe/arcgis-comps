import{A as t,K as r}from"./p-e58503d5.js";import{h as e}from"./p-58386239.js";import{_ as o}from"./p-c6ceae9e.js";import"./p-53bb6ab4.js";import"./p-285c6a34.js";import"./p-01e5a461.js";import"./p-8f986f60.js";import"./p-ccdb8e80.js";import"./p-d3105731.js";import"./p-2c84c65f.js";import"./p-b9aa4901.js";import"./p-c93d2280.js";import"./p-2f398ed1.js";import"./p-b79fcce3.js";import"./p-ea916a39.js";import"./p-fea9512d.js";import"./p-9bdf9304.js";import"./p-a3955219.js";import"./p-f06611ed.js";import"./p-e6fe5d89.js";import"./p-2f5c7e83.js";import"./p-c7a58085.js";class s{async createIndex(r,o){const s=new Array;if(!r.vertexAttributes||!r.vertexAttributes.position)return new e;const p=this.createMeshData(r),a=t(o)?await o.invoke("createIndexThread",p,{transferList:s}):this.createIndexThread(p).result;return this.createPooledRBush().fromJSON(a)}createIndexThread(t){const r=new Float64Array(t.position),e=this.createPooledRBush();return t.components?this.createIndexComponentsThread(e,r,t.components.map((t=>new Uint32Array(t)))):this.createIndexAllThread(e,r)}createIndexAllThread(t,r){const e=new Array(r.length/9);let o=0;for(let t=0;t<r.length;t+=9)e[o++]=p(r,t+0,t+3,t+6);return t.load(e),{result:t.toJSON()}}createIndexComponentsThread(t,r,e){let o=0;for(const t of e)o+=t.length/3;const s=new Array(o);let a=0;for(const t of e)for(let e=0;e<t.length;e+=3)s[a++]=p(r,3*t[e+0],3*t[e+1],3*t[e+2]);return t.load(s),{result:t.toJSON()}}createMeshData(t){const r=(t.transform?o({position:t.vertexAttributes.position,normal:null,tangent:null},t.transform,t.spatialReference).position:t.vertexAttributes.position).buffer;return!t.components||t.components.some((t=>!t.faces))?{position:r}:{position:r,components:t.components.map((t=>t.faces))}}createPooledRBush(){return new e(9,r("esri-csp-restrictions")?t=>t:[".minX",".minY",".maxX",".maxY"])}}function p(t,r,e,o){return{minX:Math.min(t[r+0],t[e+0],t[o+0]),maxX:Math.max(t[r+0],t[e+0],t[o+0]),minY:Math.min(t[r+1],t[e+1],t[o+1]),maxY:Math.max(t[r+1],t[e+1],t[o+1]),p0:[t[r+0],t[r+1],t[r+2]],p1:[t[e+0],t[e+1],t[e+2]],p2:[t[o+0],t[o+1],t[o+2]]}}export default s;export{s as ElevationSamplerWorker}