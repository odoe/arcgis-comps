import{aS as e,e as t,d as s,i as r,a1 as i,D as n,N as o,_ as a,a2 as l,a0 as u,aE as c,V as d,s as p,Q as m,bf as f,bi as h,A as v}from"./p-e58503d5.js";import{e as y,r as g}from"./p-7ca40eac.js";import{r as T}from"./p-a9a30646.js";import{h as N}from"./p-54330161.js";import A from"./p-dc852195.js";import{a as w}from"./p-e258f3af.js";import{m as M}from"./p-b79fcce3.js";const b=e()({esriCentimeters:"centimeters",esriDecimalDegrees:"decimal-degrees",esriDecimeters:"decimeters",esriFeet:"feet",esriInches:"inches",esriKilometers:"kilometers",esriMeters:"meters",esriMiles:"miles",esriMillimeters:"millimeters",esriNauticalMiles:"nautical-miles",esriPoints:"points",esriYards:"yards"}),j=e()({esriNAUCentimeters:"centimeters",esriNAUDecimalDegrees:"decimal-degrees",esriNAUDecimeters:"decimeters",esriNAUFeet:"feet",esriNAUInches:"inches",esriNAUKilometers:"kilometers",esriNAUMeters:"meters",esriNAUMiles:"miles",esriNAUMillimeters:"millimeters",esriNAUNauticalMiles:"nautical-miles",esriNAUPoints:"points",esriNAUYards:"yards"}),S=e()({esriDOTComplete:"complete",esriDOTCompleteNoEvents:"complete-no-events",esriDOTInstructionsOnly:"instructions-only",esriDOTStandard:"standard",esriDOTSummaryOnly:"summary-only"}),O=e()({esriNAOutputLineNone:"none",esriNAOutputLineStraight:"straight",esriNAOutputLineTrueShape:"true-shape",esriNAOutputLineTrueShapeWithMeasure:"true-shape-with-measure"});e()({esriNAOutputPolygonNone:"none",esriNAOutputPolygonSimplified:"simplified",esriNAOutputPolygonDetailed:"detailed"});const B=e()({esriNFSBAllowBacktrack:"allow-backtrack",esriNFSBAtDeadEndsOnly:"at-dead-ends-only",esriNFSBNoBacktrack:"no-backtrack",esriNFSBAtDeadEndsAndIntersections:"at-dead-ends-and-intersections"});e()({esriNATravelDirectionFromFacility:"from-facility",esriNATravelDirectionToFacility:"to-facility"}),e()({esriNATimeOfDayNotUsed:"not-used",esriNATimeOfDayUseAsStartTime:"start",esriNATimeOfDayUseAsEndTime:"end"});const D=e()({AUTOMOBILE:"automobile",TRUCK:"truck",WALK:"walk",OTHER:"other"});var U;let k=U=class extends i{constructor(e){super(e),this.attributeParameterValues=null,this.description=null,this.distanceAttributeName=null,this.id=null,this.impedanceAttributeName=null,this.name=null,this.restrictionAttributeNames=null,this.simplificationTolerance=null,this.simplificationToleranceUnits=null,this.timeAttributeName=null,this.type=null,this.useHierarchy=null,this.uturnAtJunctions=null}clone(){return new U(n({attributeParameterValues:this.attributeParameterValues,description:this.description,distanceAttributeName:this.distanceAttributeName,id:this.id,impedanceAttributeName:this.impedanceAttributeName,name:this.name,restrictionAttributeNames:this.restrictionAttributeNames,simplificationTolerance:this.simplificationTolerance,simplificationToleranceUnits:this.simplificationToleranceUnits,timeAttributeName:this.timeAttributeName,type:this.type,useHierarchy:this.useHierarchy,uturnAtJunctions:this.uturnAtJunctions}))}};t([s({type:[Object],json:{write:!0}})],k.prototype,"attributeParameterValues",void 0),t([s({type:String,json:{write:!0}})],k.prototype,"description",void 0),t([s({type:String,json:{write:!0}})],k.prototype,"distanceAttributeName",void 0),t([s({type:String,json:{write:!0}})],k.prototype,"id",void 0),t([s({type:String,json:{write:!0}})],k.prototype,"impedanceAttributeName",void 0),t([s({type:String,json:{write:!0}})],k.prototype,"name",void 0),t([s({type:[String],json:{write:!0}})],k.prototype,"restrictionAttributeNames",void 0),t([s({type:Number,json:{write:!0}})],k.prototype,"simplificationTolerance",void 0),t([T(b)],k.prototype,"simplificationToleranceUnits",void 0),t([s({type:String,json:{write:!0}})],k.prototype,"timeAttributeName",void 0),t([T(D)],k.prototype,"type",void 0),t([s({type:Boolean,json:{write:!0}})],k.prototype,"useHierarchy",void 0),t([T(B)],k.prototype,"uturnAtJunctions",void 0),k=U=t([r("esri.rest.support.TravelMode")],k);const R=k;let I=class extends i{constructor(e){super(e),this.currentVersion=null,this.defaultTravelMode=null,this.directionsLanguage=null,this.directionsSupportedLanguages=null,this.directionsTimeAttribute=null,this.hasZ=null,this.impedance=null,this.networkDataset=null,this.supportedTravelModes=null}};t([s()],I.prototype,"currentVersion",void 0),t([s()],I.prototype,"defaultTravelMode",void 0),t([s()],I.prototype,"directionsLanguage",void 0),t([s()],I.prototype,"directionsSupportedLanguages",void 0),t([s()],I.prototype,"directionsTimeAttribute",void 0),t([s()],I.prototype,"hasZ",void 0),t([s()],I.prototype,"impedance",void 0),t([s()],I.prototype,"networkDataset",void 0),t([s({type:[R]})],I.prototype,"supportedTravelModes",void 0),I=t([r("esri.rest.support.NetworkServiceDescription")],I);const P=I,F=new o({0:"informative",1:"process-definition",2:"process-start",3:"process-stop",50:"warning",100:"error",101:"empty",200:"abort"});let x=class extends w{constructor(e){super(e),this.type=null}};t([s({type:String,json:{read:F.read,write:F.write}})],x.prototype,"type",void 0),x=t([r("esri.rest.support.NAMessage")],x);const L=x;let E=class extends N{};t([s()],E.prototype,"events",void 0),t([s()],E.prototype,"strings",void 0),E=t([r("esri.rest.support.DirectionsFeature")],E);const C=E;let Z=class extends A{constructor(e){super(e),this.extent=null,this.features=null,this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null}readFeatures(e,t){var s;if(!e)return[];const r=null!=(s=t.summary.envelope.spatialReference)?s:t.spatialReference,i=r&&u.fromJSON(r);return e.map((e=>{var t,s;const r=this._decompressGeometry(e.compressedGeometry),n=new M({...r,spatialReference:i}),o=null!=(t=null==(s=e.events)?void 0:s.map((e=>{const{arriveTimeUTC:t,ETA:s,point:{x:r,y:n,z:o},strings:a}=e;return new C({geometry:new c({x:r,y:n,z:o,hasZ:void 0!==o,spatialReference:i}),attributes:{ETA:s,arriveTimeUTC:t},strings:a})})))?t:[];return new C({attributes:e.attributes,events:o,geometry:n,strings:e.strings})}))}get mergedGeometry(){if(!this.features)return null;const e=this.features.map((({geometry:e})=>d(e))),t=this.get("extent.spatialReference");return this._mergePolylinesToSinglePath(e,t)}get strings(){return this.features.map((({strings:e})=>e))}_decompressGeometry(e){let t=0,s=0,r=0,i=0;const n=[];let o,a,l,u,c,d,p,m,f=0,h=0,v=0;if(c=e.match(/((\+|\-)[^\+\-\|]+|\|)/g),c||(c=[]),0===parseInt(c[f],32)){f=2;const e=parseInt(c[f],32);f++,d=parseInt(c[f],32),f++,1&e&&(h=c.indexOf("|")+1,p=parseInt(c[h],32),h++),2&e&&(v=c.indexOf("|",h)+1,m=parseInt(c[v],32),v++)}else d=parseInt(c[f],32),f++;for(;f<c.length&&"|"!==c[f];){o=parseInt(c[f],32)+t,f++,t=o,a=parseInt(c[f],32)+s,f++,s=a;const e=[o/d,a/d];h&&(u=parseInt(c[h],32)+r,h++,r=u,e.push(u/p)),v&&(l=parseInt(c[v],32)+i,v++,i=l,e.push(l/m)),n.push(e)}return{paths:[n],hasZ:h>0,hasM:v>0}}_mergePolylinesToSinglePath(e,t){if(0===e.length)return new M({spatialReference:t});const s=[];for(const t of e)for(const e of t.paths)s.push(...e);const r=[];s.forEach(((e,t)=>{0!==t&&e[0]===s[t-1][0]&&e[1]===s[t-1][1]||r.push(e)}));const{hasM:i,hasZ:n}=e[0];return new M({hasM:i,hasZ:n,paths:[r],spatialReference:t})}};t([s({type:a,json:{read:{source:"summary.envelope"}}})],Z.prototype,"extent",void 0),t([s()],Z.prototype,"features",void 0),t([l("features")],Z.prototype,"readFeatures",null),t([s()],Z.prototype,"geometryType",void 0),t([s({readOnly:!0})],Z.prototype,"mergedGeometry",null),t([s()],Z.prototype,"routeId",void 0),t([s()],Z.prototype,"routeName",void 0),t([s({value:null,readOnly:!0})],Z.prototype,"strings",null),t([s({json:{read:{source:"summary.totalDriveTime"}}})],Z.prototype,"totalDriveTime",void 0),t([s({json:{read:{source:"summary.totalLength"}}})],Z.prototype,"totalLength",void 0),t([s({json:{read:{source:"summary.totalTime"}}})],Z.prototype,"totalTime",void 0),Z=t([r("esri.rest.support.DirectionsFeatureSet")],Z);const _=Z;let G=class extends i{constructor(e){super(e),this.directions=null,this.route=null,this.routeName=null,this.stops=null}};t([s({type:_,json:{write:!0}})],G.prototype,"directions",void 0),t([s({type:N,json:{write:!0}})],G.prototype,"route",void 0),t([s({type:String,json:{write:!0}})],G.prototype,"routeName",void 0),t([s({type:[N],json:{write:!0}})],G.prototype,"stops",void 0),G=t([r("esri.rest.support.RouteResult")],G);const J=G;function K(e){return e&&A.fromJSON(e).features.map((e=>e))}let V=class extends i{constructor(e){super(e),this.barriers=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.routeResults=null}readPointBarriers(e,t){return K(t.barriers||t.pointBarriers)}readPolylineBarriers(e){return K(e)}readPolygonBarriers(e){return K(e)}};t([s({aliasOf:"pointBarriers"})],V.prototype,"barriers",void 0),t([s({type:[L]})],V.prototype,"messages",void 0),t([s({type:[N]})],V.prototype,"pointBarriers",void 0),t([l("pointBarriers",["barriers","pointBarriers"])],V.prototype,"readPointBarriers",null),t([s({type:[N]})],V.prototype,"polylineBarriers",void 0),t([l("polylineBarriers")],V.prototype,"readPolylineBarriers",null),t([s({type:[N]})],V.prototype,"polygonBarriers",void 0),t([l("polygonBarriers")],V.prototype,"readPolygonBarriers",null),t([s({type:[J]})],V.prototype,"routeResults",void 0),V=t([r("esri.rest.support.RouteResultsContainer")],V);const H=V;function $(e,t,s,r){r[s]=[t.length,t.length+e.length],e.forEach((e=>{t.push(e.geometry)}))}function z(e,t){for(let s=0;s<t.length;s++){const r=e[t[s]];if(r&&r.length)for(const e of r)e.z=void 0}console.log("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}function Q(e){const t=[],s=[],{directions:r=[],routes:{features:i=[],spatialReference:n=null}={},stops:{features:o=[],spatialReference:a=null}={},barriers:l,polygonBarriers:u,polylineBarriers:c,messages:d}=e.data,p="esri.tasks.RouteTask.NULL_ROUTE_NAME";let m,f,h=!0;const y=i&&n||o&&a||l&&l.spatialReference||u&&u.spatialReference||c&&c.spatialReference;r.forEach((e=>{t.push(m=e.routeName),s[m]={directions:e}})),i.forEach((e=>{-1===t.indexOf(m=e.attributes.Name)&&(t.push(m),s[m]={}),v(e.geometry)&&(e.geometry.spatialReference=y),s[m].route=e})),o.forEach((e=>{f=e.attributes,-1===t.indexOf(m=f.RouteName||p)&&(t.push(m),s[m]={}),m!==p&&(h=!1),v(e.geometry)&&(e.geometry.spatialReference=y),null==s[m].stops&&(s[m].stops=[]),s[m].stops.push(e)})),o.length>0&&!0===h&&(s[t[0]].stops=s[p].stops,delete s[p],t.splice(t.indexOf(p),1));const g=t.map((e=>(s[e].routeName=e===p?null:e,s[e])));return H.fromJSON({routeResults:g,pointBarriers:l,polygonBarriers:u,polylineBarriers:c,messages:d})}function W(e,t){for(let s=0;s<t.length;s++){const r=e[t[s]];if(r&&r.length)for(const e of r)if(v(e)&&e.hasZ)return!0}return!1}async function Y(e,t,s){if(!e)throw new p("network-service:missing-url","Url to Network service is missing");const r=g({f:"json",token:t},s),{data:i}=await m(e,r);i.supportedTravelModes||(i.supportedTravelModes=[]);for(let e=0;e<i.supportedTravelModes.length;e++)i.supportedTravelModes[e].id||(i.supportedTravelModes[e].id=i.supportedTravelModes[e].itemId);const n=i.currentVersion>=10.4?async function(e,t,s){try{const r=g({f:"json",token:t},s),i=f(e)+"/retrieveTravelModes",{data:{supportedTravelModes:n,defaultTravelMode:o}}=await m(i,r);return{supportedTravelModes:n,defaultTravelMode:o}}catch(e){throw new p("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:e})}}(e,t,s):async function(e,t){var s,r;const i=g({f:"json"},t),{data:n}=await m(e.replace(/\/rest\/.*$/i,"/info"),i);if(!n||!n.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:o}=n,a=f(o)+"/sharing/rest/portals/self",{data:l}=await m(a,i),u=h("helperServices.routingUtilities.url",l);if(!u)return{supportedTravelModes:[],defaultTravelMode:null};const c=y(o),d=/\/solve$/i.test(c.path)?"Route":/\/solveclosestfacility$/i.test(c.path)?"ClosestFacility":"ServiceAreas",p=g({f:"json",serviceName:d},t),v=f(u)+"/GetTravelModes/execute",T=await m(v,p),N=[];let A=null;if(null!=T&&null!=(s=T.data)&&null!=(r=s.results)&&r.length){const e=T.data.results;for(const t of e){var w;if("supportedTravelModes"===t.paramName){if(null!=(w=t.value)&&w.features)for(const{attributes:e}of t.value.features)if(e){const t=JSON.parse(e.TravelMode);N.push(t)}}else"defaultTravelMode"===t.paramName&&(A=t.value)}}return{supportedTravelModes:N,defaultTravelMode:A}}(e,s),{defaultTravelMode:o,supportedTravelModes:a}=await n;return i.defaultTravelMode=o,i.supportedTravelModes=a,P.fromJSON(i)}class q{constructor(e={}){this._options=e}toQueryParams(e){if(!e)return null;const t=e.toJSON(),s={};return Object.keys(t).forEach((e=>{const r=this._options[e];if(r){const i="boolean"!=typeof r&&r.name?r.name:e,n="boolean"!=typeof r&&r.getter?r.getter(t):t[e];null!=n&&(s[i]=(e=>{if(!Array.isArray(e))return!1;const[t]=e;return"number"==typeof t||"string"==typeof t})(n)?n.join(","):"object"==typeof n?JSON.stringify(n):n)}else s[e]=t[e]}),this),s}}function X(e){return new q(e)}export{_ as a,L as b,Y as c,W as d,Q as f,b as i,R as m,B as n,X as o,z as p,S as r,j as s,O as t,$ as u}