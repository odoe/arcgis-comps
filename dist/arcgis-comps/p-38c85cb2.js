import{aT as e,e as t,d as s,i as r,H as i,P as n,_ as o,r as a,m as l,O as u,bo as c,aU as d}from"./p-9ae46e68.js";import{e as p,r as m}from"./p-41655335.js";import{a as h}from"./p-fe01b82b.js";import{f,h as v,M as y,o as g,k as T,b2 as N,E as A}from"./p-566b0715.js";import w from"./p-98a14d68.js";import{a as M}from"./p-ec378dda.js";class b{constructor(e={}){this._options=e}toQueryParams(e){if(!e)return null;const t=e.toJSON(),s={};return Object.keys(t).forEach((e=>{const r=this._options[e];if(r){const i="boolean"!=typeof r&&r.name?r.name:e,n="boolean"!=typeof r&&r.getter?r.getter(t):t[e];null!=n&&(s[i]=(e=>{if(!Array.isArray(e))return!1;const[t]=e;return"number"==typeof t||"string"==typeof t})(n)?n.join(","):"object"==typeof n?JSON.stringify(n):n)}else s[e]=t[e]}),this),s}}function j(e){return new b(e)}const O=e()({esriCentimeters:"centimeters",esriDecimalDegrees:"decimal-degrees",esriDecimeters:"decimeters",esriFeet:"feet",esriInches:"inches",esriKilometers:"kilometers",esriMeters:"meters",esriMiles:"miles",esriMillimeters:"millimeters",esriNauticalMiles:"nautical-miles",esriPoints:"points",esriYards:"yards"});e()({esriNAUCentimeters:"centimeters",esriNAUDecimalDegrees:"decimal-degrees",esriNAUDecimeters:"decimeters",esriNAUFeet:"feet",esriNAUInches:"inches",esriNAUKilometers:"kilometers",esriNAUMeters:"meters",esriNAUMiles:"miles",esriNAUMillimeters:"millimeters",esriNAUNauticalMiles:"nautical-miles",esriNAUPoints:"points",esriNAUYards:"yards"}),e()({esriDOTComplete:"complete",esriDOTCompleteNoEvents:"complete-no-events",esriDOTInstructionsOnly:"instructions-only",esriDOTStandard:"standard",esriDOTSummaryOnly:"summary-only"}),e()({esriNAOutputLineNone:"none",esriNAOutputLineStraight:"straight",esriNAOutputLineTrueShape:"true-shape",esriNAOutputLineTrueShapeWithMeasure:"true-shape-with-measure"}),e()({esriNAOutputPolygonNone:"none",esriNAOutputPolygonSimplified:"simplified",esriNAOutputPolygonDetailed:"detailed"});const S=e()({esriNFSBAllowBacktrack:"allow-backtrack",esriNFSBAtDeadEndsOnly:"at-dead-ends-only",esriNFSBNoBacktrack:"no-backtrack",esriNFSBAtDeadEndsAndIntersections:"at-dead-ends-and-intersections"});e()({esriNATravelDirectionFromFacility:"from-facility",esriNATravelDirectionToFacility:"to-facility"}),e()({esriNATimeOfDayNotUsed:"not-used",esriNATimeOfDayUseAsStartTime:"start",esriNATimeOfDayUseAsEndTime:"end"});const B=e()({AUTOMOBILE:"automobile",TRUCK:"truck",WALK:"walk",OTHER:"other"});var U;let D=U=class extends h{constructor(e){super(e),this.attributeParameterValues=null,this.description=null,this.distanceAttributeName=null,this.id=null,this.impedanceAttributeName=null,this.name=null,this.restrictionAttributeNames=null,this.simplificationTolerance=null,this.simplificationToleranceUnits=null,this.timeAttributeName=null,this.type=null,this.useHierarchy=null,this.uturnAtJunctions=null}clone(){return new U(i({attributeParameterValues:this.attributeParameterValues,description:this.description,distanceAttributeName:this.distanceAttributeName,id:this.id,impedanceAttributeName:this.impedanceAttributeName,name:this.name,restrictionAttributeNames:this.restrictionAttributeNames,simplificationTolerance:this.simplificationTolerance,simplificationToleranceUnits:this.simplificationToleranceUnits,timeAttributeName:this.timeAttributeName,type:this.type,useHierarchy:this.useHierarchy,uturnAtJunctions:this.uturnAtJunctions}))}};t([s({type:[Object],json:{write:!0}})],D.prototype,"attributeParameterValues",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"description",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"distanceAttributeName",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"id",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"impedanceAttributeName",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"name",void 0),t([s({type:[String],json:{write:!0}})],D.prototype,"restrictionAttributeNames",void 0),t([s({type:Number,json:{write:!0}})],D.prototype,"simplificationTolerance",void 0),t([f(O)],D.prototype,"simplificationToleranceUnits",void 0),t([s({type:String,json:{write:!0}})],D.prototype,"timeAttributeName",void 0),t([f(B)],D.prototype,"type",void 0),t([s({type:Boolean,json:{write:!0}})],D.prototype,"useHierarchy",void 0),t([f(S)],D.prototype,"uturnAtJunctions",void 0),D=U=t([r("esri.rest.support.TravelMode")],D);const k=D;let R=class extends h{constructor(e){super(e),this.currentVersion=null,this.defaultTravelMode=null,this.directionsLanguage=null,this.directionsSupportedLanguages=null,this.directionsTimeAttribute=null,this.hasZ=null,this.impedance=null,this.networkDataset=null,this.supportedTravelModes=null}};t([s()],R.prototype,"currentVersion",void 0),t([s()],R.prototype,"defaultTravelMode",void 0),t([s()],R.prototype,"directionsLanguage",void 0),t([s()],R.prototype,"directionsSupportedLanguages",void 0),t([s()],R.prototype,"directionsTimeAttribute",void 0),t([s()],R.prototype,"hasZ",void 0),t([s()],R.prototype,"impedance",void 0),t([s()],R.prototype,"networkDataset",void 0),t([s({type:[k]})],R.prototype,"supportedTravelModes",void 0),R=t([r("esri.rest.support.NetworkServiceDescription")],R);const P=R,I=new n({0:"informative",1:"process-definition",2:"process-start",3:"process-stop",50:"warning",100:"error",101:"empty",200:"abort"});let F=class extends M{constructor(e){super(e),this.type=null}};t([s({type:String,json:{read:I.read,write:I.write}})],F.prototype,"type",void 0),F=t([r("esri.rest.support.NAMessage")],F);const x=F;let L=class extends v{};t([s()],L.prototype,"events",void 0),t([s()],L.prototype,"strings",void 0),L=t([r("esri.rest.support.DirectionsFeature")],L);const E=L;let C=class extends w{constructor(e){super(e),this.extent=null,this.features=null,this.geometryType="polyline",this.routeId=null,this.routeName=null,this.totalDriveTime=null,this.totalLength=null,this.totalTime=null}readFeatures(e,t){var s;if(!e)return[];const r=null!=(s=t.summary.envelope.spatialReference)?s:t.spatialReference,i=r&&T.fromJSON(r);return e.map((e=>{var t,s;const r=this._decompressGeometry(e.compressedGeometry),n=new N({...r,spatialReference:i}),o=null!=(t=null==(s=e.events)?void 0:s.map((e=>{const{arriveTimeUTC:t,ETA:s,point:{x:r,y:n,z:o},strings:a}=e;return new E({geometry:new A({x:r,y:n,z:o,hasZ:void 0!==o,spatialReference:i}),attributes:{ETA:s,arriveTimeUTC:t},strings:a})})))?t:[];return new E({attributes:e.attributes,events:o,geometry:n,strings:e.strings})}))}get mergedGeometry(){if(!this.features)return null;const e=this.features.map((({geometry:e})=>o(e))),t=this.get("extent.spatialReference");return this._mergePolylinesToSinglePath(e,t)}get strings(){return this.features.map((({strings:e})=>e))}_decompressGeometry(e){let t=0,s=0,r=0,i=0;const n=[];let o,a,l,u,c,d,p,m,h=0,f=0,v=0;if(c=e.match(/((\+|\-)[^\+\-\|]+|\|)/g),c||(c=[]),0===parseInt(c[h],32)){h=2;const e=parseInt(c[h],32);h++,d=parseInt(c[h],32),h++,1&e&&(f=c.indexOf("|")+1,p=parseInt(c[f],32),f++),2&e&&(v=c.indexOf("|",f)+1,m=parseInt(c[v],32),v++)}else d=parseInt(c[h],32),h++;for(;h<c.length&&"|"!==c[h];){o=parseInt(c[h],32)+t,h++,t=o,a=parseInt(c[h],32)+s,h++,s=a;const e=[o/d,a/d];f&&(u=parseInt(c[f],32)+r,f++,r=u,e.push(u/p)),v&&(l=parseInt(c[v],32)+i,v++,i=l,e.push(l/m)),n.push(e)}return{paths:[n],hasZ:f>0,hasM:v>0}}_mergePolylinesToSinglePath(e,t){if(0===e.length)return new N({spatialReference:t});const s=[];for(const t of e)for(const e of t.paths)s.push(...e);const r=[];s.forEach(((e,t)=>{0!==t&&e[0]===s[t-1][0]&&e[1]===s[t-1][1]||r.push(e)}));const{hasM:i,hasZ:n}=e[0];return new N({hasM:i,hasZ:n,paths:[r],spatialReference:t})}};t([s({type:y,json:{read:{source:"summary.envelope"}}})],C.prototype,"extent",void 0),t([s()],C.prototype,"features",void 0),t([g("features")],C.prototype,"readFeatures",null),t([s()],C.prototype,"geometryType",void 0),t([s({readOnly:!0})],C.prototype,"mergedGeometry",null),t([s()],C.prototype,"routeId",void 0),t([s()],C.prototype,"routeName",void 0),t([s({value:null,readOnly:!0})],C.prototype,"strings",null),t([s({json:{read:{source:"summary.totalDriveTime"}}})],C.prototype,"totalDriveTime",void 0),t([s({json:{read:{source:"summary.totalLength"}}})],C.prototype,"totalLength",void 0),t([s({json:{read:{source:"summary.totalTime"}}})],C.prototype,"totalTime",void 0),C=t([r("esri.rest.support.DirectionsFeatureSet")],C);const Z=C;let _=class extends h{constructor(e){super(e),this.directions=null,this.route=null,this.routeName=null,this.stops=null}};t([s({type:Z,json:{write:!0}})],_.prototype,"directions",void 0),t([s({type:v,json:{write:!0}})],_.prototype,"route",void 0),t([s({type:String,json:{write:!0}})],_.prototype,"routeName",void 0),t([s({type:[v],json:{write:!0}})],_.prototype,"stops",void 0),_=t([r("esri.rest.support.RouteResult")],_);const G=_;function H(e){return e&&w.fromJSON(e).features.map((e=>e))}let J=class extends h{constructor(e){super(e),this.barriers=null,this.messages=null,this.pointBarriers=null,this.polylineBarriers=null,this.polygonBarriers=null,this.routeResults=null}readPointBarriers(e,t){return H(t.barriers||t.pointBarriers)}readPolylineBarriers(e){return H(e)}readPolygonBarriers(e){return H(e)}};t([s({aliasOf:"pointBarriers"})],J.prototype,"barriers",void 0),t([s({type:[x]})],J.prototype,"messages",void 0),t([s({type:[v]})],J.prototype,"pointBarriers",void 0),t([g("pointBarriers",["barriers","pointBarriers"])],J.prototype,"readPointBarriers",null),t([s({type:[v]})],J.prototype,"polylineBarriers",void 0),t([g("polylineBarriers")],J.prototype,"readPolylineBarriers",null),t([s({type:[v]})],J.prototype,"polygonBarriers",void 0),t([g("polygonBarriers")],J.prototype,"readPolygonBarriers",null),t([s({type:[G]})],J.prototype,"routeResults",void 0),J=t([r("esri.rest.support.RouteResultsContainer")],J);const K=J;function V(e,t,s,r){r[s]=[t.length,t.length+e.length],e.forEach((e=>{t.push(e.geometry)}))}function $(e,t){for(let s=0;s<t.length;s++){const r=e[t[s]];if(r&&r.length)for(const e of r)e.z=void 0}console.log("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}function z(e){const t=[],s=[],{directions:r=[],routes:{features:i=[],spatialReference:n=null}={},stops:{features:o=[],spatialReference:l=null}={},barriers:u,polygonBarriers:c,polylineBarriers:d,messages:p}=e.data,m="esri.tasks.RouteTask.NULL_ROUTE_NAME";let h,f,v=!0;const y=i&&n||o&&l||u&&u.spatialReference||c&&c.spatialReference||d&&d.spatialReference;r.forEach((e=>{t.push(h=e.routeName),s[h]={directions:e}})),i.forEach((e=>{-1===t.indexOf(h=e.attributes.Name)&&(t.push(h),s[h]={}),a(e.geometry)&&(e.geometry.spatialReference=y),s[h].route=e})),o.forEach((e=>{f=e.attributes,-1===t.indexOf(h=f.RouteName||m)&&(t.push(h),s[h]={}),h!==m&&(v=!1),a(e.geometry)&&(e.geometry.spatialReference=y),null==s[h].stops&&(s[h].stops=[]),s[h].stops.push(e)})),o.length>0&&!0===v&&(s[t[0]].stops=s[m].stops,delete s[m],t.splice(t.indexOf(m),1));const g=t.map((e=>(s[e].routeName=e===m?null:e,s[e])));return K.fromJSON({routeResults:g,pointBarriers:u,polygonBarriers:c,polylineBarriers:d,messages:p})}function W(e,t){for(let s=0;s<t.length;s++){const r=e[t[s]];if(r&&r.length)for(const e of r)if(a(e)&&e.hasZ)return!0}return!1}async function Y(e,t,s){if(!e)throw new l("network-service:missing-url","Url to Network service is missing");const r=m({f:"json",token:t},s),{data:i}=await u(e,r);i.supportedTravelModes||(i.supportedTravelModes=[]);for(let e=0;e<i.supportedTravelModes.length;e++)i.supportedTravelModes[e].id||(i.supportedTravelModes[e].id=i.supportedTravelModes[e].itemId);const n=i.currentVersion>=10.4?async function(e,t,s){try{const r=m({f:"json",token:t},s),i=c(e)+"/retrieveTravelModes",{data:{supportedTravelModes:n,defaultTravelMode:o}}=await u(i,r);return{supportedTravelModes:n,defaultTravelMode:o}}catch(e){throw new l("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:e})}}(e,t,s):async function(e,t){var s,r;const i=m({f:"json"},t),{data:n}=await u(e.replace(/\/rest\/.*$/i,"/info"),i);if(!n||!n.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};const{owningSystemUrl:o}=n,a=c(o)+"/sharing/rest/portals/self",{data:l}=await u(a,i),h=d("helperServices.routingUtilities.url",l);if(!h)return{supportedTravelModes:[],defaultTravelMode:null};const f=p(o),v=/\/solve$/i.test(f.path)?"Route":/\/solveclosestfacility$/i.test(f.path)?"ClosestFacility":"ServiceAreas",y=m({f:"json",serviceName:v},t),g=c(h)+"/GetTravelModes/execute",T=await u(g,y),N=[];let A=null;if(null!=T&&null!=(s=T.data)&&null!=(r=s.results)&&r.length){const e=T.data.results;for(const t of e){var w;if("supportedTravelModes"===t.paramName){if(null!=(w=t.value)&&w.features)for(const{attributes:e}of t.value.features)if(e){const t=JSON.parse(e.TravelMode);N.push(t)}}else"defaultTravelMode"===t.paramName&&(A=t.value)}}return{supportedTravelModes:N,defaultTravelMode:A}}(e,s),{defaultTravelMode:o,supportedTravelModes:a}=await n;return i.defaultTravelMode=o,i.supportedTravelModes=a,P.fromJSON(i)}export{x as a,Y as b,Z as c,W as d,z as f,j as o,$ as p,V as u}