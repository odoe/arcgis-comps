import{H as t,bS as s,e2 as i,al as e,dl as h,aH as n,T as r,dw as o,hb as a,g as c,W as l,N as f,d1 as u,d3 as d,d6 as p,d5 as y,c5 as w,hu as m,aq as g,dd as b,cH as M,gP as v,ed as A,s as T,a7 as x,U as _,aj as S,dJ as U,gG as I,h6 as D,ab as k,e as P,d as j,i as R}from"./p-7b6f6c18.js";import{h as C,f as L}from"./p-54e8960f.js";import{o as O}from"./p-1dd7027e.js";import{t as F}from"./p-ea65d9c9.js";import{O as z}from"./p-cede17c2.js";import{e as q,t as B,c as V}from"./p-4414d64f.js";import{r as N,o as H}from"./p-1088d11f.js";import{I as $}from"./p-804725e3.js";import{a as G}from"./p-ec15c3e1.js";import{l as K,u as W}from"./p-0b691897.js";import{g as J}from"./p-cde787e2.js";import{t as Q}from"./p-9afeab98.js";import"./p-227a5838.js";import"./p-47e1bd73.js";import"./p-b392deaf.js";import"./p-9790d1b4.js";import"./p-a4a5967b.js";import"./p-033339b0.js";import"./p-e53f77c2.js";import"./p-5bfd1d7e.js";import"./p-a617738c.js";import"./p-a16c2b1d.js";import"./p-167d094f.js";import"./p-97ec6ae5.js";import"./p-e4802f24.js";class E{constructor(t,s){this._width=0,this._height=0,this._free=[],this._width=t,this._height=s,this._free.push(new F(0,0,t,s))}get width(){return this._width}get height(){return this._height}allocate(t,s){if(t>this._width||s>this._height)return new F;let i=null,e=-1;for(let h=0;h<this._free.length;++h){const n=this._free[h];t<=n.width&&s<=n.height&&(null===i||n.y<=i.y&&n.x<=i.x)&&(i=n,e=h)}return null===i?new F:(this._free.splice(e,1),i.width<i.height?(i.width>t&&this._free.push(new F(i.x+t,i.y,i.width-t,s)),i.height>s&&this._free.push(new F(i.x,i.y+s,i.width,i.height-s))):(i.width>t&&this._free.push(new F(i.x+t,i.y,i.width-t,i.height)),i.height>s&&this._free.push(new F(i.x,i.y+s,t,i.height-s))),new F(i.x,i.y,t,s))}release(t){for(let s=0;s<this._free.length;++s){const i=this._free[s];if(i.y===t.y&&i.height===t.height&&i.x+i.width===t.x)i.width+=t.width;else if(i.x===t.x&&i.width===t.width&&i.y+i.height===t.y)i.height+=t.height;else if(t.y===i.y&&t.height===i.height&&t.x+t.width===i.x)i.x=t.x,i.width+=t.width;else{if(t.x!==i.x||t.width!==i.width||t.y+t.height!==i.y)continue;i.y=t.y,i.height+=t.height}this._free.splice(s,1),this.release(t)}this._free.push(t)}}class X{constructor(t,s,i){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=t,this.height=s,this._glyphSource=i,this._binPack=new E(t-4,s-4),this._glyphData.push(new Uint8Array(t*s)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(t,s){const i=[],e=this._glyphSource,h=new Set;for(const t of s){const s=Math.floor(.00390625*t);h.add(s)}const n=[];return h.forEach((s=>{if(s<=256){const i=t+s;if(this._rangePromises.has(i))n.push(this._rangePromises.get(i));else{const h=e.getRange(t,s).then((()=>{this._rangePromises.delete(i)}),(()=>{this._rangePromises.delete(i)}));this._rangePromises.set(i,h),n.push(h)}}})),Promise.all(n).then((()=>{let h=this._glyphIndex[t];h||(h={},this._glyphIndex[t]=h);for(const n of s){const s=h[n];if(s){i[n]={sdf:!0,rect:s.rect,metrics:s.metrics,page:s.page,code:n};continue}const r=e.getGlyph(t,n);if(!r||!r.metrics)continue;const o=r.metrics;let a;if(0===o.width)a=new F(0,0,0,0);else{const t=3,s=o.width+2*t,i=o.height+2*t;let e=s%4?4-s%4:4,h=i%4?4-i%4:4;1===e&&(e=5),1===h&&(h=5),a=this._binPack.allocate(s+e,i+h),a.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new E(this.width-4,this.height-4),a=this._binPack.allocate(s+e,i+h));const n=this._glyphData[this._currentPage],c=r.bitmap;let l,f;if(c)for(let t=0;t<i;t++){l=s*t,f=this.width*(a.y+t+1)+a.x;for(let t=0;t<s;t++)n[f+t+1]=c[l+t]}}h[n]={rect:a,metrics:o,tileIDs:null,page:this._currentPage},i[n]={sdf:!0,rect:a,metrics:o,page:this._currentPage,code:n},this._dirties[this._currentPage]=!0}return i}))}removeGlyphs(t){for(const s in this._glyphIndex){const i=this._glyphIndex[s];if(!i)continue;let e;for(const s in i)if(e=i[s],e.tileIDs.delete(t),0===e.tileIDs.size){const t=this._glyphData[e.page],h=e.rect;let n,r;for(let s=0;s<h.height;s++)for(n=this.width*(h.y+s)+h.x,r=0;r<h.width;r++)t[n+r]=0;delete i[s],this._dirties[e.page]=!0}}}bind(t,s,i,e=0){this._textures[i]||(this._textures[i]=new O(t,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));const h=this._textures[i];h.setSamplingMode(s),this._dirties[i]&&h.setData(this._glyphData[i]),t.bindTexture(h,e),this._dirties[i]=!1}dispose(){this._binPack=null;for(const t of this._textures)t&&t.dispose();this._textures.length=0}}class Y{constructor(t){if(this._metrics=[],this._bitmaps=[],t)for(;t.next();)switch(t.tag()){case 1:{const s=t.getMessage();for(;s.next();)switch(s.tag()){case 3:{const t=s.getMessage();let i,e,h,n,r,o,a;for(;t.next();)switch(t.tag()){case 1:i=t.getUInt32();break;case 2:e=t.getBytes();break;case 3:h=t.getUInt32();break;case 4:n=t.getUInt32();break;case 5:r=t.getSInt32();break;case 6:o=t.getSInt32();break;case 7:a=t.getUInt32();break;default:t.skip()}t.release(),i&&(this._metrics[i]={width:h,height:n,left:r,top:o,advance:a},this._bitmaps[i]=e);break}default:s.skip()}s.release();break}default:t.skip()}}getMetrics(t){return this._metrics[t]}getBitmap(t){return this._bitmaps[t]}}class Z{constructor(){this._ranges=[]}getRange(t){return this._ranges[t]}addRange(t,s){this._ranges[t]=s}}class tt{constructor(t){this._glyphInfo={},this._baseURL=t}getRange(i,e){const h=this._getFontStack(i);if(h.getRange(e))return Promise.resolve();const n=256*e,r=n+255,o=this._baseURL.replace("{fontstack}",i).replace("{range}",n+"-"+r);return t(o,{responseType:"array-buffer"}).then((t=>{h.addRange(e,new Y(new s(new Uint8Array(t.data),new DataView(t.data))))})).catch((()=>{h.addRange(e,new Y)}))}getGlyph(t,s){const i=this._getFontStack(t);if(!i)return;const e=Math.floor(s/256);if(e>256)return;const h=i.getRange(e);return h?{metrics:h.getMetrics(s),bitmap:h.getBitmap(s)}:void 0}_getFontStack(t){let s=this._glyphInfo[t];return s||(s=this._glyphInfo[t]=new Z),s}}class st{constructor(t,s,i=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(t<=0||s<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=t,this._pageHeight=s,i>0&&(this._maxItemSize=i),this._binPack=new E(t-4,s-4)}dispose(){this._binPack=null,this._mosaicRects={};for(const t of this._textures)t&&t.dispose();this._textures.length=0}getWidth(t){return t>=this._size.length?-1:this._size[t][0]}getHeight(t){return t>=this._size.length?-1:this._size[t][1]}getPageSize(t){return t>=this._size.length?null:this._size[t]}setSpriteSource(t){if(this.dispose(),this.pixelRatio=t.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new E(this._pageWidth-4,this._pageHeight-4);const t=Math.floor(this._pageWidth),s=Math.floor(this._pageHeight),i=new Uint32Array(t*s);this._mosaicsData[0]=i,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=t}getSpriteItem(t,s=!1){let i,e,h=this._mosaicRects[t];if(h)return h;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;if(t&&t.startsWith("dasharray-")?([i,e]=this._rasterizeDash(t),s=!0):i=this._sprites.getSpriteInfo(t),!i||!i.width||!i.height||i.width<0||i.height<0)return null;const n=i.width,r=i.height,[o,a,c]=this._allocateImage(n,r);return o.width<=0?null:(this._copy(o,i,a,c,s,e),h={rect:o,width:n,height:r,sdf:i.sdf,simplePattern:!1,pixelRatio:i.pixelRatio,page:a},this._mosaicRects[t]=h,h)}getSpriteItems(t){const s={};for(const i of t)s[i.name]=this.getSpriteItem(i.name,i.repeat);return s}getMosaicItemPosition(t,s){const i=this.getSpriteItem(t,s),e=i&&i.rect;return e?(e.width=i.width,e.height=i.height,{tl:[e.x+2,e.y+2],br:[e.x+2+i.width,e.y+2+i.height],page:i.page}):null}bind(t,s,i=0,e=0){this._textures[i]||(this._textures[i]=new O(t,{pixelFormat:6408,dataType:5121,wrapMode:33071,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));const h=this._textures[i];h.setSamplingMode(s),this._dirties[i]&&h.setData(new Uint8Array(this._mosaicsData[i].buffer)),t.bindTexture(h,e),this._dirties[i]=!1}static _copyBits(t,s,i,e,h,n,r,o,a,c,l){let f=e*s+i,u=o*n+r;if(l){u-=n;for(let r=-1;r<=c;r++,f=((r+c)%c+e)*s+i,u+=n)for(let s=-1;s<=a;s++)h[u+s]=t[f+(s+a)%a]}else for(let i=0;i<c;i++){for(let s=0;s<a;s++)h[u+s]=t[f+s];f+=s,u+=n}}_copy(t,s,i,e,h,n){if(!this._sprites||"loaded"!==this._sprites.loadStatus||i>=this._mosaicsData.length)return;const r=new Uint32Array(n?n.buffer:this._sprites.image.buffer),o=this._mosaicsData[i];o&&r||console.error("Source or target images are uninitialized!"),st._copyBits(r,n?s.width:this._sprites.width,s.x,s.y,o,e[0],t.x+2,t.y+2,s.width,s.height,h),this._dirties[i]=!0}_allocateImage(t,s){t+=2,s+=2;const i=Math.max(t,s);if(this._maxItemSize&&this._maxItemSize<i){const i=new F(0,0,t,s);return this._mosaicsData.push(new Uint32Array(t*s)),this._dirties.push(!0),this._size.push([t,s]),this._textures.push(void 0),[i,this._mosaicsData.length-1,[t,s]]}let e=t%4?4-t%4:4,h=s%4?4-s%4:4;1===e&&(e=5),1===h&&(h=5);const n=this._binPack.allocate(t+e,s+h);return n.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new E(this._pageWidth-4,this._pageHeight-4),this._allocateImage(t,s)):[n,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(t){const s=t.match(/\[(.*?)\]/);if(!s)return null;const i=s[1].split(",").map(Number),e=t.slice(t.lastIndexOf("-")+1),[h,n,r]=z.rasterizeDash(i,e);return[{x:0,y:0,width:n,height:r,sdf:!0,pixelRatio:1},new Uint8Array(h.buffer)]}}function it(t,s,i,e,h,n){t.fillStyle=s,t.fillRect(i,e,h,n)}function et(t,s,i,e,h,n){t.strokeStyle=s,t.strokeRect(i,e,h,n)}function ht(t,s){const i=window.COLLISION_XRAY;for(let e=0;e<s.length;++e){const h=!s[e].unique.show;if(i||!h)for(const n of s[e].colliders){if(!n.enabled)continue;const r=!s[e].unique.parts[n.partIndex].show;if(!i&&r)continue;const o=n.xScreen,a=n.yScreen,c=n.dxScreen,l=n.dyScreen;t.globalAlpha=h||r?.2:1,it(t,"green",o-1,a-1,3,3),et(t,"red",o+c,a+l,n.width,n.height),it(t,"blue",o+c-1,a+l-1,3,3),t.globalAlpha=1}}}class nt{constructor(t,s,i){this._layer=t,this._styleRepository=s,this.devicePixelRatio=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null}destroy(){this._connection&&(this._connection.close(),this._connection=null),this._styleRepository=null,this._layer=null,this._spriteMosaic&&(this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic=null)}get spriteMosaic(){return this._spriteSourcePromise.then((()=>this._spriteMosaic))}get glyphMosaic(){return this._glyphMosaic}async start(t){this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,t),this._spriteSourcePromise.then((t=>{this._spriteMosaic=new st(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}));const s=new tt(this._styleRepository.glyphs);this._glyphMosaic=new X(1024,1024,s),this._broadcastPromise=i("WorkerTileHandler",{client:this,schedule:t.schedule,signal:t.signal}).then((s=>(this._connection=s,Promise.all(this._connection.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,vectorTileLayerMaxBuffers:e("vectortilelayer-max-buffers")},t)))))}async updateStyle(t){return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",t)),this._broadcastPromise}async setStyle(t,s){await this._broadcastPromise,this._styleRepository=t,this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,null),this._spriteSourcePromise.then((t=>{this._spriteMosaic=new st(1024,1024,250),this._spriteMosaic.setSpriteSource(t)}));const i=new tt(t.glyphs);return this._glyphMosaic=new X(1024,1024,i),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:s,vectorTileLayerMaxBuffers:e("vectortilelayer-max-buffers")})),this._broadcastPromise}fetchTileData(t,s){return this._getRefKeys(t,s).then((t=>{const i=this._layer.sourceNameToSource,e=[];for(const t in i)e.push(t);return this._getSourcesData(e,t,s)}))}parseTileData(t,s){const i=t&&t.data;if(!i)return Promise.resolve(null);const{sourceName2DataAndRefKey:e,transferList:h}=i;return 0===Object.keys(e).length?Promise.resolve(null):this._broadcastPromise.then((()=>this._connection.getAvailableClient().then((i=>i.invoke("createTileAndParse",{key:t.key.id,sourceName2DataAndRefKey:e,styleLayerUIDs:t.styleLayerUIDs},{...s,transferList:h}).then((t=>({tileData:t})))))))}async getSprites(t){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(t)}getGlyphs(t){return this._glyphMosaic.getGlyphItems(t.font,t.codePoints)}perfReport({key:t,milliseconds:s}){!function(t,s){if(!window.PERFORMANCE_RECORDING_STORAGE)return;const i=window.PERFORMANCE_RECORDING_STORAGE;i.perf=i.perf||{};const e=i.perf;e[t]=e[t]||{start:null,time:0,min:void 0,max:void 0,samples:[],unit:"ms"},e[t].time+=s,e[t].samples.push(s),(null==e[t].min||s<e[t].min)&&(e[t].min=s),(null==e[t].max||s>e[t].max)&&(e[t].max=s)}(t,s)}async _getTilePayload(t,s,i){const e=h.pool.acquire(t.id),r=this._layer.sourceNameToSource[s].getSourceTileUrl(e.level,e.row,e.col);h.pool.release(e);try{return{protobuff:await this.request(r,i),sourceName:s}}catch(t){if(n(t))throw t;return{protobuff:null,sourceName:s}}}request(s,i){return t(s,{responseType:"array-buffer",...i}).then((({data:t})=>t))}_getRefKeys(t,s){const i=this._layer.sourceNameToSource,e=new Array;for(const h in i){const n=i[h].getRefKey(t,s);e.push(n)}return r(e)}_getSourcesData(t,s,i){const e=[];for(let h=0;h<s.length;h++)if(null==s[h].value||null==t[h])e.push(null);else{const n=this._getTilePayload(s[h].value,t[h],i);e.push(n)}return r(e).then((t=>{const i={},e=[];for(let h=0;h<t.length;h++)t[h].value&&t[h].value&&t[h].value.protobuff&&t[h].value.protobuff.byteLength>0&&(i[t[h].value.sourceName]={refKey:s[h].value.id,protobuff:t[h].value.protobuff},e.push(t[h].value.protobuff));return{sourceName2DataAndRefKey:i,transferList:e}}))}}const rt=(t,s)=>t+1/(1<<2*s);class ot{constructor(t,s){this._tiles=new Map,this._tileCache=new o(40,(t=>t.dispose())),this._viewSize=[0,0],this._visibleTiles=new Map,this.acquireTile=t.acquireTile,this.releaseTile=t.releaseTile,this.tileInfoView=t.tileInfoView,this._container=s}destroy(){for(const[t,s]of this._tiles)s.dispose();this._tiles=null,this._tileCache.clear(),this._tileCache=null}update(t){this._updateCacheSize(t);const s=this.tileInfoView,i=s.getTileCoverage(t.state,0,"smallest"),{spans:e,lodInfo:n}=i,{level:r}=n,o=this._tiles,c=new Set,l=new Set;for(const{row:t,colFrom:s,colTo:i}of e)for(let e=s;e<=i;e++){const s=h.getId(r,t,n.normalizeCol(e),n.getWorldForColumn(e)),i=this._getOrAcquireTile(s);c.add(s),i.processed()?this._addToContainer(i):l.add(new h(s))}for(const[t,s]of o)s.isCoverage=c.has(t);for(const t of l)this._findPlaceholdersForMissingTiles(t,c);let f=!1;for(const[t,e]of o)e.neededForCoverage=c.has(t),e.neededForCoverage||e.isHoldingForFade&&s.intersects(i,e.key)&&c.add(t),e.isFading&&(f=!0);for(const[t,s]of this._tiles)c.has(t)||this._releaseTile(t);return a.pool.release(i),!f}clear(){this._tiles.clear(),this._tileCache.clear(),this._visibleTiles.clear()}clearCache(){this._tileCache.clear()}_findPlaceholdersForMissingTiles(t,s){const i=[];for(const[e,h]of this._tiles)this._addPlaceholderChild(i,h,t,s);const e=i.reduce(rt,0);Math.abs(1-e)<1e-6||this._addPlaceholderParent(t.id,s)}_addPlaceholderChild(t,s,i,e){s.key.level<=i.level||!s.hasData()||function(t,s){const i=s.level-t.level;return t.row===s.row>>i&&t.col===s.col>>i&&t.world===s.world}(i,s.key)&&(this._addToContainer(s),e.add(s.id),t.push(s.key.level-i.level))}_addPlaceholderParent(t,s){const i=this._tiles;let e=t;for(;;){if(e=at(e),!e||s.has(e))return;const t=i.get(e);if(t&&t.hasData())return this._addToContainer(t),void s.add(t.id)}}_getOrAcquireTile(t){let s=this._tiles.get(t);return s||(s=this._tileCache.pop(t),s||(s=this.acquireTile(new h(t))),this._tiles.set(t,s),s)}_releaseTile(t){const s=this._tiles.get(t);this.releaseTile(s),this._removeFromContainer(s),this._tiles.delete(t),s.hasData()?this._tileCache.put(t,s,1):s.dispose()}_addToContainer(t){let s;const i=[],e=this._container;if(e.contains(t))return;const h=this._visibleTiles;for(const[e,n]of h)this._canConnectDirectly(t,n)&&i.push(n),c(s)&&this._canConnectDirectly(n,t)&&(s=n);if(l(s)){for(const e of i)s.childrenTiles.delete(e),t.childrenTiles.add(e),e.parentTile=t;s.childrenTiles.add(t),t.parentTile=s}else for(const s of i)t.childrenTiles.add(s),s.parentTile=t;h.set(t.id,t),e.addChild(t)}_removeFromContainer(t){if(this._visibleTiles.delete(t.id),this._container.removeChild(t),l(t.parentTile)){t.parentTile.childrenTiles.delete(t);for(const s of t.childrenTiles)l(t.parentTile)&&t.parentTile.childrenTiles.add(s)}for(const s of t.childrenTiles)s.parentTile=t.parentTile;t.parentTile=null,t.childrenTiles.clear()}_canConnectDirectly(t,s){const i=t.key;let{level:e,row:h,col:n,world:r}=s.key;const o=this._visibleTiles;for(;e>0;){if(e--,h>>=1,n>>=1,i.level===e&&i.row===h&&i.col===n&&i.world===r)return!0;if(o.has(`${e}/${h}/${n}/${r}`))return!1}return!1}_updateCacheSize(t){const s=t.state.size;if(s[0]===this._viewSize[0]&&s[1]===this._viewSize[1])return;const i=Math.ceil(s[0]/512)+1,e=Math.ceil(s[1]/512)+1;this._viewSize[0]=s[0],this._viewSize[1]=s[1],this._tileCache.maxSize=5*i*e}}function at(t){const[s,i,e,h]=t.split("/"),n=parseInt(s,10);return 0===n?null:`${n-1}/${parseInt(i,10)>>1}/${parseInt(e,10)>>1}/${parseInt(h,10)}`}class ct{constructor(t){this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=t}}class lt{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}}function ft(t,s,i,e,h,n){const r=i-h;if(r>=0)return(s>>r)+(e-(n<<r))*(t>>r);const o=-r;return s-(n-(e<<o))*(t>>o)<<o}class ut{constructor(t,s,i){this._rows=Math.ceil(s/i),this._columns=Math.ceil(t/i),this._cellSize=i,this.cells=new Array(this._rows);for(let t=0;t<this._rows;t++){this.cells[t]=new Array(this._columns);for(let s=0;s<this._columns;s++)this.cells[t][s]=[]}}getCell(t,s){const i=Math.min(Math.max(Math.floor(s/this._cellSize),0),this._rows-1),e=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._columns-1);return this.cells[i]&&this.cells[i][e]||null}getCellSpan(t,s,i,e){return[Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(i/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function dt(t,s,i,e,h){const n=t.layerData.get(h);if(3===n.type){for(const s of e){const e=s.unique;let h;if(s.selectedForRendering){const s=e.parts[0],n=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*n)|r<<7:r?255:0;h=o<<24|o<<16|o<<8|o}else h=0;for(const[t,i]of s.iconVertexRanges)for(let s=t;s<t+i;s+=4)n.iconOpacity[s/4]=h;if(s.selectedForRendering){const s=e.parts[1],n=s.startOpacity,r=s.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===r;const o=i?Math.floor(127*n)|r<<7:r?255:0;h=o<<24|o<<16|o<<8|o}else h=0;for(const[t,i]of s.textVertexRanges)for(let s=t;s<t+i;s+=4)n.textOpacity[s/4]=h}n.lastOpacityUpdate=s,n.opacityChanged=!0}}class pt{constructor(t,s){this.layerUIDs=[],this.isDestroyed=!1,this.data=t,this.memoryUsed=t.byteLength;let i=1;const e=new Uint32Array(t);this.layerUIDs=[];const h=e[i++];for(let t=0;t<h;t++)this.layerUIDs[t]=e[i++];this.bufferDataOffset=i,s&&(this.layer=s.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return c(this.data)}get offset(){return this.bufferDataOffset}destroy(){this.isDestroyed||(this.doDestroy(),this.isDestroyed=!0)}prepareForRendering(t){c(this.data)||(this.doPrepareForRendering(t,this.data,this.bufferDataOffset),this.data=null)}}class yt extends pt{constructor(t,s){super(t,s),this.type=2,this.lineIndexStart=0,this.lineIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.lineIndexStart=i[e++],this.lineIndexCount=i[e++];const h=i[e++];if(h>0){const t=new Map;for(let s=0;s<h;s++){const s=i[e++],h=i[e++],n=i[e++];t.set(s,[h,n])}this.patternMap=t}this.bufferDataOffset=e}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){l(this.lineVertexArrayObject)&&this.lineVertexArrayObject.dispose(),l(this.lineVertexBuffer)&&this.lineVertexBuffer.dispose(),l(this.lineIndexBuffer)&&this.lineIndexBuffer.dispose(),this.lineVertexArrayObject=null,this.lineVertexBuffer=null,this.lineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++];this.lineVertexBuffer=C.createVertex(t,35044,new Int32Array(h.buffer,4*i,n)),i+=n;const r=e[i++];this.lineIndexBuffer=C.createIndex(t,35044,new Uint32Array(e.buffer,4*i,r)),i+=r;const o=this.layer.lineMaterial;this.lineVertexArrayObject=new L(t,o.getAttributeLocations(),o.getLayoutInfo(),{geometry:this.lineVertexBuffer},this.lineIndexBuffer)}}class wt extends pt{constructor(t,s){super(t,s),this.type=1,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.fillIndexStart=i[e++],this.fillIndexCount=i[e++],this.outlineIndexStart=i[e++],this.outlineIndexCount=i[e++];const h=i[e++];if(h>0){const t=new Map;for(let s=0;s<h;s++){const s=i[e++],h=i[e++],n=i[e++];t.set(s,[h,n])}this.patternMap=t}this.bufferDataOffset=e}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){l(this.fillVertexArrayObject)&&this.fillVertexArrayObject.dispose(),l(this.fillVertexBuffer)&&this.fillVertexBuffer.dispose(),l(this.fillIndexBuffer)&&this.fillIndexBuffer.dispose(),this.fillVertexArrayObject=null,this.fillVertexBuffer=null,this.fillIndexBuffer=null,l(this.outlineVertexArrayObject)&&this.outlineVertexArrayObject.dispose(),l(this.outlineVertexBuffer)&&this.outlineVertexBuffer.dispose(),l(this.outlineIndexBuffer)&&this.outlineIndexBuffer.dispose(),this.outlineVertexArrayObject=null,this.outlineVertexBuffer=null,this.outlineIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++];this.fillVertexBuffer=C.createVertex(t,35044,new Int32Array(h.buffer,4*i,n)),i+=n;const r=e[i++];this.fillIndexBuffer=C.createIndex(t,35044,new Uint32Array(e.buffer,4*i,r)),i+=r;const o=e[i++];this.outlineVertexBuffer=C.createVertex(t,35044,new Int32Array(h.buffer,4*i,o)),i+=o;const a=e[i++];this.outlineIndexBuffer=C.createIndex(t,35044,new Uint32Array(e.buffer,4*i,a)),i+=a;const c=this.layer,l=c.fillMaterial,f=c.outlineMaterial;this.fillVertexArrayObject=new L(t,l.getAttributeLocations(),l.getLayoutInfo(),{geometry:this.fillVertexBuffer},this.fillIndexBuffer),this.outlineVertexArrayObject=new L(t,f.getAttributeLocations(),f.getLayoutInfo(),{geometry:this.outlineVertexBuffer},this.outlineIndexBuffer)}}class mt extends pt{constructor(t,s,i){super(t,s),this.type=3,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const e=new Uint32Array(t),h=new Int32Array(t),n=new Float32Array(t);let r=this.bufferDataOffset;this.isIconSDF=!!e[r++];const o=e[r++];for(let t=0;t<o;t++){const t=e[r++],s=e[r++],i=e[r++];this.iconPerPageElementsMap.set(t,[s,i])}const a=e[r++];for(let t=0;t<a;t++){const t=e[r++],s=e[r++],i=e[r++];this.glyphPerPageElementsMap.set(t,[s,i])}const c=e[r++],l=e[r++];this.iconOpacity=new Int32Array(c),this.textOpacity=new Int32Array(l),r=function(t,s,i,e,h,n){const r=s[e++];for(let o=0;o<r;o++){const r=new ct(n);r.xTile=s[e++],r.yTile=s[e++],r.hash=s[e++],r.priority=s[e++];const o=s[e++];for(let t=0;t<o;t++){const t=s[e++],h=s[e++],n=s[e++],o=s[e++],a=!!s[e++],c=s[e++],l=i[e++],f=i[e++],u=s[e++],d=s[e++];r.colliders.push({xTile:t,yTile:h,dxPixels:n,dyPixels:o,hard:a,partIndex:c,width:u,height:d,minLod:l,maxLod:f})}const a=t[e++];for(let s=0;s<a;s++)r.textVertexRanges.push([t[e++],t[e++]]);const c=t[e++];for(let s=0;s<c;s++)r.iconVertexRanges.push([t[e++],t[e++]]);h.push(r)}return e}(e,h,n,r,this.symbols,i),this.bufferDataOffset=r}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let t=0;for(const[s,i]of this.iconPerPageElementsMap)t+=i[1];for(const[s,i]of this.glyphPerPageElementsMap)t+=i[1];return t/3}doDestroy(){l(this.iconVertexArrayObject)&&this.iconVertexArrayObject.dispose(),l(this.iconVertexBuffer)&&this.iconVertexBuffer.dispose(),l(this.iconOpacityBuffer)&&this.iconOpacityBuffer.dispose(),l(this.iconIndexBuffer)&&this.iconIndexBuffer.dispose(),this.iconVertexArrayObject=null,this.iconVertexBuffer=null,this.iconOpacityBuffer=null,this.iconIndexBuffer=null,l(this.textVertexArrayObject)&&this.textVertexArrayObject.dispose(),l(this.textVertexBuffer)&&this.textVertexBuffer.dispose(),l(this.textOpacityBuffer)&&this.textOpacityBuffer.dispose(),l(this.textIndexBuffer)&&this.textIndexBuffer.dispose(),this.textVertexArrayObject=null,this.textVertexBuffer=null,this.textOpacityBuffer=null,this.textIndexBuffer=null,this.memoryUsed=0}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const t=f(this.iconOpacity),s=f(this.iconOpacityBuffer);t.length>0&&t.byteLength===s.size&&s.setSubData(t);const i=f(this.textOpacity),e=f(this.textOpacityBuffer);i.length>0&&i.byteLength===e.size&&e.setSubData(i)}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++];this.iconVertexBuffer=C.createVertex(t,35044,new Int32Array(h.buffer,4*i,n)),i+=n;const r=e[i++];this.iconIndexBuffer=C.createIndex(t,35044,new Uint32Array(e.buffer,4*i,r)),i+=r;const o=e[i++];this.textVertexBuffer=C.createVertex(t,35044,new Int32Array(h.buffer,4*i,o)),i+=o;const a=e[i++];this.textIndexBuffer=C.createIndex(t,35044,new Uint32Array(e.buffer,4*i,a)),i+=a,this.iconOpacityBuffer=C.createVertex(t,35044,f(this.iconOpacity).buffer),this.textOpacityBuffer=C.createVertex(t,35044,f(this.textOpacity).buffer);const c=this.layer,l=c.iconMaterial,u=c.textMaterial;this.iconVertexArrayObject=new L(t,l.getAttributeLocations(),l.getLayoutInfo(),{geometry:this.iconVertexBuffer,opacity:this.iconOpacityBuffer},this.iconIndexBuffer),this.textVertexArrayObject=new L(t,u.getAttributeLocations(),u.getLayoutInfo(),{geometry:this.textVertexBuffer,opacity:this.textOpacityBuffer},this.textIndexBuffer)}}class gt extends pt{constructor(t,s){super(t,s),this.type=4,this.circleIndexStart=0,this.circleIndexCount=0;const i=new Uint32Array(t);let e=this.bufferDataOffset;this.circleIndexStart=i[e++],this.circleIndexCount=i[e++],this.bufferDataOffset=e}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){l(this.circleVertexArrayObject)&&this.circleVertexArrayObject.dispose(),l(this.circleVertexBuffer)&&this.circleVertexBuffer.dispose(),l(this.circleIndexBuffer)&&this.circleIndexBuffer.dispose(),this.circleVertexArrayObject=null,this.circleVertexBuffer=null,this.circleIndexBuffer=null,this.memoryUsed=0}doPrepareForRendering(t,s,i){const e=new Uint32Array(s),h=new Int32Array(e.buffer),n=e[i++];this.circleVertexBuffer=C.createVertex(t,35044,new Int32Array(h.buffer,4*i,n)),i+=n;const r=e[i++];this.circleIndexBuffer=C.createIndex(t,35044,new Uint32Array(e.buffer,4*i,r)),i+=r;const o=this.layer.circleMaterial;this.circleVertexArrayObject=new L(t,o.getAttributeLocations(),o.getLayoutInfo(),{geometry:this.circleVertexBuffer},this.circleIndexBuffer)}}class bt extends N{constructor(t,s,i,e,h,n,r=null){super(t,s,i,e,h,4096,4096),this._memCache=r,this.type="vector-tile",this._referenced=0,this._hasSymbolBuckets=!1,this._memoryUsedByLayerData=0,this.layerData=new Map,this.layerCount=0,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.invalidating=!1,this.parentTile=null,this.childrenTiles=new Set,this._processed=!1,this._referenced=1,this.styleRepository=n,this.id=t.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<q}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<q)}get wasRequested(){return"errored"===this.status||"loaded"===this.status||"reloading"===this.status}setData(t){this.changeDataImpl(t),this.requestRender(),this.ready(),this.invalidating=!1,this._processed=!0}deleteLayerData(t){let s=!1;for(const i of t)if(this.layerData.has(i)){const t=this.layerData.get(i);this._memoryUsedByLayerData-=t.memoryUsed,3===t.type&&this.symbols.has(i)&&(this.symbols.delete(i),s=!0),t.destroy(),this.layerData.delete(i),this.layerCount--}l(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData),s&&this.emit("symbols-changed"),this.requestRender()}processed(){return this._processed}hasData(){return this.layerCount>0}dispose(){"unloaded"!==this.status&&(Mt.delete(this),bt._destroyRenderBuckets(this.layerData),this.layerData=null,this.layerCount=0,this._memoryUsedByLayerData=0,this.destroy(),this.status="unloaded")}release(){return 0==--this._referenced&&(this.dispose(),this.stage=null,!0)}retain(){++this._referenced}get referenced(){return this._referenced}get memoryUsage(){return(this._memoryUsedByLayerData+256)/(this._referenced||1)}changeDataImpl(t){let s=!1;if(t){const i=this._createRenderBuckets(t);for(const[t,e]of i){if(this.layerData.has(t)){const s=this.layerData.get(t);this._memoryUsedByLayerData-=e.memoryUsed,s.destroy(),this.layerData.delete(t),this.layerCount--}3===e.type&&(this.symbols.set(t,e.symbols),s=!0),this._memoryUsedByLayerData+=e.memoryUsed,this.layerData.set(t,e),this.layerCount++}l(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData)}this._hasSymbolBuckets=!1;for(const[t,s]of this.layerData)3===s.type&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed")}attachWithContext(t){this.stage={context:t,trashDisplayObject(t){t.processDetach()},untrashDisplayObject:()=>!1}}setTransform(t,s){super.setTransform(t,s);const i=s/(t.resolution*t.pixelRatio),e=this.width/this.rangeX*i,h=this.height/this.rangeY*i,n=[0,0];t.toScreen(n,[this.x,this.y]);const r=this.transforms.tileUnitsToPixels;u(r),d(r,r,n),p(r,r,Math.PI*t.rotation/180),y(r,r,[e,h,1])}_createTransforms(){return{dvs:w(),tileMat3:w(),tileUnitsToPixels:w()}}static _destroyRenderBuckets(t){if(!t)return;const s=new Set;t.forEach((t=>{s.has(t)||(t.destroy(),s.add(t))})),t.clear()}_createRenderBuckets(t){const s=new Map,i=new Map;for(const e of t){const t=this._deserializeBucket(e,i);for(const i of t.layerUIDs)s.set(i,t)}return s}_deserializeBucket(t,s){let i=s.get(t);if(i)return i;switch(new Uint32Array(t)[0]){case 1:i=new wt(t,this.styleRepository);break;case 2:i=new yt(t,this.styleRepository);break;case 3:i=new mt(t,this.styleRepository,this);break;case 4:i=new gt(t,this.styleRepository)}return s.set(t,i),i}}const Mt=new Map;function vt(t,s,i,e,h,n){const{iconRotationAlignment:r,textRotationAlignment:o,iconTranslate:a,iconTranslateAnchor:c,textTranslate:l,textTranslateAnchor:f}=e;let u=0;for(const e of t.colliders){const[t,d]=0===e.partIndex?a:l,p=0===e.partIndex?c:f,y=e.minLod<=n&&n<=e.maxLod;u+=y?0:1,e.enabled=y,e.xScreen=e.xTile*h[0]+e.yTile*h[3]+h[6],e.yScreen=e.xTile*h[1]+e.yTile*h[4]+h[7],0===p?(e.xScreen+=i*t-s*d,e.yScreen+=s*t+i*d):(e.xScreen+=t,e.yScreen+=d),1===(0===e.partIndex?r:o)?(e.dxScreen=e.dxPixels,e.dyScreen=e.dyPixels):(e.dxScreen=i*(e.dxPixels+e.width/2)-s*(e.dyPixels+e.height/2)-e.width/2,e.dyScreen=s*(e.dxPixels+e.width/2)+i*(e.dyPixels+e.height/2)-e.height/2)}t.colliders.length>0&&u===t.colliders.length&&(t.unique.show=!1)}class At{constructor(t,s,i,e,h,n){this._symbols=t,this._styleRepository=e,this._zoom=h,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new ut(s,i,B),this._si=Math.sin(Math.PI*n/180),this._co=Math.cos(Math.PI*n/180);for(const s of t)for(const t of s.symbols)this._allNeededMatrices.has(t.tile)||this._allNeededMatrices.set(t.tile,m(t.tile.transforms.tileUnitsToPixels))}work(t){const s=this._gridIndex;function i(t){const i=t.xScreen+t.dxScreen,e=t.yScreen+t.dyScreen,h=i+t.width,n=e+t.height,[r,o,a,c]=s.getCellSpan(i,e,h,n);for(let t=o;t<=c;t++)for(let o=r;o<=a;o++){const r=s.cells[t][o];for(const t of r){const s=t.xScreen+t.dxScreen,r=t.yScreen+t.dyScreen,o=s+t.width,a=r+t.height;if(!(h<s||i>o||n<r||e>a))return!0}}return!1}const e=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const s=this._symbols[this._currentLayerCursor],h=this._getProperties(s.styleLayerUID);for(;this._currentSymbolCursor<s.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-e>t)return!1;const n=s.symbols[this._currentSymbolCursor];if(!n.unique.show)continue;vt(n,this._si,this._co,h,this._allNeededMatrices.get(n.tile),this._zoom);const r=n.unique;if(!r.show)continue;const{iconAllowOverlap:o,iconIgnorePlacement:a,textAllowOverlap:c,textIgnorePlacement:l}=h;for(const t of n.colliders){if(!t.enabled)continue;const s=r.parts[t.partIndex];s.show&&!(t.partIndex?c:o)&&i(t)&&(t.hard?r.show=!1:s.show=!1)}if(r.show)for(const t of n.colliders){if(!t.enabled)continue;if(t.partIndex?l:a)continue;if(!r.parts[t.partIndex].show)continue;const s=t.xScreen+t.dxScreen,i=t.yScreen+t.dyScreen,e=s+t.width,h=i+t.height,[n,o,c,f]=this._gridIndex.getCellSpan(s,i,e,h);for(let s=o;s<=f;s++)for(let i=n;i<=c;i++)this._gridIndex.cells[s][i].push(t)}}}return!0}_getProperties(t){const s=this._styleProps.get(t);if(s)return s;const i=this._zoom,e=this._styleRepository.getStyleLayerByUID(t),h=0!==e.getLayoutValue("symbol-placement",i);let n=e.getLayoutValue("icon-rotation-alignment",i);2===n&&(n=h?0:1);let r=e.getLayoutValue("text-rotation-alignment",i);2===r&&(r=h?0:1);const o=e.getPaintValue("icon-translate",i),a=e.getPaintValue("icon-translate-anchor",i),c=e.getPaintValue("text-translate",i),l=e.getPaintValue("text-translate-anchor",i),f={iconAllowOverlap:e.getLayoutValue("icon-allow-overlap",i),iconIgnorePlacement:e.getLayoutValue("icon-ignore-placement",i),textAllowOverlap:e.getLayoutValue("text-allow-overlap",i),textIgnorePlacement:e.getLayoutValue("text-ignore-placement",i),iconRotationAlignment:n,textRotationAlignment:r,iconTranslateAnchor:a,iconTranslate:o,textTranslateAnchor:l,textTranslate:c};return this._styleProps.set(t,f),f}}function Tt(t,s){if(t.priority-s.priority)return t.priority-s.priority;const i=t.tile.key,e=s.tile.key;return i.world-e.world?i.world-e.world:i.level-e.level?i.level-e.level:i.row-e.row?i.row-e.row:i.col-e.col?i.col-e.col:t.xTile-s.xTile?t.xTile-s.xTile:t.yTile-s.yTile}class xt{constructor(t,s,i,e,h,n){this._visibleTiles=t,this._symbolRepository=s,this._createCollisionJob=i,this._assignTileSymbolsOpacity=e,this._symbolLayerSorter=h,this._isLayerVisible=n,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}get running(){return this._running}setScreenSize(t,s){this._screenWidth===t&&this._screenHeight===s||this.restart(),this._screenWidth=t,this._screenHeight=s}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(t){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const s=performance.now();if(!this._selectionJob.work(t))return!1;if(this._selectionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const s=performance.now();if(!this._collisionJob.work(t))return!1;if(this._collisionJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const s=performance.now();if(!this._opacityJob.work(t))return!1;if(this._opacityJobCompleted=!0,0===(t=Math.max(0,t-(performance.now()-s))))return!1}return this._running=!1,!0}_createSelectionJob(){const t=this._symbolRepository.uniqueSymbols;for(let s=0;s<t.length;s++){const i=t[s];for(let t=0;t<i.uniqueSymbols.length;t++){const s=i.uniqueSymbols[t];for(const t of s.tileSymbols)t.selectedForRendering=!1}}const s=[];let i=0,e=0;const h=this._isLayerVisible,n=this._symbolLayerSorter;return{work:function(n){let r;const o=performance.now();for(;e<t.length;e++,i=0){const a=t[e],c=a.styleLayerUID;if(!h(c)){s[e]||(s[e]={styleLayerUID:c,symbols:[]});continue}s[e]=s[e]||{styleLayerUID:c,symbols:[]};const l=s[e];for(;i<a.uniqueSymbols.length;i++){if(r=a.uniqueSymbols[i],i%100==99&&performance.now()-o>n)return!1;let t=null,s=!1,e=!1;for(const i of r.tileSymbols)if(!e||!s){const h=i.tile;(!t||h.isCoverage||h.neededForCoverage&&!s)&&(t=i,(h.neededForCoverage||h.isCoverage)&&(e=!0),h.isCoverage&&(s=!0))}if(t.selectedForRendering=!0,e){l.symbols.push(t),r.show=!0;for(const t of r.parts)t.show=!0}else r.show=!1}}for(const t of s)t.symbols.sort(Tt);return!0},get sortedSymbols(){return s.sort(n)}}}_createOpacityJob(){const t=this._assignTileSymbolsOpacity,s=this._visibleTiles;let i=0;function e(s,i){const h=s.symbols;for(const[t,s]of h)_t(s,i);t(s,i);for(const t of s.childrenTiles)e(t,i)}return{work(t){const h=performance.now();for(;i<s.length;i++){if(performance.now()-h>t)return!1;const n=s[i];l(n.parentTile)||e(n,performance.now())}return!0}}}}function _t(t,s){for(const i of t){const t=i.unique;for(const i of t.parts)i.startOpacity+=(s-i.startTime)/q*(i.targetOpacity>.5?1:-1),i.startOpacity=Math.min(Math.max(i.startOpacity,0),1),i.startTime=s,i.targetOpacity=t.show&&i.show?1:0}}class St{constructor(t,s,i){this.tileCoordRange=t,this._visibleTiles=s,this._createUnique=i,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return c(this._uniqueSymbolLayerArray)&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}add(t,s){this._uniqueSymbolLayerArray=null;let i=this._tiles.get(t.id);i||(i={symbols:new Map},this._tiles.set(t.id,i));const e=new Map;if(s)for(const t of s)i.symbols.has(t)&&(e.set(t,i.symbols.get(t)),i.symbols.delete(t));else for(const[s,h]of t.layerData)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e);const h=t.symbols,n=new Map;for(const[t,s]of h){let e=s.length;if(e>=32){let h=this.tileCoordRange;do{h/=2,e/=4}while(e>8&&h>64);const r=new ut(this.tileCoordRange,this.tileCoordRange,h);n.set(t,{flat:s,index:r}),i.symbols.set(t,{flat:s,index:r});for(const t of s)r.getCell(t.xTile,t.yTile).push(t)}else n.set(t,{flat:s}),i.symbols.set(t,{flat:s})}this._addSymbols(t.key,h)}deleteStyleLayers(t){this._uniqueSymbolLayerArray=null;for(const[s,i]of this._tiles){const e=new Map;for(const s of t)i.symbols.has(s)&&(e.set(s,i.symbols.get(s)),i.symbols.delete(s));this._removeSymbols(e),0===i.symbols.size&&this._tiles.delete(s)}}removeTile(t){this._uniqueSymbolLayerArray=null;const s=this._tiles.get(t.id);if(!s)return;const i=new Map;for(const[e,h]of t.symbols)s.symbols.has(e)&&(i.set(e,s.symbols.get(e)),s.symbols.delete(e));this._removeSymbols(i),0===s.symbols.size&&this._tiles.delete(t.id)}_removeSymbols(t){for(const[s,{flat:i}]of t)for(const t of i){const i=t.unique,e=i.tileSymbols,h=e.length-1;for(let s=0;s<h;s++)if(e[s]===t){e[s]=e[h];break}if(e.length=h,0===h){const t=this._uniqueSymbolsReferences.get(s);t.delete(i),0===t.size&&this._uniqueSymbolsReferences.delete(s)}t.unique=null}}_addSymbols(t,s){if(0===s.size)return;const i=this._visibleTiles;for(const e of i)e.parentTile||e.key.world!==t.world||e.key.level===t.level&&!e.key.equals(t)||this._matchSymbols(e,t,s);for(const[t,i]of s)for(const s of i)if(c(s.unique)){const i=this._createUnique();s.unique=i,i.tileSymbols.push(s);let e=this._uniqueSymbolsReferences.get(t);e||(e=new Set,this._uniqueSymbolsReferences.set(t,e)),e.add(i)}}_matchSymbols(t,s,i){if(t.key.level>s.level){const i=t.key.level-s.level;if(t.key.row>>i!==s.row||t.key.col>>i!==s.col)return}if(s.level>t.key.level){const i=s.level-t.key.level;if(s.row>>i!==t.key.row||s.col>>i!==t.key.col)return}if(s.equals(t.key)){for(const e of t.childrenTiles)this._matchSymbols(e,s,i);return}const e=new Map;for(const[h,n]of i){const i=[];for(const e of n){const h=ft(this.tileCoordRange,e.xTile,s.level,s.col,t.key.level,t.key.col),n=ft(this.tileCoordRange,e.yTile,s.level,s.row,t.key.level,t.key.row);h>=0&&h<this.tileCoordRange&&n>=0&&n<this.tileCoordRange&&i.push({symbol:e,xTransformed:h,yTransformed:n})}const r=[],o=t.key.level<s.level?1:1<<t.key.level-s.level,a=this._tiles.get(t.id).symbols.get(h);if(a){const t=a.flat;for(const s of i){let i,e=!1;const h=s.xTransformed,n=s.yTransformed;i=l(a.index)?a.index.getCell(h,n):t;const c=s.symbol,f=c.hash;for(const t of i)if(f===t.hash&&Math.abs(h-t.xTile)<=o&&Math.abs(n-t.yTile)<=o){const s=t.unique;c.unique=s,s.tileSymbols.push(c),e=!0;break}e||r.push(c)}}r.length>0&&e.set(h,r)}for(const i of t.childrenTiles)this._matchSymbols(i,s,e)}_createUniqueSymbolLayerArray(){const t=this._uniqueSymbolsReferences,s=new Array(t.size);let i,e=0;for(const[h,n]of t){const t=new Array(n.size);i=0;for(const s of n)t[i++]=s;s[e]={styleLayerUID:h,uniqueSymbols:t},e++}return s}}const Ut=1e-6;class It extends g{constructor(t,s){super(),this.styleRepository=t,this._tileToHandle=new Map,this._viewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._declutterViewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._completed=!1,this._symbolRepository=new St(4096,s,(()=>new lt)),this._symbolDeclutterer=new xt(s,this._symbolRepository,((t,s,i)=>new At(t,s,i,this.styleRepository,this._zoom,this._viewState.rotation)),((t,s)=>{t.allSymbolsFadingOut=!0,t.lastOpacityUpdate=s,function(t,s){for(const[i,e]of t.symbols)dt(t,s,true,e,i)}(t,s),t.decluttered=!0,t.requestRender()}),((t,s)=>this.styleRepository.getStyleLayerByUID(t.styleLayerUID).z-this.styleRepository.getStyleLayerByUID(s.styleLayerUID).z),(t=>{const s=this.styleRepository.getStyleLayerByUID(t);if(this._zoom+Ut<s.minzoom||this._zoom-Ut>=s.maxzoom)return!1;const i=s.getLayoutProperty("visibility");return!i||1!==i.getValue()}))}addTile(t){t.decluttered=!1,this._tileToHandle.set(t,t.on("symbols-changed",(()=>{this._symbolRepository.add(t),this.restartDeclutter()}))),this._symbolRepository.add(t),this.restartDeclutter()}removeTile(t){const s=this._tileToHandle.get(t);s&&(this._symbolRepository.removeTile(t),this.restartDeclutter(),s.remove(),this._tileToHandle.delete(t))}update(t,s){return this._zoom=t,this._viewState={scale:s.scale,rotation:s.rotation,center:[s.center[0],s.center[1]],size:[s.size[0],s.size[1]]},this._continueDeclutter(),this._completed}restartDeclutter(){this._completed=!1,this._symbolDeclutterer.restart(),this._notifyUnstable()}clear(){this._completed=!1,this._symbolRepository=null,this._symbolDeclutterer.restart(),this._tileToHandle.forEach((t=>t.remove())),this._tileToHandle.clear()}get stale(){return this._zoom!==this._declutterZoom||this._viewState.size[0]!==this._declutterViewState.size[0]||this._viewState.size[1]!==this._declutterViewState.size[1]||this._viewState.scale!==this._declutterViewState.scale||this._viewState.rotation!==this._declutterViewState.rotation}deleteStyleLayers(t){this._symbolRepository.deleteStyleLayers(t)}_continueDeclutter(){this._completed&&!this.stale||(this._symbolDeclutterer.running||(this._declutterZoom=this._zoom,this._declutterViewState.center[0]=this._viewState.center[0],this._declutterViewState.center[1]=this._viewState.center[1],this._declutterViewState.rotation=this._viewState.rotation,this._declutterViewState.scale=this._viewState.scale,this._declutterViewState.size[0]=this._viewState.size[0],this._declutterViewState.size[1]=this._viewState.size[1],this._symbolDeclutterer.restart()),this._symbolDeclutterer.setScreenSize(this._viewState.size[0],this._viewState.size[1]),this._completed=this._symbolDeclutterer.continue(V),this._completed&&this._scheduleNotifyStable())}_scheduleNotifyStable(){l(this._stableNotificationHandle)&&clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=setTimeout((()=>{this._stableNotificationHandle=null,this.emit("fade-complete")}),1.5*q)}_notifyUnstable(){l(this._stableNotificationHandle)&&(clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=null),this.emit("fade-start")}}class Dt extends N{_createTransforms(){return{dvs:w(),tileMat3:w()}}}const kt=1e-6;function Pt(t,s){if(t){const i=t.getLayoutProperty("visibility");if(!i||1!==i.getValue()&&(void 0===t.minzoom||t.minzoom<s+kt)&&(void 0===t.maxzoom||t.maxzoom>=s-kt))return!0}return!1}class jt extends H{constructor(t){super(t),this._backgroundTiles=[],this._pointToCallbacks=new Map}destroy(){this.removeAllChildren(),this._spriteMosaic&&(this._spriteMosaic.dispose(),this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic.dispose(),this._glyphMosaic=null),l(this._symbolFader)&&(this._symbolFader.clear(),this._symbolFader=null),this._styleRepository=null,this._backgroundTiles=[],this._pointToCallbacks.clear()}setStyleResources(t,s,i){if(this._spriteMosaic=t,this._glyphMosaic=s,this._styleRepository=i,c(this._symbolFader)){const t=new It(this._styleRepository,this.children);t.on("fade-start",(()=>{this.emit("fade-start"),this.requestRender()})),t.on("fade-complete",(()=>{this.emit("fade-complete"),this.requestRender()})),this._symbolFader=t}f(this._symbolFader).styleRepository=i}deleteStyleLayers(t){l(this._symbolFader)&&this._symbolFader.deleteStyleLayers(t)}async hitTest(t,s){const i=[t,s],e=b();return this._pointToCallbacks.set(i,e),this.requestRender(),e.promise}enterTileInvalidation(){for(const t of this.children)t.invalidating=!0}createRenderParams(t){return{...super.createRenderParams(t),renderPass:null,styleLayer:null,styleLayerUID:-1,glyphMosaic:this._glyphMosaic,spriteMosaic:this._spriteMosaic,hasClipping:!!this._clippingInfos}}doRender(t){!this.visible||t.drawPhase!==$.MAP&&t.drawPhase!==$.DEBUG||void 0===this._spriteMosaic||super.doRender(t)}addChild(t){return super.addChild(t),l(this._symbolFader)?this._symbolFader.addTile(t):t.decluttered=!0,this.requestRender(),t}removeChild(t){return l(this._symbolFader)&&this._symbolFader.removeTile(t),this.requestRender(),super.removeChild(t)}renderChildren(t){const{drawPhase:s}=t;if(s!==$.DEBUG){if(this._doRender(t),this._pointToCallbacks.size>0){t.drawPhase=$.HITTEST;const i=t.painter.effects.hittest;i.bind(t),this._doRender(t),i.draw(t,this._pointToCallbacks),i.unbind(t),t.drawPhase=s}}else super.renderChildren(t)}removeAllChildren(){for(let t=0;t<this.children.length;t++){const s=this.children[t];l(this._symbolFader)&&this._symbolFader.removeTile(s),s.dispose()}super.removeAllChildren()}getStencilTarget(){return this.children.filter((t=>t.neededForCoverage&&t.hasData()))}restartDeclutter(){l(this._symbolFader)&&this._symbolFader.restartDeclutter()}_doRender(t){const{context:s}=t,i=this._styleRepository;if(!i)return;const e=i.layers;let h=!0;t.drawPhase===$.HITTEST&&(h=!1),i.backgroundBucketIds.length>0&&(t.renderPass="background",this._renderBackgroundLayers(t,i.backgroundBucketIds)),super.renderChildren(t),t.drawPhase===$.MAP&&this._fade(t.displayLevel,t.state);const n=this.children.filter((t=>t.visible&&t.hasData()));if(!n||0===n.length)return s.bindVAO(),s.setStencilTestEnabled(!0),void s.setBlendingEnabled(!0);for(const t of n)t.triangleCount=0;s.setStencilWriteMask(0),s.setColorMask(!0,!0,!0,!0),s.setStencilOp(7680,7680,7681),s.setStencilTestEnabled(!0),s.setBlendingEnabled(!1),s.setDepthTestEnabled(!0),s.setDepthWriteEnabled(!0),s.setDepthFunction(515),s.setClearDepth(1),s.clear(s.gl.DEPTH_BUFFER_BIT),t.renderPass="opaque";for(let s=e.length-1;s>=0;s--)this._renderStyleLayer(e[s],t,n);s.setDepthWriteEnabled(!1),s.setBlendingEnabled(h),s.setBlendFunctionSeparate(1,771,1,771),t.renderPass="translucent";for(let s=0;s<e.length;s++)this._renderStyleLayer(e[s],t,n);s.setDepthTestEnabled(!1),t.renderPass="symbol";for(let s=0;s<e.length;s++)this._renderStyleLayer(e[s],t,n);s.bindVAO(),s.setStencilTestEnabled(!0),s.setBlendingEnabled(!0)}_fade(t,s){l(this._symbolFader)&&(this._symbolFader.update(t,s)||this.requestRender())}_renderStyleLayer(t,s,i){const{painter:e,renderPass:h}=s;if(void 0===t)return;const n=t.getLayoutProperty("visibility");if(n&&1===n.getValue())return;let r;switch(t.type){case 0:return;case 1:if("opaque"!==h&&"translucent"!==s.renderPass)return;r="vtlFill";break;case 2:if("translucent"!==h)return;r="vtlLine";break;case 4:if("symbol"!==h)return;r="vtlCircle";break;case 3:if("symbol"!==h)return;r="vtlSymbol"}if(i=i.filter(3===t.type?t=>t.decluttered:t=>t.neededForCoverage),"vtlSymbol"!==r){const e=s.displayLevel;if(0===i.length||void 0!==t.minzoom&&t.minzoom>=e+kt||void 0!==t.maxzoom&&t.maxzoom<e-kt)return}const o=t.uid;s.styleLayerUID=o,s.styleLayer=t;for(const t of i)if(t.layerData.has(o)){e.renderObjects(s,i,r);break}}_renderBackgroundLayers(t,s){const{context:i,displayLevel:e,painter:n,state:r}=t,o=this._styleRepository;let c=!1;for(const t of s)if(0===o.getLayerById(t).type&&Pt(o.getLayerById(t),e)){c=!0;break}if(!c)return;const f=this._tileInfoView.getTileCoverage(t.state,0,"smallest"),{spans:u,lodInfo:d}=f,{level:p}=d,y=M(),w=[];if(this._renderPasses){const s=this._renderPasses[0];l(this._clippingInfos)&&(s.brushes[0].prepareState(t,this._clippingInfos[0]),s.brushes[0].drawMany(t,this._clippingInfos))}const m=this._backgroundTiles;let g,b=0;for(const{row:t,colFrom:s,colTo:i}of u)for(let e=s;e<=i;e++){if(b<m.length)g=m[b],g.key.set(p,t,d.normalizeCol(e),d.getWorldForColumn(e)),this._tileInfoView.getTileBounds(y,g.key,!1),g.x=y[0],g.y=y[3];else{const s=new h(p,t,d.normalizeCol(e),d.getWorldForColumn(e)),i=this._tileInfoView.getTileBounds(M(),s);g=new Dt(s,i[0],i[3],512,512,4096,4096),m.push(g)}g.setTransform(r,this._tileInfoView.getTileResolution(g.key)),w.push(g),b++}i.setStencilWriteMask(0),i.setColorMask(!0,!0,!0,!0),i.setStencilOp(7680,7680,7681),i.setStencilFunction(514,0,255);let v=!0;t.drawPhase===$.HITTEST&&(v=!1),i.setStencilTestEnabled(v);for(const i of s){const s=o.getLayerById(i);0===s.type&&Pt(s,e)&&(t.styleLayerUID=s.uid,t.styleLayer=s,n.renderObjects(t,w,"vtlBackground"))}a.pool.release(f)}}class Rt extends Q{constructor(t){super(),this.requestRender=this.requestRender.bind(this),this._layerView=t,this._canvas=document.createElement("canvas"),this._context=this._canvas.getContext("2d"),this._bitmap=new J(null,"standard",!1),this.addChild(this._bitmap)}doRender(t){const s=t.state,i=this._createCustomRenderParams(t),e=i.pixelRatio,h=this._canvas,n=this._bitmap;h.width=s.size[0]*e,h.height=s.size[1]*e,n.resolution=s.resolution,n.pixelRatio=e,n.x=s.viewpoint.targetGeometry.x-Math.abs(s.extent.xmax-s.extent.xmin)/2,n.y=s.viewpoint.targetGeometry.y+Math.abs(s.extent.ymax-s.extent.ymin)/2,this._layerView.render(i),n.source=h,n.rotation=s.rotation,super.doRender(t)}_createCustomRenderParams(t){const s=window.devicePixelRatio,i={...t.state,pixelRatio:s};return{...t,pixelRatio:s,context:this._context,state:i}}}class Ct extends v{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(t){const s=h.pool.acquire(t),i=0===s.level?null:h.getId(s.level-1,s.row>>1,s.col>>1,s.world);return h.pool.release(s),i}getTileCoverage(t,s,i){const e=super.getTileCoverage(t,s,i);if(!e)return e;const h=1<<e.lodInfo.level;return e.spans=e.spans.filter((t=>t.row>=0&&t.row<h)),e}scaleToLevel(t){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[t])return this._levelByScale[t];{const s=this._fullCacheLodInfos;if(t>s[0].scale)return s[0].level;let i,e;for(let h=0;h<s.length-1;h++)if(e=s[h+1],t>e.scale)return i=s[h],i.level+(i.scale-t)/(i.scale-e.scale);return s[s.length-1].level}}_initializeFullCacheLODs(t){let s;s=0===t[0].level?t.map((t=>({level:t.level,resolution:t.resolution,scale:t.scale}))):A.create({size:this.tileInfo.size[0],spatialReference:this.tileInfo.spatialReference}).lods.map((t=>({level:t.level,resolution:t.resolution,scale:t.scale})));for(let t=0;t<s.length;t++)this._levelByScale[s[t].scale]=s[t].level;this._fullCacheLodInfos=s}}const Lt=T.getLogger("esri.views.2d.layers.VectorTileLayerView2D");let Ot=class extends(K(W)){constructor(){super(...arguments),this._styleChanges=[],this._fetchQueue=null,this._parseQueue=null,this._isTileHandlerReady=!1,this.fading=!1}initialize(){const t=this.layer.tileInfo;if(!(t&&t.spatialReference).equals(this.view.spatialReference))return void this.addResolvingPromise(Promise.reject(new x("layerview:spatial-reference-incompatible","The spatial reference of this layer does not meet the requirements of the view",{layer:this.layer})));const{style:s,spriteUrl:i,glyphsUrl:e}=this.layer.currentStyleInfo;this._styleRepository=new G(s,{spriteUrl:i,glyphsUrl:e}),this._tileInfoView=new Ct(this.layer.tileInfo,this.layer.fullExtent),this._vectorTileContainer=new jt(this._tileInfoView),this._tileHandler=new nt(this.layer,this._styleRepository,window.devicePixelRatio||1),this.container.addChild(this._vectorTileContainer),this.handles.add([this._vectorTileContainer.on("fade-start",(()=>{this.fading=!0,this.notifyChange("updating"),this.requestUpdate()})),this._vectorTileContainer.on("fade-complete",(()=>{this._collisionBoxesDisplay&&this._collisionBoxesDisplay.requestRender(),this.fading=!1,this.notifyChange("updating"),this.requestUpdate()})),_(this.layer,"symbolCollisionBoxesVisible",(t=>{t?(this._collisionBoxesDisplay=new Rt({render:t=>this._renderCollisionBoxes(t.context)}),this.container.addChild(this._collisionBoxesDisplay)):(this.container.removeChild(this._collisionBoxesDisplay),this._collisionBoxesDisplay=null)}))])}destroy(){var t;this._stop(),this.container.removeAllChildren(),this._vectorTileContainer&&(this._vectorTileContainer.destroy(),this._vectorTileContainer=null),null==(t=this._tileHandler)||t.destroy(),this._tileHandler=null}async hitTest(t,s){if(this.suspended||!this._tileHandlerPromise)return null;await this._tileHandlerPromise;const i=await this._vectorTileContainer.hitTest(t,s);if(!i||0===i.length)return null;const e=i[0]-1,h=this._styleRepository,n=h.getStyleLayerByUID(e);if(!n)return null;const r=h.getStyleLayerIndex(n.id),o=new S({attributes:{layerId:r,layerName:n.id,layerUID:e}});return o.layer=this.layer,o.sourceLayer=this.layer,o}update(t){if(this._tileHandlerPromise&&this._isTileHandlerReady)return t.pixelRatio!==this._tileHandler.devicePixelRatio?(this._start(),void(this._tileHandler.devicePixelRatio=t.pixelRatio)):void(this._styleChanges.length>0?this._tileHandlerPromise=this._applyStyleChanges():(this._fetchQueue.pause(),this._parseQueue.pause(),this._fetchQueue.state=t.state,this._parseQueue.state=t.state,this._tileManager.update(t)||this.requestUpdate(),this._parseQueue.resume(),this._fetchQueue.resume()))}attach(){this._start(),this.handles.add([this.layer.on("paint-change",(t=>{if(t.isDataDriven)this._styleChanges.push({type:0,data:t}),this.notifyChange("updating"),this.requestUpdate();else{const s=this._styleRepository,i=s.getLayerById(t.layer);if(!i)return;const e=3===i.type;s.setPaintProperties(t.layer,t.paint),e&&this._vectorTileContainer.restartDeclutter(),this._vectorTileContainer.requestRender()}})),this.layer.on("layout-change",(t=>{const s=this._styleRepository,i=s.getLayerById(t.layer);if(!i)return;const e=U(i.layout,t.layout);if(!c(e)){if(I(e,"visibility")&&1===function(t){if(c(t))return 0;switch(t.type){case"partial":return Object.keys(t.diff).length;case"complete":return Math.max(Object.keys(t.oldValue).length,Object.keys(t.newValue).length);case"collection":return Object.keys(t.added).length+Object.keys(t.changed).length+Object.keys(t.removed).length}}(e))return s.setLayoutProperties(t.layer,t.layout),3===i.type&&this._vectorTileContainer.restartDeclutter(),void this._vectorTileContainer.requestRender();this._styleChanges.push({type:1,data:t}),this.notifyChange("updating"),this.requestUpdate()}})),this.layer.on("style-layer-visibility-change",(t=>{const s=this._styleRepository,i=s.getLayerById(t.layer);i&&(s.setStyleLayerVisibility(t.layer,t.visibility),3===i.type&&this._vectorTileContainer.restartDeclutter(),this._vectorTileContainer.requestRender())})),this.layer.on("style-layer-change",(t=>{this._styleChanges.push({type:2,data:t}),this.notifyChange("updating"),this.requestUpdate()})),this.layer.on("delete-style-layer",(t=>{this._styleChanges.push({type:3,data:t}),this.notifyChange("updating"),this.requestUpdate()})),this.layer.on("load-style",(()=>this._loadStyle()))],this.declaredClass)}detach(){this._stop(),this.handles.remove(this.declaredClass)}moveStart(){this.requestUpdate()}viewChange(){this.requestUpdate()}moveEnd(){this._collisionBoxesDisplay&&this._vectorTileContainer.restartDeclutter(),this.requestUpdate()}canResume(){let t=super.canResume();const s=this.layer;if(t&&s.currentStyleInfo){const i=this.view.scale,e=s.currentStyleInfo;if(e&&e.layerDefinition){const s=e.layerDefinition;s.minScale&&s.minScale<i&&(t=!1),s.maxScale&&s.maxScale>i&&(t=!1)}}return t}isUpdating(){const t=this._vectorTileContainer.children;return!this._isTileHandlerReady||!this._fetchQueue||!this._parseQueue||this._fetchQueue.updating||this._parseQueue.updating||t.length>0&&t.filter((t=>t.invalidating)).length>0||this.fading}acquireTile(t){const s=this._createVectorTile(t);return this._tileHandlerPromise.then((()=>{this._fetchQueue.push(s.key).then((t=>this._parseQueue.push({key:s.key,data:t}))).then((t=>{s.once("attach",(()=>this.requestUpdate())),t&&(s.setData(t.tileData),this.requestUpdate(),this.notifyChange("updating"))})).catch((t=>{this.notifyChange("updating"),n(t)||Lt.error(t)}))})),s}releaseTile(t){const s=t.key.id;this._fetchQueue.abort(s),this._parseQueue.abort(s),this.requestUpdate()}_start(){if(this._stop(),this._tileManager=new ot({acquireTile:t=>this.acquireTile(t),releaseTile:t=>this.releaseTile(t),tileInfoView:this._tileInfoView},this._vectorTileContainer),!this.layer.currentStyleInfo)return;const t=new AbortController,s=this._tileHandler.start({signal:t.signal}).then((()=>{this._fetchQueue=new D({tileInfoView:this._tileInfoView,process:(t,s)=>this._getTileData(t,s),concurrency:15}),this._parseQueue=new D({tileInfoView:this._tileInfoView,process:(t,s)=>this._parseTileData(t,s),concurrency:8}),this.requestUpdate(),this._isTileHandlerReady=!0}));this._tileHandler.spriteMosaic.then((t=>{this._vectorTileContainer.setStyleResources(t,this._tileHandler.glyphMosaic,this._styleRepository),this.requestUpdate()})),this._tileHandlerAbortController=t,this._tileHandlerPromise=s}_stop(){if(!this._tileHandlerAbortController||!this._vectorTileContainer)return;const t=this._tileHandlerAbortController;t&&t.abort(),this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._fetchQueue&&(this._fetchQueue.destroy(),this._fetchQueue=null),this._parseQueue&&(this._parseQueue.destroy(),this._parseQueue=null),this._tileManager&&(this._tileManager.destroy(),this._tileManager=null),this._vectorTileContainer.removeAllChildren()}async _getTileData(t,s){const i=await this._tileHandler.fetchTileData(t,s);return this.notifyChange("updating"),i}async _parseTileData(t,s){return this._tileHandler.parseTileData(t,s)}async _applyStyleChanges(){this._isTileHandlerReady=!1,this._fetchQueue.pause(),this._parseQueue.pause(),this._fetchQueue.clear(),this._parseQueue.clear(),this._tileManager.clearCache();const t=this._styleChanges;try{await this._tileHandler.updateStyle(t)}catch(t){Lt.error("error applying vector-tiles style update",t.message),this._fetchQueue.resume(),this._parseQueue.resume(),this._isTileHandlerReady=!0}const s=this._styleRepository,i=[];t.forEach((t=>{if(3!==t.type)return;const e=s.getLayerById(t.data.layer);e&&i.push(e.uid)}));const e=[];let h;t.forEach((t=>{const i=t.data;switch(t.type){case 0:s.setPaintProperties(i.layer,i.paint),h=i.layer;break;case 1:s.setLayoutProperties(i.layer,i.layout),h=i.layer;break;case 3:return void s.deleteStyleLayer(i.layer);case 2:s.setStyleLayer(i.layer,i.index),h=i.layer.id}const n=s.getLayerById(h);n&&e.push(n.uid)}));const n=this._vectorTileContainer.children;if(i.length>0){this._vectorTileContainer.deleteStyleLayers(i);for(const t of n)t.deleteLayerData(i)}if(this._fetchQueue.resume(),this._parseQueue.resume(),e.length>0){const t=[];for(const s of n){const i=this._fetchQueue.push(s.key).then((t=>this._parseQueue.push({key:s.key,data:t,styleLayerUIDs:e}))).then((t=>s.setData(t.tileData)));t.push(i)}await Promise.all(t)}this._styleChanges=[],this._isTileHandlerReady=!0,this.notifyChange("updating"),this.requestUpdate()}async _loadStyle(){const{style:t,spriteUrl:s,glyphsUrl:i}=this.layer.currentStyleInfo,e=k(t);this._isTileHandlerReady=!1,this._fetchQueue.pause(),this._parseQueue.pause(),this._fetchQueue.clear(),this._parseQueue.clear(),this.notifyChange("updating"),this._styleRepository=new G(e,{spriteUrl:s,glyphsUrl:i}),this._vectorTileContainer.destroy(),this._tileManager.clear(),this._tileHandlerAbortController.abort(),this._tileHandlerAbortController=new AbortController;const{signal:h}=this._tileHandlerAbortController;try{this._tileHandlerPromise=this._tileHandler.setStyle(this._styleRepository,e),await this._tileHandlerPromise}catch(t){if(!n(t))throw t}if(h.aborted)return this._fetchQueue.resume(),this._parseQueue.resume(),this._isTileHandlerReady=!0,this.notifyChange("updating"),void this.requestUpdate();const r=await this._tileHandler.spriteMosaic;this._vectorTileContainer.setStyleResources(r,this._tileHandler.glyphMosaic,this._styleRepository),this._fetchQueue.resume(),this._parseQueue.resume(),this._isTileHandlerReady=!0,this.notifyChange("updating"),this.requestUpdate()}_createVectorTile(t){const s=this._tileInfoView.getTileBounds(M(),t);return new bt(t,s[0],s[3],512,512,this._styleRepository)}_renderCollisionBoxes(t){for(const s of this._vectorTileContainer.children)if(s.symbols){const i=[];for(const[t,e]of s.symbols)i.push(...e);ht(t,i)}}};P([j()],Ot.prototype,"_fetchQueue",void 0),P([j()],Ot.prototype,"_parseQueue",void 0),P([j()],Ot.prototype,"_isTileHandlerReady",void 0),P([j()],Ot.prototype,"fading",void 0),Ot=P([R("esri.views.2d.layers.VectorTileLayerView2D")],Ot);const Ft=Ot;export default Ft;