import{s as t,af as i,bt as s,br as e,A as n,bo as r,ai as a,D as o,dm as h}from"./p-e58503d5.js";import{h as l,i as c}from"./p-b0565d49.js";import{H as u}from"./p-01e5a461.js";import{A as f,D as d,f as m,a as p}from"./p-f94762ac.js";import{o as y,u as w}from"./p-ea916a39.js";import{g as x}from"./p-b79fcce3.js";import{d as g,s as F,c as S}from"./p-c048b814.js";import{v}from"./p-c1cd5521.js";import{e as b}from"./p-9f58a277.js";import{WhereClause as T}from"./p-61f47d2b.js";import{g as z,M as _,f as P}from"./p-e49308c6.js";import{t as R}from"./p-06d309e6.js";import{s as I}from"./p-4019eec3.js";import{e as V}from"./p-5032dfbd.js";import{h as M,s as E,u as Q,v as j,b as A,g as D,y as q,D as C,d as N,c as B,o as k}from"./p-292d2320.js";import{z as L,J as O,O as U,n as $,t as G,P as Z,U as J,v as W,I as H,a as X}from"./p-85a6d41b.js";import{H as K,a as Y}from"./p-765e6c28.js";import{d as tt}from"./p-612de336.js";import{C as it}from"./p-ca295674.js";const st=new class{constructor(t,i){this._cache=new b(t),this._invalidCache=new b(i)}get(t,i){const s=`${i.uid}:${t}`,e=this._cache.get(s);if(e)return e;if(void 0!==this._invalidCache.get(s))return null;try{const e=T.create(t,i);return this._cache.put(s,e),e}catch{return this._invalidCache.put(s,null),null}}}(50,500),et="feature-store:unsupported-query",nt=" as ",rt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function at(i,s){if(!s)return!0;const e=st.get(s,i);if(!e)throw new t(et,"invalid SQL expression",{where:s});if(!e.isStandardized)throw new t(et,"where clause is not standard",{where:s});return lt(i,e.fieldNames,"where clause contains missing fields"),!0}function ot(i,s,e){if(!s)return!0;const n=st.get(s,i);if(!n)throw new t(et,"invalid SQL expression",{having:s});if(!n.isAggregate)throw new t(et,"having does not contain a valid aggregate function",{having:s});if(lt(i,n.fieldNames,"having contains missing fields"),!n.getExpressions().every((t=>{const{aggregateType:s,field:n}=t,r=i.has(n)&&i.get(n).name;return e.some((t=>{const{onStatisticField:e,statisticType:n}=t;return(i.has(e)&&i.get(e).name)===r&&n.toLowerCase().trim()===s}))})))throw new t(et,"expressions in having should also exist in outStatistics",{having:s});return!0}function ht(t,i){return t?st.get(t,i):null}function lt(i,s,e,n=!0){const r=[];for(const e of s)if("*"!==e&&!i.has(e))if(n){const s=ct(e);try{const e=ht(s,i);if(!e)throw new t(et,"invalid SQL expression",{where:s});if(!e.isStandardized)throw new t(et,"expression is not standard",{clause:e});lt(i,e.fieldNames,"expression contains missing fields")}catch(t){const i=t&&t.details;if(i&&(i.clause||i.where))throw t;i&&i.missingFields?r.push(...i.missingFields):r.push(e)}}else r.push(e);if(r.length)throw new t(et,e,{missingFields:r})}function ct(t){return t.split(nt)[0]}function ut(t){return t.split(nt)[1]}function ft(t,i){const s=i.get(t);return!!s&&!rt.has(s.type)}class dt{constructor(t,i,s){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=t.returnDistinctValues,this.fieldsIndex=s,this.featureAdapter=i;const e=t.outFields;if(e&&-1===e.indexOf("*")){this.outFields=e;let t=0;for(const i of e){const e=ct(i),n=this.fieldsIndex.get(e),r=n?null:ht(e,s),a=n?n.name:ut(i)||"FIELD_EXP_"+t++;this._fieldDataCache.set(i,{alias:a,clause:r})}}}countDistinctValues(t){return this.returnDistinctValues?(t.forEach((t=>this.getAttributes(t))),this._returnDistinctMap.size):t.length}getAttributes(t){const i=this._processAttributesForOutFields(t);return this._processAttributesForDistinctValues(i)}getFieldValue(t,i,s){const e=s?s.name:i;let n=null;return this._fieldDataCache.has(e)?n=this._fieldDataCache.get(e).clause:s||(n=ht(i,this.fieldsIndex),this._fieldDataCache.set(e,{alias:e,clause:n})),s?this.featureAdapter.getAttribute(t,e):n.calculateValue(t,this.featureAdapter)}getNormalizedValue(t,i){const s=i.normalizationType,e=i.normalizationTotal;let n=this.getFieldValue(t,i.field,i.fieldInfo);if(s&&Number.isFinite(n)){const r=this.getFieldValue(t,i.normalizationField,i.normalizationFieldInfo);n=M(n,s,r,e)}return n}getExpressionValue(t,i,s){const e={attributes:this.featureAdapter.getAttributes(t)},n=s.createExecContext(e,i.viewInfo);return s.executeFunction(i.compiledFunc,n)}validateItem(t,i){return this._fieldDataCache.has(i)||this._fieldDataCache.set(i,{alias:i,clause:ht(i,this.fieldsIndex)}),this._fieldDataCache.get(i).clause.testFeature(t,this.featureAdapter)}validateItems(t,i){return this._fieldDataCache.has(i)||this._fieldDataCache.set(i,{alias:i,clause:ht(i,this.fieldsIndex)}),this._fieldDataCache.get(i).clause.testSet(t,this.featureAdapter)}_processAttributesForOutFields(t){const i=this.outFields;if(!i||!i.length)return this.featureAdapter.getAttributes(t);const s={};for(const e of i){const{alias:i,clause:n}=this._fieldDataCache.get(e);s[i]=n?n.calculateValue(t,this.featureAdapter):this.featureAdapter.getAttribute(t,i)}return s}_processAttributesForDistinctValues(t){if(i(t)||!this.returnDistinctValues)return t;const s=this.outFields,e=[];if(s)for(const i of s){const{alias:s}=this._fieldDataCache.get(i);e.push(t[s])}else for(const i in t)e.push(t[i]);const n=`${(s||["*"]).join(",")}=${e.join(",")}`;let r=this._returnDistinctMap.get(n)||0;return this._returnDistinctMap.set(n,++r),r>1?null:t}}class mt{constructor(t,i,s){this.items=t,this.queryGeometry=i,this.definitionExpression=s.definitionExpression,this.geometryType=s.geometryType,this.hasM=s.hasM,this.hasZ=s.hasZ,this.objectIdField=s.objectIdField,this.spatialReference=s.spatialReference,this.fieldsIndex=s.fieldsIndex,this.timeInfo=s.timeInfo,this.featureAdapter=s.featureAdapter,this.aggregateAdapter=s.aggregateAdapter}get size(){return this.items.length}createQueryResponseForCount(t){const i=new dt(t,this.featureAdapter,this.fieldsIndex);if(!t.outStatistics)return i.countDistinctValues(this.items);const{groupByFieldsForStatistics:s,having:e}=t;if(!(null==s?void 0:s.length))return 1;const n=new Map,r=new Map,a=new Set,o=t.outStatistics;for(const t of o){const{statisticType:o}=t,h="exceedslimit"!==o?t.onStatisticField:void 0;if(!r.has(h)){const t=[];for(const e of s){const s=this._getAttributeValues(i,e,n);t.push(s)}r.set(h,this._calculateUniqueValues(t,i.returnDistinctValues))}const l=r.get(h);for(const t in l){const{data:s,items:n}=l[t],r=s.join(",");e&&!i.validateItems(n,e)||a.add(r)}}return a.size}createQueryResponse(t){let i;return i=t.outStatistics?t.outStatistics.some((t=>"exceedslimit"===t.statisticType))?this._createExceedsLimitQueryResponse(t):this._createStatisticsQueryResponse(t):this._createFeatureQueryResponse(t),t.returnQueryGeometry&&(i.queryGeometry=s(t.outSR)&&!e(this.queryGeometry.spatialReference,t.outSR)?L({spatialReference:t.outSR,...z(this.queryGeometry,this.queryGeometry.spatialReference,t.outSR)}):L({spatialReference:t.outSR,...this.queryGeometry})),i}createSnappingResponse(t,s){const e=this.featureAdapter,n=function(t,i){return t?i?4:3:i?3:2}(this.hasZ,this.hasM),{x:r,y:a}=t.point,o="number"==typeof t.distance?t.distance:t.distance.x,h="number"==typeof t.distance?t.distance:t.distance.y,l={candidates:[]},c="esriGeometryPolygon"===this.geometryType,u=this.getPointCreator(t.point,this.spatialReference,s);for(const s of this.items){const f=e.getGeometry(s);if(i(f))continue;const{coords:d,lengths:m}=f;if(1&t.types){let t=0;for(let i=0;i<m.length;i++){const c=m[i];for(let i=0;i<c;i++,t+=n){const f=d[t],m=d[t+1];if(i!==c-1){const i=d[t+n],c=d[t+n+1],{x:p,y}=pt(r,a,f,m,i,c),w=(r-p)/o,x=(a-y)/h,g=w*w+x*x;g<=1&&l.candidates.push({type:"edge",objectId:e.getObjectId(s),distance:Math.sqrt(g),target:u(p,y),start:u(f,m),end:u(i,c)})}}}}if(2&t.types){const t=c?d.length-n:d.length;for(let i=0;i<t;i+=n){const t=d[i],n=d[i+1],c=(r-t)/o,f=(a-n)/h,m=c*c+f*f;m<=1&&l.candidates.push({type:"vertex",objectId:e.getObjectId(s),distance:Math.sqrt(m),target:u(t,n)})}}}return l.candidates.sort(((t,i)=>t.distance-i.distance)),l}getPointCreator(t,i,s){const r=n(s)&&!e(i,s)?t=>z(t,i,s):t=>t;return null!=t.z&&null!=t.m?(i,s)=>r({x:i,y:s,z:t.z,m:t.m}):null!=t.z?(i,s)=>r({x:i,y:s,z:t.z}):null!=t.m?(i,s)=>r({x:i,y:s,m:t.m}):(t,i)=>r({x:t,y:i})}executeAttributesQuery(t){const i=ht(t.where,this.fieldsIndex);if(!i)return Promise.resolve(this);if(i.isStandardized){let s=0;const e=[];for(const t of this.items)i.testFeature(t,this.featureAdapter)&&(e[s++]=t);const n=new mt(e,this.queryGeometry,this);return n.definitionExpression=t.where,Promise.resolve(n)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(t){if(!t.aggregateIds||!t.aggregateIds.length||i(this.aggregateAdapter))return Promise.resolve(this);const s=new Set;for(const i of t.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(i).forEach((t=>s.add(t)));const e=this.featureAdapter.getObjectId;return Promise.resolve(new mt(this.items.filter((t=>s.has(e(t)))),this.queryGeometry,this))}executeObjectIdsQuery(t){if(!t.objectIds||!t.objectIds.length)return Promise.resolve(this);const i=new Set(t.objectIds),s=this.featureAdapter.getObjectId;return Promise.resolve(new mt(this.items.filter((t=>i.has(s(t)))),this.queryGeometry,this))}executeTimeQuery(t){const i=$(this.timeInfo,t.timeExtent,this.featureAdapter);if(!n(i))return Promise.resolve(this);const s=this.items.filter(i);return Promise.resolve(new mt(s,this.queryGeometry,this))}filterLatest(){const{trackIdField:t,startTimeField:i,endTimeField:s}=this.timeInfo,e=s||i,n=new Map,r=this.featureAdapter.getAttribute;for(const i of this.items){const s=r(i,t),a=r(i,e),o=n.get(s);(!o||a>r(o,e))&&n.set(s,i)}const a=Array.from(n.values());return Promise.resolve(new mt(a,this.queryGeometry,this))}async project(t){if(!t||e(this.spatialReference,t))return this;const i=this.featureAdapter,s=(await _(this.items.map((t=>O(this.geometryType,this.hasZ,this.hasM,i.getGeometry(t)))),this.spatialReference,t)).map(((t,s)=>i.cloneWithGeometry(this.items[s],V(t,this.hasZ,this.hasM))));return new mt(s,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:t,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(t,i){const{field:s,valueExpression:e,normalizationField:n,normalizationType:r,normalizationTotal:a,minValue:o,maxValue:h,scale:l}=i,c=this.fieldsIndex.isDateField(s),u=await this._getDataValues(t,{field:s,valueExpression:e,normalizationField:n,normalizationType:r,normalizationTotal:a,scale:l}),f=k({normalizationType:r,normalizationField:n,minValue:o,maxValue:h}),d=this.fieldsIndex.get(s),m={value:.5,fieldType:null==d?void 0:d.type},p=K(d)?E({values:u,supportsNullCount:f,percentileParams:m}):Q({values:u,minValue:o,maxValue:h,useSampleStdDev:!r,supportsNullCount:f,percentileParams:m});return j(p,c)}async createUniqueValuesResponse(t,i){const{field:s,valueExpression:e,domain:n,returnAllCodedValues:r,scale:a}=i,o=await this._getDataValues(t,{field:s,valueExpression:e,scale:a}),h=A(o);return D(h,n,r)}async createClassBreaksResponse(t,i){const{field:s,valueExpression:e,normalizationField:n,normalizationType:r,normalizationTotal:a,classificationMethod:o,standardDeviationInterval:h,minValue:l,maxValue:c,numClasses:u,scale:f}=i,d=await this._getDataValues(t,{field:s,valueExpression:e,normalizationField:n,normalizationType:r,normalizationTotal:a,scale:f}),m=q(d,{field:s,normalizationField:n,normalizationType:r,normalizationTotal:a,classificationMethod:o,standardDeviationInterval:h,minValue:l,maxValue:c,numClasses:u});return C(m,o)}_sortFeatures(t,i,s){if(t.length>1&&i&&i.length)for(const e of i.reverse()){const i=e.split(" "),n=i[0],r=this.fieldsIndex.get(n),a=i[1]&&"desc"===i[1].toLowerCase(),o=N(null==r?void 0:r.type,a);t.sort(((t,i)=>{const e=s(t,n,r),a=s(i,n,r);return o(e,a)}))}}_createFeatureQueryResponse(t){const i=this.items,{geometryType:s,hasM:e,hasZ:n,objectIdField:r,spatialReference:a}=this,{outFields:o,outSR:h,quantizationParameters:l,resultRecordCount:c,resultOffset:u,returnZ:f,returnM:d}=t,m=null!=c&&i.length>(u||0)+c,p=o&&(o.indexOf("*")>-1?[...this.fieldsIndex.fields]:o.map((t=>this.fieldsIndex.get(t))));return{exceededTransferLimit:m,features:this._createFeatures(t,i),fields:p,geometryType:s,hasM:e&&d,hasZ:n&&f,objectIdFieldName:r,spatialReference:L(h||a),transform:l&&I(l)||null}}_createFeatures(t,i){const s=new dt(t,this.featureAdapter,this.fieldsIndex),{hasM:e,hasZ:n}=this,{orderByFields:r,quantizationParameters:a,returnGeometry:o,returnCentroid:h,maxAllowableOffset:l,resultOffset:c,resultRecordCount:u,returnZ:f=!1,returnM:d=!1}=t,m=n&&f,p=e&&d;let y=[],w=0;const x=[...i];if(this._sortFeatures(x,r,((t,i,e)=>s.getFieldValue(t,i,e))),o||h){const t=I(a);if(o&&!h)for(const i of x)y[w++]={attributes:s.getAttributes(i),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(i),l,t,m,p)};else if(!o&&h)for(const i of x)y[w++]={attributes:s.getAttributes(i),centroid:U(this,this.featureAdapter.getCentroid(i,this),t)};else for(const i of x)y[w++]={attributes:s.getAttributes(i),centroid:U(this,this.featureAdapter.getCentroid(i,this),t),geometry:O(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(i),l,t,m,p)}}else for(const t of x){const i=s.getAttributes(t);i&&(y[w++]={attributes:i})}const g=c||0;return null!=u&&(y=y.slice(g,Math.min(y.length,g+u))),y}_createExceedsLimitQueryResponse(t){let i=!1,s=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const i of t.outStatistics)if("exceedslimit"===i.statisticType){s=null!=i.maxPointCount?i.maxPointCount:Number.POSITIVE_INFINITY,e=null!=i.maxRecordCount?i.maxRecordCount:Number.POSITIVE_INFINITY,r=null!=i.maxVertexCount?i.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)i=this.items.length>s;else if(this.items.length>e)i=!0;else{const t=this.hasZ?this.hasM?4:3:this.hasM?3:2,s=this.featureAdapter;i=this.items.reduce(((t,i)=>{const e=s.getGeometry(i);return t+(n(e)&&e.coords.length||0)}),0)/t>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(i)}}]}}_createStatisticsQueryResponse(t){const i={attributes:{}},s=[],e=new Map,n=new Map,r=new Map,a=new Map,o=new dt(t,this.featureAdapter,this.fieldsIndex),h=t.outStatistics,{groupByFieldsForStatistics:l,having:c,orderByFields:u}=t,f=l&&l.length,d=!!f,m=d&&l[0],p=d&&!this.fieldsIndex.get(m);for(const t of h){const{outStatisticFieldName:h,statisticType:u}=t,y=t,w="exceedslimit"!==u?t.onStatisticField:void 0,x="percentile_disc"===u||"percentile_cont"===u,g=d&&1===f&&(w===m||p)&&"count"===u;if(d){if(!r.has(w)){const t=[];for(const i of l){const s=this._getAttributeValues(o,i,e);t.push(s)}r.set(w,this._calculateUniqueValues(t,o.returnDistinctValues))}const t=r.get(w);for(const i in t){const{count:s,data:n,items:r,itemPositions:u}=t[i],f=n.join(",");if(!c||o.validateItems(r,c)){const t=a.get(f)||{attributes:{}};let i=null;if(g)i=s;else{const t=this._getAttributeValues(o,w,e),s=u.map((i=>t[i]));i=x&&"statisticParameters"in y?this._getPercentileValue(y,s):this._getStatisticValue(y,s,null,o.returnDistinctValues)}t.attributes[h]=i,l.forEach(((i,s)=>t.attributes[this.fieldsIndex.get(i)?i:`EXPR_${s+1}`]=n[s])),a.set(f,t)}}}else{const t=this._getAttributeValues(o,w,e);i.attributes[h]=x&&"statisticParameters"in y?this._getPercentileValue(y,t):this._getStatisticValue(y,t,n,o.returnDistinctValues)}s.push({name:h,alias:h,type:"esriFieldTypeDouble"})}const y=d?Array.from(a.values()):[i];return this._sortFeatures(y,u,((t,i)=>t.attributes[i])),{fields:s,features:y}}_getStatisticValue(t,i,s,e){const{onStatisticField:n,statisticType:r}=t;let a=null;return a=null!=s&&s.has(n)?s.get(n):K(this.fieldsIndex.get(n))?E({values:i,returnDistinct:e}):Q({values:i,minValue:null,maxValue:null,useSampleStdDev:!0}),s&&s.set(n,a),a["var"===r?"variance":r]}_getPercentileValue(t,i){const{onStatisticField:s,statisticParameters:e,statisticType:n}=t,{value:r,orderBy:a}=e,o=this.fieldsIndex.get(s);return B(i,{value:r,orderBy:a,fieldType:null==o?void 0:o.type,isDiscrete:"percentile_disc"===n})}_getAttributeValues(t,i,s){if(s.has(i))return s.get(i);const e=this.fieldsIndex.get(i),n=this.items.map((s=>t.getFieldValue(s,i,e)));return s.set(i,n),n}_getAttributeNormalizedValues(t,i){return this.items.map((s=>t.getNormalizedValue(s,{field:i.field,fieldInfo:this.fieldsIndex.get(i.field),normalizationField:i.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(i.normalizationField),normalizationType:i.normalizationType,normalizationTotal:i.normalizationTotal})))}async _getAttributeExpressionValues(t,i,s){const{arcadeUtils:e}=await Y(),n=e.createFunction(i),r=s&&e.getViewInfo(s);return this.items.map((i=>t.getExpressionValue(i,{compiledFunc:n,viewInfo:r},e)))}_calculateUniqueValues(t,i){const s={},e=this.items,n=e.length;for(let r=0;r<n;r++){const n=e[r],a=[];for(const i of t)a.push(i[r]);const o=a.join(",");i?null==s[o]&&(s[o]={count:1,data:a,items:[n],itemPositions:[r]}):null==s[o]?s[o]={count:1,data:a,items:[n],itemPositions:[r]}:(s[o].count++,s[o].items.push(n),s[o].itemPositions.push(r))}return s}async _getDataValues(t,i){const s=new dt(t,this.featureAdapter,this.fieldsIndex),{valueExpression:e,field:n,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:h}=i;return e?this._getAttributeExpressionValues(s,e,e?{viewingMode:"map",scale:h,spatialReference:t.outSR||this.spatialReference}:null):this._getAttributeNormalizedValues(s,{field:n,normalizationField:r,normalizationType:a,normalizationTotal:o})}}function pt(t,i,s,e,n,r){const a=n-s,o=r-e,h=Math.min(1,Math.max(0,((t-s)*a+(i-e)*o)/(a*a+o*o)));return{x:s+a*h,y:e+o*h}}const yt="feature-store:unsupported-query",wt=new Set,xt=new l(2e6);let gt=0;class Ft{constructor(t){this.capabilities={query:R},this.geometryType=t.geometryType,this.hasM=t.hasM,this.hasZ=t.hasZ,this.objectIdField=t.objectIdField,this.spatialReference=t.spatialReference,this.definitionExpression=t.definitionExpression,this.featureStore=t.featureStore,this.aggregateAdapter=t.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",(()=>this.clearCache())),this.timeInfo=t.timeInfo,t.cacheSpatialQueries&&(this._geometryQueryCache=new c(gt+++"$$",xt)),this.fieldsIndex=new tt(t.fields),t.scheduler&&t.priority&&(this._frameTask=t.scheduler.registerTask(t.priority))}destroy(){this._frameTask=r(this._frameTask),this.clearCache(),a(this._geometryQueryCache),this._changeHandle=r(this._changeHandle),a(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const t=this.featureStore.fullBounds;return t?{xmin:t[0],ymin:t[1],xmax:t[2],ymax:t[3],spatialReference:L(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=G(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(t={},i){let s,e=o(t);try{e=await this._schedule((()=>Z(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),s=await this._reschedule((()=>this._executeGeometryQuery(e,i)),i),s=await this._reschedule((()=>s.executeAggregateIdsQuery(e)),i),s=await this._reschedule((()=>s.executeObjectIdsQuery(e)),i),s=await this._reschedule((()=>s.executeTimeQuery(e)),i),s=await this._reschedule((()=>s.executeAttributesQuery(e)),i)}catch(t){if(t!==J)throw t;s=new mt([],null,this)}return s.createQueryResponse(e)}async executeQueryForCount(t={},i){let s=o(t);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule((()=>Z(s,this.definitionExpression,this.spatialReference)),i),s=await this._reschedule((()=>this._checkQuerySupport(s)),i);let t=await this._reschedule((()=>this._executeGeometryQuery(s,i)),i);return t=await this._reschedule((()=>t.executeAggregateIdsQuery(s)),i),t=await this._reschedule((()=>t.executeObjectIdsQuery(s)),i),t=await this._reschedule((()=>t.executeTimeQuery(s)),i),t=await this._reschedule((()=>t.executeAttributesQuery(s)),i),t.createQueryResponseForCount(s)}catch(t){if(t!==J)throw t;return 0}}async executeQueryForExtent(t={},i){let s,e=o(t);const n=e.outSR;try{e=await this._schedule((()=>Z(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),e.returnGeometry=!0,e.returnCentroid=!1,e.outSR=null,s=await this._reschedule((()=>this._executeGeometryQuery(e,i)),i),s=await this._reschedule((()=>s.executeAggregateIdsQuery(e)),i),s=await this._reschedule((()=>s.executeObjectIdsQuery(e)),i),s=await this._reschedule((()=>s.executeTimeQuery(e)),i),s=await this._reschedule((()=>s.executeAttributesQuery(e)),i);const t=s.size;if(!t)return{count:t,extent:null};f(vt,d),this.featureStore.forEachBounds(s.items,(t=>m(vt,t)),St);const r={xmin:vt[0],ymin:vt[1],xmax:vt[3],ymax:vt[4],spatialReference:L(this.spatialReference)};this.hasZ&&isFinite(vt[2])&&isFinite(vt[5])&&(r.zmin=vt[2],r.zmax=vt[5]);const a=z(r,s.spatialReference,n);if(a.spatialReference=L(n||this.spatialReference),a.xmax-a.xmin==0){const t=u(a.spatialReference);a.xmin-=t,a.xmax+=t}if(a.ymax-a.ymin==0){const t=u(a.spatialReference);a.ymin-=t,a.ymax+=t}if(this.hasZ&&null!=a.zmin&&null!=a.zmax&&a.zmax-a.zmin==0){const t=u(a.spatialReference);a.zmin-=t,a.zmax+=t}return{count:t,extent:a}}catch(t){if(t===J)return{count:0,extent:null};throw t}}async executeQueryForIds(t={},i){return this.executeQueryForIdSet(t,i).then((t=>Array.from(t)))}async executeQueryForIdSet(t={},i){let s,e=o(t);e.returnGeometry=!1,e.returnCentroid=!1,e.outSR=null;try{e=await this._schedule((()=>Z(e,this.definitionExpression,this.spatialReference)),i),e=await this._reschedule((()=>this._checkQuerySupport(e)),i),s=await this._reschedule((()=>this._executeGeometryQuery(e,i)),i),s=await this._reschedule((()=>s.executeAggregateIdsQuery(e)),i),s=await this._reschedule((()=>s.executeObjectIdsQuery(e)),i),s=await this._reschedule((()=>s.executeTimeQuery(e)),i),s=await this._reschedule((()=>s.executeAttributesQuery(e)),i);const t=s.items,n=new Set;return await this._reschedule((()=>{for(const i of t)n.add(s.featureAdapter.getObjectId(i))}),i),n}catch(t){if(t===J)return new Set;throw t}}async executeQueryForSnapping(t,s){const{point:n,distance:r,types:a}=t;if(0===a)return{candidates:[]};const o=await this._reschedule((()=>this._checkQuerySupport(t.query)),s),h=!e(n.spatialReference,this.spatialReference);h&&await P(n.spatialReference,this.spatialReference);const l="number"==typeof r?r:r.x,c="number"==typeof r?r:r.y,u={xmin:n.x-l,xmax:n.x+l,ymin:n.y-c,ymax:n.y+c,spatialReference:n.spatialReference},f=h?z(u,this.spatialReference):u;if(!f)return{candidates:[]};const d=(await v(g(n),null,{signal:s}))[0],m=(await v(g(f),null,{signal:s}))[0];if(i(d)||i(m))return{candidates:[]};let p=new mt(this._searchFeatures(this._getQueryBBoxes(m.toJSON())),null,this);p=await this._reschedule((()=>p.executeObjectIdsQuery(o)),s),p=await this._reschedule((()=>p.executeTimeQuery(o)),s),p=await this._reschedule((()=>p.executeAttributesQuery(o)),s);const y=d.toJSON(),w=h?z(y,this.spatialReference):y,x=h?Math.max(f.xmax-f.xmin,f.ymax-f.ymin)/2:r;return p.createSnappingResponse({...t,point:w,distance:x},n.spatialReference)}async executeQueryForLatestObservations(i={},s){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new t(yt,"Missing timeInfo or timeInfo.trackIdField",{query:i,timeInfo:this.timeInfo});let e,n=o(i);try{n=await this._schedule((()=>Z(n,this.definitionExpression,this.spatialReference)),s),n=await this._reschedule((()=>this._checkQuerySupport(n)),s),e=await this._reschedule((()=>this._executeGeometryQuery(n,s)),s),e=await this._reschedule((()=>e.executeAggregateIdsQuery(n)),s),e=await this._reschedule((()=>e.executeObjectIdsQuery(n)),s),e=await this._reschedule((()=>e.executeTimeQuery(n)),s),e=await this._reschedule((()=>e.executeAttributesQuery(n)),s),e=await this._reschedule((()=>e.filterLatest()),s)}catch(t){if(t!==J)throw t;e=new mt([],null,this)}return e.createQueryResponse(n)}async executeQueryForSummaryStatistics(t={},i,s){const{field:e,normalizationField:n,valueExpression:r}=i;return(await this._getQueryEngineResultForStats(t,{field:e,normalizationField:n,valueExpression:r},s)).createSummaryStatisticsResponse(t,i)}async executeQueryForUniqueValues(t={},i,s){const{field:e,valueExpression:n}=i;return(await this._getQueryEngineResultForStats(t,{field:e,valueExpression:n},s)).createUniqueValuesResponse(t,i)}async executeQueryForClassBreaks(t={},i,s){const{field:e,normalizationField:n,valueExpression:r}=i;return(await this._getQueryEngineResultForStats(t,{field:e,normalizationField:n,valueExpression:r},s)).createClassBreaksResponse(t,i)}async _schedule(t,i){return n(this._frameTask)?this._frameTask.schedule(t,i):t(it)}async _reschedule(t,i){return n(this._frameTask)?this._frameTask.reschedule(t,i):t(it)}_getAll(){if(!this._allItems){const t=[];this.featureStore.forEach((i=>t.push(i))),this._allItems=new mt(t,null,this)}return this._allItems}async _executeGeometryQuery(t,i){const{geometry:n,outSR:r,spatialRel:a,returnGeometry:o,returnCentroid:l}=t,c=o||l,u=s(r)&&!e(this.spatialReference,r),f=this._geometryQueryCache?u&&c?JSON.stringify({geometry:n,spatialRelationship:a,outSpatialReference:r}):JSON.stringify({geometry:n,spatialRelationship:a}):null;if(f){const t=this._geometryQueryCache.get(f);if(!h(t))return t}const d=async t=>{if(u&&c){const i=await t.project(r);return f&&this._geometryQueryCache.put(f,i,i.size||1),i}return f&&this._geometryQueryCache.put(f,t,t.size||1),t};if(!n)return d(this._getAll());const m=this.featureAdapter;if("esriSpatialRelDisjoint"===a){const t=this._searchFeatures(this._getQueryBBoxes(n));if(!t.length)return d(this._getAll());let s,e;const r=new Set;for(const i of t)r.add(m.getObjectId(i));return await this._reschedule((()=>{let t=0;s=new Array(r.size),this.featureStore.forEach((i=>s[t++]=i)),e=r}),i),d(await this._reschedule((async()=>{const t=await W(a,n,this.geometryType,this.hasZ,this.hasM);return new mt(await this._runSpatialFilter(s,(i=>!e.has(m.getObjectId(i))||t(m.getGeometry(i))),i),n,this)}),i))}const p=this._searchFeatures(this._getQueryBBoxes(n));if(!p.length){const t=new mt([],n,this);return f&&this._geometryQueryCache.put(f,t,t.size||1),t}if(this._canExecuteSoloPass(n,t))return d(new mt(p,n,this));const y=await W(a,n,this.geometryType,this.hasZ,this.hasM),w=await this._runSpatialFilter(p,(t=>y(m.getGeometry(t))),i);return d(new mt(w,n,this))}async _runSpatialFilter(t,s,e){if(!s)return t;if(i(this._frameTask))return t.filter((t=>s(t)));let n=0;const r=new Array,a=async i=>{for(;n<t.length;){const o=t[n++];s(o)&&(r.push(o),i.madeProgress()),i.done&&await this._reschedule((t=>a(t)),e)}};return this._reschedule((t=>a(t)),e).then((()=>r))}_canExecuteSoloPass(t,i){const{geometryType:s}=this,{spatialRel:e}=i;return H(t)&&("esriSpatialRelEnvelopeIntersects"===e||"esriGeometryPoint"===s&&("esriSpatialRelIntersects"===e||"esriSpatialRelContains"===e||"esriSpatialRelWithin"===e))}_getQueryBBoxes(t){if(H(t)){if(F(t))return[y(t.xmin,t.ymin,t.xmax,t.ymax)];if(S(t))return t.rings.map((t=>y(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1]))))}return[x(w(),t)]}_searchFeatures(t){for(const i of t)this.featureStore.forEachInBounds(i,(t=>{wt.add(t)}));const i=new Array(wt.size);let s=0;return wt.forEach((t=>i[s++]=t)),wt.clear(),i}async _checkStatisticsSupport(i,s){if(i.distance<0||null!=i.geometryPrecision||i.multipatchOption||i.pixelSize||i.relationParam||i.text||i.outStatistics||i.groupByFieldsForStatistics||i.having||i.orderByFields)throw new t(yt,"Unsupported query options",{query:i});return Promise.all([this._checkAttributesQuerySupport(i),this._checkStatisticsParamsSupport(s),X(i,this.geometryType,this.spatialReference),P(this.spatialReference,i.outSR)]).then((()=>i))}async _checkStatisticsParamsSupport(i){let s=[];if(i.valueExpression){const{arcadeUtils:t}=await Y();s=t.extractFieldNames(i.valueExpression)}if(i.field&&s.push(i.field),i.normalizationField&&s.push(i.normalizationField),!s.length)throw new t(yt,"params should have at least a field or valueExpression",{params:i});lt(this.fieldsIndex,s,"params contains missing fields")}async _checkQuerySupport(i){if(i.distance<0||null!=i.geometryPrecision||i.multipatchOption||i.pixelSize||i.relationParam||i.text)throw new t(yt,"Unsupported query options",{query:i});return Promise.all([this._checkAttributesQuerySupport(i),this._checkStatisticsQuerySupport(i),X(i,this.geometryType,this.spatialReference),P(this.spatialReference,i.outSR)]).then((()=>i))}_checkAttributesQuerySupport(i){const{outFields:s,orderByFields:e,returnDistinctValues:n,outStatistics:r}=i,a=r?r.map((t=>t.outStatisticFieldName&&t.outStatisticFieldName.toLowerCase())):[];if(e&&e.length>0){const t=" asc",i=" desc",s=e.map((s=>{const e=s.toLowerCase();return e.indexOf(t)>-1?e.split(t)[0]:e.indexOf(i)>-1?e.split(i)[0]:s})).filter((t=>-1===a.indexOf(t)));lt(this.fieldsIndex,s,"orderByFields contains missing fields")}if(s&&s.length>0)lt(this.fieldsIndex,s,"outFields contains missing fields");else if(n)throw new t(yt,"outFields should be specified for returnDistinctValues",{query:i});at(this.fieldsIndex,i.where)}async _checkStatisticsQuerySupport(i){const{outStatistics:s,groupByFieldsForStatistics:e,having:n}=i,r=e&&e.length,a=s&&s.length;if(n){if(!r||!a)throw new t(yt,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:i});ot(this.fieldsIndex,n,s)}if(a){if(!function(t){return t.every((t=>"exceedslimit"!==t.statisticType))}(s))return;const n=s.map((t=>t.onStatisticField));lt(this.fieldsIndex,n,"onStatisticFields contains missing fields"),r&&lt(this.fieldsIndex,e,"groupByFieldsForStatistics contains missing fields");for(const e of s){const{onStatisticField:s,statisticType:n}=e;if("percentile_disc"!==n&&"percentile_cont"!==n||!("statisticParameters"in e)){if("count"!==n&&s&&ft(s,this.fieldsIndex))throw new t(yt,"outStatistics contains non-numeric fields",{definition:e,query:i})}else{const{statisticParameters:s}=e;if(!s)throw new t(yt,"statisticParamters should be set for percentile type",{definition:e,query:i})}}}}async _getQueryEngineResultForStats(t={},i,s){let e;t=o(t);try{t=await this._schedule((()=>Z(t,this.definitionExpression,this.spatialReference)),s),t=await this._reschedule((()=>this._checkStatisticsSupport(t,i)),s),e=await this._reschedule((()=>this._executeGeometryQuery(t,s)),s),e=await this._reschedule((()=>e.executeAggregateIdsQuery(t)),s),e=await this._reschedule((()=>e.executeObjectIdsQuery(t)),s),e=await this._reschedule((()=>e.executeTimeQuery(t)),s),e=await this._reschedule((()=>e.executeAttributesQuery(t)),s)}catch(t){if(t!==J)throw t;e=new mt([],null,this)}return e}}const St=p(),vt=p();export{Ft as V}