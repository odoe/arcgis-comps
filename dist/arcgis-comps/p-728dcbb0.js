import{n as t,e as s}from"./p-ccdb8e80.js";import{e as i,n as h,a as e}from"./p-2c84c65f.js";import{I as r,y as o,r as n,o as a,q as c,d as u,s as m,u as l,f as d,a as f}from"./p-2f398ed1.js";import{r as g,n as p,b}from"./p-d3105731.js";import{n as j}from"./p-4d38e149.js";import{c as y}from"./p-ea0c022e.js";import{P as v,C as N,d as w,l as A}from"./p-95909347.js";import{ce as T,bK as V,A as S,aW as C,af as G}from"./p-e58503d5.js";import{d as O}from"./p-6ded4c02.js";import{r as x,f as M,u as I}from"./p-0d1e969a.js";import{i as _}from"./p-7f47b970.js";class B{constructor(){this._disposed=!1}get disposed(){return this._disposed}get shaderTransformation(){return this._shaderTransformation}acquire(t,s,i,h,e,r){this.id=V(),this.geometry=t,this.material=s,this.transformation=i,this.instanceParameters=h,this.origin=e,this._shaderTransformation=r,this._disposed=!1}release(){this._disposed=!1}dispose(){this._disposed=!0}getStaticTransformation(){return this.transformation}getShaderTransformation(){return S(this._shaderTransformation)?this._shaderTransformation(this.transformation):this.transformation}computeAttachmentOrigin(t){return!!(this.material.computeAttachmentOrigin?this.material.computeAttachmentOrigin(this.geometry,t):this.geometry.computeAttachmentOrigin(t))&&(r(t,t,this.getStaticTransformation()),!0)}}B.pool=new T(B);class D{constructor(t){this.channel=t,this.id=V()}}class L extends x{constructor(t={}){super(),this.type=1,this._geometryRecords=new Array,this._geometries=new Array,this._objectTransformation=i(),this._bvObjectSpace=new P,this._bvWorldSpace=new P,this._bvDirty=!0,this._hasVolatileTransformation=!1,this._visible=!0,this.castShadow=null==t.castShadow||t.castShadow,this.metadata=t.metadata,this.metadata&&this.metadata.isElevationSource&&(this.metadata.lastValidElevationBB=new R),this.transformation=i();const{geometries:s,materials:e,transformations:r,origins:o}=t;if(Array.isArray(s)){_(e.length===s.length,"Object3D: materials don't match geometries"),_(r.length===s.length,"Object3D: transformations don't match geometries"),this._geometryRecords.length=s.length,this._geometries.length=s.length;for(let t=0;t<s.length;t++)this._geometries[t]=s[t],this._geometryRecords[t]=B.pool.acquire(s[t],e[t],h(r[t]),{highlights:null,occludees:null,visible:this._visible},o&&o[t])}}get geometryRecords(){return this._geometryRecords}get geometries(){return this._geometries}get transformation(){return this._objectTransformation}set transformation(s){t(this._objectTransformation,s),this._invalidateBoundingVolume(),this._emit("objectTransformation",this)}dispose(){this._geometryRecords.length=0,this._geometries.length=0}get parentLayer(){return this._parentLayer}set parentLayer(t){_(null==this._parentLayer||null==t,"Object3D can only be added to a single Layer"),this._parentLayer=t}addGeometry(t,s,i,h,r){i=i||e,this._geometries.push(t);const o=B.pool.acquire(t,s,i,{highlights:null,occludees:null,visible:this._visible},h,r);return this._geometryRecords.push(o),this._hasVolatileTransformation=this._hasVolatileTransformation||S(o.shaderTransformation),this._emit("objectGeometryAdded",{object:this,record:o}),this._invalidateBoundingVolume(),o}removeGeometry(t){const s=this._geometryRecords.splice(t,1)[0];return this._hasVolatileTransformation=S(s.shaderTransformation)?this._geometryRecords.some((t=>S(t.shaderTransformation))):this._hasVolatileTransformation,s.dispose(),this._geometries.splice(t,1),this._emit("objectGeometryRemoved",{object:this,record:s}),this._invalidateBoundingVolume(),s}removeAllGeometries(){for(;this.geometryRecords.length>0;)this.removeGeometry(0)}geometryVertexAttrsUpdated(t){this._emit("vertexAttrsUpdated",{object:this,record:t}),this._invalidateBoundingVolume()}get isVisible(){return this._visible}setVisible(t){if(this._visible!==t){this._visible=t;for(const t of this._geometryRecords)t.instanceParameters.visible=this._visible;this._emit("visibilityChanged",this)}}maskOccludee(){const t=new D(1);for(const s of this._geometryRecords)s.instanceParameters.occludees=M(s.instanceParameters.occludees,t);return this._emit("occlusionChanged",this),t}removeOcclude(t){for(const s of this._geometryRecords)s.instanceParameters.occludees=I(s.instanceParameters.occludees,t);this._emit("occlusionChanged",this)}highlight(){const t=new D(0);for(const s of this._geometryRecords)s.instanceParameters.highlights=M(s.instanceParameters.highlights,t);return this._emit("highlightChanged",this),t}removeHighlight(t){for(const s of this._geometryRecords)s.instanceParameters.highlights=I(s.instanceParameters.highlights,t);this._emit("highlightChanged",this)}getCombinedStaticTransformation(t,h){return s(C(h,i()),this.transformation,t.getStaticTransformation())}getCombinedShaderTransformation(t,h){return h=h||i(),s(h,this.transformation,t.getShaderTransformation()),h}hasVolativeTransformation(){return this._hasVolatileTransformation}get boundingVolumeWorldSpace(){return this._validateBoundingVolume(),this._bvWorldSpace}get boundingVolumeObjectSpace(){return this._validateBoundingVolume(),this._bvObjectSpace}_validateBoundingVolume(){if(!this._bvDirty&&!this._hasVolatileTransformation)return;this._bvObjectSpace.init(),this._bvWorldSpace.init();for(let t=0;t<this._geometryRecords.length;++t){const s=this._geometryRecords[t],i=this._geometries[t].boundingInfo;S(i)&&(this._calculateTransformedBoundingVolume(i,this._bvObjectSpace,s.getShaderTransformation()),this._calculateTransformedBoundingVolume(i,this._bvWorldSpace,this.getCombinedShaderTransformation(s)))}o(this._bvObjectSpace.bounds,this._bvObjectSpace.min,this._bvObjectSpace.max,.5),o(this._bvWorldSpace.bounds,this._bvWorldSpace.min,this._bvWorldSpace.max,.5);const t=p(),s=p(),i=O(this.transformation);for(let h=0;h<this._geometryRecords.length;++h){const e=this._geometries[h].boundingInfo;if(G(e))continue;const o=this._geometryRecords[h].getShaderTransformation(),n=O(o);r(t,e.getCenter(),o);const a=c(t,this._bvObjectSpace.bounds),u=e.getBSRadius()*n;this._bvObjectSpace.bounds[3]=Math.max(this._bvObjectSpace.bounds[3],a+u),r(s,t,this.transformation);const m=c(s,this._bvWorldSpace.bounds);this._bvWorldSpace.bounds[3]=Math.max(this._bvWorldSpace.bounds[3],m+u*i)}this._bvDirty=!1}_calculateTransformedBoundingVolume(t,s,i){const h=t.getBBMin(),e=t.getBBMax(),o=b(h),a=b(e);r(o,o,i),r(a,a,i);for(let t=0;t<3;++t)s.min[t]=Math.min(s.min[t],o[t],a[t]),s.max[t]=Math.max(s.max[t],o[t],a[t]);for(let t=0;t<3;++t){n(o,h),n(a,e),o[t]=e[t],a[t]=h[t],r(o,o,i),r(a,a,i);for(let t=0;t<3;++t)s.min[t]=Math.min(s.min[t],o[t],a[t]),s.max[t]=Math.max(s.max[t],o[t],a[t])}}_invalidateBoundingVolume(){this._bvDirty=!0,S(this._parentLayer)&&this._parentLayer.notifyObjectBBChanged(this,this._bvWorldSpace.bounds)}_emit(t,s){S(this._parentLayer)&&this._parentLayer.events.emit(t,s)}get test(){const t=this;return{hasGeometry:s=>t._geometries.indexOf(s)>-1,getGeometryIndex:s=>t._geometries.indexOf(s)}}}class R{constructor(){this.min=g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this.max=g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)}isEmpty(){return this.max[0]<this.min[0]&&this.max[1]<this.min[1]&&this.max[2]<this.min[2]}}class P extends R{constructor(){super(...arguments),this.bounds=v()}init(){a(this.min,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),a(this.max,-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),N(this.bounds)}}function U(t){return(s,i,h)=>(o(q,s,i,h),!y(t,q))}class W{constructor(){this.min=new k,this.max=new k,this.hud=new k,this.ground=new k}init(t){this.min.init(t),this.max.init(t),this.hud.init(t),this.ground.init(t),this.all=[]}}class k{constructor(t){this.normal=p(),this.transformation=i(),this._ray=w(),this.init(t)}get ray(){return this._ray}get hasIntersectionPoint(){return null!=this.dist}get distanceInRenderSpace(){if(null!=this.dist)return u(E,this.ray.direction,this.dist),m(E)}getIntersectionPoint(t){return!!this.hasIntersectionPoint&&(u(E,this.ray.direction,this.dist),l(t,this.ray.origin,E),!0)}getTransformedNormal(t){return n(F,this.normal),F[3]=0,d(F,F,this.transformation),n(t,F),f(t,t),t}init(t){this.dist=void 0,this.target=void 0,this.name=void 0,this.drapedLayerOrder=void 0,this.drapedLayerGraphicOrder=void 0,this.center=null,this.geometryId=null,this.triangleNr=null,this.intersector="Stage",t?A(t,this._ray):this._ray=w()}set(s,i,h,e,r,o,a,c,u,m){s instanceof L&&(s={type:"stage",obj:s}),this.dist=h,n(this.normal,e),t(this.transformation,r),this.target=s,this.name=i,this.drapedLayerOrder=o,this.center=a?b(a):null,this.geometryId=c,this.triangleNr=u,this.drapedLayerGraphicOrder=m}copyFrom(s){A(s.ray,this._ray),this.dist=s.dist,this.target=s.target,this.name=s.name,this.drapedLayerOrder=s.drapedLayerOrder,this.center=s.center?b(s.center):null,this.geometryId=s.geometryId,this.triangleNr=s.triangleNr,this.intersector=s.intersector,this.drapedLayerGraphicOrder=s.drapedLayerGraphicOrder,n(this.normal,s.normal),t(this.transformation,s.transformation)}}const q=p(),E=p(),F=j();export{L as T,W as f,U as g,k as j,B as o,D as r}