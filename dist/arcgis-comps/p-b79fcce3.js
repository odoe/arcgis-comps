import{e as t,d as n,a3 as i,i as r,bu as e,_ as s,D as o,aE as u,bw as l,c7 as h,af as c,A as a,C as f,ar as p,aL as y,a0 as d,aS as m,ae as v}from"./p-e58503d5.js";function g(t,n,i=!1){let{hasM:r,hasZ:e}=t;Array.isArray(n)?4!==n.length||r||e?3===n.length&&i&&!r?(e=!0,r=!1):3===n.length&&r&&e&&(r=!1,e=!1):(r=!0,e=!0):(e=!e&&n.hasZ&&(!r||n.hasM),r=!r&&n.hasM&&(!e||n.hasZ)),t.hasZ=e,t.hasM=r}var x;function w(t){return(n,i)=>null==n?i:null==i?n:t(n,i)}let P=x=class extends e{constructor(...t){super(...t),this.points=[],this.type="multipoint"}normalizeCtorArgs(t,n){if(!t&&!n)return null;const i={};Array.isArray(t)?(i.points=t,i.spatialReference=n):function(t){return t&&("esri.geometry.SpatialReference"===t.declaredClass||null!=t.wkid)}(t)?i.spatialReference=t:(t.points&&(i.points=t.points),t.spatialReference&&(i.spatialReference=t.spatialReference),t.hasZ&&(i.hasZ=t.hasZ),t.hasM&&(i.hasM=t.hasM));const r=i.points&&i.points[0];return r&&(void 0===i.hasZ&&void 0===i.hasM?(i.hasZ=r.length>2,i.hasM=!1):void 0===i.hasZ?i.hasZ=r.length>3:void 0===i.hasM&&(i.hasM=r.length>3)),i}get cache(){return this.commitProperty("points"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get extent(){const t=this.points;if(!t.length)return null;const n=new s,i=this.hasZ,r=this.hasM,e=i?3:2,o=t[0],u=w(Math.min),l=w(Math.max);let h,c,a,f,[p,y]=o,[d,m]=o;for(let n=0,s=t.length;n<s;n++){const s=t[n],[o,v]=s;if(p=u(p,o),y=u(y,v),d=l(d,o),m=l(m,v),i&&s.length>2){const t=s[2];h=u(h,t),a=l(a,t)}if(r&&s.length>e){const t=s[e];c=u(c,t),f=l(f,t)}}return n.xmin=p,n.ymin=y,n.xmax=d,n.ymax=m,n.spatialReference=this.spatialReference,i?(n.zmin=h,n.zmax=a):(n.zmin=null,n.zmax=null),r?(n.mmin=c,n.mmax=f):(n.mmin=null,n.mmax=null),n}writePoints(t,n){n.points=o(this.points)}addPoint(t){return g(this,t),Array.isArray(t)?this.points.push(t):this.points.push(t.toArray()),this.notifyChange("points"),this}clone(){const t={points:o(this.points),spatialReference:this.spatialReference};return this.hasZ&&(t.hasZ=!0),this.hasM&&(t.hasM=!0),new x(t)}getPoint(t){if(!this._validateInputs(t))return null;const n=this.points[t],i={x:n[0],y:n[1],spatialReference:this.spatialReference};let r=2;return this.hasZ&&(i.z=n[2],r=3),this.hasM&&(i.m=n[r]),new u(i)}removePoint(t){if(!this._validateInputs(t))return null;const n=new u(this.points.splice(t,1)[0],this.spatialReference);return this.notifyChange("points"),n}setPoint(t,n){return this._validateInputs(t)?(g(this,n),Array.isArray(n)||(n=n.toArray()),this.points[t]=n,this.notifyChange("points"),this):this}toJSON(t){return this.write({},t)}_validateInputs(t){return null!=t&&t>=0&&t<this.points.length}};t([n({readOnly:!0})],P.prototype,"cache",null),t([n()],P.prototype,"extent",null),t([n({type:[[Number]],json:{write:{isRequired:!0}}})],P.prototype,"points",void 0),t([i("points")],P.prototype,"writePoints",null),P=x=t([r("esri.geometry.Multipoint")],P),P.prototype.toJSON.isDefaultToJSON=!0;const M=P;function R(t){if(!t)return null;if(Array.isArray(t))return t;const n=t.hasZ,i=t.hasM;if("point"===t.type)return i&&n?[t.x,t.y,t.z,t.m]:n?[t.x,t.y,t.z]:i?[t.x,t.y,t.m]:[t.x,t.y];if("polygon"===t.type)return t.rings.slice(0);if("polyline"===t.type)return t.paths.slice(0);if("multipoint"===t.type)return t.points.slice(0);if("extent"===t.type){const n=t.clone().normalize();if(!n)return null;let i=!1,r=!1;return n.forEach((t=>{t.hasZ&&(i=!0),t.hasM&&(r=!0)})),n.map((t=>{const n=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(i&&t.hasZ){const i=.5*(t.zmax-t.zmin);for(let t=0;t<n.length;t++)n[t].push(i)}if(r&&t.hasM){const i=.5*(t.mmax-t.mmin);for(let t=0;t<n.length;t++)n[t].push(i)}return n}))}return null}function A(t,n){const i=n[0]-t[0],r=n[1]-t[1];if(t.length>2&&n.length>2){const e=t[2]-n[2];return Math.sqrt(i*i+r*r+e*e)}return Math.sqrt(i*i+r*r)}function N(t,n,i){const r=t[0]+i*(n[0]-t[0]),e=t[1]+i*(n[1]-t[1]);return t.length>2&&n.length>2?[r,e,t[2]+i*(n[2]-t[2])]:[r,e]}function O(t,n,i,r){const[e,s]=n,[o,u]=i[r],[l,h]=i[r+1],c=l-o,a=h-u,f=Math.min(1,Math.max(0,((e-o)*c+(s-u)*a)/(c*c+a*a)));return t[0]=o+c*f,t[1]=u+a*f,t}function b(t,n){return N(t,n,.5)}function G(t){const n=t.length;let i=0;for(let r=0;r<n-1;++r)i+=A(t[r],t[r+1]);return i}function Z(t,n){if(n<=0)return t[0];const i=t.length;let r=0;for(let e=0;e<i-1;++e){const i=A(t[e],t[e+1]);if(n-r<i)return N(t[e],t[e+1],(n-r)/i);r+=i}return t[i-1]}function z(t,n,i){const r=t.length;let e=0,s=0,o=0;for(let u=0;u<r;u++){const l=t[u],h=t[(u+1)%r];let c=2;e+=l[0]*h[1]-h[0]*l[1],l.length>2&&h.length>2&&i&&(s+=l[0]*h[2]-h[0]*l[2],c=3),l.length>c&&h.length>c&&n&&(o+=l[0]*h[c]-h[0]*l[c])}return e<=0&&s<=0&&o<=0}function S(t){if("rings"in t){for(const n of t.rings)n.length<3||n[0][0]===n[n.length-1][0]&&n[0][1]===n[n.length-1][1]||n.push([n[0][0],n[0][1]]);if(t.rings.length>0&&!z(t.rings[0],t.hasM,t.hasZ))for(let n=0;n<t.rings.length;++n)t.rings[n]=t.rings[n].reverse()}}function j(t){return"polygon"!==t.type&&"polyline"!==t.type||q("polygon"===t.type?t.rings:t.paths,t.spatialReference),t}function q(t,n){const i=l(n);if(!i)return;const r=i.valid[0],e=i.valid[1],s=e-r;for(const n of t){let t=1/0,i=-1/0;n.forEach((n=>{let o=n[0];for(;o<r;)o+=s;for(;o>e;)o-=s;t=Math.min(t,o),i=Math.max(i,o),n[0]=o}));const o=i-t;s-o<o&&n.forEach((t=>{t[0]<0&&(t[0]+=s)}))}}function C(t){return t?I(t.rings,t.hasZ):null}function I(t,n){if(!t||!t.length)return null;const i=[],r=[],e=n?[1/0,-1/0,1/0,-1/0,1/0,-1/0]:[1/0,-1/0,1/0,-1/0];for(let i=0,s=t.length;i<s;i++){const s=_(t[i],n,e);s&&r.push(s)}if(r.sort(((t,i)=>{let r=t[2]-i[2];return 0===r&&n&&(r=t[4]-i[4]),r})),r.length&&(i[0]=r[0][0],i[1]=r[0][1],n&&(i[2]=r[0][3]),(i[0]<e[0]||i[0]>e[1]||i[1]<e[2]||i[1]>e[3]||n&&(i[2]<e[4]||i[2]>e[5]))&&(i.length=0)),!i.length){const r=t[0]&&t[0].length?function(t,n){const i=n?[0,0,0]:[0,0],r=n?[0,0,0]:[0,0];let e=0,s=0,o=0,u=0;for(let l=0,h=t.length;l<h-1;l++){const h=t[l],c=t[l+1];if(h&&c){i[0]=h[0],i[1]=h[1],r[0]=c[0],r[1]=c[1],n&&h.length>2&&c.length>2&&(i[2]=h[2],r[2]=c[2]);const t=A(i,r);if(t){e+=t;const i=b(h,c);s+=t*i[0],o+=t*i[1],n&&i.length>2&&(u+=t*i[2])}}}return e>0?n?[s/e,o/e,u/e]:[s/e,o/e]:t.length?t[0]:null}(t[0],n):null;if(!r)return null;i[0]=r[0],i[1]=r[1],n&&r.length>2&&(i[2]=r[2])}return i}function _(t,n,i){let r=0,e=0,s=0,o=0,u=0;const l=t.length?t[0][0]:0,h=t.length?t[0][1]:0,c=t.length&&n?t[0][2]:0;for(let a=0;a<t.length;a++){const f=t[a],p=t[(a+1)%t.length],[y,d,m]=f,v=y-l,g=d-h,x=n?m-c:void 0,[w,P,M]=p,R=w-l,A=P-h,N=n?M-c:void 0,O=v*A-R*g;if(o+=O,r+=(v+R)*O,e+=(g+A)*O,n&&f.length>2&&p.length>2){const t=v*N-R*x;s+=(x+N)*t,u+=t}y<i[0]&&(i[0]=y),y>i[1]&&(i[1]=y),d<i[2]&&(i[2]=d),d>i[3]&&(i[3]=d),n&&(m<i[4]&&(i[4]=m),m>i[5]&&(i[5]=m))}if(o>0&&(o*=-1),u>0&&(u*=-1),!o)return null;o*=.5,u*=.5;const a=[r/(6*o)+l,e/(6*o)+h,o];return n&&(i[4]===i[5]||0===u?(a[3]=(i[4]+i[5])/2,a[4]=0):(a[3]=s/(6*u)+c,a[4]=u)),a}function k(t){return void 0!==t.xmin&&void 0!==t.ymin&&void 0!==t.xmax&&void 0!==t.ymax}function E(t){return void 0!==t.points}function J(t){return void 0!==t.x&&void 0!==t.y}function D(t){return void 0!==t.paths}function L(t){return void 0!==t.rings}function B(t){return(n,i)=>null==n?i:null==i?n:t(n,i)}const F=B(Math.min),H=B(Math.max);function K(t,n){return D(n)?T(t,n.paths,!1,!1):L(n)?T(t,n.rings,!1,!1):E(n)?V(t,n.points,!1,!1,!1,!1):k(n)?U(t,n):(J(n)&&(t[0]=n.x,t[1]=n.y,t[2]=n.x,t[3]=n.y),t)}function Q(t,n){return D(n)?T(t,n.paths,!0,!1):L(n)?T(t,n.rings,!0,!1):E(n)?V(t,n.points,!0,!1,!0,!1):k(n)?U(t,n,0,0,!0,!1):(J(n)&&(t[0]=n.x,t[1]=n.y,t[2]=n.z,t[3]=n.x,t[4]=n.y,t[5]=n.z),t)}function T(t,n,i,r){const e=i?3:2;if(!n.length||!n[0].length)return null;let s,o,u,l,[h,c]=n[0][0],[a,f]=n[0][0];for(let t=0;t<n.length;t++){const p=n[t];for(let t=0;t<p.length;t++){const n=p[t],[y,d]=n;if(h=F(h,y),c=F(c,d),a=H(a,y),f=H(f,d),i&&n.length>2){const t=n[2];s=F(s,t),o=H(o,t)}if(r&&n.length>e){const t=n[e];u=F(s,t),l=H(o,t)}}}return i?r?(t[0]=h,t[1]=c,t[2]=s,t[3]=u,t[4]=a,t[5]=f,t[6]=o,t[7]=l,t.length=8,t):(t[0]=h,t[1]=c,t[2]=s,t[3]=a,t[4]=f,t[5]=o,t.length=6,t):r?(t[0]=h,t[1]=c,t[2]=u,t[3]=a,t[4]=f,t[5]=l,t.length=6,t):(t[0]=h,t[1]=c,t[2]=a,t[3]=f,t.length=4,t)}function U(t,n,i,r,e,s){const o=n.xmin,u=n.xmax,l=n.ymin,h=n.ymax;let c=n.zmin,a=n.zmax,f=n.mmin,p=n.mmax;return e?(c=c||0,a=a||0,s?(f=f||0,p=p||0,t[0]=o,t[1]=l,t[2]=c,t[3]=f,t[4]=u,t[5]=h,t[6]=a,t[7]=p,t):(t[0]=o,t[1]=l,t[2]=c,t[3]=u,t[4]=h,t[5]=a,t)):s?(f=f||0,p=p||0,t[0]=o,t[1]=l,t[2]=f,t[3]=u,t[4]=h,t[5]=p,t):(t[0]=o,t[1]=l,t[2]=u,t[3]=h,t)}function V(t,n,i,r,e,s){const o=i?3:2,u=r&&s,l=i&&e;if(!n.length||!n[0].length)return null;let h,c,a,f,[p,y]=n[0],[d,m]=n[0];for(let t=0;t<n.length;t++){const i=n[t],[r,e]=i;if(p=F(p,r),y=F(y,e),d=H(d,r),m=H(m,e),l&&i.length>2){const t=i[2];h=F(h,t),c=H(c,t)}if(u&&i.length>o){const t=i[o];a=F(h,t),f=H(c,t)}}return e?(h=h||0,c=c||0,s?(a=a||0,f=f||0,t[0]=p,t[1]=y,t[2]=h,t[3]=a,t[4]=d,t[5]=m,t[6]=c,t[7]=f,t):(t[0]=p,t[1]=y,t[2]=h,t[3]=d,t[4]=m,t[5]=c,t)):s?(a=a||0,f=f||0,t[0]=p,t[1]=y,t[2]=a,t[3]=d,t[4]=m,t[5]=f,t):(t[0]=p,t[1]=y,t[2]=d,t[3]=m,t)}const W=[];function X(t,n,i,r){return{xmin:t,ymin:n,xmax:i,ymax:r}}function Y(t,n,i,r,e,s){return{xmin:t,ymin:n,zmin:i,xmax:r,ymax:e,zmax:s}}function $(t,n,i,r,e,s){return{xmin:t,ymin:n,mmin:i,xmax:r,ymax:e,mmax:s}}function tt(t,n,i,r,e,s,o,u){return{xmin:t,ymin:n,zmin:i,mmin:r,xmax:e,ymax:s,zmax:o,mmax:u}}function nt(t,n=!1,i=!1){return n?i?tt(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7]):Y(t[0],t[1],t[2],t[3],t[4],t[5]):i?$(t[0],t[1],t[2],t[3],t[4],t[5]):X(t[0],t[1],t[2],t[3])}function it(t){return t?function(t){return void 0!==t.xmin&&void 0!==t.ymin&&void 0!==t.xmax&&void 0!==t.ymax}(t)?t:function(t){return void 0!==t.x&&void 0!==t.y}(t)?function(t){const{x:n,y:i,z:r,m:e}=t,s=null!=e;return null!=r?s?tt(n,i,r,e,n,i,r,e):Y(n,i,r,n,i,r):s?$(n,i,e,n,i,e):X(n,i,n,i)}(t):function(t){return void 0!==t.rings}(t)?rt(t):function(t){return void 0!==t.paths}(t)?et(t):function(t){return void 0!==t.points}(t)?function(t){const{hasZ:n,hasM:i,points:r}=t;return nt(V(W,r,n,i),n,i)}(t):null:null}function rt(t){const{hasZ:n,hasM:i,rings:r}=t,e=T(W,r,n,i);return e?nt(e,n,i):null}function et(t){const{hasZ:n,hasM:i,paths:r}=t,e=T(W,r,n,i);return e?nt(e,n,i):null}var st;function ot(t){return!Array.isArray(t[0])}let ut=st=class extends e{constructor(...t){super(...t),this.rings=[],this.type="polygon"}static fromExtent(t){const n=t.clone().normalize(),i=t.spatialReference;let r=!1,e=!1;for(const t of n)t.hasZ&&(r=!0),t.hasM&&(e=!0);const s={rings:n.map((function(t){const n=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(r&&t.hasZ){const i=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<n.length;t++)n[t].push(i)}if(e&&t.hasM){const i=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<n.length;t++)n[t].push(i)}return n})),spatialReference:i};return r&&(s.hasZ=!0),e&&(s.hasM=!0),new st(s)}normalizeCtorArgs(t,n){let i,r,e=null,s=null;return t&&!Array.isArray(t)?(e=t.rings?t.rings:null,n||(t.spatialReference?n=t.spatialReference:t.rings||(n=t)),i=t.hasZ,r=t.hasM):e=t,e=e||[],e.length&&e[0]&&null!=e[0][0]&&"number"==typeof e[0][0]&&(e=[e]),s=e[0]&&e[0][0],s&&(void 0===i&&void 0===r?(i=s.length>2,r=s.length>3):void 0===i?i=r?s.length>3:s.length>2:void 0===r&&(r=i?s.length>3:s.length>2)),{rings:e,spatialReference:n=n||d.WGS84,hasZ:i,hasM:r}}get cache(){return this.commitProperty("rings"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get centroid(){const t=C(this);if(!t||isNaN(t[0])||isNaN(t[1])||this.hasZ&&isNaN(t[2]))return null;const n=new u;return n.x=t[0],n.y=t[1],n.spatialReference=this.spatialReference,this.hasZ&&(n.z=t[2]),n}get extent(){const{spatialReference:t}=this,n=rt(this);if(!n)return null;const i=new s(n);return i.spatialReference=t,i}get isSelfIntersecting(){return h(this.rings)}writeRings(t,n){n.rings=o(this.rings)}addRing(t){if(!t)return;const n=this.rings,i=n.length;if(ot(t)){const r=[];for(let n=0,i=t.length;n<i;n++)r[n]=t[n].toArray();n[i]=r}else n[i]=t.concat();return this.notifyChange("rings"),this}clone(){const t=new st;return t.spatialReference=this.spatialReference,t.rings=o(this.rings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}equals(t){if(this===t)return!0;if(c(t))return!1;const n=this.spatialReference,i=t.spatialReference;if(a(n)!==a(i))return!1;if(a(n)&&a(i)&&!n.equals(i))return!1;if(this.rings.length!==t.rings.length)return!1;const r=([t,n,i,r],[e,s,o,u])=>t===e&&n===s&&(null==i&&null==o||i===o)&&(null==r&&null==u||r===u);for(let n=0;n<this.rings.length;n++)if(!f(this.rings[n],t.rings[n],r))return!1;return!0}contains(t){if(!t)return!1;const n=p(t,this.spatialReference);return y(this,a(n)?n:t)}isClockwise(t){let n;return n=ot(t)?t.map((t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y])):t,z(n,this.hasM,this.hasZ)}getPoint(t,n){if(!this._validateInputs(t,n))return null;const i=this.rings[t][n],r=this.hasZ,e=this.hasM;return r&&!e?new u(i[0],i[1],i[2],void 0,this.spatialReference):e&&!r?new u(i[0],i[1],void 0,i[2],this.spatialReference):r&&e?new u(i[0],i[1],i[2],i[3],this.spatialReference):new u(i[0],i[1],this.spatialReference)}insertPoint(t,n,i){return this._validateInputs(t,n,!0)?(g(this,i),Array.isArray(i)||(i=i.toArray()),this.rings[t].splice(n,0,i),this.notifyChange("rings"),this):this}removePoint(t,n){if(!this._validateInputs(t,n))return null;const i=new u(this.rings[t].splice(n,1)[0],this.spatialReference);return this.notifyChange("rings"),i}removeRing(t){if(!this._validateInputs(t,null))return null;const n=this.rings.splice(t,1)[0],i=this.spatialReference,r=n.map((t=>new u(t,i)));return this.notifyChange("rings"),r}setPoint(t,n,i){return this._validateInputs(t,n)?(g(this,i),Array.isArray(i)||(i=i.toArray()),this.rings[t][n]=i,this.notifyChange("rings"),this):this}_validateInputs(t,n,i=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=n){const r=this.rings[t];if(i&&(n<0||n>r.length))return!1;if(!i&&(n<0||n>=r.length))return!1}return!0}toJSON(t){return this.write({},t)}};t([n({readOnly:!0})],ut.prototype,"cache",null),t([n({readOnly:!0})],ut.prototype,"centroid",null),t([n({readOnly:!0})],ut.prototype,"extent",null),t([n({readOnly:!0})],ut.prototype,"isSelfIntersecting",null),t([n({type:[[[Number]]],json:{write:{isRequired:!0}}})],ut.prototype,"rings",void 0),t([i("rings")],ut.prototype,"writeRings",null),ut=st=t([r("esri.geometry.Polygon")],ut),ut.prototype.toJSON.isDefaultToJSON=!0;const lt=ut;var ht;let ct=ht=class extends e{constructor(...t){super(...t),this.paths=[],this.type="polyline"}normalizeCtorArgs(t,n){let i,r,e=null,s=null;return t&&!Array.isArray(t)?(e=t.paths?t.paths:null,n||(t.spatialReference?n=t.spatialReference:t.paths||(n=t)),i=t.hasZ,r=t.hasM):e=t,e=e||[],e.length&&e[0]&&null!=e[0][0]&&"number"==typeof e[0][0]&&(e=[e]),s=e[0]&&e[0][0],s&&(void 0===i&&void 0===r?(i=s.length>2,r=!1):void 0===i?i=!r&&s.length>3:void 0===r&&(r=!i&&s.length>3)),{paths:e,spatialReference:n=n||d.WGS84,hasZ:i,hasM:r}}get cache(){return this.commitProperty("paths"),this.commitProperty("hasZ"),this.commitProperty("hasM"),this.commitProperty("spatialReference"),{}}get extent(){const{spatialReference:t}=this,n=et(this);if(!n)return null;const i=new s(n);return i.spatialReference=t,i}writePaths(t,n){n.paths=o(this.paths)}addPath(t){if(!t)return;const n=this.paths,i=n.length;if(function(t){return!Array.isArray(t[0])}(t)){const r=[];for(let n=0,i=t.length;n<i;n++)r[n]=t[n].toArray();n[i]=r}else n[i]=t.concat();return this.notifyChange("paths"),this}clone(){const t=new ht;return t.spatialReference=this.spatialReference,t.paths=o(this.paths),t.hasZ=this.hasZ,t.hasM=this.hasM,t}getPoint(t,n){if(!this._validateInputs(t,n))return null;const i=this.paths[t][n],r=this.hasZ,e=this.hasM;return r&&!e?new u(i[0],i[1],i[2],void 0,this.spatialReference):e&&!r?new u(i[0],i[1],void 0,i[2],this.spatialReference):r&&e?new u(i[0],i[1],i[2],i[3],this.spatialReference):new u(i[0],i[1],this.spatialReference)}insertPoint(t,n,i){return this._validateInputs(t,n,!0)?(g(this,i),Array.isArray(i)||(i=i.toArray()),this.paths[t].splice(n,0,i),this.notifyChange("paths"),this):this}removePath(t){if(!this._validateInputs(t,null))return null;const n=this.paths.splice(t,1)[0],i=this.spatialReference,r=n.map((t=>new u(t,i)));return this.notifyChange("paths"),r}removePoint(t,n){if(!this._validateInputs(t,n))return null;const i=new u(this.paths[t].splice(n,1)[0],this.spatialReference);return this.notifyChange("paths"),i}setPoint(t,n,i){return this._validateInputs(t,n)?(g(this,i),Array.isArray(i)||(i=i.toArray()),this.paths[t][n]=i,this.notifyChange("paths"),this):this}_validateInputs(t,n,i=!1){if(null==t||t<0||t>=this.paths.length)return!1;if(null!=n){const r=this.paths[t];if(i&&(n<0||n>r.length))return!1;if(!i&&(n<0||n>=r.length))return!1}return!0}toJSON(t){return this.write({},t)}};t([n({readOnly:!0})],ct.prototype,"cache",null),t([n({readOnly:!0})],ct.prototype,"extent",null),t([n({type:[[[Number]]],json:{write:{isRequired:!0}}})],ct.prototype,"paths",void 0),t([i("paths")],ct.prototype,"writePaths",null),ct=ht=t([r("esri.geometry.Polyline")],ct),ct.prototype.toJSON.isDefaultToJSON=!0;const at=ct,ft=m()({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon"}),pt=m()({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh"}),yt={base:e,key:"type",typeMap:{extent:s,multipoint:M,point:u,polyline:at,polygon:lt}};v(yt);export{ft as a,M as b,R as c,I as d,C as e,z as f,K as g,it as h,yt as i,Q as j,j as k,Z as l,at as m,q as n,O as o,T as p,b as q,G as s,pt as t,S as u,lt as v}