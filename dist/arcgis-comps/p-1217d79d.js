import{m as t,v as e,t as s,r as i,a7 as r,_ as n,k as h,c0 as o,aw as a,a0 as c,ae as u,bc as l,N as d,O as f,e as p,i as y,d as g,bS as m,aq as w,aJ as v,bY as b,c3 as _,bG as M,bF as S,aQ as x,aG as j}from"./p-9ae46e68.js";import{d as k}from"./p-6ebb24ba.js";import{j as F}from"./p-523f37cd.js";import{n as q,m as I,c as A,u as C,i as R,Q as T,a as E,M as O}from"./p-4003c7ae.js";import{V as P}from"./p-574af054.js";import{d as U}from"./p-5a0fe1d0.js";import{r as G,o as D,l as N}from"./p-1584b803.js";import{y as L}from"./p-844dad6c.js";import{l as z}from"./p-4681e856.js";import{s as B}from"./p-685003b3.js";import{q as $}from"./p-75a0302a.js";import{d as V,y as Q}from"./p-3ffd0931.js";import{d as Y,u as X,P as J}from"./p-d778cb09.js";import{a as W}from"./p-c7a0a732.js";import{s as H,t as Z,o as K}from"./p-b2d0e2de.js";import{A as tt}from"./p-9dcf03f7.js";import{q as et,c as st}from"./p-3048cc18.js";import{y as it}from"./p-79553c8d.js";import{m as rt,a as nt,y as ht}from"./p-30ddb3a0.js";import{b as ot}from"./p-f42060e0.js";import{s as at}from"./p-fb9c0392.js";import{a as ct,i as ut,h as lt,l as dt}from"./p-1f10277d.js";import{F as ft,I as pt,k as yt,a9 as gt,a3 as mt}from"./p-566b0715.js";import{t as wt}from"./p-3d1b25b6.js";import{f as vt,g as bt}from"./p-47f143cb.js";import{o as _t}from"./p-47e1bd73.js";import"./p-84bf99cb.js";import"./p-4fd6e394.js";import"./p-fe01b82b.js";import"./p-81e5b36e.js";import"./p-db87794e.js";import"./p-3a2e88bf.js";import"./p-8031c809.js";import"./p-27ef204b.js";import"./p-b74f39e0.js";import"./p-06d309e6.js";import"./p-007111db.js";import"./p-0659cf81.js";import"./p-8ac97b63.js";import"./p-5ee2f7e2.js";import"./p-8d03d70f.js";import"./p-59312e26.js";import"./p-f8afda5b.js";import"./p-e5429b9e.js";import"./p-32462343.js";import"./p-22c8d854.js";import"./p-16def889.js";import"./p-7c7c5507.js";import"./p-0509f8e7.js";import"./p-b392deaf.js";import"./p-9739c166.js";import"./p-2a252a78.js";import"./p-8e03c038.js";import"./p-2b250922.js";import"./p-285c6a34.js";import"./p-bae36c84.js";import"./p-138c2b2c.js";import"./p-50ff864e.js";const Mt=268435455;class St{constructor(){this.fieldMap=new Map,this.fields=[],this.hasFeatures=!1,this.fieldCount=0,this.featureCount=0,this.objectIdFieldIndex=0,this.vertexCount=0,this.offsets={attributes:new Array,geometry:new Array},this.centroid=new Array}hasField(t){return this.fieldMap.has(t)}isDateField(t){var e;return null==(e=this.fieldMap.get(t))?void 0:e.isDate}getFieldIndex(t){var e;return null==(e=this.fieldMap.get(t))?void 0:e.index}}function xt(t){const e=t.getLength(),s=t.pos()+e,i={name:"",isDate:!1};for(;t.pos()<s&&t.next();)switch(t.tag()){case 1:i.name=t.getString();break;case 2:"esriFieldTypeDate"===st(t.getEnum())&&(i.isDate=!0);break;default:t.skip()}return i}function jt(t){return t.toLowerCase().trim()}function kt(e,s,i=!1){const r=e.pos(),n=new St;let h=0,o=0,a=null,c=null,u=null,l=!1;for(;e.next();)switch(e.tag()){case 1:a=e.getString();break;case 3:c=e.getString();break;case 12:u=e.processMessage(et);break;case 9:if(n.exceededTransferLimit=e.getBool(),n.exceededTransferLimit){n.offsets.geometry=i?new Float64Array(8e3):new Int32Array(8e3),n.centroid=i?new Float64Array(16e3):new Int32Array(16e3);for(let t=0;t<n.centroid.length;t++)n.centroid[t]=Mt}break;case 13:{const t=xt(e),s=t.name,i=jt(t.name),r={fieldName:s,index:h++,isDate:t.isDate};n.fields.push(r),n.fieldMap.set(t.name,r),n.fieldMap.set(i,r);break}case 15:{const t=e.getLength(),r=e.pos()+t;if(!n.exceededTransferLimit){const t=n.centroid;n.offsets.geometry.push(0),t.push(Mt),t.push(Mt)}!l&&n.exceededTransferLimit&&(l=!0,n.offsets.attributes=i?new Float64Array(8e3*h):new Uint32Array(8e3*h));let a=o*h;for(;e.pos()<r&&e.next();)switch(e.tag()){case 1:{l?n.offsets.attributes[a++]=e.pos():n.offsets.attributes.push(e.pos());const t=e.getLength();e.skipLen(t);break}case 2:if(s){const t=e.getLength(),s=e.pos()+t;for(;e.pos()<s&&e.next();)switch(e.tag()){case 3:{e.getUInt32();const t=e.getSInt64(),s=e.getSInt64();n.centroid[2*o]=t,n.centroid[2*o+1]=s;break}default:e.skip()}}else{n.offsets.geometry[o]=e.pos();const t=e.getLength();n.vertexCount+=t,e.skipLen(t)}break;case 4:{const t=e.getLength(),s=e.pos()+t;for(;e.pos()<s&&e.next();)switch(e.tag()){case 3:{e.getUInt32();const t=e.getSInt64(),s=e.getSInt64();n.centroid[2*o]=t,n.centroid[2*o+1]=s;break}default:e.skip()}break}default:e.skip()}o++,n.hasFeatures=!0;break}default:e.skip()}const d=a||c;if(!d)throw new t("FeatureSet has no objectId or globalId field name");return n.featureCount=o,n.fieldCount=h,n.objectIdFieldIndex=n.getFieldIndex(d),n.transform=u,n.displayIds=new Uint32Array(n.featureCount),n.groupIds=new Uint16Array(n.featureCount),e.move(r),n}const Ft=e.getLogger("esri.view.2d.layers.features.support.FeatureSetReaderPBF"),qt=268435455,It={small:{delta:new Int32Array(128),decoded:new Int32Array(128)},large:{delta:new Int32Array(128e3),decoded:new Int32Array(128e3)}};function At(t){return t<=It.small.delta.length?It.small:(t<=It.large.delta.length||(It.large.delta=new Int32Array(Math.round(1.25*t)),It.large.decoded=new Int32Array(Math.round(1.25*t))),It.large)}function Ct(e){try{const t=2,s=new W(new Uint8Array(e),new DataView(e));for(;s.next();){if(s.tag()===t)return Rt(s.getMessage());s.skip()}}catch(e){const s=new t("query:parsing-pbf","Error while parsing FeatureSet PBF payload",{error:e});Ft.error(s)}return null}function Rt(t){for(;t.next();){if(1===t.tag())return t.getMessage();t.skip()}return null}function Tt(t,e,s,i,r,n){return.5*Math.abs(t*i+s*n+r*e-t*n-s*e-r*i)}function Et(t,e,s,i){return 0==t*i-s*e&&t*s+e*i>0}class Ot extends tt{constructor(t,e,s,i){super(t),this._hasNext=!1,this._isPoints=!1,this._featureIndex=-1,this._featureOffset=0,this._cache={area:0,unquantGeometry:void 0,geometry:void 0,centroid:void 0,legacyFeature:void 0,optFeature:void 0},this._geometryType=i,this._reader=e,this._header=s,this._hasNext=s.hasFeatures,this._isPoints="esriGeometryPoint"===i}static fromBuffer(t,e,s=!1){const i=Ct(t),r=kt(i,"esriGeometryPoint"===e,s),n=tt.createInstance();return new Ot(n,i,r,e)}get geometryType(){return this._geometryType}get size(){return this._header.featureCount}get hasZ(){return!1}get hasM(){return!1}get stride(){return 2+(this.hasZ?1:0)+(this.hasM?1:0)}get hasFeatures(){return this._header.hasFeatures}get hasNext(){return this._hasNext}get exceededTransferLimit(){return this._header.exceededTransferLimit}getSize(){return this.size}getQuantizationTransform(){return this._header.transform}getCursor(){return this.copy()}getIndex(){return this._featureIndex}setIndex(t){this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0,this._featureIndex=t}getAttributeHash(){let t="";return this._header.fields.forEach((({index:e})=>{t+=this._readAttributeAtIndex(e)+"."})),t}getObjectId(){return this._readAttributeAtIndex(this._header.objectIdFieldIndex)}getDisplayId(){return this._header.displayIds[this._featureIndex]}setDisplayId(t){this._header.displayIds[this._featureIndex]=t}getGroupId(){return this._header.groupIds[this._featureIndex]}setGroupId(t){this._header.groupIds[this._featureIndex]=t}readLegacyFeature(){if(void 0===this._cache.legacyFeature){var t;const e=this.readCentroid(),s={attributes:this.readAttributes(),geometry:this._isPoints?this.readLegacyPointGeometry():this.readLegacyGeometry(),centroid:null!=(t=e&&{x:e.coords[0],y:e.coords[1]})?t:null};return this._cache.legacyFeature=s,s}return this._cache.legacyFeature}readOptimizedFeature(){if(void 0===this._cache.optFeature){const t=new H(this.readGeometry(),this.readAttributes(),this.readCentroid());return t.objectId=this.getObjectId(),t.displayId=this.getDisplayId(),this._cache.optFeature=t,t}return this._cache.optFeature}getXHydrated(){const t=this._header.centroid[2*this._featureIndex],e=this.getQuantizationTransform();return s(e)?t:t*e.scale[0]+e.translate[0]}getYHydrated(){const t=this._header.centroid[2*this._featureIndex+1],e=this.getQuantizationTransform();return s(e)?t:e.translate[1]-t*e.scale[1]}getX(){return this._header.centroid[2*this._featureIndex]*this._sx+this._tx}getY(){return this._header.centroid[2*this._featureIndex+1]*this._sy+this._ty}readLegacyPointGeometry(){return{x:this.getX(),y:this.getY()}}readLegacyGeometry(t){const e=this.readGeometry(t);return q(e,this.geometryType,!1,!1)}readLegacyCentroid(){const t=this.readCentroid();if(!t)return null;const[e,s]=t.coords;return{x:e,y:s}}readGeometryArea(){return this._cache.area||this.readGeometry(!0),this._cache.area}readUnquantizedGeometry(t=!1){if(void 0===this._cache.unquantGeometry){const e=this.readGeometry(t);if(!e)return this._cache.unquantGeometry=null,null;const s=At(e.coords.length).decoded,i=e.clone(s),r=i.coords;let n=0;for(const t of i.lengths){for(let e=1;e<t;e++){const t=2*(n+e),s=2*(n+e-1);r[t]+=r[s],r[t+1]+=r[s+1]}n+=t}return this._cache.unquantGeometry=i,i}return this._cache.unquantGeometry}readHydratedGeometry(){if(this._isPoints){if(this._header.centroid[2*this._featureIndex]===qt)return null;const t=this.getXHydrated(),e=this.getYHydrated();return new Z([],[t,e])}const t=this.readGeometry();if(!t)return null;const e=t.clone(),s=this.getQuantizationTransform();return i(s)&&I(e,e,this.hasZ,this.hasM,s),e}readGeometry(t=!1){if(void 0===this._cache.geometry){let e=null;if(this._isPoints){if(this._header.centroid[2*this._featureIndex]===qt)return null;const t=this.getX(),s=this.getY();e=new Z([],[t,s])}else{const s=this._header.offsets.geometry[this._featureIndex],i=this._reader;if(0===s)return null;i.move(s);try{e=t?this._parseGeometryForDisplay(i):this._parseGeometry(i)}catch(t){return console.error("Failed to parse geometry!",t),null}}return this._cache.geometry=e,e}return this._cache.geometry}readCentroid(){if(void 0===this._cache.centroid){let t=null;const e=this._header.centroid[2*this._featureIndex]+this._tx,s=this._header.centroid[2*this._featureIndex+1]+this._ty;return e===qt?(t=this._computeCentroid(),t&&(this._header.centroid[2*this._featureIndex]=t.coords[0]-this._tx,this._header.centroid[2*this._featureIndex+1]=t.coords[1]-this._ty)):t=new Z([],[e,s]),this._cache.centroid=t,t}return this._cache.centroid}copy(){const t=this._reader.clone(),e=new Ot(this.instance,t,this._header,this.geometryType);return this.copyInto(e),e}next(){for(this._cache.area=0,this._cache.unquantGeometry=void 0,this._cache.geometry=void 0,this._cache.centroid=void 0,this._cache.legacyFeature=void 0,this._cache.optFeature=void 0;++this._featureIndex<this.size&&!this._getExists(););return this._featureIndex<this.size}_readAttribute(t,e){const s=this._header.hasField(t)?t:function(t){return t.toLowerCase().trim()}(t),i=this._header.getFieldIndex(s);if(null==i)return;const r=this._readAttributeAtIndex(i);return e?null==r?r:this._header.isDateField(s)?new Date(r):r:r}_readAttributes(){const t={};return this._header.fields.forEach((({fieldName:e,index:s})=>{t[e]=this._readAttributeAtIndex(s)})),t}copyInto(t){super.copyInto(t),t._featureIndex=this._featureIndex,t._featureOffset=this._featureOffset,t._hasNext=this._hasNext}_readAttributeAtIndex(t){const e=this._reader;return e.move(this._header.offsets.attributes[this._featureIndex*this._header.fieldCount+t]),function(t){const e=t.getLength(),s=t.pos()+e;for(;t.pos()<s&&t.next();)switch(t.tag()){case 1:return t.getString();case 2:return t.getFloat();case 3:return t.getDouble();case 4:return t.getSInt32();case 5:return t.getUInt32();case 6:return t.getInt64();case 7:return t.getUInt64();case 8:return t.getSInt64();case 9:return t.getBool();default:return t.skip(),null}return null}(e)}_parseGeometry(t){const e=t.getLength(),s=t.pos()+e,i=[],r=[];for(;t.pos()<s&&t.next();)switch(t.tag()){case 2:{const e=t.getUInt32(),s=t.pos()+e;for(;t.pos()<s;)r.push(t.getUInt32());break}case 3:{const e=t.getUInt32(),s=t.pos()+e;for(i.push(t.getSInt32()+this._tx),i.push(t.getSInt32()+this._ty),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();t.pos()<s;)i.push(t.getSInt32()),i.push(t.getSInt32()),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();break}default:t.skip()}return new Z(r,i)}_parseGeometryForDisplay(t){const e=t.getLength(),s=t.pos()+e,i=[],r=[];let n=0,h=0,o=null,a=0;const c="esriGeometryPolygon"===this.geometryType;for(;t.pos()<s&&t.next();)switch(t.tag()){case 2:{const e=t.getUInt32(),s=t.pos()+e;for(;t.pos()<s;){const e=t.getUInt32();i.push(e),n+=e}o=At(2*n).delta;break}case 3:{t.getUInt32();const e=2+(this.hasZ?1:0)+(this.hasM?1:0);for(const s of i)if(h+e*s>o.length)for(let e=0;e<s;e++)t.getSInt32(),t.getSInt32(),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();else if(c){const e=this.getAreaSimplificationThreshold(s,this._header.vertexCount);let i=2,n=1;const c=!1;let u=t.getSInt32(),l=t.getSInt32();o[h++]=u,o[h++]=l,this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();let d=t.getSInt32(),f=t.getSInt32();for(this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();i<s;){let s=t.getSInt32(),r=t.getSInt32();this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32();const c=u+d,p=l+f;Tt(u,l,c,p,c+s,p+r)>=e?(a+=-.5*(c-u)*(p+l),n>1&&Et(o[h-2],o[h-1],d,f)?(o[h-2]+=d,o[h-1]+=f):(o[h++]=d,o[h++]=f,n++),u=c,l=p):(s+=d,r+=f),d=s,f=r,i++}n<3||c?h-=2*n:(a+=-.5*(u+d-u)*(l+f+l),Et(o[h-2],o[h-1],d,f)?(o[h-2]+=d,o[h-1]+=f,r.push(n)):(o[h++]=d,o[h++]=f,r.push(++n)))}else{let e=0,i=t.getSInt32(),n=t.getSInt32();this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32(),o[h++]=i,o[h++]=n,e+=1;for(let r=1;r<s;r++){const s=t.getSInt32(),c=t.getSInt32(),u=i+s,l=n+c;a+=-.5*(u-i)*(l+n),this.hasZ&&t.getSInt32(),this.hasM&&t.getSInt32(),r>2&&Et(o[h-2],o[h-1],s,c)?(o[h-2]+=s,o[h-1]+=c):(o[h++]=s,o[h++]=c,e+=1),i=u,n=l}r.push(e)}break}default:t.skip()}if(this._cache.area=a,!r.length)return null;if(this._tx||this._ty){let t=0;for(const e of r)o[2*t]+=this._tx,o[2*t+1]+=this._ty,t+=e}return new Z(r,o)}}class Pt{constructor(t){this.service=t}destroy(){}}class Ut extends Pt{constructor(t){super(t),this._portsOpen=async function(t){const e=new z;return await e.open(t,{}),e}(t.source).then((t=>this.client=t))}destroy(){this.client.close(),this.client=null}async executeQuery(t,e){await this._portsOpen;const s=await this.client.invoke("queryFeatures",t.toJSON(),e);return Y.fromFeatureSet(s,this.service.objectIdField)}}class Gt extends Pt{async executeQuery(t,e){const{data:s}=await V(this.service.source,t,e);return Ot.fromBuffer(s,this.service.geometryType,!t.quantizationParameters)}}class Dt extends Pt{async executeQuery(t,e){const{source:s,capabilities:r,spatialReference:h,objectIdField:o,geometryType:a}=this.service;if(i(t.quantizationParameters)&&!r.query.supportsQuantization){const i=t.clone(),r=B(n(i.quantizationParameters));i.quantizationParameters=null;const{data:a}=await Q(s,i,h,e),c=A(a,o);return C(r,c),Y.fromOptimizedFeatureSet(c)}const{data:c}=await Q(s,t,this.service.spatialReference,e);return"esriGeometryPoint"===a&&(c.features=c.features.filter((t=>{if(i(t.geometry)){const e=t.geometry;return Number.isFinite(e.x)&&Number.isFinite(e.y)}return!0}))),Y.fromFeatureSet(c,this.service.objectIdField)}}class Nt extends Pt{async executeQuery(t,e){const{capabilities:s}=this.service;if(t.quantizationParameters&&!s.query.supportsQuantization){const s=t.clone(),i=B(n(s.quantizationParameters));s.quantizationParameters=null;const r=await $(this.service.source,t,e);return C(i,r),Y.fromOptimizedFeatureSet(r)}const i=await $(this.service.source,t,e);return Y.fromOptimizedFeatureSet(i)}}class Lt{constructor(){this.source=!1,this.targets={feature:!1,aggregate:!1},this.storage={filters:!1,data:!1},this.mesh=!1,this.queryFilter=!1,this.why={mesh:[],source:[]}}static create(t){const e=new Lt;for(const s in t){const i=t[s];if("object"==typeof i)for(const t in i)e[s][t]=i[t];e[s]=i}return e}static empty(){return Lt.create({})}static all(){return Lt.create({source:!0,targets:{feature:!0,aggregate:!0},storage:{filters:!0,data:!0},mesh:!0})}unset(t){t.source&&(this.source=!1),t.targets.feature&&(this.targets.feature=!1),t.targets.aggregate&&(this.targets.aggregate=!1),t.storage.filters&&(this.storage.filters=!1),t.storage.data&&(this.storage.data=!1),t.mesh&&(this.mesh=!1),t.queryFilter&&(this.queryFilter=!1)}any(){return this.source||this.mesh||this.storage.filters||this.storage.data||this.targets.feature||this.targets.aggregate||this.queryFilter}describe(){let t=0,e="";if(this.mesh){t+=20,e+="-> (20) Mesh needs update\n";for(const t of this.why.mesh)e+=`    + ${t}\n`}if(this.source){t+=10,e+="-> (10) The source needs update\n";for(const t of this.why.source)e+=`    + ${t}\n`}this.targets.feature&&(t+=5,e+="-> (5) Feature target parameters changed\n"),this.storage.filters&&(t+=5,e+="-> (5) Feature filter parameters changed\n"),this.targets.aggregate&&(t+=4,e+="-> (4) Aggregate target parameters changed\n"),this.storage.data&&(t+=1,e+="-> (1) Texture storage parameters changed"),console.debug(`Applying ${t<5?"Fastest":t<10?"Fast":t<15?"Moderate":t<20?"Slow":"Very Slow"} update of cost ${t}/45 `),console.debug(e)}toJSON(){return{queryFilter:this.queryFilter,source:this.source,targets:this.targets,storage:this.storage,mesh:this.mesh}}}class zt{constructor(t){this.requests={done:new Array,stream:new at(10)},this._edits=null,this._abortController=new AbortController,this._done=!1,this.didSend=!1,this.tile=t}get signal(){return this._abortController.signal}get options(){return{signal:this._abortController.signal}}get empty(){return!this.requests.done.length}get edits(){return this._edits}get done(){return this._done}end(){this._done=!0}clear(){this.requests.done=[]}applyUpdate(t){this.requests.done.forEach((e=>e.message.status.unset(t))),i(this._edits)&&this._edits.status.unset(t)}add(t){var e;t.message.status=null!=(e=t.message.status)?e:Lt.empty(),t.message.end&&this.requests.done.forEach((t=>{i(t.message)&&t.message.end&&(t.message.end=!1)})),this.requests.done.push(t)}edit(t,e){const i=t.getQuantizationTransform(),r=t.geometryType,h=Array.from(t.features()),o=[...e,...h.map((t=>t.objectId))];this.removeIds(o),this._invalidate(),s(this._edits)?this._edits={type:"append",addOrUpdate:Y.fromOptimizedFeatures(h,r,n(i)),id:this.tile.id,status:Lt.empty(),end:!0}:(this.requests.done.forEach((t=>t.message.end=!1)),n(this._edits.addOrUpdate).append(t.features()))}*readers(){for(const{message:t}of this.requests.done)i(t.addOrUpdate)&&(yield t.addOrUpdate);i(this._edits)&&i(this._edits.addOrUpdate)&&(yield this._edits.addOrUpdate)}_invalidate(){for(const t of this.requests.done)t.message.status=Lt.empty();i(this._edits)&&(this._edits.status=Lt.empty())}removeIds(t){this._invalidate();for(const{message:e}of this.requests.done){const s=e.addOrUpdate;i(s)&&(s.removeIds(t),s.isEmpty&&(e.addOrUpdate=null))}i(this._edits)&&i(this._edits.addOrUpdate)&&this._edits.addOrUpdate.removeIds(t),this.requests.done=this.requests.done.filter((t=>t.message.addOrUpdate||t.message.end))}abort(){this._abortController.abort()}}class Bt{constructor(t){this.events=new h,this._resolver=o(),this._didEdit=!1,this._subscriptions=new Map,this._outSR=t.outSR,this._serviceInfo=t.serviceInfo,this._onTileUpdateMessage=t.onMessage}destroy(){}async _onMessage(t){var e;const s=this._subscriptions.get(t.id);if(!s)return;const i={...t,remove:null!=(e=t.remove)?e:[],status:t.status};return this._onTileUpdateMessage(i,s.options)}update(t,e){var s;const i=e.fields.length;e.outFields=function(t,e){const s=new Set;return t&&t.forEach((t=>s.add(t))),e&&e.forEach((t=>s.add(t))),s.has("*")?["*"]:Array.from(s)}(null==(s=this._schema)?void 0:s.outFields,e.outFields),e.outFields=e.outFields.length>=.75*i?["*"]:e.outFields,e.outFields.sort();const n=rt(this._schema,e);if(!n)return;r("esri-2d-update-debug")&&console.debug("Applying Update - Source:",n);const h="orderByFields"in this._serviceInfo&&this._serviceInfo.orderByFields?this._serviceInfo.orderByFields:this._serviceInfo.objectIdField+" ASC",o={returnCentroid:r("esri-2d-query-centroid-enabled")&&"esriGeometryPolygon"===this._serviceInfo.geometryType,returnGeometry:!0,timeReferenceUnknownClient:"stream"!==this._serviceInfo.type&&this._serviceInfo.timeReferenceUnknownClient,outFields:e.outFields,outSpatialReference:this._outSR,orderByFields:[h],where:e.definitionExpression||"1=1",gdbVersion:e.gdbVersion,historicMoment:e.historicMoment,timeExtent:it.fromJSON(e.timeExtent),customParameters:e.customParameters},a=this._schema&&nt(n,"outFields");this._schema&&ht(n,["timeExtent","definitionExpression","gdbVersion","historicMoment","customParameters"])&&(t.why.mesh.push("Layer filter and/or custom parameters changed"),t.why.source.push("Layer filter and/or custom parameters changed"),t.mesh=!0,t.source=!0,t.queryFilter=!0),a&&(t.why.source.push("Layer required fields changed"),t.source=!0),rt(o,this._queryInfo)&&(this._queryInfo=o),this._schema=e,this._resolver.resolve()}whenInitialized(){return this._resolver.promise}async applyUpdate(t){if(t.queryFilter||t.source&&this._didEdit)return this.refresh(),void(this._didEdit=!1);this._subscriptions.forEach((e=>e.applyUpdate(t))),await this.resend()}refresh(){for(const t of this._tiles())this.unsubscribe(t),this.subscribe(t)}subscribe(t){const e=new zt(t);this._subscriptions.set(t.id,e)}unsubscribe(t){const e=this.get(t.id);i(e)&&e.abort(),this._subscriptions.delete(t.id)}createQuery(t={}){const e=this._queryInfo.historicMoment?new Date(this._queryInfo.historicMoment):null;return new ot({...this._queryInfo,historicMoment:e,...t})}get(t){return this._subscriptions.has(t)?this._subscriptions.get(t):null}async queryLastEditDate(){throw new Error("Service does not support query type")}async query(t){throw new Error("Service does not support query")}*_tiles(){const t=Array.from(this._subscriptions.values());for(const e of t)yield e.tile}async edit(t,e){const s=Array.from(this._subscriptions.values()),i=s.map((({tile:t})=>t));for(const t of s)t.removeIds(e);if(t.length){const s=i.map((e=>{const s=this.createTileQuery(e);return s.objectIds=t,{tile:e,query:s}})).map((async({tile:t,query:e})=>({tile:t,result:await this.query(e),query:e}))),r=(await a(s)).map((async({tile:s,result:i})=>{if(!i.hasFeatures&&!e.length&&!t.length)return;const r=this._subscriptions.get(s.key.id);r&&r.edit(i,t)}));await c(r)}this._didEdit=!0}}const $t=e.getLogger("esri.views.2d.layers.features.sources.BaseFeatureSource");class Vt extends Bt{constructor(t){super(t),this.type="feature",this.mode="on-demand",this._adapter=function(t){const{capabilities:e}=t;return function(t){return t&&t.capabilities&&t.collection&&t.layerDefinition}(t.source)?new Nt(t):function(t){return Array.isArray(t.source)}(t)?new Ut(t):e.query.supportsFormatPBF&&r("featurelayer-pbf")?new Gt(t):new Dt(t)}(t.serviceInfo),this._queue=new ct({concurrency:8,process:async t=>{if(u(t),i(t.tile)){const e=t.tile.key.id,{signal:s}=t,i=r("esri-tiles-debug")?{tile:e.replace(/\//g,"."),depth:t.depth}:void 0,n=await this._adapter.executeQuery(t.query,{signal:s,query:{...i,...this._schema.customParameters}});return n.level=t.tile.key.level,n}return this._adapter.executeQuery(t.query,{...t,query:this._schema.customParameters})}}),this._patchQueue=new ct({concurrency:8,process:async t=>{if(u(t),i(t.tile)){const e=t.tile.key.id,{signal:s}=t,i=r("esri-tiles-debug")?{tile:e.replace(/\//g,"."),depth:t.depth}:void 0,n=await this._adapter.executeQuery(t.query,{signal:s,query:{...i,...this._schema.customParameters}});return n.level=t.tile.key.level,n}return this._adapter.executeQuery(t.query,{...t,query:this._schema.customParameters})}})}destroy(){super.destroy(),this._adapter.destroy(),this._queue.destroy(),this._patchQueue.destroy()}get updating(){return!!this._queue.length||Array.from(this._subscriptions.values()).some((t=>!t.done))}get maxRecordCountFactor(){const{query:t}=this._serviceInfo.capabilities;return t.supportsMaxRecordCountFactor?4:null}get maxPageSize(){var t;const{query:e}=this._serviceInfo.capabilities;return(null!=(t=e.maxRecordCount)?t:8e3)*l(this.maxRecordCountFactor,1)}get pageSize(){return Math.min(8e3,this.maxPageSize)}enableEvent(t,e){}subscribe(e){super.subscribe(e);const s=this._subscriptions.get(e.id);this._fetchDataTile(e).catch((s=>{d(s)||$t.error(new t("mapview-query-error","Encountered error when fetching tile",{tile:e,error:s}))})).then((()=>s.end()))}unsubscribe(t){super.unsubscribe(t)}readers(t){return this._subscriptions.get(t).readers()}async query(t){return this._adapter.executeQuery(t,{query:this._schema.customParameters})}async queryLastEditDate(){const t=this._serviceInfo.source,e={...t.query,f:"json"};return(await f(t.path,{query:e,responseType:"json"})).data.editingInfo.lastEditDate}createTileQuery(t,e={}){var s;const i=this.createQuery(e);return i.quantizationParameters=null!=(s=e.quantizationParameters)?s:t.getQuantizationParameters(),i.resultType="tile",i.geometry=t.extent,i.quantizationParameters&&"esriGeometryPolyline"===this._serviceInfo.geometryType&&(i.maxAllowableOffset=t.resolution),i}async _executePatchQuery(t,e,s,r){const n=e.clone();n.outFields=[this._serviceInfo.objectIdField,...s],n.returnCentroid=!1,n.returnGeometry=!1;const h=i(n.start)?n.start/8e3:0;return this._patchQueue.push({tile:t,query:n,signal:r.signal,depth:h})}async _resend(t,e){const{query:r,message:n}=t,h=i(r.outFields)?r.outFields:[],o=this._queryInfo.outFields,a=o.filter((t=>-1===h.indexOf(t)));if(s(n.addOrUpdate))this._onMessage({...n,type:"append"});else if(a.length)try{const t=this._subscriptions.get(n.id).tile,s=await this._executePatchQuery(t,r,a,e);u(e),r.outFields=o,n.addOrUpdate.joinAttributes(s),this._onMessage({...n,end:n.end,type:"append"})}catch(t){}else this._onMessage({...n,type:"append"})}async _resendSubscription(t){if(t.empty)return this._onMessage({id:t.tile.id,addOrUpdate:null,end:!1,type:"append"});const e=t.signal;for(const s of t.requests.done)await this._resend(s,{signal:e});return i(t.edits)?this._onMessage(t.edits):void 0}async resend(){const t=Array.from(this._subscriptions.values());await Promise.all(t.map((t=>this._resendSubscription(t))))}}const Qt=r("esri-mobile"),Yt={maxDrillLevel:Qt?1:4,maxRecordCountFactor:Qt?1:3};class Xt extends Vt{constructor(t){super(t)}async _fetchDataTile(t){const e=this._serviceInfo.capabilities.query.supportsMaxRecordCountFactor,s=this._subscriptions.get(t.key.id),i=s.signal,r=t.getQuantizationParameters();let n=0;const h=async(o,a)=>{const c=this._queryInfo,l=this.createTileQuery(o,{maxRecordCountFactor:e?Yt.maxRecordCountFactor:void 0,returnExceededLimitFeatures:!1,quantizationParameters:r});n++;try{const e=await this._queue.push({tile:t,query:l,signal:i,depth:a});if(n--,u(i),!e)return;if(c!==this._queryInfo)return void h(o,a);if(e.exceededTransferLimit&&a<Yt.maxDrillLevel){for(const t of o.createChildTiles())h(t,a+1);return}const r={id:t.id,addOrUpdate:e,end:0===n,type:"append"};s.add({query:l,message:r}),this._onMessage(r)}catch(e){d(e)||this._onMessage({id:t.id,addOrUpdate:null,end:!0,type:"append"})}};h(t,0)}}const Jt="__esri_timestamp__";class Wt{constructor(t,e,s,i,r=128){this._trackIdToObservations=new Map,this._idCounter=0,this._lastPurge=performance.now(),this._addOrUpdated=new Map,this._removed=[],this._maxAge=0,this._timeInfo=s,this._purgeOptions=i,this.store=t,this.objectIdField=e,this.purgeInterval=r,this._useGeneratedIds="__esri_stream_id__"===this.objectIdField}add(t){if(this._useGeneratedIds){const e=this._nextId();t.attributes[this.objectIdField]=e,t.objectId=e}else t.objectId=t.attributes[this.objectIdField];if(this._addOrUpdated.set(t.objectId,t),this._maxAge=Math.max(this._maxAge,t.attributes[this._timeInfo.startTimeField]),!this._timeInfo.trackIdField)return s(this._trackIdLessObservations)&&(this._trackIdLessObservations=new at(1e5)),void this._trackIdLessObservations.enqueue(t.objectId);const e=t.attributes[this._timeInfo.trackIdField];if(!this._trackIdToObservations.has(e)){const t=i(this._purgeOptions)&&null!=this._purgeOptions.maxObservations?this._purgeOptions.maxObservations:1e3,s=ft(t,0,1e3);this._trackIdToObservations.set(e,new at(s))}const r=this._trackIdToObservations.get(e).enqueue(t.objectId);i(r)&&(this._addOrUpdated.has(r)?this._addOrUpdated.delete(r):this._removed.push(r))}checkForUpdates(){const t=this._getToAdd(),e=this._getToRemove(),s=performance.now();s-this._lastPurge>=this.purgeInterval&&(this._purge(s),this._lastPurge=s);const r=[];if(i(e))for(const t of e){const e=this.store.removeById(t);i(e)&&r.push(e)}if(i(t))for(const e of t)e.attributes[Jt]=s,this.store.add(e);(t||r)&&this.store.update(t,r)}_getToAdd(){if(!this._addOrUpdated.size)return null;const t=new Array(this._addOrUpdated.size);let e=0;return this._addOrUpdated.forEach((s=>t[e++]=s)),this._addOrUpdated.clear(),t}_getToRemove(){const t=this._removed;return this._removed.length?(this._removed=[],t):null}_nextId(){const t=this._idCounter;return this._idCounter=(this._idCounter+1)%4294967294+1,t}_purge(t){const e=this._purgeOptions;i(e)&&(this._purgeSomeByDisplayCount(e),this._purgeByAge(e),this._purgeByAgeReceived(t,e),this._purgeTracks())}_purgeSomeByDisplayCount(t){if(!t.displayCount)return;let e=this.store.size;if(e>t.displayCount){if(this._timeInfo.trackIdField)for(const s of this._trackIdToObservations.values())if(e>t.displayCount&&s.size){const t=n(s.dequeue());this._removed.push(t),e--}if(i(this._trackIdLessObservations)){let s=e-t.displayCount;for(;s-- >0;){const t=this._trackIdLessObservations.dequeue();i(t)&&this._removed.push(t)}}}}_purgeByAge(t){var e;if(!t.age||null==(e=this._timeInfo)||!e.startTimeField)return;const s=this._maxAge-60*t.age*1e3;this.store.forEach((t=>{t.attributes[this._timeInfo.startTimeField]<s&&this._removed.push(t.objectId)}))}_purgeByAgeReceived(t,e){if(!e.ageReceived)return;const s=t-60*e.ageReceived*1e3;this.store.forEach((t=>{t.attributes[Jt]<s&&this._removed.push(t.objectId)}))}_purgeTracks(){this._trackIdToObservations.forEach(((t,e)=>{0===t.size&&this._trackIdToObservations.delete(e)}))}}let Ht=class extends(h.EventedMixin(k)){onFeature(t){this.emit("feature",t)}};Ht=p([y("esri.layers.graphics.sources.connections.StreamConnection")],Ht);const Zt=Ht,Kt=e.getLogger("esri.layers.graphics.sources.connections.WebSocketConnection");var te;!function(t){t[t.CONNECTING=0]="CONNECTING",t[t.OPEN=1]="OPEN",t[t.CLOSING=2]="CLOSING",t[t.CLOSED=3]="CLOSED"}(te||(te={}));let ee=class extends Zt{constructor(t){super(),this.errorString=null;const{geometryType:e,spatialReference:s,sourceSpatialReference:i}=t;this._config=t,this._featureZScaler=wt(e,i,s),this._open()}async _open(){await this._tryCreateWebSocket(),this.destroyed||await this._handshake()}destroy(){i(this._websocket)&&(this._websocket.onopen=null,this._websocket.onclose=null,this._websocket.onerror=null,this._websocket.onmessage=null,this._websocket.close()),this._websocket=null}get connectionStatus(){if(s(this._websocket))return"disconnected";switch(this._websocket.readyState){case te.CONNECTING:case te.OPEN:return"connected";case te.CLOSING:case te.CLOSED:return"disconnected"}}async _tryCreateWebSocket(e=this._config.source.path,s=1e3,i=0){try{if(this.destroyed)return;const t=m(e,this._config.customParameters);this._websocket=await this._createWebSocket(t),this.notifyChange("connectionStatus")}catch(r){const n=s/1e3;return this._config.maxReconnectionAttempts&&i>=this._config.maxReconnectionAttempts?(Kt.error(new t("websocket-connection","Exceeded maxReconnectionAttempts attempts. No further attempts will be made")),void this.destroy()):(Kt.error(new t("websocket-connection",`Failed to connect. Attempting to reconnect in ${n}s`,r)),await w(s),this._tryCreateWebSocket(e,Math.min(1.5*s,1e3*this._config.maxReconnectionInterval),i+1))}}_createWebSocket(t){return new Promise(((e,s)=>{const i=new WebSocket(t);i.onopen=()=>{if(i.onopen=null,this.destroyed)return i.onclose=null,void i.close();i.onclose=t=>this._onClose(t),i.onerror=t=>this._onError(t),i.onmessage=t=>this._onMessage(t),e(i)},i.onclose=t=>{i.onopen=i.onclose=null,s(t)}}))}async _handshake(e=1e4){const i=this._websocket;if(s(i))return;const r=o(),n=i.onmessage,{filter:h,outFields:a,spatialReference:c}=this._config;return r.timeout(e),i.onmessage=e=>{var s;let o=null;try{o=JSON.parse(e.data)}catch(t){}o&&"object"==typeof o||(Kt.error(new t("websocket-connection","Protocol violation. Handshake failed - malformed message",e.data)),r.reject(),this.destroy()),(null==(s=o.spatialReference)?void 0:s.wkid)!==(null==c?void 0:c.wkid)&&(Kt.error(new t("websocket-connection",`Protocol violation. Handshake failed - expected wkid of ${c.wkid}`,e.data)),r.reject(),this.destroy()),"json"!==o.format&&(Kt.error(new t("websocket-connection","Protocol violation. Handshake failed - format is not set",e.data)),r.reject(),this.destroy()),h&&o.filter!==h&&Kt.error(new t("websocket-connection","Tried to set filter, but server doesn't support it")),a&&o.outFields!==a&&Kt.error(new t("websocket-connection","Tried to set outFields, but server doesn't support it")),i.onmessage=n,r.resolve()},i.send(JSON.stringify({filter:h,outFields:a,format:"json",spatialReference:{wkid:c.wkid}})),r.promise}_onMessage(e){try{const s=JSON.parse(e.data);if("featureResult"!==s.type)throw new t("websocket-connection","Protocol violation - Expected to find message of type 'featureResult'",s);for(const t of s.features)i(this._featureZScaler)&&this._featureZScaler(t.geometry),this.onFeature(t)}catch(e){return Kt.error(new t("websocket-connection","Failed to parse message",e)),void this.destroy()}}_onError(t){const e="Encountered an error over WebSocket connection";this._set("errorString",e),Kt.error("websocket-connection",e)}_onClose(t){this._websocket=null,this.notifyChange("connectionStatus"),1e3!==t.code&&Kt.error("websocket-connection",`WebSocket closed unexpectedly with error code ${t.code}`),this.destroyed||this._open()}};p([g()],ee.prototype,"connectionStatus",null),p([g()],ee.prototype,"errorString",void 0),ee=p([y("esri.layers.graphics.sources.connections.WebSocketConnection")],ee);const se=e.getLogger("esri.layers.graphics.sources.connections.GeoEventConnection"),ie={maxQueryDepth:5,maxRecordCountFactor:3};let re=class extends ee{constructor(t){super({...ie,...t})}async _open(){const t=await this._fetchServiceDefinition(this._config.source);t.timeInfo.trackIdField||se.warn("GeoEvent service was configured without a TrackIdField. This may result in certain functionality being disabled. The purgeOptions.maxObservations property will have no effect.");const e=this._fetchWebSocketUrl(t.streamUrls,this._config.spatialReference);this._buddyServicesQuery||(this._buddyServicesQuery=this._queryBuddyServices()),await this._buddyServicesQuery,await this._tryCreateWebSocket(e);const{filter:s,outFields:i}=this._config;this.destroyed||this._setFilter(s,i)}_onMessage(e){let s;try{s=this._enrich(JSON.parse(e.data)),i(this._featureZScaler)&&this._featureZScaler(s.geometry)}catch(e){return void se.error(new t("geoevent-connection","Failed to parse message",e))}this.onFeature(s)}async _fetchServiceDefinition(t){const e={f:"json",...this._config.customParameters},s=f(t.path,{query:e,responseType:"json"}),i=(await s).data;return this._serviceDefinition=i,i}_fetchWebSocketUrl(t,e){const s=t[0],{urls:i,token:r}=s,n=this._inferWebSocketBaseUrl(i);return m(`${n}/subscribe`,{outSR:""+e.wkid,token:r})}_inferWebSocketBaseUrl(e){if(1===e.length)return e[0];for(const t of e)if(-1!==t.indexOf("wss"))return t;return se.error(new t("geoevent-connection","Unable to infer WebSocket url",e)),null}async _setFilter(e,i){const r=this._websocket;if(s(r)||s(e)&&s(i))return;const n=JSON.stringify({filter:this._serializeFilter(e,i)});let h=!1;const a=o();return r.onmessage=e=>{const s=JSON.parse(e.data);s.filter&&(s.error&&(se.error(new t("geoevent-connection","Failed to set service filter",s.error)),this._set("errorString",`Could not set service filter - ${s.error}`),a.reject(s.error)),r.onmessage=this._onMessage.bind(this),h=!0,a.resolve())},r.send(n),setTimeout((()=>{h||(this.destroyed||this._websocket!==r||se.error(new t("geoevent-connection","Server timed out when setting filter")),a.reject())}),1e4),a.promise}_serializeFilter(e,r){const n={};if(s(e)&&s(r))return n;if(i(e)&&e.geometry)try{const s=pt(e.geometry);if("extent"!==s.type)throw new t(`Expected extent but found type ${s.type}`);n.geometry=JSON.stringify(s.shiftCentralMeridian())}catch(e){se.error(new t("geoevent-connection","Encountered an error when setting connection geometryDefinition",e))}return i(e)&&e.where&&"1 = 1"!==e.where&&(n.where=e.where),i(r)&&(n.outFields=r.join(",")),n}_enrich(e){if(!this._relatedFeatures)return e;const s=e.attributes[this._serviceDefinition.relatedFeatures.joinField];if(!this._relatedFeatures.has(s))return se.warn("geoevent-connection","Feature join failed. Is the join field configured correctly?",e),e;const{attributes:i,geometry:r}=this._relatedFeatures.get(s);for(const t in i)e.attributes[t]=i[t];return r&&(e.geometry=r),e.geometry||e.centroid||se.error(new t("geoevent-connection","Found malformed feature - no geometry found",e)),e}async _queryBuddyServices(){try{const{relatedFeatures:t,keepLatestArchive:e}=this._serviceDefinition,s=this._queryRelatedFeatures(t),i=this._queryArchive(e);await s;const r=await i;if(!r)return;for(const t of r.features)this.onFeature(this._enrich(t))}catch(e){se.error(new t("geoevent-connection","Encountered an error when querying buddy services",{error:e}))}}async _queryRelatedFeatures(t){if(!t)return;const e=await this._queryBuddy(t.featuresUrl);this._addRelatedFeatures(e)}async _queryArchive(t){if(t)return this._queryBuddy(t.featuresUrl)}async _queryBuddy(t){const e=new((await import("./p-7e9d2371.js")).default)({url:t}),{capabilities:s}=await e.load(),i=s.query.supportsMaxRecordCountFactor,r=s.query.supportsPagination,n=s.query.supportsCentroid,h=this._config.maxRecordCountFactor,o=e.capabilities.query.maxRecordCount,a=i?o*h:o,c=new ot;if(c.outFields=l(this._config.outFields,["*"]),c.where=l(v(this._config.filter,"where"),"1=1"),c.returnGeometry=!0,c.returnExceededLimitFeatures=!0,c.outSpatialReference=yt.fromJSON(this._config.spatialReference),n&&(c.returnCentroid=!0),i&&(c.maxRecordCountFactor=h),r)return c.num=a,e.destroy(),this._queryPages(t,c);const u=await Q(t,c,this._config.sourceSpatialReference);return e.destroy(),u.data}async _queryPages(t,e,s=[],r=0){e.start=i(e.num)?r*e.num:null;const{data:n}=await Q(t,e,this._config.sourceSpatialReference);return n.exceededTransferLimit&&r<this._config.maxQueryDepth?(n.features.forEach((t=>s.push(t))),this._queryPages(t,e,s,r+1)):(s.forEach((t=>n.features.push(t))),n)}_addRelatedFeatures(t){const e=new Map,s=t.features,i=this._serviceDefinition.relatedFeatures.joinField;for(const t of s)e.set(t.attributes[i],t);this._relatedFeatures=e}};re=p([y("esri.layers.graphics.sources.connections.GeoEventConnection")],re);const ne=re;function he(t,e){const s=t.weakClone();if(i(t.geometry)){const i=E(e,t.geometry.coords[0]),r=O(e,t.geometry.coords[1]);s.geometry=new Z([],[i,r])}return s}class oe{constructor(t,e){this.onUpdate=t,this._geometryType=e,this._objectIdToFeature=new Map}get _features(){const t=[];return this._objectIdToFeature.forEach((e=>t.push(e))),t}add(t){this._objectIdToFeature.set(t.objectId,t),this._index=null}get(t){return this._objectIdToFeature.has(t)?this._objectIdToFeature.get(t):null}forEach(t){this._objectIdToFeature.forEach(t)}search(t){return this._index||(this._index=function(t,e){const s=ut(9,"esriGeometryPoint"===e?t=>i(t.geometry)?{minX:t.geometry.coords[0],minY:t.geometry.coords[1],maxX:t.geometry.coords[0],maxY:t.geometry.coords[1]}:{minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}:t=>{let e=1/0,s=1/0,r=-1/0,n=-1/0;return i(t.geometry)&&t.geometry.forEachVertex(((t,i)=>{e=Math.min(e,t),s=Math.min(s,i),r=Math.max(r,t),n=Math.max(n,i)})),{minX:e,minY:s,maxX:r,maxY:n}});return s.load(t),s}(this._features,this._geometryType)),function(t,e){return t.search({minX:e.bounds[0],minY:e.bounds[1],maxX:e.bounds[2],maxY:e.bounds[3]})}(this._index,t)}removeById(t){const e=this._objectIdToFeature.get(t);return e?(this._objectIdToFeature.delete(t),this._index=null,e):null}update(t,e){this.onUpdate(t,e)}get size(){return this._objectIdToFeature.size}}class ae extends Bt{constructor(t){super(t),this.type="geoevent",this._dataReceiveEventEnabled=!1,this._level=0,this._updateInfo={websocket:0,client:0};const{outSR:e}=t,{geometryType:s,objectIdField:i,timeInfo:r,purgeOptions:n,source:h,spatialReference:o,serviceFilter:a,maxReconnectionAttempts:c,maxReconnectionInterval:u,updateInterval:l,enableDataReceived:d,customParameters:f}=t.serviceInfo,p=new oe(this._onUpdate.bind(this),s),y=new Wt(p,i,r,n),g=function(t,e,s,i,r,n,h,o){const a=0===t.path.indexOf("wss://")||0===t.path.indexOf("ws://"),c={source:t,sourceSpatialReference:e,spatialReference:s,geometryType:i,filter:r,maxReconnectionAttempts:n,maxReconnectionInterval:h,customParameters:o};return a?new ee(c):new ne(c)}(h,o,e,s,a,c,u,f);this._store=p,this._manager=y,this._connection=g,this._quantize=function(t){return"esriGeometryPoint"===t?he:(e,s)=>{const i=e.weakClone(),r=new Z,n=R(r,e.geometry,!1,!1,t,s,!1,!1);return i.geometry=n,i}}(s),this._dataReceiveEventEnabled=d,this._handles=[this._connection.on("feature",(t=>this._onFeature(t))),this._connection.watch("connectionStatus",(t=>this.events.emit("connectionStatus",t))),this._connection.watch("errorString",(t=>this.events.emit("errorString",t)))];let m=performance.now();this._updateIntervalId=setInterval((()=>{const e=performance.now(),s=e-m;if(s>2500){m=e;const t=Math.round(this._updateInfo.client/(s/1e3)),i=Math.round(this._updateInfo.websocket/(s/1e3));this._updateInfo.client=0,this._updateInfo.websocket=0,this.events.emit("updateRate",{client:t,websocket:i})}t.canAcceptRequest()&&this._manager.checkForUpdates()}),l)}destroy(){super.destroy(),clearInterval(this._updateIntervalId),this._handles.forEach((t=>t.remove())),this._connection.destroy()}_fetchDataTile(){}resume(){}enableEvent(t,e){"data-received"===t&&(this._dataReceiveEventEnabled=e)}get updating(){return!1}subscribe(t){super.subscribe(t);const e=this._subscriptions.get(t.id);this._level=t.level;const s=this._getTileFeatures(t);this._onMessage({type:"append",id:t.key.id,addOrUpdate:s,end:!0}),e.didSend=!0}unsubscribe(t){super.unsubscribe(t)}*readers(t){const e=this._subscriptions.get(t),{tile:s}=e;yield this._getTileFeatures(s);for(const t of e.requests.stream.entries)i(t)&&i(t.addOrUpdate)&&(yield t.addOrUpdate)}createTileQuery(t){throw new Error("Service does not support tile  queries")}async resend(){this._subscriptions.forEach((t=>{const{tile:e}=t,s={type:"append",id:e.id,addOrUpdate:this._getTileFeatures(e),end:!0};this._onMessage(s)}))}_getTileFeatures(t){const e=this._store.search(t).map((e=>this._quantize(e,t.transform)));return Y.fromOptimizedFeatures(e,this._serviceInfo.geometryType,t.transform)}_onFeature(t){this._updateInfo.websocket++;try{this._dataReceiveEventEnabled&&this.events.emit("feature",t);const e=T(t,this._serviceInfo.geometryType,!1,!1,this._serviceInfo.objectIdField);this._manager.add(e)}catch(t){}}_onUpdate(t,e){i(t)&&(this._updateInfo.client+=t.length),this._subscriptions.forEach(((t,e)=>{t.didSend&&t.tile.level===this._level&&this._onMessage({type:"append",id:e,addOrUpdate:null,clear:!0,end:!1})})),this._subscriptions.forEach(((t,e)=>{if(!t.didSend||t.tile.level!==this._level)return;const s={type:"append",id:e,addOrUpdate:this._getTileFeatures(t.tile),remove:[],end:!0,status:Lt.empty()};t.requests.stream.enqueue(s),this._onMessage(s)}))}}const ce=e.getLogger("esri.views.2d.layers.features.sources.FeatureSource");class ue extends Vt{constructor(t){super(t)}async _fetchDataTile(e){const s=this._subscriptions.get(e.key.id);let i=!1,r=0,n=0;const h=(t,r)=>{n--,u(s);const h=e.id,o=t.reader,a=t.query;if(!o.exceededTransferLimit){if(i=!0,0!==r&&!o.hasFeatures){const t={id:h,addOrUpdate:o,end:0===n,type:"append"};return s.add({message:t,query:a}),void this._onMessage(t)}const t={id:h,addOrUpdate:o,end:0===n,type:"append"};return s.add({message:t,query:a}),void this._onMessage(t)}const c={id:h,addOrUpdate:o,end:i&&0===n,type:"append"};s.add({message:c,query:a}),this._onMessage(c)};let o=0,a=0;for(;!i&&a++<20;){let a;for(let c=0;c<o+1;c++){const o=r++;n++,a=this._fetchDataTilePage(e,o,s).then((t=>t&&h(t,o))).catch((s=>{i=!0,d(s)||(ce.error(new t("mapview-query-error","Encountered error when fetching tile",{tile:e,error:s})),this._onMessage({id:e.id,addOrUpdate:null,end:i,type:"append"}))}))}await a,u(s),o=Math.min(o+2,6)}}async _fetchDataTilePage(t,e,s){const r=this._queryInfo,n={start:this.pageSize*e,num:this.pageSize,returnExceededLimitFeatures:!0,quantizationParameters:t.getQuantizationParameters()};i(this.maxRecordCountFactor)&&(n.maxRecordCountFactor=this.maxRecordCountFactor);const h=this.createTileQuery(t,n);try{const i=s.signal,n=await this._queue.push({tile:t,query:h,signal:i,depth:e});return u(s),n?r!==this._queryInfo?this._fetchDataTilePage(t,e,s):{reader:n,query:h}:null}catch(t){return b(t),null}}}const le=e.getLogger("esri.views.2d.layers.features.sources.SnapshotFeatureSource");function de(t,e,s){const i=t.getXHydrated(),r=t.getYHydrated(),n=e.getColumnForX(i),h=Math.floor(e.normalizeCol(n));return`${s}/${Math.floor(e.getRowForY(r))}/${h}`}function fe(t,e){if(s(t))return null;const i=e.transform,r=t.getQuantizationTransform();if(s(r)){const[e,s]=i.scale,[r,n]=i.translate;return t.transform(-r/e,n/s,1/e,1/-s)}const[n,h]=r.scale,[o,a]=r.translate,[c,u]=i.scale,[l,d]=i.translate;return t.transform((o-l)/c,(-a+d)/u,n/c,h/u)}class pe extends Vt{constructor(t){super(t),this.mode="snapshot",this._loading=!0,this._controller=new AbortController,this._downloadPromise=null,this._didSendEnd=!1,this._queries=new Array,this._invalidated=!1,this._hasAggregates=!1,this._random=new _(1e3),this._featureCount=t.featureCount,this._store=t.store,this._markedIdsBufId=this._store.storage.createBitset()}destroy(){super.destroy(),this._controller.abort()}get loading(){return this._loading}get _signal(){return this._controller.signal}update(t,e){super.update(t,e),this._hasAggregates=t.targets.aggregate}async resend(t=!1){if(await this._downloadPromise,this._invalidated||t)return this._invalidated=!1,this._subscriptions.forEach((t=>t.clear())),this._downloadPromise=this._download(this._featureCount),void await this._downloadPromise;const e=this._queries.map((({query:t,reader:e})=>this._sendPatchQuery(t,e)));await Promise.all(e),this._subscriptions.forEach((t=>{t.requests.done.forEach((t=>this._onMessage(t.message)))}))}async refresh(){await this.resend(!0)}async _sendPatchQuery(t,e){const s=i(t.outFields)?t.outFields:[],r=this._queryInfo.outFields,n=r.filter((t=>-1===s.indexOf(t)));if(!n.length)return;const h=t.clone(),o=this._signal;h.returnGeometry=!1,h.returnCentroid=!1,h.outFields=n,t.outFields=r;const a=await this._queue.push({query:h,depth:0,signal:o});u({signal:o}),e.joinAttributes(a)}async _fetchDataTile(t){this._downloadPromise||(this._downloadPromise=this._download(this._featureCount));const e=this._store.search(t),s=this._subscriptions.get(t.key.id),i=e.length-1;for(let r=0;r<i;r++){const i=fe(e[r],t),n={type:"append",id:t.id,addOrUpdate:i,end:!1,status:Lt.empty()};s.add({query:null,message:n}),this._hasAggregates||await w(1),this._onMessage(n)}const r=fe(i>=0?e[i]:null,t),n={type:"append",id:t.id,addOrUpdate:r,end:this._didSendEnd,status:Lt.empty()};s.add({query:null,message:n}),this._onMessage(n)}async _download(t){try{await this.whenInitialized();const e=this._store.storage.getBitset(this._markedIdsBufId),s=new Set;e.clear();const i=Math.ceil(t/this.pageSize),r=Array.from({length:i},((t,e)=>e)).sort((()=>this._random.getInt()-this._random.getInt())).map((t=>this._downloadPage(t,e,s)));await Promise.all(r),this._store.sweepFeatures(e,this._store.storage),this._store.sweepFeatureSets(s)}catch(t){le.error("mapview-snapshot-source","Encountered and error when downloading feature snapshot",t)}this._sendEnd(),this._loading=!1}async _downloadPage(t,e,s){const r=this.pageSize,n={start:t*r,num:r,cacheHint:!0};i(this.maxRecordCountFactor)&&(n.maxRecordCountFactor=this.maxRecordCountFactor);const h=this.createQuery(n),o=this._signal,a=await this._queue.push({query:h,depth:t,signal:o});u({signal:o}),this._queries.push({query:h,reader:a}),this._store.insert(a),s.add(a.instance);const c=a.getCursor();for(;c.next();)e.set(c.getDisplayId());this._send(a)}_send(t){if(!this._subscriptions.size)return;let e=null;const r=new Map,n=new Set,h=new Map;this._subscriptions.forEach((t=>{var s;const i=t.tile;r.set(i.key.id,null),e=i.tileInfoView,n.add(i.level);const{row:o,col:a}=i.key,c=`${i.level}/${o}/${a}`,u=null!=(s=h.get(c))?s:[];u.push(t),h.set(c,u)}));for(const i of n){const n=e.getLODInfoAt(i),o=t.getCursor();for(;o.next();){const t=de(o,n,i),e=o.getIndex();if(h.has(t))for(const i of h.get(t)){const t=i.tile.id;let n=r.get(t);s(n)&&(n=[],r.set(t,n)),n.push(e)}}}r.forEach(((e,s)=>{if(i(e)){const i=this._subscriptions.get(s),r={type:"append",id:s,addOrUpdate:fe(G.from(t,e),i.tile),end:!1,status:Lt.empty()};i.add({query:null,message:r}),this._onMessage(r)}}))}_sendEnd(){this._subscriptions.forEach((t=>{const e={type:"append",id:t.tile.id,addOrUpdate:null,end:!0,status:Lt.empty()};t.add({query:null,message:e}),this._onMessage(e)})),this._didSendEnd=!0}}function ye(t,e,s,i){i%2&&(i+=1);let r=0,n=0,h=-90,o=90,a=-180,c=180;for(let t=0;t<i/2;t++){for(let e=0;e<5;e++){const i=(a+c)/2,n=s>i?1:0;r|=n<<29-(e+5*t),a=(1-n)*a+n*i,c=(1-n)*i+n*c}for(let s=0;s<5;s++){const i=(h+o)/2,r=e>i?1:0;n|=r<<29-(s+5*t),h=(1-r)*h+r*i,o=(1-r)*i+r*o}}t.geohashX=r,t.geohashY=n}function ge(t,e,s,i,r){r%2&&(r+=1);let n=0,h=0,o=-90,a=90,c=-180,u=180;for(let t=0;t<r/2;t++){for(let e=0;e<5;e++){const s=(c+u)/2,r=i>s?1:0;n|=r<<29-(e+5*t),c=(1-r)*c+r*s,u=(1-r)*s+r*u}for(let e=0;e<5;e++){const i=(o+a)/2,r=s>i?1:0;h|=r<<29-(e+5*t),o=(1-r)*o+r*i,a=(1-r)*i+r*a}}t[2*e]=n,t[2*e+1]=h}class me{constructor(t=[],e=8096){this._nodes=0,this._root=new we(0,0,0),this._statisticFields=t,this._pool=e?new at(8096):null}_acquire(t,e,s){this._nodes++;let r=null;return i(this._pool)&&(r=this._pool.dequeue()),i(r)?r.realloc(t,e,s):new we(t,e,s)}_release(t){this._nodes--,i(this._pool)&&this._pool.enqueue(t)}get count(){return this._root.count}get size(){return this._nodes}get poolSize(){return M(this._pool,0,(t=>t.size))}get depth(){let t=0;return this._forEachNode((e=>t=Math.max(t,e.depth))),t}dropLevels(t){this._forEachNode((e=>{if(e.depth>=t)for(let t=0;t<e.children.length;t++){const s=e.children[t];e.children[t]=null,s&&this._release(s)}}))}clear(){this.dropLevels(0)}insert(t,e,s=0){const i=Y.fromOptimizedFeatures([t],"esriGeometryPoint").getCursor();i.next();const r=i.readGeometry();if(!r)return;const[n,h]=r.coords;this.insertCursor(i,t.displayId,n,h,t.geohashX,t.geohashY,e,s)}insertCursor(t,e,s,i,r,n,h,o=0){let a=this._root,c=0,u=0,l=0;for(;null!==a;){if(a.depth>=o&&(a.count+=1,a.xTotal+=s,a.yTotal+=i,a.xGeohashTotal+=r,a.yGeohashTotal+=n,a.displayId=e,this._updateStatisticsCursor(t,a,1)),c>=h)return void a.add(e);const d=Math.ceil((c+1)/2),f=Math.floor((c+1)/2),p=1-c%2,y=30-(3*d+2*f),g=30-(2*d+3*f),m=(r&7*p+3*(1-p)<<y)>>y,w=(n&3*p+7*(1-p)<<g)>>g,v=m+w*(8*p+4*(1-p));u=u<<3*p+2*(1-p)|m,l=l<<2*p+3*(1-p)|w,null==a.children[v]&&(a.children[v]=this._acquire(u,l,c+1)),c+=1,a=a.children[v]}}remove(t,e){const s=Y.fromOptimizedFeatures([t],"esriGeometryPoint").getCursor();s.next();const i=s.readGeometry();if(!i)return;const[r,n]=i.coords;this.removeCursor(s,r,n,t.geohashX,t.geohashY,e)}removeCursor(t,e,s,i,r,n){let h=this._root,o=0;for(;null!==h;){if(h.count-=1,h.xTotal-=e,h.yTotal-=s,h.xGeohashTotal-=i,h.yGeohashTotal-=r,this._updateStatisticsCursor(t,h,-1),o>=n)return void h.remove(t.getDisplayId());const a=Math.ceil((o+1)/2),c=Math.floor((o+1)/2),u=1-o%2,l=30-(3*a+2*c),d=30-(2*a+3*c),f=((i&7*u+3*(1-u)<<l)>>l)+((r&3*u+7*(1-u)<<d)>>d)*(8*u+4*(1-u)),p=h.children[f];1===p.count&&(this._release(p),h.children[f]=null),o+=1,h=p}}find(t,e,s){return this._root.find(t,e,s,0,0,0)}findSingleOccupancyNode(t,e,s,i,r){let n=this._root;for(;null!==n;){const h=n.depth,o=n.xNode,a=n.yNode,c=1-h%2,u=n.xGeohashTotal/n.count,l=n.yGeohashTotal/n.count;if(1===n.count&&t<u&&u<=s&&e<l&&l<=i)return n;if(h>=r){n=n.next;continue}const d=Math.ceil((h+1)/2),f=Math.floor((h+1)/2),p=30-(3*d+2*f),y=30-(2*d+3*f),g=~((1<<p)-1),m=~((1<<y)-1),w=(e&m)>>y,v=(s&g)>>p,b=(i&m)>>y,_=o<<3*c+2*(1-c),M=a<<2*c+3*(1-c),S=_+8*c+4*(1-c),x=M+4*c+8*(1-c),j=Math.max(_,(t&g)>>p),k=Math.max(M,w),F=Math.min(S,v),q=Math.min(x,b);let I=null,A=null;for(let t=k;t<=q;t++)for(let e=j;e<=F;e++){const s=n.children[e-_+(t-M)*(8*c+4*(1-c))];s&&(I||(I=s,I.next=n.next),A&&(A.next=s),A=s,s.next=n.next)}n=I||n.next}return null}getRegionDisplayIds(t,e,s,i,r){let n=this._root;const h=[];for(;null!==n;){const o=n.depth,a=n.xNode,c=n.yNode;if(o>=r){const r=n.xGeohashTotal/n.count,o=n.yGeohashTotal/n.count;t<=r&&r<=s&&e<=o&&o<=i&&n.displayIds.forEach((t=>h.push(t))),n=n.next;continue}const u=Math.ceil((o+1)/2),l=Math.floor((o+1)/2),d=1-o%2,f=30-(3*u+2*l),p=30-(2*u+3*l),y=~((1<<f)-1),g=~((1<<p)-1),m=(e&g)>>p,w=(s&y)>>f,v=(i&g)>>p,b=a<<3*d+2*(1-d),_=c<<2*d+3*(1-d),M=b+8*d+4*(1-d),S=_+4*d+8*(1-d),x=Math.max(b,(t&y)>>f),j=Math.max(_,m),k=Math.min(M,w),F=Math.min(S,v);let q=null,I=null;for(let t=j;t<=F;t++)for(let e=x;e<=k;e++){const s=n.children[e-b+(t-_)*(8*d+4*(1-d))];s&&(q||(q=s,q.next=n.next),I&&(I.next=s),I=s,s.next=n.next)}n=q||n.next}return h}getRegionStatistics(t,e,s,i,r){let n=this._root,h=0,o=0,a=0;const c={};let u=0;for(;null!==n;){const l=n.depth,d=n.xNode,f=n.yNode;if(l>=r){const r=n.xGeohashTotal/n.count,l=n.yGeohashTotal/n.count;t<r&&r<=s&&e<l&&l<=i&&(h+=n.count,o+=n.xTotal,a+=n.yTotal,1===n.count&&(u=n.displayId),this._aggregateStatistics(c,n.statistics)),n=n.next;continue}const p=Math.ceil((l+1)/2),y=Math.floor((l+1)/2),g=1-l%2,m=30-(3*p+2*y),w=30-(2*p+3*y),v=~((1<<m)-1),b=~((1<<w)-1),_=(e&b)>>w,M=(s&v)>>m,S=(i&b)>>w,x=d<<3*g+2*(1-g),j=f<<2*g+3*(1-g),k=x+8*g+4*(1-g),F=j+4*g+8*(1-g),q=Math.max(x,(t&v)>>m),I=Math.max(j,_),A=Math.min(k,M),C=Math.min(F,S);let R=null,T=null;for(let r=I;r<=C;r++)for(let l=q;l<=A;l++){const d=n.children[l-x+(r-j)*(8*g+4*(1-g))];if(d){if(r!==I&&r!==C&&l!==q&&l!==A){const r=d.xGeohashTotal/d.count,n=d.yGeohashTotal/d.count;t<r&&r<=s&&e<n&&n<=i&&(h+=d.count,o+=d.xTotal,a+=d.yTotal,1===d.count&&(u=d.displayId),this._aggregateStatistics(c,d.statistics));continue}R||(R=d,R.next=n.next),T&&(T.next=d),T=d,d.next=n.next}}n=R||n.next}return{count:h,attributes:this._normalizeStatistics(c,h),xTotal:o,yTotal:a,referenceId:u}}_forEachNode(t){let e=this._root;for(;null!==e;){const s=this._linkChildren(e)||e.next;t(e),e=s}}_linkChildren(t){let e=null,s=null;for(let i=0;i<=t.children.length;i++){const r=t.children[i];r&&(e||(e=r,e.next=t.next),s&&(s.next=r),s=r,r.next=t.next)}return e}_updateStatisticsCursor(t,e,s){for(const i of this._statisticFields){const r=i.name,n=i.inField?t.readAttribute(i.inField):t.getComputedNumericAtIndex(i.inFieldIndex);switch(i.statisticType){case"norm":{e.statistics[r]||(e.statistics[r]={});const h=t.readAttribute(i.inNormalizationField),o=e.statistics[r].onStatisticField||0,a=e.statistics[r].onStatisticNormalizationField||0;null==n||isNaN(n)||null==h||0===h||isNaN(h)||(e.statistics[r].onStatisticField=o+s*n,e.statistics[r].onStatisticNormalizationField=a+s*h);break}case"sum":case"avg":{e.statistics[r]||(e.statistics[r]={value:0,nanCount:0});const t=e.statistics[r].value,i=e.statistics[r].nanCount;null==n||isNaN(n)?e.statistics[r].nanCount=i+s:e.statistics[r].value=t+s*n;break}case"avg_angle":{e.statistics[r]||(e.statistics[r]={x:0,y:0,nanCount:0});const t=e.statistics[r].x,i=e.statistics[r].y,h=e.statistics[r].nanCount,o=Math.PI/180;null==n||isNaN(n)?e.statistics[r].nanCount=h+s:(e.statistics[r].x=t+s*Math.cos(n*o),e.statistics[r].y=i+s*Math.sin(n*o));break}case"mode":e.statistics[r]||(e.statistics[r]={}),e.statistics[r][n]=(e.statistics[r][n]||0)+s}}}_aggregateStatistics(t,e){for(const s of this._statisticFields){const i=s.name;switch(s.statisticType){case"sum":case"avg":case"avg_angle":case"mode":case"norm":t[i]||(t[i]={});for(const s in e[i])t[i][s]=(t[i][s]||0)+e[i][s]}}}_normalizeStatistics(t,e){const s={};for(const i of this._statisticFields){const r=i.name;switch(i.statisticType){case"norm":{const i=t[r];if(e&&null==i.onStatisticNormalizationField)break;if(e&&i.onStatisticNormalizationField){s[r]=i.onStatisticField/i.onStatisticNormalizationField;break}s[r]=0;break}case"sum":{if(!e)break;const{value:i,nanCount:n}=t[r];if(!(e-n))break;s[r]=i;break}case"avg":{if(!e)break;const{value:i,nanCount:n}=t[r];if(!(e-n))break;s[r]=i/(e-n);break}case"avg_angle":{if(!e)break;const{x:i,y:n,nanCount:h}=t[r];if(!(e-h))break;const o=180/Math.PI,a=Math.atan2(n/(e-h),i/(e-h))*o;s[r]=a;break}case"mode":{const e=t[r];let i=0,n=null;for(const t in e){const s=e[t];s>i&&(i=s,n=t)}s[r]="null"===n?null:n;break}}}return s}}class we{constructor(t,e,s){this.count=0,this.xTotal=0,this.yTotal=0,this.statistics={},this.displayId=0,this.displayIds=new Set,this.next=null,this.depth=0,this.xNode=0,this.yNode=0,this.xGeohashTotal=0,this.yGeohashTotal=0,this.children=new Array(32);for(let t=0;t<this.children.length;t++)this.children[t]=null;this.xNode=t,this.yNode=e,this.depth=s}realloc(t,e,s){for(let t=0;t<this.children.length;t++)this.children[t]=null;return this.xNode=t,this.yNode=e,this.depth=s,this.next=null,this.xGeohashTotal=0,this.yGeohashTotal=0,this.xTotal=0,this.yTotal=0,this.count=0,this.statistics={},this.displayIds.clear(),this}add(t){this.displayIds.add(t)}remove(t){this.displayIds.delete(t)}getLngLatBounds(){const t=this.depth,e=Math.ceil(t/2),s=Math.floor(t/2);return function(t,e){let s=-90,i=90,r=-180,n=180;for(let h=0;h<e;h++){const e=Math.ceil((h+1)/2),o=Math.floor((h+1)/2),a=1-h%2,c=30-(3*e+2*o),u=30-(2*e+3*o),l=2*a+3*(1-a),d=(7*a+3*(1-a)<<c&t.geohashX)>>c,f=(3*a+7*(1-a)<<u&t.geohashY)>>u;for(let t=3*a+2*(1-a)-1;t>=0;t--){const e=(r+n)/2,s=d&1<<t?1:0;r=(1-s)*r+s*e,n=(1-s)*e+s*n}for(let t=l-1;t>=0;t--){const e=(s+i)/2,r=f&1<<t?1:0;s=(1-r)*s+r*e,i=(1-r)*e+r*i}}return[r,s,n,i]}({geohashX:this.xNode<<30-(3*e+2*s),geohashY:this.yNode<<30-(2*e+3*s)},this.depth)}find(t,e,s,i,r,n){if(i>=s)return this;const h=1-i%2,o=3*h+2*(1-h),a=2*h+3*(1-h),c=30-r-o,u=30-n-a,l=this.children[((t&7*h+3*(1-h)<<c)>>c)+((e&3*h+7*(1-h)<<u)>>u)*(8*h+4*(1-h))];return null==l?null:l.find(t,e,s,i+1,r+o,n+a)}}class ve extends K{constructor(t,e,s,i,r){super(new Z([],[e,s]),i,null,t),this.geohashBoundsInfo=r}get count(){return this.attributes.cluster_count}static create(t,e,s,i,r,n,h,o){const a=new ve(e,s,i,n,h);return a.displayId=t.createDisplayId(!0),a.referenceId=o,a.tileLevel=r,a}update(t,e,s,i,r,n){return this.geometry.coords[0]=t,this.geometry.coords[1]=e,this.tileLevel=s,this.attributes=i,this.geohashBoundsInfo=r,this.referenceId=null,this.referenceId=n,this}toJSON(){return{objectId:this.objectId,referenceId:1===this.attributes.cluster_count?this.referenceId:null,attributes:{...this.attributes,clusterId:this.objectId},geometry:{x:this.geometry.coords[0],y:this.geometry.coords[1]}}}}function be(t){return 57.29577951308232*t}class _e extends D{constructor(t,e,s){super(t,s),this.events=new h,this._geohashLevel=0,this._tileLevel=0,this._aggregateValueRanges={},this._aggregateValueRangesChanged=!1,this._geohashBuf=[],this._clusters=new Map,this._tiles=new Map,this.geometryInfo=t.geometryInfo,this._spatialReference=e,this._projectionSupportCheck=vt(e,yt.WGS84),this._bitsets.geohash=s.getBitset(s.createBitset()),this._bitsets.inserted=s.getBitset(s.createBitset())}async updateSchema(t,e){const i=this._schema;try{await super.updateSchema(t,e),await this._projectionSupportCheck}catch(t){}const n=rt(i,e);e&&(!s(n)||t.source||t.storage.filters)?((nt(n,"params.fields")||!this._tree||t.source)&&(this._tree=new me(this._statisticFields),this._rebuildTree(),r("esri-2d-update-debug")&&console.debug("Aggregate mesh needs update due to tree changing")),r("esri-2d-update-debug")&&console.debug("Applying Update - ClusterStore:",n),t.targets[e.name]=!0,t.mesh=!1,this._aggregateValueRanges={}):i&&(t.mesh=!0)}clear(){this._rebuildTree()}sweepFeatures(t,e){this._bitsets.inserted.forEachSet((s=>{if(!t.has(s)){const t=e.lookupByDisplayIdUnsafe(s);this._remove(t)}}))}sweepClusters(t,e,s){this._clusters.forEach(((i,r)=>{i&&i.tileLevel!==s&&(t.releaseDisplayId(i.displayId),e.unsetAttributeData(i.displayId),this._clusters.delete(r))}))}onTileData(t,e,i,r,n=!0){if(!this._schema||s(e.addOrUpdate))return e;const h=this._getTransforms(t,this._spatialReference);{const t=e.addOrUpdate.getCursor();for(;t.next();)this._update(t,r)}if(e.status.mesh||!n)return e;const o=new Array;this._getClustersForTile(o,t,this._schema.params.clusterRadius,i,h),e.addOrUpdate=Y.fromOptimizedFeatures(o,"esriGeometryPoint"),e.addOrUpdate.attachStorage(i),e.end=!0;{const s=e.addOrUpdate.getCursor();for(;s.next();){const e=s.getDisplayId();this._bitsets.computed.unset(e),this.setComputedAttributes(i,s,e,t.scale)}}return this._aggregateValueRangesChanged&&e.end&&(this.events.emit("valueRangesChanged",{valueRanges:this._aggregateValueRanges}),this._aggregateValueRangesChanged=!1),e}onTileUpdate({added:t,removed:e}){if(t.length){const e=t[0].level;this._tileLevel=e,this._setGeohashLevel(e)}if(!this._schema)return;const s=this._schema.params.clusterRadius;e.forEach((t=>{this._tiles.delete(t.key.id),this._markTileClustersForDeletion(t,s)}))}getAggregate(t){let e=null;return this._clusters.forEach((s=>{s&&s.displayId===t&&(e=s.toJSON())})),e}getAggregates(){const t=[];return this._clusters.forEach((e=>{e&&e.tileLevel===this._tileLevel&&t.push(e.toJSON())})),t}getDisplayId(t){const e=this._clusters.get(t);return e?e.displayId:null}getFeatureDisplayIdsForAggregate(t){const e=this._clusters.get(t);if(!e)return[];const s=e.geohashBoundsInfo;return this._tree.getRegionDisplayIds(s.xLL,s.yLL,s.xTR,s.yTR,s.level)}getDisplayIdForReferenceId(t){let e;return this._clusters.forEach((s=>{s&&s.referenceId===t&&(e=s.displayId)})),e}getAggregateValueRanges(){return this._aggregateValueRanges}forEach(t){this._clusters.forEach(((e,s)=>{e&&t(e,s)}))}size(){let t=0;return this.forEach((()=>t++)),t}_rebuildTree(){this._bitsets.computed.clear(),this._bitsets.inserted.clear(),this._tree&&this._tree.clear()}_remove(t){const e=t.getDisplayId(),s=t.getXHydrated(),i=t.getYHydrated(),r=this._geohashBuf[2*e],n=this._geohashBuf[2*e+1];this._bitsets.inserted.has(e)&&(this._bitsets.inserted.unset(e),this._tree.removeCursor(t,s,i,r,n,this._geohashLevel))}_update(t,e){const s=t.getDisplayId(),i=this._bitsets.inserted,r=e.isVisible(s);if(r===i.has(s))return;if(!r)return void this._remove(t);const n=t.getXHydrated(),h=t.getYHydrated();this._setGeohash(s,n,h)&&(this._tree.insertCursor(t,s,n,h,this._geohashBuf[2*s],this._geohashBuf[2*s+1],this._geohashLevel),i.set(s))}_setGeohash(t,e,s){if(this._bitsets.geohash.has(t))return!0;const i=this._geohashBuf;if(this._spatialReference.isWebMercator){const r=be(e/mt.radius),n=r-360*Math.floor((r+180)/360);ge(i,t,be(Math.PI/2-2*Math.atan(Math.exp(-s/mt.radius))),n,12)}else{const r=bt({x:e,y:s},this._spatialReference,yt.WGS84);if(!r)return!1;ge(i,t,r.y,r.x,12)}return this._bitsets.geohash.set(t),!0}_getClustersForTile(t,e,r,n,h,o=!0){const a=this._schema.params.clusterPixelBuffer,c=2*r,u=this._getGeohashLevel(e.key.level),l=Math.ceil(2**e.key.level*_t/c),d=Math.ceil(a/c)+0,f=Math.ceil(_t/c),{row:p,col:y}=e.key,g=p*_t,m=Math.floor(y*_t/c)-d,w=Math.floor(g/c)-d,v=m+f+2*d,b=w+f+2*d,_=e.tileInfoView.getLODInfoAt(e.key.level);for(let r=m;r<=v;r++)for(let a=w;a<=b;a++){let c=r;_.wrap&&(c=r<0?r+l:r%l);const d=_.wrap&&r<0,f=_.wrap&&r%l!==r,p=this._lookupCluster(n,_,e.key.level,c,a,u);if(i(p)){const e=S(h,(t=>d?t.left:f?t.right:t.tile));if(o&&s(e))continue;if(!p.count)continue;if(i(e)&&o){const s=p.geometry.clone();let r=p.attributes;s.coords[0]=E(e,s.coords[0]),s.coords[1]=O(e,s.coords[1]),1===p.count&&i(p.referenceId)&&(r={...p.attributes,referenceId:p.referenceId});const n=new H(s,r);n.displayId=p.displayId,t.push(n)}}}}_getGeohashLevel(t){return Math.min(Math.ceil(t/2+2),12)}_setGeohashLevel(t){const e=this._getGeohashLevel(t),s=1*(Math.floor(e/1)+1)-1;if(this._geohashLevel!==s)return this._geohashLevel=s,this._rebuildTree(),void this._bitsets.geohash.clear()}_getTransforms(t,e){const s={originPosition:"upperLeft",scale:[t.resolution,t.resolution],translate:[t.bounds[0],t.bounds[3]]},i=gt(e);if(!i)return{tile:s,left:null,right:null};const[r,n]=i.valid;return{tile:s,left:{...s,translate:[n,t.bounds[3]]},right:{...s,translate:[r-n+t.bounds[0],t.bounds[3]]}}}_getClusterId(t,e,s){return(15&t)<<28|(16383&e)<<14|16383&s}_markForDeletion(t,e,s){const i=this._getClusterId(t,e,s);this._clusters.delete(i)}_getClusterBounds(t,e,s){const i=this._schema.params.clusterRadius,r=2*i;let n=s%2?e*r:e*r-i;const h=s*r;let o=n+r;const a=2**t.level*_t;t.wrap&&n<0&&(n=0),t.wrap&&o>a&&(o=a);const c=h/_t,u=o/_t,l=(h-r)/_t;return[t.getXForColumn(n/_t),t.getYForRow(c),t.getXForColumn(u),t.getYForRow(l)]}_lookupCluster(t,e,s,r,n,h){const o=this._getClusterId(s,r,n),a=this._clusters.get(o),[c,u,l,d]=this._getClusterBounds(e,r,n),f={x:c,y:u},p={x:l,y:d};let y=0,g=0,m=0,w=0;if(this._spatialReference.isWebMercator){{const t=be(f.x/mt.radius);y=t-360*Math.floor((t+180)/360),g=be(Math.PI/2-2*Math.atan(Math.exp(-f.y/mt.radius)))}{const t=be(p.x/mt.radius);m=t-360*Math.floor((t+180)/360),w=be(Math.PI/2-2*Math.atan(Math.exp(-p.y/mt.radius)))}}else{const t=bt(f,this._spatialReference,yt.WGS84),e=bt(p,this._spatialReference,yt.WGS84);if(!t||!e)return null;y=t.x,g=t.y,m=e.x,w=e.y}const v={geohashX:0,geohashY:0},b={geohashX:0,geohashY:0};ye(v,g,y,h),ye(b,w,m,h);const _=v.geohashX,M=v.geohashY,S=b.geohashX,x=b.geohashY,j={xLL:_,yLL:M,xTR:S,yTR:x,level:h},k=this._tree.getRegionStatistics(_,M,S,x,h),{count:F,xTotal:q,yTotal:I,referenceId:A}=k,C=F?q/F:0,R=F?I/F:0;if(0===F)return this._clusters.set(o,null),null;const T={cluster_count:F,...k.attributes},E=i(a)?a.update(C,R,s,T,j,A):ve.create(t,o,C,R,s,T,j,A);return 0===F&&(E.geometry.coords[0]=(c+l)/2,E.geometry.coords[1]=(u+d)/2),this._clusters.set(o,E),this._updateAggregateValueRangeForCluster(E,E.tileLevel),E}_updateAggregateValueRangeForCluster(t,e){const s=this._aggregateValueRanges[e]||{minValue:1/0,maxValue:0},i=s.minValue,r=s.maxValue;s.minValue=Math.min(i,t.count),s.maxValue=Math.max(r,t.count),this._aggregateValueRanges[e]=s,i===s.minValue&&r===s.maxValue||(this._aggregateValueRangesChanged=!0)}_markTileClustersForDeletion(t,e){const s=2*e,i=Math.ceil(_t/s),{row:r,col:n}=t.key,h=r*_t,o=Math.floor(n*_t/s),a=Math.floor(h/s);for(let e=o;e<o+i;e++)for(let s=a;s<a+i;s++)this._markForDeletion(t.key.level,e,s)}}function Me(t){if(!d(t)&&!function(t){return"worker:port-closed"===t.name}(t))throw t}function Se(t){return"feature"===t.type&&"snapshot"===t.mode}let xe=class extends k{constructor(){super(...arguments),this._storage=new X,this._markedIdsBufId=this._storage.createBitset(),this._lastCleanup=performance.now(),this._cleanupNeeded=!1,this._invalidated=!1,this._tileToResolver=new Map,this._didEdit=!1,this.tileStore=null,this.config=null,this.processor=null,this.remoteClient=null,this.service=null}initialize(){this._initAttributeStore(),this._initStores(),this._initQueryEngine(),this._initSource(),this._updateQueue=new ct({concurrency:"geoevent"===this._source.type?1:4,process:(t,e)=>this._onTileMessage(t,{signal:e})}),this.handles.add([this.tileStore.on("update",this.onTileUpdate.bind(this)),this.watch("updating",(t=>!t&&this.onIdle()))]),this._checkUpdating=setInterval((()=>this.notifyChange("updating")),300)}async startup(){this._initAttributeStore(),this.tileStore.tiles.forEach((t=>this._source.subscribe(t)))}_initSource(){this._source=function(t,e,s,i,r,n){const h=function(t,e,s,i,r,n){switch(t.type){case"snapshot":return{type:"feature",origin:"snapshot",featureCount:l(t.featureCount,0),serviceInfo:t,onMessage:i,outSR:e,tileInfoView:s,canAcceptRequest:r,store:n};case"stream":return{type:"geoevent",serviceInfo:t,onMessage:i,outSR:e,canAcceptRequest:r};case"memory":case"on-demand":return{type:"feature",serviceInfo:t,onMessage:i,outSR:e,origin:function(t){return Array.isArray(t)?"local":"path"in t&&L(t.path)?"hosted":"unknown"}(t.source),tileInfoView:s,canAcceptRequest:r}}}(t,e,s,i,r,n);switch(h.type){case"feature":switch(h.origin){case"hosted":case"local":return new ue(h);case"snapshot":return new pe(h);case"unknown":return new Xt(h)}case"geoevent":return new ae(h)}}(this.service,this.spatialReference,this.tileStore.tileScheme,((t,e)=>(this._invalidated=!0,this._patchTile(t,e))),(()=>this._updateQueue.length<50),this.featureStore),this._proxyEvents()}_proxyEvents(){if("geoevent"===this._source.type){const t=this._source.events;this.handles.add([t.on("connectionStatus",(t=>this.remoteClient.invoke("setProperty",{propertyName:"connectionStatus",value:t}).catch(Me))),t.on("errorString",(t=>this.remoteClient.invoke("setProperty",{propertyName:"errorString",value:t}).catch(Me))),t.on("feature",(t=>this.remoteClient.invoke("emitEvent",{name:"data-received",event:{attributes:t.attributes,centroid:t.centroid,geometry:t.geometry}}).catch(Me))),t.on("updateRate",(t=>this.remoteClient.invoke("emitEvent",{name:"update-rate",event:{...t}}).catch(Me)))])}}_initAttributeStore(){this.attributeStore?this.attributeStore.invalidateResources():this.attributeStore=new J({type:"remote",initialize:(t,e)=>x(this.remoteClient.invoke("tileRenderer.featuresView.attributeView.initialize",t,{signal:e}).catch(Me)),update:(t,e)=>x(this.remoteClient.invoke("tileRenderer.featuresView.attributeView.requestUpdate",t,{signal:e}).catch(Me)),render:t=>x(this.remoteClient.invoke("tileRenderer.featuresView.requestRender",void 0,{signal:t}).catch(Me))},this.config)}_initStores(){const t={geometryInfo:{geometryType:this.service.geometryType,hasM:!1,hasZ:!1},spatialReference:this.spatialReference,fieldsIndex:this.fieldsIndex,fields:this.service.fields};this.featureStore=new N(t,this._storage,"snapshot"===this.service.type?"snapshot":"on-demand"),this.aggregateStore=new _e(t,this.spatialReference,this._storage),this.handles.add(this.aggregateStore.events.on("valueRangesChanged",(t=>{this.remoteClient.invoke("emitEvent",{name:"valueRangesChanged",event:{valueRanges:t.valueRanges}}).catch(Me)})))}_initQueryEngine(){var t;const e=this;null==(t=this.queryEngine)||t.destroy(),this.queryEngine=new P({definitionExpression:this.config.definitionExpression,fields:this.service.fields,geometryType:this.service.geometryType,objectIdField:this.service.objectIdField,hasM:!1,hasZ:!1,spatialReference:this.spatialReference.toJSON(),cacheSpatialQueries:!0,featureStore:this.featureStore,aggregateAdapter:{getFeatureObjectIds:t=>e.aggregateStore.getFeatureDisplayIdsForAggregate(t).map((t=>e.getObjectId(t)))},timeInfo:this.service.timeInfo})}destroy(){this._updateQueue.destroy(),this._source.destroy(),this.queryEngine.destroy(),this.attributeStore&&this.attributeStore.destroy(),clearInterval(this._checkUpdating)}get fieldsIndex(){return new U(this.service.fields)}get hasAggregates(){return!!this.config.schema.targets.aggregate}get spatialReference(){return this.tileStore.tileScheme.spatialReference}get updating(){return this.isUpdating()}isUpdating(){return this._source.updating||!!this._updateQueue.length}enableEvent(t){this._source.enableEvent(t.name,t.value)}pause(){this._updateQueue.pause(),this._updateQueue.clear()}async update(t,e){this._set("config",e),this._schema=e.schema,this._initQueryEngine(),await Promise.all([this._source.update(t,e.schema.source),this.featureStore.updateSchema(t,e.schema.targets.feature),this.attributeStore.update(t,e),this.attributeStore.updateFilters(t,this)]),await this.aggregateStore.updateSchema(t,e.schema.targets.aggregate),r("esri-2d-update-debug")&&t.describe()}async applyUpdate(t){t.mesh&&this.clearTiles(),this._updateQueue.resume(),await this._source.applyUpdate(t),this.notifyChange("updating"),await j(this,"updating",!0),this.hasAggregates&&(await w(10),await j(this,"updating",!0))}async onEdits({edits:t}){r("esri-2d-update-debug")&&console.debug("Applying Edit:",t),this._didEdit=!0;try{const e=t.removed.map((t=>t.objectId&&-1!==t.objectId?t.objectId:this._lookupObjectIdByGlobalId(t.globalId))),s=t.addOrModified.map((({objectId:t})=>t));this.featureStore.invalidate(),await this._source.edit(s,e),this.clearTiles(),this.notifyChange("updating"),this.aggregateStore.clear(),await this._source.resend(),await j(this,"updating",!0)}catch(t){}}async refresh(){this.featureStore.invalidate(),this.clearTiles(),this._source.refresh(),this._cleanupNeeded=!0,this.notifyChange("updating"),await j(this,"updating",!0)}clearTiles(){for(const t of this.tileStore.tiles)this.processor.onTileClear(t)}onTileUpdate(t){this.aggregateStore.onTileUpdate(t);for(const e of t.added)this._source.subscribe(e),this._level=e.level;for(const e of t.removed)this._source.unsubscribe(e),this._cleanupNeeded=!0,this._tileToResolver.has(e.id)&&(this._tileToResolver.get(e.id).resolve(),this._tileToResolver.delete(e.id));this.notifyChange("updating")}onIdle(){this._invalidated&&((this.hasAggregates||"heatmap"===this.processor.type)&&this._repushCurrentLevelTiles(),this._invalidated=!1),this._markAndSweep()}async querySummaryStatistics({query:t,params:e}){return this.queryEngine.executeQueryForSummaryStatistics(t,e)}async queryUniqueValues({query:t,params:e}){return this.queryEngine.executeQueryForUniqueValues(t,e)}async queryClassBreaks({query:t,params:e}){return this.queryEngine.executeQueryForClassBreaks(t,e)}queryExtent(t){return this.queryEngine.executeQueryForExtent(t)}queryFeatures(t){return this.queryEngine.executeQuery(t)}queryFeatureCount(t){return this.queryEngine.executeQueryForCount(t)}queryLatestObservations(t){return this.queryEngine.executeQueryForLatestObservations(t)}queryObjectIds(t){return this.queryEngine.executeQueryForIds(t)}async queryStatistics(){return this.featureStore.storeStatistics}getObjectId(t){return this.featureStore.lookupObjectId(t,this._storage)}getDisplayId(t){if(this._schema.targets.aggregate){const e=this.aggregateStore.getDisplayId(t);if(s(e)){const e=this.featureStore.lookupDisplayId(t);return this.aggregateStore.getDisplayIdForReferenceId(e)}return e}return this.featureStore.lookupDisplayId(t)}getFeature(t){const e=this.featureStore.lookupFeatureByDisplayId(t,this._storage);if(s(e))return null;const i=e.readHydratedGeometry(),r=q(i,e.geometryType,e.hasZ,e.hasM);return{attributes:e.readAttributes(),geometry:r}}getAggregate(t){return this.aggregateStore.getAggregate(t)}getAggregates(){return this.aggregateStore.getAggregates()}async setHighlight(t){const e=t.map((t=>this.getDisplayId(t)));return this.attributeStore.setHighlight(t,e)}_lookupObjectIdByGlobalId(t){const e=this.service.globalIdField;if(s(e))throw new Error("Expected globalIdField to be defined");let i=null;if(this.featureStore.forEach((s=>{t===s.readAttribute(e)&&(i=s.getObjectId())})),s(i))throw new Error(`Expected to find a feature with globalId ${t}`);return i}_repushCurrentLevelTiles(){const t=this.tileStore.tiles.filter((t=>t.level===this._level));for(const e of t)this._patchTile({type:"append",id:e.key.id,addOrUpdate:Y.fromOptimizedFeatures([],this.service.geometryType),remove:[],end:!0,status:Lt.empty()})}_maybeForceCleanup(){performance.now()-this._lastCleanup>5e3&&this._markAndSweep()}_patchTile(t,e){const s=this._updateQueue.push(t,e).then((()=>{this.notifyChange("updating")})).catch((()=>{this.notifyChange("updating")}));return this.notifyChange("updating"),s}async _onTileMessage(t,e){u(e);const i=this.tileStore.get(t.id);if(!i)return;if(t.clear)return this.processor.onTileClear(i);const r=t.status;this._cleanupNeeded=!0;const n=[];for(const e of t.remove){const t=this.featureStore.lookupDisplayId(e);t&&n.push(t)}t.remove=n;try{if(s(t.addOrUpdate))return void this.processor.onTileMessage(i,{...t,addOrUpdate:null},this.hasAggregates,e).catch(b);if(t.addOrUpdate.setArcadeSpatialReference(this.spatialReference),this.featureStore.hasInstance(t.addOrUpdate.instance)&&r.targets.feature||(r.targets.feature=!0,this.featureStore.onTileData(i,t)),r.storage.data&&r.storage.filters||(r.storage.data=!0,r.storage.filters=!0,this.attributeStore.onTileData(i,t),"geoevent"===this._source.type||this._didEdit?(await this.attributeStore.sendUpdates(),u(e)):this.attributeStore.sendUpdates()),this.hasAggregates&&!r.targets.aggregate){r.targets.aggregate=!0;const e=Se(this._source)&&this._source.loading,s=!Se(this._source)||e||t.end;if(this.aggregateStore.onTileData(i,t,this._storage,this.attributeStore,s),!s)return;r.mesh||(this.attributeStore.onTileData(i,t),await this.attributeStore.sendUpdates(),this.processor.onTileClear(i))}r.mesh||(r.mesh=!0,await this.processor.onTileMessage(i,t,this.hasAggregates,e),u(e)),this._maybeForceCleanup()}catch(t){b(t)}}_mark(t,e,s){const i=(4294901760&this._storage.getInstanceId(t))>>>16;t&&(e.add(i),s.set(t))}_markAndSweep(){if(this._lastCleanup=performance.now(),"feature"===this._source.type&&"snapshot"===this._source.mode||"geoevent"!==this._source.type&&!this._cleanupNeeded)return;this._cleanupNeeded=!1;const t=this._storage.getBitset(this._markedIdsBufId),e=new Set;t.clear();for(const s of this.tileStore.tiles)for(const i of this._source.readers(s.id)){const s=i.getCursor();for(;s.next();){let i=s.getDisplayId();if(!i){const t=s.getObjectId();i=this.featureStore.lookupDisplayId(t)}this._mark(i,e,t)}}"symbol"===this.processor.type&&this.processor.forEachBufferId((s=>{this._mark(s,e,t)})),this._updateQueue.forEach((s=>{for(const i of s.remove){const s=this.featureStore.lookupDisplayId(i);this._mark(s,e,t)}})),this.config.schema.targets.aggregate&&(this.aggregateStore.sweepFeatures(t,this.featureStore),this.aggregateStore.sweepClusters(this._storage,this.attributeStore,this._level)),this.featureStore.sweepFeatures(t,this._storage,this.attributeStore),this.featureStore.sweepFeatureSets(e)}};p([g({constructOnly:!0})],xe.prototype,"tileStore",void 0),p([g()],xe.prototype,"config",void 0),p([g({readOnly:!0})],xe.prototype,"fieldsIndex",null),p([g()],xe.prototype,"processor",void 0),p([g({constructOnly:!0})],xe.prototype,"remoteClient",void 0),p([g({constructOnly:!0})],xe.prototype,"service",void 0),p([g()],xe.prototype,"spatialReference",null),p([g()],xe.prototype,"updating",null),xe=p([y("esri.views.2d.layers.features.controllers.FeatureController2D")],xe);const je=xe,ke=new Set;function Fe(){return ke}let qe=class extends k{constructor(){super(...arguments),this.controller=null,this.processor=null,this.remoteClient=null,this.tileStore=null,this.service=null,this.viewState=null}initialize(){this.handles.add(this.watch("updating",(t=>{this.remoteClient.invoke("setUpdating",t).catch((()=>{}))})))}destroy(){var t,e,s;null==(t=this.controller)||t.destroy(),null==(e=this.processor)||e.destroy(),null==(s=this.tileStore)||s.destroy(),this.controller=this.processor=this.tileStore=this.remoteClient=null}get updating(){return!this.controller||this.controller.updating}async startup({service:t,config:e,tileInfo:s,tiles:i}){if(this.service=t,!this.tileStore){const t=new lt(F.fromJSON(s));this.tileStore=new dt(t)}this.tileStore.clear(),await this._createProcessorAndController(e),await this.update({config:e},!0),this.tileStore.updateTiles(i)}async updateTiles(t){this.tileStore.updateTiles(t)}async update({config:t},e=!1){const s=Lt.empty();return e||this.controller.pause(),await Promise.all([this.processor.update(s,t),this.controller.update(s,t)]),s.toJSON()}async applyUpdate(t){return this.controller.applyUpdate(Lt.create(t))}async _createProcessorAndController(t){await Promise.all([this._handleControllerConfig(t),this._handleProcessorConfig(t)]),this.controller.processor=this.processor}async _handleControllerConfig(t){const e=await this._createController(this.service,t);return await e.startup(),e}async _handleProcessorConfig(t){return this._createProcessor(this.service,t)}async _createController(t,e){this.controller&&this.controller.destroy();const{tileStore:s,remoteClient:i}=this,r=new je({service:t,config:e,tileStore:s,remoteClient:i});return this.controller=r,r}async _createProcessor(t,e){const s=e.schema.processors[0].type,i=(await function(t){return"heatmap"===t?import("./p-cdf8686b.js"):import("./p-23880767.js")}(s)).default,{remoteClient:r,tileStore:n}=this,h=new i({service:t,config:e,tileStore:n,remoteClient:r});return this.processor&&this.processor.destroy(),this.processor=h,h}};p([g()],qe.prototype,"controller",void 0),p([g()],qe.prototype,"processor",void 0),p([g()],qe.prototype,"updating",null),p([g()],qe.prototype,"viewState",void 0),qe=p([y("esri.views.2d.layers.features.Pipeline")],qe);const Ie=qe;export default Ie;export{Fe as getInstances}