import{a as t}from"./p-57ae469d.js";import{v as e,t as s,bc as i,r as n,m as o,ac as a,aa as r,a0 as l}from"./p-9ae46e68.js";import{E as c,a7 as h,ab as u,a1 as f,b3 as m,b2 as p}from"./p-566b0715.js";import{r as y,O as w}from"./p-bae36c84.js";import{m as d,u as v,c as x,q as T}from"./p-81e5b36e.js";import"./p-84bf99cb.js";import"./p-fe01b82b.js";import"./p-138c2b2c.js";const q=e.getLogger("esri.layers.support.ElevationSampler");class g{queryElevation(t){return function(t,e){const s=E(t,e.spatialReference);if(!s)return null;switch(t.type){case"point":!function(t,e,s){t.z=i(s.elevationAt(e),0)}(t,s,e);break;case"polyline":!function(t,e,s){M.spatialReference=e.spatialReference;const n=t.hasM&&!t.hasZ;for(let o=0;o<t.paths.length;o++){const a=t.paths[o],r=e.paths[o];for(let t=0;t<a.length;t++){const e=a[t],o=r[t];M.x=o[0],M.y=o[1],n&&(e[3]=e[2]),e[2]=i(s.elevationAt(M),0)}}t.hasZ=!0}(t,s,e);break;case"multipoint":!function(t,e,s){M.spatialReference=e.spatialReference;const n=t.hasM&&!t.hasZ;for(let o=0;o<t.points.length;o++){const a=t.points[o],r=e.points[o];M.x=r[0],M.y=r[1],n&&(a[3]=a[2]),a[2]=i(s.elevationAt(M),0)}t.hasZ=!0}(t,s,e)}return t}(t.clone(),this)}on(){return A}projectIfRequired(t,e){return E(t,e)}}class _ extends g{constructor(t,e,s){super(),this.tile=t,this.noDataValue=s,this.extent=d(t.tile.extent,e.spatialReference);const i=h(e.spatialReference),n=e.lodAt(t.tile.level).resolution*i;this.demResolution={min:n,max:n}}get spatialReference(){return this.extent.spatialReference}contains(t){const e=this.projectIfRequired(t,this.spatialReference);return u(this.extent,e)}elevationAt(t){const e=this.projectIfRequired(t,this.spatialReference);if(s(e))return null;if(!this.contains(t)){const e=this.extent;return q.warn("#elevationAt()",`Point used to sample elevation (${t.x}, ${t.y}) is outside of the sampler extent (${e.xmin}, ${e.ymin}, ${e.xmax}, ${e.ymax})`),this.noDataValue}return this.tile.sample(e.x,e.y)}}class b extends g{constructor(t,e,s){let i;super(),"number"==typeof e?(this.noDataValue=e,i=null):(i=e,this.noDataValue=s),this.samplers=i?t.map((t=>new _(t,i,this.noDataValue))):t;const n=this.samplers[0];if(n){this.extent=n.extent.clone();const{min:t,max:e}=n.demResolution;this.demResolution={min:t,max:e};for(let t=1;t<this.samplers.length;t++){const e=this.samplers[t];this.extent.union(e.extent),this.demResolution.min=Math.min(this.demResolution.min,e.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,e.demResolution.max)}}else this.extent=d(v(),i.spatialReference),this.demResolution={min:0,max:0}}get spatialReference(){return this.extent.spatialReference}elevationAt(t){const e=this.projectIfRequired(t,this.spatialReference);if(!e)return null;for(const t of this.samplers)if(t.contains(e))return t.elevationAt(e);return q.warn("#elevationAt()",`Point used to sample elevation (${t.x}, ${t.y}) is outside of the sampler`),this.noDataValue}}function E(t,e){if(s(t))return null;const i=t.spatialReference;if(i.equals(e))return t;const n=f(t,e);return n||q.error(`Cannot project geometry spatial reference (wkid:${i.wkid}) to elevation sampler spatial reference (wkid:${e.wkid})`),n}const M=new c,A={remove(){}};class ${constructor(t,e=null){if(this.tile=t,n(e)){const s=t.extent;this.samplerData={pixelData:e.values,width:e.width,height:e.height,safeWidth:.99999999*(e.width-1),noDataValue:e.noDataValue,dx:(e.width-1)/(s[2]-s[0]),dy:(e.width-1)/(s[3]-s[1]),x0:s[0],y1:s[3]}}}sample(t,e){if(s(this.samplerData))return;const{safeWidth:i,width:n,pixelData:o,noDataValue:a,dx:r,dy:l,y1:c,x0:h}=this.samplerData,u=R(l*(c-e),0,i),f=R(r*(t-h),0,i),m=Math.floor(u),p=Math.floor(f),y=m*n+p,w=y+n,d=o[y],v=o[w],x=o[y+1],T=o[w+1];if(d!==a&&v!==a&&x!==a&&T!==a){const t=f-p,e=d+(x-d)*t;return e+(v+(T-v)*t-e)*(u-m)}}}function R(t,e,s){return t<e?e:t>s?s:t}class D{async queryAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new o("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");const i=F.fromGeometry(e);let n=!1;s&&s.returnSampleInfo||(n=!0);const a={...k,...s,returnSampleInfo:!0},r=await this.query(t[t.length-1],i,a),l=await this._queryAllContinue(t,r,a);return l.geometry=l.geometry.export(),n&&delete l.sampleInfo,l}async query(t,e,s){if(!t)throw new o("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||!(e instanceof F)&&"point"!==e.type&&"multipoint"!==e.type&&"polyline"!==e.type)throw new o("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const i={...k,...s},n=new I(t,e.spatialReference,i),a=i.signal;return await t.load({signal:a}),await this._createGeometryDescriptor(n,e,a),await this._selectTiles(n,a),await this._populateElevationTiles(n,a),this._sampleGeometryWithElevation(n),this._createQueryResult(n,a)}async createSampler(t,e,s){if(!t)throw new o("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new o("elevation-query:invalid-extent","Invalid or undefined extent");const i={...k,...s};return this._createSampler(t,e,i)}async createSamplerAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new o("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new o("elevation-query:invalid-extent","Invalid or undefined extent");const i={...k,...s,returnSampleInfo:!0},n=await this._createSampler(t[t.length-1],e,i);return this._createSamplerAllContinue(t,e,n,i)}async _createSampler(t,e,s,i){const n=s.signal;await t.load({signal:n});const o=e.spatialReference,a=t.tileInfo.spatialReference;o.equals(a)||(await y([{source:o,dest:a}],{signal:n}),e=w(e,a));const r=new C(t,e,s,i);return await this._selectTiles(r,n),await this._populateElevationTiles(r,n),new b(r.elevationTiles,r.layer.tileInfo,r.options.noDataValue)}async _createSamplerAllContinue(t,e,s,i){if(t.pop(),!t.length)return s;const n=s.samplers.map((t=>x(t.extent))),o=await this._createSampler(t[t.length-1],e,i,n);if(0===o.samplers.length)return s;const a=s.samplers.concat(o.samplers),r=new b(a,i.noDataValue);return this._createSamplerAllContinue(t,e,r,i)}async _queryAllContinue(t,e,s){const i=t.pop(),n=e.geometry.coordinates,o=[],a=[];for(let s=0;s<n.length;s++){const r=e.sampleInfo[s];r.demResolution>=0?r.source||(r.source=i):t.length&&(o.push(n[s]),a.push(s))}if(!t.length||0===o.length)return e;const r=e.geometry.clone(o),l=await this.query(t[t.length-1],r,s);return a.forEach(((t,s)=>{n[t].z=l.geometry.coordinates[s].z,e.sampleInfo[t].demResolution=l.sampleInfo[s].demResolution})),this._queryAllContinue(t,e,s)}async _createQueryResult(t,e){const s={geometry:(await t.geometry.project(t.outSpatialReference,e)).export(),noDataValue:t.options.noDataValue};return t.options.returnSampleInfo&&(s.sampleInfo=this._extractSampleInfo(t)),t.geometry.coordinates.forEach((t=>{t.tile=null,t.elevationTile=null})),s}async _createGeometryDescriptor(t,e,s){let i;const n=t.layer.tileInfo.spatialReference;if(e instanceof F?i=await e.project(n,s):(await y([{source:e.spatialReference,dest:n}],{signal:s}),i=w(e,n)),!i)throw new o("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${e.spatialReference.wkid}' on an elevation service in '${n.wkid}'`);t.geometry=F.fromGeometry(i)}async _selectTiles(t,e){const s=t.options.demResolution;if("geometry"===t.type&&this._preselectOutsideLayerExtent(t),"number"==typeof s)this._selectTilesClosestResolution(t);else if("finest-contiguous"===s)await this._selectTilesFinestContiguous(t,e);else{if("auto"!==s)throw new o("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${s}', expected a number, "finest-contiguous" or "auto"`);await this._selectTilesAuto(t,e)}}_preselectOutsideLayerExtent(t){if(s(t.layer.fullExtent))return;const e=new $(null);e.sample=()=>t.options.noDataValue,t.outsideExtentTile=e;const i=t.layer.fullExtent;t.geometry.coordinates.forEach((t=>{const s=t.x,n=t.y;(s<i.xmin||s>i.xmax||n<i.ymin||n>i.ymax)&&(t.elevationTile=e)}))}_selectTilesClosestResolution(t){const e=this._findNearestDemResolutionLODIndex(t.layer.tileInfo,t.options.demResolution);t.selectTilesAtLOD(e)}_findNearestDemResolutionLODIndex(t,e){const s=e/h(t.spatialReference);let i=t.lods[0],n=0;for(let e=1;e<t.lods.length;e++){const o=t.lods[e];Math.abs(o.resolution-s)<Math.abs(i.resolution-s)&&(i=o,n=e)}return n}async _selectTilesFinestContiguous(t,e){const s=S(t.layer.tileInfo,t.options.minDemResolution);await this._selectTilesFinestContiguousAt(t,s,e)}async _selectTilesFinestContiguousAt(t,e,s){const i=t.layer;if(t.selectTilesAtLOD(e),e<0)return;const n=i.tilemapCache,l=t.getTilesToFetch();try{if(n)await a(Promise.all(l.map((t=>n.fetchAvailability(t.level,t.row,t.col,{signal:s})))),s);else if(await this._populateElevationTiles(t,s),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new o("elevation-query:has-unavailable-tiles")}catch(i){r(i),await this._selectTilesFinestContiguousAt(t,e-1,s)}}async _populateElevationTiles(t,e){const s=t.getTilesToFetch(),i={},o=t.options.cache,r=t.options.noDataValue,c=s.map((async s=>{const a=`${t.layer.uid}:${s.id}:${r}`,l=n(o)?o.get(a):null,c=n(l)?l:await t.layer.fetchTile(s.level,s.row,s.col,{noDataValue:r,signal:e});n(o)&&o.put(a,c),i[s.id]=new $(s,c)}));await a(l(c),e),t.populateElevationTiles(i)}async _selectTilesAuto(e,s){this._selectTilesAutoFinest(e),this._reduceTilesForMaximumRequests(e);const i=e.layer.tilemapCache;if(!i)return this._selectTilesAutoPrefetchUpsample(e,s);const n=e.getTilesToFetch(),o={},l=n.map((async e=>{const n={id:null,level:0,row:0,col:0,extent:v()},a=await t(i.fetchAvailabilityUpsample(e.level,e.row,e.col,n,{signal:s}));!1===a.ok?r(a.error):o[e.id]=n}));await a(Promise.all(l),s),e.remapTiles(o)}_reduceTilesForMaximumRequests(t){const e=t.layer.tileInfo;let s=0;const i={},n=t=>{t.id in i?i[t.id]++:(i[t.id]=1,s++)},o=t=>{const e=i[t.id];1===e?(delete i[t.id],s--):i[t.id]=e-1};t.forEachTileToFetch(n,o);let a=!0;for(;a&&(a=!1,t.forEachTileToFetch((i=>{s<=t.options.maximumAutoTileRequests||(o(i),e.upsampleTile(i)&&(a=!0),n(i))}),o),a););}_selectTilesAutoFinest(t){const e=S(t.layer.tileInfo,t.options.minDemResolution);t.selectTilesAtLOD(e,t.options.maximumAutoTileRequests)}async _selectTilesAutoPrefetchUpsample(t,e){const s=t.layer.tileInfo;await this._populateElevationTiles(t,e);let i=!1;t.forEachTileToFetch(((t,e)=>{s.upsampleTile(t)?i=!0:e()})),i&&await this._selectTilesAutoPrefetchUpsample(t,e)}_sampleGeometryWithElevation(t){t.geometry.coordinates.forEach((e=>{const s=e.elevationTile;let i=t.options.noDataValue;if(s){const t=s.sample(e.x,e.y);n(t)?i=t:e.elevationTile=null}e.z=i}))}_extractSampleInfo(t){const e=t.layer.tileInfo,s=h(e.spatialReference);return t.geometry.coordinates.map((i=>{let n=-1;return i.elevationTile&&i.elevationTile!==t.outsideExtentTile&&(n=e.lodAt(i.elevationTile.tile.level).resolution*s),{demResolution:n}}))}}class F{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(t){const e=new F;return e.geometry=this.geometry,e.spatialReference=this.spatialReference,e.coordinates=t||this.coordinates.map((t=>this._cloneCoordinate(t))),e._exporter=this._exporter,e}async project(t,e){if(this.spatialReference.equals(t))return this.clone();await y([{source:this.spatialReference,dest:t}],{signal:e});const s=new m({spatialReference:this.spatialReference,points:this.coordinates.map((t=>[t.x,t.y]))}),i=w(s,t);if(!i)return null;const n=this.coordinates.map(((t,e)=>{const s=this._cloneCoordinate(t),n=i.points[e];return s.x=n[0],s.y=n[1],s})),o=this.clone(n);return o.spatialReference=t,o}_cloneCoordinate(t){return{x:t.x,y:t.y,z:t.z,m:t.m,tile:null,elevationTile:null}}static fromGeometry(t){const e=new F;if(e.geometry=t,e.spatialReference=t.spatialReference,t instanceof F)e.coordinates=t.coordinates.map((t=>e._cloneCoordinate(t))),e._exporter=(e,s)=>{const i=t.clone(e);return i.spatialReference=s,i};else switch(t.type){case"point":{const s=t,{hasZ:i,hasM:n}=s;e.coordinates=i&&n?[{x:s.x,y:s.y,z:s.z,m:s.m}]:i?[{x:s.x,y:s.y,z:s.z}]:n?[{x:s.x,y:s.y,m:s.m}]:[{x:s.x,y:s.y}],e._exporter=(e,s)=>t.hasM?new c(e[0].x,e[0].y,e[0].z,e[0].m,s):new c(e[0].x,e[0].y,e[0].z,s);break}case"multipoint":{const s=t,{hasZ:i,hasM:n}=s;e.coordinates=s.points.map(i&&n?t=>({x:t[0],y:t[1],z:t[2],m:t[3]}):i?t=>({x:t[0],y:t[1],z:t[2]}):n?t=>({x:t[0],y:t[1],m:t[2]}):t=>({x:t[0],y:t[1]})),e._exporter=(e,s)=>t.hasM?new m({points:e.map((t=>[t.x,t.y,t.z,t.m])),hasZ:!0,hasM:!0,spatiaReference:s}):new m(e.map((t=>[t.x,t.y,t.z])),s);break}case"polyline":{const s=t,i=[],n=[],{hasZ:o,hasM:a}=t;let r=0;for(const t of s.paths)if(n.push([r,r+t.length]),r+=t.length,o&&a)for(const e of t)i.push({x:e[0],y:e[1],z:e[2],m:e[3]});else if(o)for(const e of t)i.push({x:e[0],y:e[1],z:e[2]});else if(a)for(const e of t)i.push({x:e[0],y:e[1],m:e[2]});else for(const e of t)i.push({x:e[0],y:e[1]});e.coordinates=i,e._exporter=(e,s)=>{const i=e.map(t.hasM?t=>[t.x,t.y,t.z,t.m]:t=>[t.x,t.y,t.z]),o=n.map((t=>i.slice(t[0],t[1])));return new p({paths:o,hasM:t.hasM,hasZ:!0,spatialReference:s})};break}}return e}}class j{constructor(t,e){this.layer=t,this.options=e}}class I extends j{constructor(t,e,s){super(t,s),this.outSpatialReference=e,this.type="geometry"}selectTilesAtLOD(t){if(t<0)this.geometry.coordinates.forEach((t=>t.tile=null));else{const e=this.layer.tileInfo,s=e.lods[t].level;this.geometry.coordinates.forEach((t=>{t.tile=e.tileAt(s,t.x,t.y)}))}}allElevationTilesFetched(){return!this.geometry.coordinates.some((t=>!t.elevationTile))}clearElevationTiles(){for(const t of this.geometry.coordinates)t.elevationTile!==this.outsideExtentTile&&(t.elevationTile=null)}populateElevationTiles(t){for(const e of this.geometry.coordinates)!e.elevationTile&&e.tile&&(e.elevationTile=t[e.tile.id])}remapTiles(t){for(const e of this.geometry.coordinates)e.tile=t[e.tile.id]}getTilesToFetch(){const t={},e=[];for(const s of this.geometry.coordinates){const i=s.tile;s.elevationTile||!s.tile||t[i.id]||(t[i.id]=i,e.push(i))}return e}forEachTileToFetch(t){for(const e of this.geometry.coordinates)e.tile&&!e.elevationTile&&t(e.tile,(()=>e.tile=null))}}class C extends j{constructor(t,e,s,i){super(t,s),this.type="extent",this.elevationTiles=[],this.candidateTiles=[],this.fetchedCandidates=new Set,this.extent=e.intersection(t.fullExtent),this.maskExtents=i}selectTilesAtLOD(t,e){const s=this._maximumLodForRequests(e),i=Math.min(s,t);i<0?this.candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(i)}_maximumLodForRequests(t){const e=this.layer.tileInfo;if(!t)return e.lods.length-1;const i=this.extent;if(s(i))return-1;for(let s=e.lods.length-1;s>=0;s--){const n=e.lods[s],o=n.resolution*e.size[1];if(Math.ceil(i.width/(n.resolution*e.size[0]))*Math.ceil(i.height/o)<=t)return s}return-1}allElevationTilesFetched(){return this.candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this.fetchedCandidates.clear()}populateElevationTiles(t){for(const e of this.candidateTiles){const s=t[e.id];s&&(this.fetchedCandidates.add(e),this.elevationTiles.push(s))}}remapTiles(t){this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles.map((e=>t[e.id])))}getTilesToFetch(){return this.candidateTiles}forEachTileToFetch(t,e){const s=this.candidateTiles;this.candidateTiles=[],s.forEach((s=>{if(this.fetchedCandidates.has(s))return void(e&&e(s));let i=!1;t(s,(()=>i=!0)),i?e&&e(s):this.candidateTiles.push(s)})),this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles,e)}_uniqueNonOverlappingTiles(t,e){const s={},i=[];for(const n of t)s[n.id]?e&&e(n):(s[n.id]=n,i.push(n));const n=i.sort(((t,e)=>t.level-e.level));return n.filter(((t,s)=>{for(let i=0;i<s;i++)if(T(n[i].extent,t.extent))return e&&e(t),!1;return!0}))}_selectCandidateTilesCoveringExtentAt(t){this.candidateTiles.length=0;const e=this.extent;if(s(e))return;const i=this.layer.tileInfo,n=i.lods[t],o=i.tileAt(n.level,e.xmin,e.ymin),a=n.resolution*i.size[1],r=Math.ceil((e.xmax-o.extent[0])/(n.resolution*i.size[0])),l=Math.ceil((e.ymax-o.extent[1])/a);for(let t=0;t<l;t++)for(let e=0;e<r;e++){const s={id:null,level:o.level,row:o.row-t,col:o.col+e};i.updateTileInfo(s),this._tileIsMasked(s)||this.candidateTiles.push(s)}}_tileIsMasked(t){return!!this.maskExtents&&this.maskExtents.some((e=>T(e,t.extent)))}}function S(t,e){let s=t.lods.length-1;if(e>0){const i=t.lods.findIndex((t=>t.resolution<e));0===i?s=0:i>0&&(s=i-1)}return s}const k={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};export default D;export{D as ElevationQuery,F as GeometryDescriptor,S as getFinestLodIndex}