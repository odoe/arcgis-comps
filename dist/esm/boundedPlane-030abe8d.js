import { c as s } from './messageBundle-f75b4090.js';
import { r, d, u, o, q, s as s$2, H as H$1, c as c$1, F as F$1, I as I$1, a as j$1, i as p$1, z as z$2, l } from './mathUtils-e16f9389.js';
import { s as s$1, c } from './vectorStacks-9205ea46.js';
import { h as h$1, o as o$1, f, r as r$1 } from './mat4-f34c6460.js';
import { e as e$1 } from './mat4f64-677a419d.js';
import { n, b as t, r as r$2 } from './common-d5b993de.js';
import { v, A, b as b$1 } from './lineSegment-4881dbd9.js';
import { p, M, b, B, W as W$1, j, D as D$1, E, F, I, O, z as z$1 } from './plane-f3c19202.js';
import { e, h } from './sphere-c3d60863.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
const L=s.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class z{constructor(){this.plane=p(),this.origin=n(),this.basis1=n(),this.basis2=n();}}function G(s=Ns){return {plane:p(s.plane),origin:t(s.origin),basis1:t(s.basis1),basis2:t(s.basis2)}}function W(s,i,n){const t=Ss.get();return t.origin=s,t.basis1=i,t.basis2=n,t.plane=M(0,0,0,0),K(t),t}function D(s,i=G()){return J(s.origin,s.basis1,s.basis2,i)}function H(s,i){r(i.origin,s.origin),r(i.basis1,s.basis1),r(i.basis2,s.basis2),b(s.plane,i.plane);}function J(s,i,n,t=G()){return r(t.origin,s),r(t.basis1,i),r(t.basis2,n),K(t),ys(t,"fromValues()"),t}function K(s){B(s.basis2,s.basis1,s.origin,s.plane);}function Q(s,i,n){s!==n&&D(s,n);const t=d(c.get(),ms(s),i);return u(n.origin,n.origin,t),n.plane[3]-=i,n}function X(s,i,n){return Z(i,n),Q(n,gs(s,s.origin),n),n}function Z(s,i=G()){const n=(s[2]-s[0])/2,t=(s[3]-s[1])/2;return o(i.origin,s[0]+n,s[1]+t,0),o(i.basis1,n,0,0),o(i.basis2,0,t,0),j(0,0,1,0,i.plane),i}function $(s,i,n){return !!D$1(s.plane,i,n)&&hs(s,n)}function ss(s,i,n){if($(s,i,n))return n;const t=is(s,i,c.get());return u(n,i.origin,d(c.get(),i.direction,q(i.origin,t)/s$2(i.direction))),n}function is(s,n,t){const a=vs.get();Ps(s,n,a,vs.get());let o=Number.POSITIVE_INFINITY;for(const r$1 of Ts){const e=Is(s,r$1,ws.get()),u=c.get();if(E(a,e,u)){const s=H$1(c.get(),n.origin,u),a=Math.abs(l(z$2(n.direction,s)));a<o&&(o=a,r(t,u));}}return o===Number.POSITIVE_INFINITY?ns(s,n,t):t}function ns(s,i,n){if($(s,i,n))return n;const t=vs.get(),a=vs.get();Ps(s,i,t,a);let o=Number.POSITIVE_INFINITY;for(const r$1 of Ts){const e=Is(s,r$1,ws.get()),u=c.get();if(F(t,e,u)){const s=h(i,u);if(!I(a,u))continue;s<o&&(o=s,r(n,u));}}return os(s,i.origin)<o&&ts(s,i.origin,n),n}function ts(s,i,n){const t=O(s.plane,i,c.get()),a=A(js(s,s.basis1),t,-1,1,c.get()),o=A(js(s,s.basis2),t,-1,1,c.get());return c$1(n,u(c.get(),a,o),s.origin),n}function as(s,i,n){const{origin:t,basis1:a,basis2:o$1}=s,r=c$1(c.get(),i,t),e$1=e(a,r),c$2=e(o$1,r),u=e(ms(s),r);return o(n,e$1,c$2,u)}function os(s,i){const n=as(s,i,c.get()),{basis1:t,basis2:a}=s,o=s$2(t),r=s$2(a),e=Math.max(Math.abs(n[0])-o,0),c$1=Math.max(Math.abs(n[1])-r,0),u=n[2];return e*e+c$1*c$1+u*u}function rs(s,i){return Math.sqrt(os(s,i))}function es(s,i){let n=Number.NEGATIVE_INFINITY;for(const t of Ts){const a=Is(s,t,ws.get()),o=b$1(a,i);o>n&&(n=o);}return Math.sqrt(n)}function cs(s,i){return I(s.plane,i)&&hs(s,i)}function us(s,i,n,t){return ds(s,n,t)}function gs(s,i){const n=-s.plane[3];return e(ms(s),i)-n}function bs(s,i,n,t){const a=gs(s,i),o=d(Ms,ms(s),n-a);return u(t,i,o),t}function fs(s,i){return F$1(s.basis1,i.basis1)&&F$1(s.basis2,i.basis2)&&F$1(s.origin,i.origin)}function ls(s,i,n){return s!==n&&D(s,n),h$1(As,i),o$1(As,As),I$1(n.basis1,s.basis1,As),I$1(n.basis2,s.basis2,As),I$1(W$1(n.plane),W$1(s.plane),As),I$1(n.origin,s.origin,i),z$1(n.plane,n.origin,n.plane),n}function ps(s,i,n,t){return s!==t&&D(s,t),f(Vs,r$1(Vs),i,n),I$1(t.basis1,s.basis1,Vs),I$1(t.basis2,s.basis2,Vs),K(t),t}function ms(s){return W$1(s.plane)}function ds(s,i,n){switch(i){case 0:r(n,s.basis1),j$1(n,n);break;case 1:r(n,s.basis2),j$1(n,n);break;case 2:r(n,ms(s));}return n}function hs(s,i){const n=c$1(c.get(),i,s.origin),t=p$1(s.basis1),a=p$1(s.basis2),o=z$2(s.basis1,n),r=z$2(s.basis2,n);return -o-t<0&&o-t<0&&-r-a<0&&r-a<0}function js(s,i){const n=ws.get();return r(n.origin,s.origin),r(n.vector,i),n}function Is(s,i,n){const{basis1:t,basis2:a,origin:o}=s,r=d(c.get(),t,i.origin[0]),e=d(c.get(),a,i.origin[1]);u(n.origin,r,e),u(n.origin,n.origin,o);const c$1=d(c.get(),t,i.direction[0]),b=d(c.get(),a,i.direction[1]);return d(n.vector,u(c$1,c$1,b),2),n}function ys(s,i){Math.abs(z$2(s.basis1,s.basis2)/(s$2(s.basis1)*s$2(s.basis2)))>1e-6&&L.warn(i,"Provided basis vectors are not perpendicular"),Math.abs(z$2(s.basis1,ms(s)))>1e-6&&L.warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-z$2(ms(s),s.origin)-s.plane[3])>1e-6&&L.warn(i,"Plane offset is not consistent with plane origin");}function Ps(s,i,n,t){const a=ms(s);B(a,i.direction,i.origin,n),B(W$1(n),a,i.origin,t);}const Ns={plane:p(),origin:r$2(0,0,0),basis1:r$2(1,0,0),basis2:r$2(0,1,0)},vs=new s$1(p),ws=new s$1(v),Ms=n(),Ss=new s$1((()=>({origin:null,basis1:null,basis2:null,plane:null}))),Ts=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],As=e$1(),Vs=e$1(),_s=Object.freeze({__proto__:null,BoundedPlaneClass:z,create:G,wrap:W,copy:D,copyWithoutVerify:H,fromValues:J,updateUnboundedPlane:K,elevate:Q,setExtent:X,fromAABoundingRect:Z,intersectRay:$,intersectRayClosestSilhouette:ss,closestPointOnSilhouette:is,closestPoint:ns,projectPoint:ts,projectPointLocal:as,distance2:os,distance:rs,distanceToSilhouette:es,extrusionContainsPoint:cs,axisAt:us,altitudeAt:gs,setAltitudeAt:bs,equals:fs,transform:ls,rotate:ps,normal:ms,UP:Ns});

export { D, G, H, J, K, Z, _s as _, cs as c, ls as l, ms as m, ps as p, rs as r, z };
